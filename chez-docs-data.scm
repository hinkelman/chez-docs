(define chez-docs-data (quote ((csug ("system:s1" "\nprocedure: (warning who msg irritant ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "warning raises a continuable exception with condition type\n&warning and should be used to describe situations for which the\n&warning condition type is appropriate, typically a situation\nthat should not prevent the program from continuing but might result\nin a more serious problem at some later point.\n" "\nThe continuation object with which the exception is raised also includes\na &who condition whose who field is who if who is\nnot #f, a &message condition whose message field is\nmsg, and an &irritants condition whose irritants field\nis (irritant ...).\n" "\nwho must be a string, a symbol, or #f identifying the procedure\nor syntactic form reporting the warning.\nIt is usually best to identify a procedure the programmer has called rather\nthan some other procedure the programmer may not be aware is involved in\ncarrying out the operation.\nmsg must be a string and should describe the exceptional situation.\nThe irritants may be any Scheme objects and should include values that may\nhave caused or been materially involved in the exceptional situation.\n\n") ("system:s2" "\nprocedure: (assertion-violationf who msg irritant ...)\nreturns: does not return\nprocedure: (errorf who msg irritant ...)\nreturns: does not return\nprocedure: (warningf who msg irritant ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "These procedures are like assertion-violation, error,\nand warning except\nthat msg is assumed to be a format string, as if in a call to\nformat (Section 9.13), with\nirritant ... treated as the additional arguments to\nformat.\nThis allows programs to control the appearance of the error message, at\nleast when the default exception handler is in place.\n" "\nFor each of these procedures, the continuation object with which the exception\nis raised includes a &format condition to signify that the string\ncontained in the condition object's &message condition is a\nformat string and the objects contained in the condition object's\n&irritants condition should be treated as the additional\nformat arguments.\n") ("system:s4" "\nsyntax: &format\nprocedure: (make-format-condition)\nreturns: a condition of type &format\nprocedure: (format-condition? obj)\nreturns: #t if obj is a condition of type &format, #f otherwise\nlibraries: (chezscheme)\n" "\n" "Presence of this condition type within a compound condition indicates\nthat the string provided by the &message condition, if\npresent, is a format string and the list of objects provided by\nthe &irritants condition, if present, should be treated as\nadditional format arguments.\nThis condition type might be defined as follows.\n" "(define-condition-type &format &condition\n  make-format-condition format-condition?)\n") ("system:s5" "\nsyntax: &source\nprocedure: (make-source-condition form)\nreturns: a condition of type &source\nprocedure: (source-condition? obj)\nreturns: #t if obj is a condition of type &source, #f otherwise\nprocedure: (source-condition-form condition)\nreturns: the contents of condition's form field\nlibraries: (chezscheme)\n" "\n" "This condition type can be included within a compound condition when a\nsource expression can be identified in situations in which a\n&syntax condition would be inappropriate, such as when a\nrun-time assertion violation is detected.\nThe form argument should be an s-expression or syntax object\nrepresenting the source expression.\nThis condition type might be defined as follows.\n" "(define-condition-type &source &condition\n  make-source-condition source-condition?\n  (form source-condition-form))\n") ("system:s6" "\nsyntax: &continuation\nprocedure: (make-continuation-condition continuation)\nreturns: a condition of type &continuation\nprocedure: (continuation-condition? obj)\nreturns: #t if obj is a condition of type &continuation, #f otherwise\nprocedure: (condition-continuation condition)\nreturns: the contents of condition's continuation field\nlibraries: (chezscheme)\n" "\n" "This condition type can be included within a compound condition to indicate\nthe current continuation at the point where the exception described by the\ncondition occurred.\nThe continuation of a failed assert or a call to\nassertion-violation, assertion-violationf,\nerror, errorf, or syntax-error is now included\nvia this condition type in the conditions passed to raise.\nThe continuation argument should be a continuation.\nThis condition type might be defined as follows.\n" "(define-condition-type &continuation &condition\n  make-continuation-condition continuation-condition?\n  (continuation condition-continuation))\n") ("system:s7" "\nprocedure: (display-condition obj)\nprocedure: (display-condition obj textual-output-port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "If textual-output-port is not supplied, it defaults to the current output port.\nThis procedure displays a message to the effect that an exception\nhas occurred with value obj.\nIf obj is a condition (Chapter http://scheme.com/tspl4/./exceptions.html#g14711 of\nThe Scheme Programming Language, 4th Edition), it displays information encapsulated within the condition,\nhandling messages, who conditions, irritants, source information,\netc., as appropriate.\n") ("system:s8" "\nprocedure: (default-exception-handler obj)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure is the default value of the base-exception-handler\nparameter called on a condition when no other exception handler has been\ndefined or when all dynamically established exception handlers have chosen\nnot to handle the condition.\nIt first displays obj, as if with display-condition, to the\nconsole error port.\nFor non-serious warning conditions, it returns immediately after displaying\nthe condition.\n" "\nFor serious or other non-warning conditions, it\nsaves the condition in the parameter debug-condition, where\ndebug (Section 3.2) can retrieve it and\nallow it to be inspected.\nIf the debug-on-exception parameter is set to #f (the\ndefault unless the --debug-on-exception command-line option is provided), the\nhandler prints a message instructing the user to type (debug) to\nenter the debugger, then resets to the current caf.\nOtherwise, the handler invokes debug directly and resets if\ndebug returns.\n" "\nIf an I/O exception occurs while attempting to display the condition,\nthe default exception handler resets (as if by calling reset).\nThe intent is to avoid an infinite regression (ultimately ending\nin exhaustion of memory) in which the process repeatedly recurs\nback to the default exception handler trying to write to a console-error\nport (typically stderr) that is no longer writable, e.g., due to\nthe other end of a pipe or socket having been closed.\n") ("system:s10" "\nglobal parameter: debug-on-exception\nlibraries: (chezscheme)\n" "The value of this parameter determines whether the default exception handler\nimmediately enters the debugger immediately when it receives a serious or\nnon-warning condition.\nIf the --debug-on-exception\ncommand-line option (Section 2.1) has been provided, the\ninitial value of this parameter is #t.\nOtherwise, the initial value is #f.\n\n") ("system:s12" "\nthread parameter: base-exception-handler\nlibraries: (chezscheme)\n" "The value of this parameter must be a procedure, and the procedure\nshould accept one argument.\nThe default value of base-exception-handler is\nthe procedure default-exception-handler.\n" "\nThe value of this parameter is invoked whenever no exception handler\nestablished by a program has chosen to handle an exception.\n") ("system:s13" "\nthread parameter: debug-condition\nlibraries: (chezscheme)\n" "This parameter is used by the default exception handler to hold the\nlast serious or non-warning condition received by the handler, where\nit can be inspected via the debug procedure\n(Section 3.2).\nIt can also be invoked by user code to store or retrieve a\ncondition.\n") ("system:s14" "\nthread parameter: current-exception-state\nlibraries: (chezscheme)\n" "current-exception-state may be used to get or set\nthe current exception state.\nWhen called without arguments, current-exception-state returns\nan exception state comprising the current stack of handlers established\nby with-exception-handler and guard.\nWhen called with a single argument, which must be an exception state,\ncurrent-exception-state sets the exception state.\n") ("system:s15" "\nprocedure: (create-exception-state)\nprocedure: (create-exception-state procedure)\nlibraries: (chezscheme)\n" "create-exception-state creates an exception\nstate whose stack of exception handlers is empty except for, in effect,\nan infinite number of occurrences of handler at its\nbase.\nhandler must be a procedure, and should accept one argument.\nIf not provided, handler defaults to a procedure equivalent\nto the value of the following expression.\n" "\n" "(lambda (x) ((base-exception-handler) x))\n") ("system:s17" "\nprocedure: (break who msg irritant ...)\nprocedure: (break who)\nprocedure: (break)\nreturns: unspecified\nlibraries: (chezscheme)\n" "The arguments to break follow the protocol described above for\nerrorf.\nThe default break handler (see break-handler) displays a message and\ninvokes the debugger.\nThe format string and objects may be omitted, in which case the\nmessage issued by the default break handler identifies the break\nusing the who argument but provides no more information\nabout the break.\nIf the who argument is omitted as well, no message is generated.\nThe default break handler returns normally if the debugger\nexits normally.\n") ("system:s19" "\nthread parameter: break-handler\nlibraries: (chezscheme)\n" "The value of this parameter must be a procedure.\nThe current break handler is called by break, which passes\nalong its arguments.\nSee break for a description of the default break\nhandler.\nThe example below shows how to disable breaks.\n" "\n" "(break-handler (lambda args (void)))\n") ("system:s20" "\nthread parameter: keyboard-interrupt-handler\nlibraries: (chezscheme)\n" "The value of this parameter must be a procedure.\nThe keyboard-interrupt handler is called (with no arguments) when\na keyboard interrupt occurs.\nThe default keyboard-interrupt handler invokes the interactive\ndebugger.\nIf the debugger exits normally the interrupted computation is\nresumed.\nThe example below shows how to install a keyboard-interrupt handler\nthat resets without invoking the debugger.\n" "\n" "(keyboard-interrupt-handler\n  (lambda ()\n    (newline (console-output-port))\n    (reset)))\n") ("system:s22" "desc:set-timer\nprocedure: (set-timer n)\nreturns: previous current timer value\nlibraries: (chezscheme)\n" "n must be a nonnegative integer.\nWhen n is nonzero, set-timer starts an internal timer with\nan initial value of n.\nWhen n ticks elapse, a timer interrupt occurs, resulting in\ninvocation of the timer interrupt handler.\nEach tick corresponds roughly to one nonleaf procedure call (see the\nintroduction to this section); thus, ticks are not\nuniform time units but instead depend heavily on how much work is done\nby each procedure call.\n" "\nWhen n is zero, set-timer turns the timer off.\n" "\nThe value returned in either case is the value of the timer before the\ncall to set-timer.\nA return value of 0 should not be taken to imply that the timer was not on;\nthe return value may also be 0 if the timer was just about to fire when\nthe call to set-timer occurred.\n" "\nThe engine mechanism (Section 6.4) is built on top of the\ntimer interrupt so timer interrupts should not be used with engines.\n\n") ("system:s24" "\nthread parameter: timer-interrupt-handler\nlibraries: (chezscheme)\n" "The value of this parameter must be a procedure.\nThe timer interrupt handler is called by the system when the internal timer\n(set by set-timer) expires.\nThe default handler raises an exception with condition type &assertion\nto say that the handler has not\nbeen defined; any program that uses the timer should redefine the\nhandler before setting the timer.\n") ("system:s26" "\nprocedure: (disable-interrupts)\nprocedure: (enable-interrupts)\nreturns: disable count\nlibraries: (chezscheme)\n" "disable-interrupts disables the handling of interrupts,\nincluding timer, keyboard, and collect request interrupts.\nenable-interrupts re-enables these interrupts.\nThe system maintains a disable count that starts at zero; when zero,\ninterrupts are enabled.\nEach call to disable-interrupts increments the count,\neffectively disabling interrupts.\nEach call to enable-interrupts decrements the count, if\nnot already zero, effectively enabling interrupts.\nFor example, two calls to disable-interrupts followed by one call to\nenable-interrupts leaves interrupts disabled.\nCalls to enable-interrupts when the count is already zero\n(and interrupts are enabled) have no effect.\nThe value returned by either procedure is the number of calls to\nenable-interrupts required to enable interrupts.\n" "\nGreat care should be exercised when using these procedures, since disabling\ninterrupts inhibits the normal processing of keyboard interrupts,\ntimer interrupts, and, perhaps most importantly, collect request interrupts.\nSince garbage collection does not happen automatically when interrupts are\ndisabled, it is possible for the storage allocator to run out of space\nunnecessarily should interrupts be disabled for a long period of time.\n" "\nThe with-interrupts-disabled syntactic form should be used instead of\nthese more primitive procedures whenever possible,\nsince with-interrupts-disabled ensures that interrupts are re-enabled\nwhenever a nonlocal exit occurs, such as when an exception is handled by\nthe default exception handler.\n\n") ("system:s27" "\nsyntax: (with-interrupts-disabled body1 body2 ...)\nsyntax: (critical-section body1 body2 ...)\nreturns: the values of the body body1 body2 ...\nlibraries: (chezscheme)\n" "with-interrupts-disabled evaluates the body\nbody1 body2 ... with interrupts disabled.\nThat is, upon entry, interrupts are disabled, and\nupon exit, interrupts are re-enabled.\nThus, with-interrupts-disabled allows the implementation of indivisible\noperations in nonthreaded versions of Chez Scheme or within a single thread\nin threaded versions of Chez Scheme.\ncritical-section is the same as with-interrupts-disabled and\nis provided for backward compatibility.\n" "\nwith-interrupts-disabled can be defined as follows.\n" "\n" "(define-syntax with-interrupts-disabled\n  (syntax-rules ()\n    [(_ b1 b2 ...)\n     (dynamic-wind\n       disable-interrupts\n       (lambda () b1 b2 ...)\n       enable-interrupts)]))\n" "The use of dynamic-wind ensures that interrupts are\ndisabled whenever the body of the with-interrupts-disabled expression\nis active and re-enabled whenever it is not.\nSince calls to disable-interrupts are counted (see the\ndiscussion under disable-interrupts and\nenable-interrupts above), with-interrupts-disabled\nexpressions may be nested with the desired effect.\n\n") ("system:s28" "\nprocedure: (register-signal-handler sig procedure)\nreturns: unspecified\nlibraries: (chezscheme)\n" "register-signal-handler is used to\nestablish a signal handler for a given low-level signal.\nsig must be an exact integer identifying a valid signal, and\nprocedure should accept one argument.\nSee your host system's <signal.h> or documentation for a list\nof valid signals and their numbers.\nAfter a signal handler for a given signal has been registered, receipt\nof the specified signal results in a call to the handler.\nThe handler is passed the signal number, allowing the same handler to\nbe used for different signals while differentiating among them.\n" "\nSignals handled in this fashion are treated like keyboard interrupts in\nthat the handler is not called immediately when the signal is delivered\nto the process, but rather at some procedure call boundary after the\nsignal is delivered.\nIt is generally not a good idea, therefore, to establish handlers for\nmemory faults, illegal instructions, and the like, since the code that\ncauses the fault or illegal instruction will continue to execute\n(presumably erroneously) for some time before the handler is invoked.\nA finite amount of storage is used to buffer as-yet unhandled\nsignals, after which additional signals are dropped.\n" "\nregister-signal-handler is supported only on Unix-based\nsystems.\n\n") ("system:s29" "\nprocedure: (environment? obj)\nreturns: #t if obj is an environment, otherwise #f\nlibraries: (chezscheme)\n" "\n" "(environment? (interaction-environment)) --> #t\n(environment? 'interaction-environment) --> #f\n(environment? (copy-environment (scheme-environment))) --> #t\n(environment? (environment '(prefix (rnrs) $rnrs-))) --> #t\n") ("system:s30" "\nprocedure: (environment-mutable? env)\nreturns: #t if env is mutable, otherwise #f\nlibraries: (chezscheme)\n" "\n" "(environment-mutable? (interaction-environment)) --> #t\n(environment-mutable? (scheme-environment)) --> #f\n(environment-mutable? (copy-environment (scheme-environment))) --> #t\n(environment-mutable? (environment '(prefix (rnrs) $rnrs-))) --> #f\n") ("system:s31" "\nprocedure: (scheme-environment)\nreturns: an environment\nlibraries: (chezscheme)\n" "scheme-environment returns an environment containing\nthe initial top-level bindings.\nThis environment corresponds to the scheme module.\n" "\nThe environment returned by this procedure is immutable.\n" "\n" "(define cons 3)\n(top-level-value 'cons (scheme-environment)) --> #<procedure cons>\n(set-top-level-value! 'cons 3 (scheme-environment)) --> exception\n") ("system:s32" "\nprocedure: (ieee-environment)\nreturns: an IEEE/ANSI standard compatibility environment\nlibraries: (chezscheme)\n" "ieee-environment returns an environment containing\nbindings for the keywords and variables whose meanings are\ndefined by the IEEE/ANSI Standard for Scheme [citation26].\n" "\nThe bindings for each of the identifiers in the IEEE environment are those\nof the corresponding Revised6 Report library, so this does not provide\nfull backward compatibility.\n" "\nThe environment returned by this procedure is immutable.\n" "\n" "(define cons 3)\n(top-level-value 'cons (ieee-environment)) --> #<procedure cons>\n(set-top-level-value! 'cons 3 (ieee-environment)) --> exception\n") ("system:s33" "\nthread parameter: interaction-environment\nlibraries: (chezscheme)\n" "The original value of interaction-environment is the default\ntop-level environment.\nIt is initially set to a mutable copy of\n(scheme-environment) and which may be extended or otherwise\naltered by top-level definitions and assignments.\nIt may be set to any environment, mutable or not, to change the\ndefault top-level evaluation environment.\n" "\nAn expression's top-level bindings resolve to the environment that is\nin effect when the expression is expanded, and changing the value\nof this parameter has no effect on running code.\nChanges affect only code that is subsequently expanded, e.g., as the\nresult of a call to eval, load, or\ncompile-file.\n" "\n" "(define cons 3)\ncons --> 3\n(top-level-value 'cons (interaction-environment)) --> 3\n\n(interaction-environment (scheme-environment))\ncons --> #<procedure cons>\n(set! cons 3) --> exception: attempt to assign immutable variable\n(define cons 3) --> exception: invalid definition in immutable environment\n") ("system:s34" "\nprocedure: (copy-environment env)\nprocedure: (copy-environment env mutable?)\nprocedure: (copy-environment env mutable? syms)\nreturns: a new environment\nlibraries: (chezscheme)\n" "copy-environment returns a copy of env, i.e., a new\nenvironment that contains the same bindings as env.\n" "\nThe environment is mutable if mutable? is omitted or true;\nif mutable? is false, the environment is immutable.\n" "\nThe set of bindings copied from env to the new environment\nis determined by syms, which defaults to the value of\n(environment-symbols env).\nThe binding, if any, for each element of syms is copied to the\nnew environment, and no other bindings are present in the new\nenvironment.\n" "\nIn the current implementation, the storage space used by an environment\nis never collected, so repeated use of copy-environment will\neventually cause the system to run out of memory.\n" "\n" "(define e (copy-environment (scheme-environment)))\n(eval '(define cons +) e)\n(eval '(cons 3 4) e)                    --> 7\n(eval '(cons 3 4) (scheme-environment)) --> (3 . 4)\n") ("system:s35" "\nprocedure: (environment-symbols env)\nreturns: a list of symbols\nlibraries: (chezscheme)\n" "This procedure returns a list of symbols representing the identifiers\nbound in environment env.\nIt is primarily useful in building the list of symbols to be copied\nfrom one environment to another.\n" "\n" "(define listless-environment\n  (copy-environment\n    (scheme-environment)\n    #t\n    (remq 'list (environment-symbols (scheme-environment)))))\n(eval '(let ([x (cons 3 4)]) x) listless-environment) --> (3 . 4)\n(eval '(list 3 4) listless-environment) --> exception\n") ("system:s36" "\nprocedure: (apropos-list s)\nprocedure: (apropos-list s env)\nreturns: see below\nlibraries: (chezscheme)\n" "This procedure returns a selected list of symbols and pairs.\nEach symbol in the list represents an identifier bound in env.\nEach pair represents a set of identifiers exported by a\npredefined library or a library previously defined or loaded\ninto the system.\nThe car of the pair is the library name, and the cdr is a list\nof symbols.\nIf s is a string, only entries whose names have s as a\nsubstring are included, and if s is a symbol, only those whose names\nhave the name of s as a substring are selected.\nIf no environment is provided, it defaults to the value of\ninteraction-environment.\n" "\n" "(library (a) (export a-vector-sortof) (import (rnrs))\n  (define a-vector-sortof '(vector 1 2 3)))\n(apropos-list 'vector-sort) -->\n  (vector-sort vector-sort!\n   ((a) a-vector-sortof)\n   ((chezscheme) vector-sort vector-sort!)\n   ((rnrs) vector-sort vector-sort!)\n   ((rnrs sorting) vector-sort vector-sort!)\n   ((scheme) vector-sort vector-sort!))\n") ("system:s37" "\nprocedure: (apropos s)\nprocedure: (apropos s env)\nreturns: unspecified\nlibraries: (chezscheme)\n" "apropos is like apropos-list except the information is\ndisplayed to the current output port, as shown in the following\ntranscript.\n" "\n" "> (library (a) (export a-vector-sortof) (import (rnrs))\n    (define a-vector-sortof '(vector 1 2 3)))\n> (apropos 'vector-sort)\ninteraction environment:\n  vector-sort, vector-sort!\n(a):\n  a-vector-sortof\n(chezscheme):\n  vector-sort, vector-sort!\n(rnrs):\n  vector-sort, vector-sort!\n(rnrs sorting):\n  vector-sort, vector-sort!\n(scheme):\n  vector-sort, vector-sort!\n") ("system:s38" "\nprocedure: (eval obj)\nprocedure: (eval obj env)\nreturns: value of the Scheme form represented by obj\nlibraries: (chezscheme)\n" "eval treats obj as the representation of an expression.\nIt evaluates the expression in environment env and returns\nits value.\nIf no environment is provided, it defaults to the environment\nreturned by interaction-environment.\n" "\nSingle-argument eval is a Chez Scheme extension.\nChez Scheme also permits obj to be the representation of a\nnonexpression form, i.e., a definition, whenever the environment\nis mutable.\nChez Scheme further allows obj to be an annotation\n(Section 11.11), and the default evaluators\nmake use of annotations to incorporate source-file\ninformation in error messages and associate source-file\ninformation with compiled code.\n" "\nIn Chez Scheme, eval is actually a wrapper that simply\npasses its arguments to the current evaluator.\n(See current-eval.)\nThe default evaluator is compile, which expands the\nexpression via the current expander (see\ncurrent-expand), compiles it,\nexecutes the resulting code, and returns its value.\nIf the environment argument, env, is present,\ncompile passes it along to the current expander,\nwhich is sc-expand by default.\n\n") ("system:s39" "\nthread parameter: current-eval\nlibraries: (chezscheme)\n" "current-eval determines the evaluation procedure used by the\nprocedures eval, load, and\nnew-cafe.\ncurrent-eval is initially bound to the value of\ncompile.\n(In Petite Chez Scheme, it is initially bound to the value of\ninterpret.)\nThe evaluation procedure should expect one or two arguments: an object\nto evaluate and an optional environment.\nThe second argument might be an annotation\n(Section 11.11).\n" "\n" "(current-eval interpret)\n(+ 1 1) --> 2\n\n(current-eval (lambda (x . ignore) x))\n(+ 1 1) --> (+ 1 1)\n") ("system:s43" "\nprocedure: (compile obj)\nprocedure: (compile obj env)\nreturns: value of the Scheme form represented by obj\nlibraries: (chezscheme)\n" "obj, which can be an annotation (Section 11.11)\nor unannotated value, is treated as a Scheme expression, expanded with the\ncurrent expander (the value of current-expand) in the specified\nenvironment (or the interaction environment, if no environment\nis provided), compiled to machine code, and executed.\ncompile is the default value of the current-eval\nparameter.\n\n") ("system:s44" "\nprocedure: (interpret obj)\nprocedure: (interpret obj env)\nreturns: value of the Scheme form represented by obj\nlibraries: (chezscheme)\n" "interpret is like compile, except that the expression\nis interpreted rather than compiled.\ninterpret may be used as a replacement for compile,\nwith the following caveats:\n" "\nInterpreted code runs significantly slower.\n\nInspector information is not generated for\ninterpreted code, so the inspector is not as useful for interpreted\ncode as it is for compiled code.\n\nForeign procedure expressions cannot be\ninterpreted, so the interpreter invokes the compiler for all\nforeign procedure expressions (this is done transparently).\n" "\n" "\ninterpret is sometimes faster than compile when the\nform to be evaluated is short running, since it avoids some of the\nwork done by compile prior to evaluation.\n\n") ("system:s45" "\nprocedure: (load path)\nprocedure: (load path eval-proc)\nreturns: unspecified\nlibraries: (chezscheme)\n" "path must be a string.\nload reads and evaluates the contents of the file specified by\npath.\nThe file may contain source or object code.\nBy default, load employs eval to evaluate each source\nexpression found in a source file.\nIf eval-proc is specified, load uses this procedure instead.\neval-proc must accept one argument, the expression to evaluate.\nThe expression passed to eval-proc might be an annotation\n(Section 11.11) or an unannotated value.\n" "\nThe eval-proc argument\nfacilitates the implementation of embedded Scheme-like languages\nand the use of alternate\nevaluation mechanisms to be used for Scheme programs.\neval-proc can be put to other uses as well.\nFor example,\n" "\n" "(load \"myfile.ss\"\n  (lambda (x)\n    (pretty-print\n      (if (annotation? x)\n          (annotation-stripped x)\n          x))\n    (newline)\n    (eval x)))\n" "pretty-prints each expression before evaluating it.\n" "\nThe parameter source-directories (Section 12.5)\ndetermines the set of directories searched for source files not identified\nby absolute path names.\n") ("system:s47" "\nprocedure: (load-library path)\nprocedure: (load-library path eval-proc)\nreturns: unspecified\nlibraries: (chezscheme)\n" "load-library is identical to load except\nthat it treats the input file as if it were prefixed by an implicit\n#!r6rs.\nThis effectively disables any non-R6RS lexical\nsyntax except where subsequently overridden by #!chezscheme.\n\n") ("system:s48" "\nprocedure: (load-program path)\nprocedure: (load-program path eval-proc)\nreturns: unspecified\nlibraries: (chezscheme)\n" "path must be a string.\nload-program reads and evaluates the contents of the file specified by\npath.\nThe file may contain source or object code.\nIf it contains source code, load-program wraps\nthe code in a top-level-program form so that the file's\ncontent is treated as an RNRS top-level program\n(Section http://scheme.com/tspl4/./libraries.html#g14510.3 of The Scheme Programming Language, 4th Edition).\nBy default, load-program employs eval to evaluate each source\nexpression found in the file.\nIf eval-proc is specified, load-program uses this procedure instead.\neval-proc must accept one argument, the expression to evaluate.\nThe expression passed to eval-proc might be an annotation\n(Section 11.11) or an unannotated value.\n" "\nThe parameter source-directories (Section 12.5)\ndetermines the set of directories searched for source files not identified\nby absolute path names.\n\n") ("system:s50" "\nprocedure: (verify-loadability situation input ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "situation must be one of the symbols visit, revisit, or load.\nEach input must be a string pathname or a pair of a string pathname and a library search path.\nEach of the pathnames should name a file containing object code for a set of libraries and\ntop-level programs, such as would be produced by\ncompile-program,\ncompile-library,\ncompile-whole-program,\nor\ncompile-whole-library.\nA library search path must be a suitable argument for\nlibrary-directories.\n" "\nverify-loadability verifies, without actually loading any\ncode or defining any libraries, whether the object files named\nby the specified pathnames and their library dependencies, direct\nor indirect, are present, readable, and mutually compatible.\nThe type of dependencies for each named object file is determined\nby the situation argument: compile-time dependencies for\nvisit, run-time dependencies for revisit and both for\nload.\n" "\nFor each input pathname that is paired with a search path,\nthe library-directories parameter is parameterized to the\nlibrary search path during the recursive search for dependencies\nof the programs and libraries found in the object file named by the\npathname.\n" "\nIf verify-loadability finds a problem, such as a missing\nlibrary dependency or compilation-instance mismatch, it raises an\nexception with an appropriate condition.\nOtherwise, it returns an unspecified value.\n" "\nSince verify-loadability does not load or run any code\nfrom the files it processes, it cannot determine whether errors\nunrelated to missing or unreadable files or mutual compatibility\nwill occur when the files are actually loaded.\n\n") ("system:s56" "\nprocedure: (load-compiled-from-port input-port)\nreturns: result of the last compiled expression\nlibraries: (chezscheme)\n" "load-compiled-from-port reads and evaluates the object-code contents\nof input-port as previously created by functions like compile-file,\ncompile-script, compile-library, and\ncompile-to-port.\n" "\nThe return value is the value of the last expression whose compiled\nform is in input-port. If input-port is empty, then the\nresult value is unspecified.\nThe port is left at end-of-file but is not closed.\n\n") ("system:s57" "\nprocedure: (visit-compiled-from-port input-port)\nreturns: result of the last compiled expression processed\nlibraries: (chezscheme)\n" "visit-compiled-from-port reads and evaluates the object-code contents\nof input-port as previously created by functions like compile-file,\ncompile-script, compile-library, and\ncompile-to-port.  In the process, it skips any revisit (run-time-only) code.\n" "\nThe return value is the value of the last expression whose last non-revisit compiled\nform is in input-port. If there are no such forms, then the\nresult value is unspecified.\nThe port is left at end-of-file but is not closed.\n\n") ("system:s58" "\nprocedure: (revisit-compiled-from-port input-port)\nreturns: result of the last compiled expression processed\nlibraries: (chezscheme)\n" "revisit-compiled-from-port reads and evaluates the object-code contents\nof input-port as previously created by functions like compile-file,\ncompile-script, compile-library, and\ncompile-to-port.  In the process, it skips any visit (compile-time-only) code.\n" "\nThe return value is the value of the last expression whose last non-visit compiled\nform is in input-port. If there are no such forms, then the\nresult value is unspecified.\nThe port is left at end-of-file but is not closed.\n\n") ("system:s59" "\nprocedure: (visit path)\nreturns: unspecified\nlibraries: (chezscheme)\n" "path must be a string.\nvisit reads the named file, which must contain compiled object\ncode compatible with the current machine type and version, and it\nruns those portions of the compiled object code that\nestablish compile-time information or correspond to expressions\nidentified as \"visit\" time by eval-when forms contained in\nthe original source file.\n" "\nFor example, assume the file t1.ss contains the following\nforms:\n" "\n" "(define-syntax a (identifier-syntax 3))\n(module m (x) (define x 4))\n(define y 5)\n" "If t1.ss is compiled to t1.so, applying load\nto t1.so has the effect of defining all three identifiers.\nApplying visit to t1.so, however, has the effect of\ninstalling the transformer for a, installing the interface for\nm (for use by import),  and recording y as\na variable.\nvisit is useful when separately compiling one file that depends\non bindings defined in another without actually loading and evaluating\nthe code in the supporting file.\n" "\nThe parameter source-directories (Section 12.5)\ndetermines the set of directories searched for source files not identified\nby absolute path names.\n") ("system:s61" "\nprocedure: (revisit path)\nreturns: unspecified\nlibraries: (chezscheme)\n" "path must be a string.\nrevisit reads the named file, which must contain compiled object\ncode compatible with the current machine type and version, and it\nruns those portions of the compiled object code that compute\nrun-time values or correspond to expressions identified as \"revisit\" time by\neval-when forms contained in the original source file.\n" "\nContinuing the example given for visit above,\napplying revisit to the object file, t1.so, has\nthe effect of establishing the values of the variable x\nexported from m and the top-level variable y,\nwithout installing either the interface for m or\nthe transformer for a.\n" "\nrevisit is useful for loading compiled application code without\nloading unnecessary compile-time information.\nCare must be taken when using this feature if the application calls\neval or uses top-level-value,\nset-top-level-value!, or top-level-syntax to access\ntop-level bindings at run-time, since these procedures use compile-time\ninformation to resolve top-level bindings.\n" "\nThe parameter source-directories (Section 12.5)\ndetermines the set of directories searched for source files not identified\nby absolute path names.\n") ("system:s63" "\nprocedure: (compile-file input-filename)\nprocedure: (compile-file input-filename output-filename)\nreturns: unspecified\nlibraries: (chezscheme)\n" "input-filename and output-filename must be strings.\ninput-filename must name an existing, readable file.\nIt must contain a sequence of zero or more source expressions;\nif this is not the case, compile-file raises an exception\nwith condition type &syntax.\n" "\nThe normal evaluation process proceeds in two steps: compilation and\nexecution.\ncompile-file performs the compilation process for an entire source\nfile, producing an object file.\nWhen the object file is subsequently loaded (see load), the\ncompilation process is not necessary, and the file typically loads\nseveral times faster.\n" "\nIf the optional output-filename argument is omitted, the\nactual input and output filenames are determined as follows.\nIf input-filename has no extension, the input filename\nis input-filename followed by .ss  and the\noutput filename is input-filename followed by .so.\nIf input-filename has the extension .so, the\ninput filename is input-filename and the output filename\nis input-filename followed by .so.\nOtherwise, the input filename is input-filename and the\noutput filename is input-filename without its extension,\nfollowed by .so.\nFor example, (compile-file \"myfile\") produces an object file\nwith the name \"myfile.so\" from the source file named\n\"myfile.ss\", (compile-file \"myfile.sls\") produces an\nobject file with the name \"myfile.so\" from the source file named\n\"myfile.sls\", and\n(compile-file \"myfile1\" \"myfile2\") produces an object file with\nthe name \"myfile2\" from the source file name \"myfile1\".\n" "\nBefore compiling a file, compile-file saves the values of the\nfollowing parameters:\n" "\n" "optimize-level\ndebug-level\nrun-cp0\ncp0-effort-limit\ncp0-score-limit\ncp0-outer-unroll-limit\ngenerate-inspector-information\ngenerate-procedure-source-information\ncompile-profile\ngenerate-covin-files\ngenerate-interrupt-trap\nenable-cross-library-optimization\n" "It restores the values after the file has been compiled.\nThis allows the programmer to control the values of these parameters on\na per-file basis, e.g., via an eval-when with situation\ncompile embedded in the source file.\nFor example, if\n" "\n" "(eval-when (compile) (optimize-level 3))\n" "appears at the top of a source file, the optimization level is set\nto 3 just while the remainder of file is compiled.\n") ("system:s66" "\nprocedure: (compile-script input-filename)\nprocedure: (compile-script input-filename output-filename)\nreturns: unspecified\nlibraries: (chezscheme)\n" "input-filename and output-filename must be strings.\n" "\ncompile-script is like compile-file but differs in\nthat it copies the leading #! line from the\nsource-file script into the object file.\n" "\ncompile-script permits compiled script files to be created from\nsource script to reduce script load time.\nAs with source-code scripts, compiled scripts may be run with the\n--script\ncommand-line option.\n") ("system:s68" "\nprocedure: (compile-library input-filename)\nprocedure: (compile-library input-filename output-filename)\nreturns: unspecified\nlibraries: (chezscheme)\n" "input-filename and output-filename must be strings.\n" "\ncompile-library is identical to compile-file except\nthat it treats the input file as if it were prefixed by an implicit\n#!r6rs.\nThis effectively disables any non-R6RS lexical\nsyntax except where subsequently overridden by #!chezscheme.\n") ("system:s69" "\nprocedure: (compile-program input-filename)\nprocedure: (compile-program input-filename output-filename)\nreturns: a list of libraries invoked by the program\nlibraries: (chezscheme)\n" "input-filename and output-filename must be strings.\n" "\ncompile-program is like compile-script but differs in\nthat it implements the semantics of RNRS top-level programs, while\ncompile-script implements the semantics of the interactive\ntop-level.\nThe resulting compiled program will also run faster than if compiled\nvia compile-file or compile-script.\n" "\ncompile-program returns a list of libraries directly\ninvoked by the compiled top-level program, excluding built-in\nlibraries like (rnrs) and (chezscheme).\nThe procedure library-requirements may be used to determine\nthe indirect requirements, i.e., additional libraries required by\nthe directly invoked libraries.\nWhen combined with library-object-filename, this information can\nbe used to determine the set of files that must be distributed with the\ncompiled program file.\n" "\nA program invokes a library only if it references one or more variables\nexported from the library.\nThe set of libraries invoked by a top-level program, and hence\nloaded when the program is loaded, might be smaller than the set\nimported by the program, and it might be larger than the set\ndirectly imported by the program.\n" "\nAs with source-code top-level programs, compiled top-level programs may be\nrun with the\n--program\ncommand-line option.\n") ("system:s71" "\nprocedure: (maybe-compile-file input-filename)\nprocedure: (maybe-compile-file input-filename output-filename)\nprocedure: (maybe-compile-library input-filename)\nprocedure: (maybe-compile-library input-filename output-filename)\nprocedure: (maybe-compile-program input-filename)\nprocedure: (maybe-compile-program input-filename output-filename)\nreturns: see below\nlibraries: (chezscheme)\n" "These procedures are like their non-maybe counterparts but\ncompile the source file only if the object file is out-of-date.\nAn object file X is considered out-of-date if it does not exist or\nif it is older than the source file or any files included (via include)\nwhen X was created.\nWhen the value of the parameter compile-imported-libraries\nis #t, X is also considered out-of-date if the object\nfile for any library imported when X was compiled is out-of-date.\nIf maybe-compile-file determines that compilation is necessary,\nit compiles the source file by passing compile-file the\ninput and output filenames.\ncompile-library does so by similarly invoking the value of the\ncompile-library-handler parameter, and\ncompile-program does so by similarly invoking the value of the\ncompile-program-handler parameter.\n" "\nWhen output-filename is not specified, the input and output\nfilenames are determined in the same manner as for compile-file.\n") ("system:s72" "\nthread parameter: compile-library-handler\nlibraries: (chezscheme)\n" "This parameter must be set to a procedure, and the procedure should\naccept two string arguments naming a source file and an object file.\nThe procedure should typically invoke compile-library and\npass it the two arguments, but it can also use one of the other\nfile or port compilation procedures.\nFor example, it might read the source file using its own parser and\nuse compile-to-file to finish\nthe compilation process.\nThe procedure can perform other actions as well, such as parameterizing\ncompilation parameters, establishing guards, or gathering statistics.\nThe default value of this parameter simply invokes\ncompile-library on the two string arguments without taking\nany other action.\n" "\nThe value of this parameter is called by maybe-compile-library\nwhen the object file is out-of-date.\nIt is also called by the expander to compile an\nimported library when compile-imported-libraries is #t\nand the expander determines the object file is out-of-date.\n") ("system:s74" "\nthread parameter: compile-program-handler\nlibraries: (chezscheme)\n" "This parameter must be set to a procedure, and the procedure should\naccept two string arguments naming a source file and an object file.\nThe procedure should typically invoke compile-program and\npass it the two arguments, but it can also use one of the other\nfile or port compilation procedures.\nFor example, it might read the source file using its own parser and\nuse compile-to-file to finish\nthe compilation process.\nThe procedure can perform other actions as well, such as parameterizing\ncompilation parameters, establishing guards, or gathering statistics.\nThe default value of this parameter simply invokes\ncompile-program on the two string arguments without taking\nany other action and returns the list of libraries returned by\ncompile-program.\n" "\nThe value of this parameter is called by maybe-compile-program\nwhen the object file is out-of-date.\n") ("system:s76" "\nprocedure: (compile-whole-program input-filename output-filename)\nprocedure: (compile-whole-program input-filename output-filename libs-visible?)\nreturns: a list of libraries left to be loaded at run time\nlibraries: (chezscheme)\n" "compile-whole-program accepts as input a filename naming\na \"whole program optimization\" (wpo) file for a top-level program\nand produces an object file incorporating the program and each\nlibrary upon which it depends, provided that a wpo file for the\nlibrary can be found.\n" "\nIf a wpo file for a required library cannot be found, but an object\nfile for the library can, the library is not incorporated in the\nresulting object file.\nSuch libraries are left to be loaded at run time.\ncompile-whole-program returns a list of such libraries.\nIf there are no such libraries, the resulting object file is\nself-contained and compile-whole-program returns the empty\nlist.\n" "\nThe libraries incorporated into the resulting object file are visible (for\nuse by environment and eval) if the libs-visible?\nargument is supplied and non-false.\nAny library incorporated into the resulting object file and required by\nan object file left to be loaded at run time is also visible, as are any\nlibraries the object file depends upon, regardless of the value of\nlibs-visible?.\n" "\ncompile-whole-program linearizes the initialization code for the\nset of incorporated libraries in a way that respects static\ndependencies among the libraries but not necessary dynamic dependencies\nderiving from initialization-time uses of environment\nor eval.\nAdditional static dependencies can be added in most cases to force\nan ordering that allows the dynamic imports to succeed,\nthough not in general since a different order might be required each\ntime the program is run.\nAdding a static dependency of one library on a second requires\nadding an import of the second in the first as well as a run-time\nreference to one of the variables exported by the second in the\nbody of the first.\n" "\ninput-filename and output-filename must be strings.\ninput-filename must identify a wpo file, and a wpo or object\nfile must also be present for each required library somewhere in\nthe directories specified by the library-directories\nparameter.\n" "\nTo the extent possible given the specified set of visible libraries\nand requirements of libraries to be loaded at run time,\ncompile-whole-program discards unused code and optimizes\nacross program and library boundaries, potentially reducing program\nload time, run time, and memory requirements.\nSome optimization also occurs even across the boundaries of libraries\nthat are not incorporated into the output, though this optimization\nis limited in nature.\n" "\nThe procedures compile-file, compile-program, compile-library,\ncompile-script, and compile-whole-library produce wpo files as well as ordinary\nobject files when the generate-wpo-files parameter is set\nto #t (the default is #f).\ncompile-port and compile-to-port do so when passed\nan optional wpo port.\n") ("system:s78" "\nprocedure: (compile-whole-library input-filename output-filename)\nreturns: a list of libraries left to be loaded at run time\nlibraries: (chezscheme)\n" "compile-whole-library is like compile-whole-program,\nexcept input-filename must specify a wpo file for a library,\nall libraries are automatically made visible, and a new wpo file is\nproduced (when generate-wpo-files is #t) as well\nas an object file for the resulting combination of libraries.\n" "\nThe comment in the description of compile-whole-program\nabout the effect of initialization-code linearization on dynamic\ndependencies applies to compile-whole-library as well.\n") ("system:s79" "\nprocedure: (compile-port input-port output-port)\nprocedure: (compile-port input-port output-port sfd)\nprocedure: (compile-port input-port output-port sfd wpo-port)\nprocedure: (compile-port input-port output-port sfd wpo-port covop)\nreturns: unspecified\nlibraries: (chezscheme)\n" "input-port must be a textual input port.\noutput-port and, if present and non-false, wpo-port must be binary output ports.\nIf present and non-false, sfd must be a source-file descriptor.\nIf present and non-false, covop must be a textual output port.\n" "\ncompile-port is like compile-file except that it takes\ninput from an arbitrary textual input port and sends output to an arbitrary\nbinary output port.\nIf sfd is supplied, it is passed to the reader so that source information\ncan be associated with the expressions read from input-port.\nIt is also used to associate block-profiling information with the input\nfile name encapsulated within sfd.\nIf wpo-port is supplied, compile-port sends whole-program optimization information\nto wpo-port for use by compile-whole-program, as if\n(and regardless of whether) generate-wpo-files is set.\nIf covop is supplied, compile-port sends coverage information to\ncovop, as if (and regardless of whether) generate-covin-files is set.\n" "\nThe ports are closed automatically after compilation under the assumption\nthe program that opens the ports and invokes compile-port\nwill take care of closing the ports.\n") ("system:s80" "\nprocedure: (compile-to-port obj-list output-port)\nprocedure: (compile-to-port obj-list output-port sfd)\nprocedure: (compile-to-port obj-list output-port sfd wpo-port)\nprocedure: (compile-to-port obj-list output-port sfd wpo-port covop)\nreturns: see below\nlibraries: (chezscheme)\n" "obj-list must be a list containing a sequence of\nobjects that represent syntactically valid expressions, each possibly\nannotated (Section 11.11).\nIf any of the objects does not represent a syntactically valid\nexpression, compile-to-port raises an exception with\ncondition type &syntax.\noutput-port and, if present, wpo-port must be binary output ports.\nIf present, sfd must be a source-file descriptor.\n" "\ncompile-to-port is like compile-file except that it takes\ninput from a list of objects and sends output to an arbitrary binary\noutput port.\nsfd is used to associate block-profiling information with the\ninput file name encapsulated within sfd.\nIf wpo-port is present, compile-to-port sends whole-program optimization information\nto wpo-port for use by compile-whole-program, as if\n(and regardless of whether) generate-wpo-files is set.\nIf covop is present, compile-to-port sends coverage information to\ncovop, as if (and regardless of whether) generate-covin-files is set.\n" "\nThe ports are not closed automatically after compilation under the assumption\nthe program that opens the port and invokes compile-to-port\nwill take care of closing the port.\n" "\nWhen obj-list contains a single list-structured element whose\nfirst-element is the symbol top-level-program,\ncompile-to-port returns a list of the libraries the top-level\nprogram requires at run time, as with compile-program.\nOtherwise, the return value is unspecified.\n") ("system:s81" "\nprocedure: (compile-to-file obj-list output-file)\nprocedure: (compile-to-file obj-list output-file sfd)\nreturns: see below\nlibraries: (chezscheme)\n" "obj-list must be a list containing a sequence of\nobjects that represent syntactically valid expressions, each possibly\nannotated (Section 11.11).\nIf any of the objects does not represent a syntactically valid\nexpression, compile-to-file raises an exception with\ncondition type &syntax.\noutput-file must be a string.\nIf present, sfd must be a source-file descriptor.\n" "\ncompile-to-file is like compile-file except that it takes\ninput from a list of objects.\nsfd is used to associate block-profiling information with the\ninput file name encapsulated within sfd.\n" "\nWhen obj-list contains a single list-structured element whose\nfirst-element is the symbol top-level-program,\ncompile-to-file returns a list of the libraries the top-level\nprogram requires at run time, as with compile-program.\nOtherwise, the return value is unspecified.\n") ("system:s82" "\nprocedure: (concatenate-object-files out-file in-file1 in-file2 ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "out-file and each in-file must be strings.\n" "\nconcatenate-object-files combines the header information\ncontained in the object files named by each in-file.  It then\nwrites the combined header information to the file named by\nout-file, followed by the remaining object code from each\ninput file in turn.\n") ("system:s83" "\nprocedure: (make-boot-file output-filename base-boot-list input-filename ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "output-filename, input-filename, and the elements of\nbase-boot-list must be strings.\n" "\nmake-boot-file writes a boot header to the file named by\noutput-filename, followed by the object code for each\ninput-filename in turn.\nIf an input file is not already compiled, make-boot-file compiles\nthe file as it proceeds.\n" "\nThe boot header identifies the elements of base-boot-list as\nalternative boot files upon which the new boot file depends.\nIf the list of strings naming base boot files is empty, the first named\ninput file should be a base boot file, i.e., petite.boot or some boot file\nderived from petite.boot.\n" "\nBoot files are loaded explicitly via the --boot or -b\ncommand-line options or implicitly based on the name of the executable\n(Section 2.9).\n" "\nSee Section 2.8 for more information on boot files\nand the use of make-boot-file.\n") ("system:s86" "\nprocedure: (make-boot-header output-filename base-boot1 base-boot2...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure has been subsumed by make-boot-file and is provided for\nbackward compatibility.\nThe call\n" "\n" "(make-boot-header output-filename base-boot1 base-boot2 ...)\n" "is equivalent to\n" "\n" "(make-boot-file output-filename '(base-boot1 base-boot2 ...))\n") ("system:s87" "\nprocedure: (strip-fasl-file input-path output-path options)\nreturns: unspecified\nlibraries: (chezscheme)\n" "input-path and output-path must be strings.\ninput-path must name an existing, readable file containing\nobject code produced by compile-file, one of the other\nfile-compiling procedures, or an earlier run of strip-fasl-file.\noptions must be an enumeration set over the symbols constituting\nvalid strip options, as described in the fasl-strip-options\nentry below.\n" "\nThe new procedure strip-fasl-file allows the removal of\nsource information of various sorts from a compiled object (fasl)\nfile produced by compile-file or one of the other file\ncompiling procedures.\nIt also allows removal of library visit code from object files\ncontaining compiled libraries.\nVisit code is the code for macro transformers and meta definitions\nrequired to compile (but not run) dependent libraries.\n" "\nOn most platforms, the input and output paths can be the same,\nin which case the input file is replaced with a new file containing\nthe stripped object code.\nUsing the same path will likely fail on Windows file systems,\nwhich do not generally permit an open file to be removed.\n" "\nIf options is empty, the output file is effectively equivalent\nto the input file, though it will not necessarily be identical.\n") ("system:s88" "\nsyntax: (fasl-strip-options symbol ...)\nreturns: a fasl-strip-options enumeration set\nlibraries: (chezscheme)\n" "Fasl-strip-options enumeration sets are passed to strip-fasl-file\nto determine what is stripped.\nThe available options are described below.\n" "\ninspector-source:\nStrip inspector source information.\nThis includes source expressions that might otherwise be available\nfor procedures and continuations with the \"code\" and \"call\"\ncommands and messages in the interactive and object inspectors.\nIt also includes filename and position information that might\notherwise be available for the same via the \"file\" command and\n\"source\" messages.\n" "\nsource-annotations:\nStrip source annotations, which typically appear only on syntax objects,\ne.g., identifiers, in the templates of macro transformers.\n" "\nprofile-source:\nStrip source file and character position information from profiled\ncode objects.\nThis does not remove the profile counters or eliminate the overhead\nfor incrementing them at run time.\n" "\ncompile-time-information: \nThis strips compile-time information from compiled libraries, potentially\nreducing the size of the resulting file but making it impossible to\nuse the file to compile dependent code.\nThis option is useful for creating smaller object files to ship\nas part of a binary-only package.\n\n") ("system:s89" "\nprocedure: (machine-type)\nreturns: the current machine type\nlibraries: (chezscheme)\n" "Consult the release notes for the current version of Chez Scheme\nfor a list of supported machine types.\n\n") ("system:s90" "\ndesc:expand\nprocedure: (expand obj)\nprocedure: (expand obj env)\nreturns: expansion of the Scheme form represented by obj\nlibraries: (chezscheme)\n" "expand treats obj as the representation of an expression.\nIt expands the expression in environment env and returns\nan object representing the expanded form.\nIf no environment is provided, it defaults to the environment\nreturned by interaction-environment.\n" "\nobj can be an annotation\n(Section 11.11), and the default expander\nmakes use of annotations to incorporate source-file\ninformation in error messages.\n" "\nexpand actually passes its arguments to the current expander\n(see current-expand), initially sc-expand.\n" "\nSee also expand-output (page 363)\nwhich can be used to request that the compiler or interpreter show\nexpander output.\n") ("system:s92" "\nthread parameter: current-expand\nlibraries: (chezscheme)\n" "current-expand determines the expansion procedure used by\nthe compiler, interpreter, and direct calls to\nexpand\nto expand syntactic extensions.\ncurrent-expand is initially bound to the value of\nsc-expand.\n" "\nIt may be set another procedure, but since the format of\nexpanded code expected by the compiler and interpreter is not publicly\ndocumented, only sc-expand produces correct output, so the\nother procedure must ultimately be defined in terms of\nsc-expand.\n" "\nThe first argument to the expansion procedure represents the input\nexpression.\nIt can be an annotation (Section 11.11) or an\nunannotated value.\nthe second argument is an environment.\nAdditional arguments might be passed to the expansion procedure\nby the compiler, interpreter, and expand; their number\nand roles are unspecified.\n") ("system:s95" "\nprocedure: (sc-expand obj)\nprocedure: (sc-expand obj env)\nreturns: the expanded form of obj\nlibraries: (chezscheme)\n" "The procedure\nsc-expand is used to expand programs written using\nsyntax-case macros.\nsc-expand is the default expander, i.e., the initial\nvalue of current-expand.\nobj represents the program to be expanded, and\nenv must be an environment.\nobj can be an annotation (Section 11.11)\nor unannotated value.\nIf not provided, env defaults to the environment returned by\ninteraction-environment.\n") ("system:s96" "\ndesc:expand/optimize\nprocedure: (expand/optimize obj)\nprocedure: (expand/optimize obj env)\nreturns: result of expanding and optimizing form represented by obj\nlibraries: (chezscheme)\n" "expand/optimize treats obj as the representation of\nan expression.\nobj can be an annotation (Section 11.11)\nor unannotated value.\nexpand/optimize expands the expression in environment env\nand passes the expression through the source optimizer cp0\n(unless cp0 is disabled via run-cp0).\nIt also simplifies letrec and letrec* expressions within\nthe expression and makes their undefined checks explicit.\nIt returns an object representing the expanded, simplified, and optimized form.\nIf no environment is provided, it defaults to the environment\nreturned by interaction-environment.\n" "\nexpand/optimize is primarily useful for understanding what\ncp0 does and does not optimize.\nMany optimizations are performed later in the compiler,\nso expand/optimize does not give a complete picture of\noptimizations performed.\n" "\n" "(expand/optimize\n  '(let ([y '(3 . 4)])\n     (+ (car y) (cdr y)))) --> 7\n\n(print-gensym #f)\n(expand/optimize\n  '(let ([y '(3 . 4)])\n     (lambda (x)\n       (* (+ (car y) (cdr y)) x)))) --> (lambda (x) (#2%* 7 x))\n\n(expand/optimize\n  '(let ([n (expt 2 10)])\n     (define even?\n       (lambda (x) (or (zero? x) (not (odd? x)))))\n     (define odd?\n       (lambda (x) (not (even? (- x 1)))))\n     (define f\n       (lambda (x)\n         (lambda (y)\n           (lambda (z)\n             (if (= z 0) (omega) (+ x y z))))))\n     (define omega\n       (lambda ()\n         ((lambda (x) (x x)) (lambda (x) (x x)))))\n     (let ([g (f 1)] [m (f n)])\n       (let ([h (if (> ((g 2) 3) 5)\n                    (lambda (x) (+ x 1))\n                    odd?)])\n         (h n))))) --> 1025\n" "See also expand/optimize-output (page 363)\nwhich can be used to request that the compiler or interpreter show\nsource-optimizer output.\n") ("system:s98" "\nsyntax: (eval-when situations form1 form2 ...)\nreturns: see below\nlibraries: (chezscheme)\n" "situations must be a list containing some combination of the symbols\neval, compile, load, visit, and\nrevisit.\n" "\nWhen source files are loaded (see load), the forms in the file\nare read, compiled, and executed sequentially, so that each form in\nthe file is fully evaluated before the next one is read.\nWhen a source file is compiled (see compile-file), however, the\nforms are read and compiled, but not executed, in sequence.\nThis distinction matters only when the execution of one\nform in the file affects the compilation of later forms, e.g.,\nwhen the form results in the definition of a module or syntactic form or\nsets a compilation parameter such as optimize-level or\ncase-sensitive.\n" "\nFor example, assume that a file contains the following two forms:\n" "\n" "(define-syntax reverse-define\n  (syntax-rules ()\n    [(_ e x) (define x e)]))\n\n(reverse-define 3 three)\n" "Loading this from source has the effect of defining\nreverse-define as a syntactic form and binding the identifier\nthree to 3.\nThe situation may be different if the file is compiled with\ncompile-file, however.\nUnless the system or programmer takes steps to assure that the first\nform is fully executed before the second expression is compiled,\nthe syntax expander will not recognize reverse-define as a syntactic\nform and will generate code for a procedure call to reverse-define\ninstead of generating code to define three to be 3.\nWhen the object file is subsequently loaded, the attempt to reference\neither reverse-define or three will fail.\n" "\nAs it happens, when a define-syntax, module,\nimport, or import-only form appears at top level, as in the\nexample above, the compiler does indeed arrange to evaluate it before\ngoing on to compile the remainder of the file.\nIf the compiler encounters a variable definition for an identifier that\nwas previously something else, it records that fact as well.\nThe compiler also generates the\nappropriate code so that the bindings will be present as well when\nthe object file is subsequently loaded.\nThis solves most, but not all, problems of this nature, since most are\nrelated to the use of define-syntax and modules.\nSome problems are not so straightforwardly handled, however.\nFor example, assume that the file contains the following definitions\nfor nodups? and mvlet.\n" "\n" "(define nodups?\n  (lambda (ids)\n    (define bound-id-member?\n      (lambda (id ids)\n        (and (not (null? ids))\n             (or (bound-identifier=? id (car ids))\n                 (bound-id-member? id (cdr ids))))))\n    (or (null? ids)\n        (and (not (bound-id-member? (car ids) (cdr ids)))\n             (nodups? (cdr ids))))))\n\n(define-syntax mvlet\n  (lambda (x)\n    (syntax-case x ()\n      [(_ ((x ...) expr) b1 b2 ...)\n       (and (andmap identifier? #'(x ...))\n            (nodups? #'(x ...)))\n       #'(call-with-values\n           (lambda () expr)\n           (lambda (x ...) b1 b2 ...))])))\n\n(mvlet ((a b c) (values 1 2 3))\n  (list (* a a) (* b b) (* c c)))\n" "When loaded directly, this results in the definition of\nnodups? as a procedure and mvlet as a syntactic\nabstraction before evaluation of the mvlet expression.\nBecause nodups? is defined before the mvlet\nexpression is expanded, the call to nodups? during the\nexpansion of mvlet causes no difficulty.\nIf instead this file were compiled, using compile-file, the\ncompiler would arrange to define mvlet before continuing\nwith the expansion and evaluation of the mvlet expression,\nbut it would not arrange to define nodups?.\nThus the expansion of the mvlet expression would fail.\n" "\nIn this case it does not help to evaluate the syntactic extension alone.\nA solution in this case would be to move the definition of\nnodups? inside the definition for mvlet, just as\nthe definition for bound-id-member? is placed within\nnodups?, but this does not work for help routines shared\namong several syntactic definitions.\nAnother solution is to label the nodups? definition a\n\"meta\" definition (see Section 11.8) but this\ndoes not work for helpers that are used both by syntactic\nabstractions and by run-time code.\n" "\nA somewhat simpler problem occurs when setting parameters that affect\ncompilation, such as optimize-level and\ncase-sensitive?.\nIf not set prior to compilation, their settings usually will not have\nthe desired effect.\n" "\neval-when offers a solution to these problems by allowing the\nprogrammer to explicitly control what forms should or should not\nbe evaluated during compilation.\neval-when is a syntactic form and is handled directly by the\nexpander.\nThe action of eval-when depends upon the situations argument\nand whether or not the forms form1 form2 ...\nare being compiled via compile-file or are being evaluated\ndirectly.\nLet's consider each of the possible situation specifiers\neval, compile, load, visit, and\nrevisit in turn.\n" "\neval:\nThe eval specifier is relevant only when the eval-when\nform is being\nevaluated directly, i.e., if it is typed at the keyboard or loaded from a\nsource file.\nIts presence causes form1 form2 ... to be\nexpanded and this expansion to be included in the expansion of the\neval-when form.\nThus, the forms will be evaluated directly as if not contained within an\neval-when form.\n" "\ncompile:\nThe compile specifier is relevant only when the eval-when\nform appears in a file currently being compiled.\n(Its presence is simply ignored otherwise.)\nIts presence forces form1 form2 ... to be\nexpanded and evaluated immediately.\n" "\nload:\nThe load specifier is also relevant only when the eval-when\nform appears\nin a file currently being compiled.\nIts presence causes form1 form2 ... to be\nexpanded and this expansion to be included in the expansion of the\neval-when form.\nAny code necessary to record binding information and evaluate syntax\ntransformers for definitions contained in the forms is marked for\nexecution when the file is \"visited,\" and any code necessary to\ncompute the values of variable definitions and the expressions contained\nwithin the forms is marked for execution when the file is \"revisited.\"\n" "\nvisit:\nThe visit specifier is also relevant only when the eval-when\nform appears\nin a file currently being compiled.\nIts presence causes form1 form2 ... to be\nexpanded and this expansion to be included in the expansion of the\neval-when form, with an annotation that the forms are to be\nexecuted when the file is \"visited.\"\n" "\nrevisit:\nThe revisit specifier is also relevant only when the eval-when\nform appears\nin a file currently being compiled.\nIts presence causes form1 form2 ... to be\nexpanded and this expansion to be included in the expansion of the\neval-when form, with an annotation that the forms are to be\nexecuted when the file is \"revisited.\"\n\n" "\nA file is considered \"visited\" when it is brought in by either\nload or visit and \"revisited\" when it is brought in\nby either load or revisit.\n" "\nTop-level expressions are treated as if they are wrapped in an\neval-when with situations load and eval.\nThis means that, by default, forms typed at the keyboard or\nloaded from a source file are evaluated, and forms appearing in a\nfile to be compiled are not evaluated directly but are compiled for\nexecution when the resulting object file is subsequently loaded.\n" "\nThe treatment of top-level definitions is slightly more involved.\nAll definitions result in changes to the compile-time environment.\nFor example, an identifier defined by define is recorded\nas a variable, and an identifier defined by define-syntax\nis recorded as a keyword and associated with the value of its\nright-hand-side (transformer) expression.\nThese changes are made at eval, compile, and load\ntime as if the definitions were wrapped in an eval-when with\nsituations eval, load, and compile.\n(This behavior can be altered by changing the value of the\nparameter eval-syntax-expanders-when.)\nSome definitions also result in changes to the run-time environment.\nFor example, a variable is associated with the value of its\nright-hand-side expression.\nThese changes are made just at evaluation and load time as if the\ndefinitions were wrapped in an eval-when with situations\neval and load.\n" "\nThe treatment of local expressions or definitions (those not at top level)\nthat are wrapped in an eval-when depends only upon whether the\nsituation eval is present in the list of situations.\nIf the situation eval is present, the definitions and expressions\nare evaluated as if they were not wrapped in an eval-when form,\ni.e., the eval-when form is treated as a begin form.\nIf the situation eval is not present, the forms are ignored;\nin a definition context, the eval-when form is treated as an\nempty begin, and in an expression context, the eval-when\nform is treated as a constant with an unspecified value.\n" "\nSince top-level syntax bindings are established, by default, at compile\ntime as well as eval and load time, top-level variable bindings needed\nby syntax transformers should be wrapped in an eval-when form\nwith situations compile, load, and eval.\nWe can thus nodups? problem above by enclosing the definition\nof nodups? in an eval-when as follows.\n" "\n" "(eval-when (compile load eval)\n  (define nodups?\n    (lambda (ids)\n      (define bound-id-member?\n        (lambda (id ids)\n          (and (not (null? ids))\n               (or (bound-identifier=? id (car ids))\n                   (bound-id-member? id (cdr ids))))))\n      (or (null? ids)\n          (and (not (bound-id-member? (car ids) (cdr ids)))\n               (nodups? (cdr ids)))))))\n" "This forces it to be evaluated before it is needed during the expansion\nof the mvlet expression.\n" "\nJust as it is useful to add compile to the default\nload and eval situations, omitting options is also\nuseful.\nOmitting one or more of compile, load, and\neval has the effect of preventing the evaluation at the given\ntime.\nOmitting all of the options has the effect of inhibiting evaluation\naltogether.\n" "\nOne common combination of situations is (compile eval), which by the\ninclusion of compile causes the expression to be evaluated at\ncompile time, and by the omission of load inhibits the generation\nof code by the compiler for execution when the file is subsequently loaded.\nThis is typically used for the definition of syntactic extensions used only\nwithin the file in which they appear; in this case their presence in the\nobject file is not necessary.\nIt is also used to set compilation parameters that are intended to be in\neffect whether the file is loaded from source or compiled via\ncompile-file\n" "\n" "(eval-when (compile eval) (case-sensitive #t))\n" "Another common situations list is (compile), which might be\nused to set compilation options to be used only when the file is\ncompiled via compile-file.\n" "\n" "(eval-when (compile) (optimize-level 3))\n" "Finally, one other common combination is (load eval), which might\nbe useful for inhibiting the double evaluation (during the compilation of\na file and again when the resulting object file is loaded) of syntax\ndefinitions when the syntactic extensions are not needed within\nthe file in which their definitions appear.\n" "\nThe behavior of eval-when is usually intuitive but can be\nunderstood precisely as follows.\nThe syntax-case expander, which handles eval-when\nforms, maintains two state sets, one for compile-time forms and\none for run-time forms.\nThe set of possible states in each set are \"L\" for load,\n\"C\" for compile, \"V\" for visit, \"R\" for\nrevisit, and \"E\" for eval.\n" "\nWhen compiling a file, the compile-time set initially contains \"L\"\nand \"C\" and the run-time set initially contains only \"L.\"\nWhen not compiling a file (as when a form is evaluated by the\nread-eval-print loop or loaded from a source file), both sets\ninitially contain only \"E.\"\nThe subforms of an eval-when form at top level are expanded with\nnew compile- and run-time sets determined by the current sets and\nthe situations listed in the eval-when form.\nEach element of the current set contributes zero or more elements to the\nnew set depending upon the given situations according to the following\ntable.\n" "\ncenter\n  center load  center  compile  center  visit  center  revisit  center  evalcenter\nL center  L  center  C  center  V  center  R  center --- center\nC center --- center --- center --- center --- center  C  center\nV center  V  center  C  center  V  center --- center --- center\nR center  R  center  C  center --- center  R  center --- center\nE center --- center --- center --- center --- center  E  center\n\n" "\nFor example, if the current compile-time state set is {L}\nand the situations are load and compile, the new compile-time\nstate set is {L, C}, since L/load\ncontributes \"L\" and L/compile contributes \"C.\"\n" "\nThe state sets determine how forms are treated by the expander.\nCompile-time forms such as syntax definitions are evaluated at a time\nor times determined by the compile-time state set, and run-time forms\nare evaluated at a time or times determined by the run-time state set.\nA form is evaluated immediately if \"C\" is in the state set.\nCode is generated to evaluate the form at visit or revisit\ntime if \"V\" or \"R\" is present.\nIf \"L\" is present in the compile-time set, it is treated as \"V;\"\nlikewise, if \"L\" is present in the run-time set, it is treated as\n\"R.\"\nIf more than one of states is present in the state set, the\nform is evaluated at each specified time.\n" "\n\"E\" can appear in the state set only when not compiling a file, i.e.,\nwhen the expander is invoked from an evaluator such as compile\nor interpret.\nWhen it does appear, the expanded form is returned from the expander to be\nprocessed by the evaluator, e.g., compile or interpret,\nthat invoked the expander.\n" "\nThe value of the parameter eval-syntax-expanders-when actually determines\nthe initial compile-time state set.\nThe parameter is bound to a list of situations, which defaults to\n(compile load eval).\nWhen compiling a file, compile contributes \"C\" to the\nstate set, load contributes \"L,\" visit contributes\n\"V,\" revisit contributes \"R,\" and eval\ncontributes nothing.\nWhen not compiling a file, eval contributes \"E\" to the\nstate set, and the other situations contribute nothing.\nThere is no corresponding parameter for controlling the initial value\nof the run-time state set.\n" "\neval-when-tlpFor RNRS top-level programs, eval-when is essentially ineffective.\nThe entire program is treated as a single expression, so eval-when\nbecomes a local eval-when for which only the eval\nsituation has any relevance.\nAs for any local eval-when form, the subforms are ignored if\nthe eval situation is not present; otherwise, they are treated as\nif the eval-when wrapper were absent.\n") ("system:s101" "\nthread parameter: eval-syntax-expanders-when\nlibraries: (chezscheme)\n" "This parameter must be set to a list representing a set of\neval-when situations, e.g., a list containing at most one\noccurrence of each of the symbols eval, compile,\nload, visit, and revisit.\nIt is used to determine the evaluation time of syntax\ndefinitions, module forms, and import forms are expanded.\n(See the discussion of eval-when above.)\nThe default value is (compile load eval), which causes\ncompile-time information in a file to be established when the file is\nloaded from source, when it is compiled via compile-file,\nand when a compiled version of the file is loaded via load\nor visit.\n") ("system:s102" "\nglobal parameter: source-directories\nlibraries: (chezscheme)\n" "The value of source-directories must be a list of strings, each\nof which names a directory path.\nsource-directories determines the set of directories searched\nfor source or object files when a file is loaded via load, load-library,\nload-program, include,\nvisit, or revisit,\nwhen a syntax error occurs, or when a source\nfile is opened in the interactive inspector.\n" "\nThe default value is the list (\".\"), which means source files\nwill be found only in or relative to the current directory, unless named\nwith an absolute path.\n" "\nThis parameter is never altered by the system, with one exception.\nThe expander temporarily adds (via parameterize) the directory\nin which a library file resides to the front of the source-directories\nlist when it compiles (when compile-imported-libraries is true) or loads the library from source, which it does\nonly if the library is not already defined.\n") ("system:s103" "\nprocedure: (with-source-path who name procedure)\nlibraries: (chezscheme)\n" "The procedure with-source-path searches through the current\nsource-directories path, in order, for a file with the specified\nname and invokes procedure on the result.\nIf no such file is found, an exception is raised with condition types\n&assertion and &who with who as\nwho value.\n" "\nIf name is an absolute pathname or one beginning with \n(or .\\ under Windows) or ../ (or ..\\ under\nWindows), or if the list of source directories\ncontains only \".\", the default, or \"\", which is\nequivalent to \".\", no searching is performed and name is\nreturned.\n" "\nwho must be a symbol, name must be a string, and\nprocedure should accept one argument.\n" "\nThe following examples assumes that the file \"pie\" exists\nin the directory \"../spam\" but not in \"../ham\" or the current\ndirectory.\n" "\n" "(define find-file\n  (lambda (fn)\n    (with-source-path 'find-file fn values)))\n\n(find-file \"pie\") --> \"pie\"\n\n(source-directories '(\".\" \"../ham\"))\n(find-file \"pie\") --> exception in find-file: pie not found\n\n(source-directories '(\".\" \"../spam\"))\n(find-file \"pie\") --> \"../spam/pie\"\n\n(source-directories '(\".\" \"../ham\"))\n(find-file \"/pie\") --> \"/pie\"\n\n(source-directories '(\".\" \"../ham\"))\n(find-file \"./pie\") --> \"./pie\"\n\n(source-directories '(\".\" \"../spam\"))\n(find-file \"../pie\") --> \"../ham/pie\"\n") ("system:s104" "\nthread parameter: optimize-level\nlibraries: (chezscheme)\n" "This parameter can take on one of the four values 0, 1, 2, and 3.\n" "\nIn theory, this parameter controls the amount of optimization\nperformed by the compiler.\nIn practice, it does so only indirectly, and the only difference\nis between optimize level 3, at which the compiler generates\n\"unsafe\" code, and optimize levels 0-2, at which the compiler\ngenerates \"safe\" code.\nSafe code performs full type and bounds checking so that, for example,\nan attempt to apply a non-procedure, an attempt to take the car of a\nnon-pair, or an attempt to reference beyond the end of a vector each\nresult in an exception being raised.\nWith unsafe code, the same situations may result in invalid memory\nreferences, corruption of the Scheme heap (which may cause\nseemingly unrelated problems later), system crashes, or other undesirable\nbehaviors.\nUnsafe code is typically faster, but optimize-level 3 should be used with\ncaution and only on sections of well-tested code that must run as quickly\nas possible.\n" "\nWhile the compiler produces the same code for optimize levels 0-2,\nuser-defined macro transformers can differentiate among the different\nlevels if desired.\n" "\nOne way to use optimize levels is on a per-file\nbasis, using eval-when to force the use of a particular\noptimize level at compile time.\nFor example, placing:\n" "\n" "(eval-when (compile) (optimize-level 3))\n" "at the front of a file will cause all of the forms in the file to be\ncompiled at optimize level 3 when the file is compiled (using\ncompile-file) but does not affect the optimize level used\nwhen the file is loaded from source.\nSince compile-file parameterizes optimize-level (see parameterize),\nthe above\nexpression does not permanently alter the optimize level in the\nsystem in which the compile-file is performed.\n" "\nThe optimize level can also be set via the\n--optimize-level\ncommand-line option (Section 2.9).\nThis option is particularly useful for running RNRS top-level programs\nat optimize-level 3 via the\n--program command-line option,\nsince eval-when is ineffective for RNRS top-level programs as described\non page 355.\n\n") ("system:s109" "\ndesc:hash-primitive\nsyntax: ($primitive variable)\nsyntax: #%variable\nsyntax: ($primitive 2 variable)\nsyntax: #2%variable\nsyntax: ($primitive 3 variable)\nsyntax: #3%variable\nreturns: the primitive value for variable\nlibraries: (chezscheme)\n" "variable must name a primitive procedure.\nThe $primitive syntactic form allows control over the\noptimize level at the granularity of individual primitive references,\nand it can be used to access the original value\nof a primitive, regardless of the lexical context or the current\ntop-level binding for the variable originally bound to the primitive.\n" "\nThe expression ($primitive variable) may\nbe abbreviated as #%variable.\nThe reader expands #% followed by an object\ninto a $primitive expression, much as it expands 'object\ninto a quote expression.\n" "\nIf a 2 or 3 appears in the form or between the\n# and % in the abbreviated form, the compiler treats\nan application of the primitive as if it were compiled\nat the corresponding optimize level (see the optimize-level\nparameter).\nIf no number appears in the form, an application of the primitive is\ntreated as an optimize-level 3 application if the current optimize\nlevel is 3;\notherwise, it is treated as an optimize-level 2 application.\n" "\n" "(#%car '(a b c)) --> a\n(let ([car cdr]) (car '(a b c))) --> (b c)\n(let ([car cdr]) (#%car '(a b c))) --> a\n(begin (set! car cdr) (#%car '(a b c))) --> a\n") ("system:s110" "\nthread parameter: debug-level\nlibraries: (chezscheme)\n" "This parameter can take on one of the four values 0, 1, 2, and 3.\nIt is used to tell the compiler how important the preservation of\ndebugging information is, with 0 being least important and 3 being\nmost important.\nThe default value is 1.\nAs of Version 9.0, it is used solely to determine whether an\nerror-causing call encountered in nontail position is treated as\nif it were in tail position (thus causing the caller's frame not\nto appear in a stack backtrace); this occurs at debug levels below 2.\n") ("system:s111" "\nthread parameter: generate-interrupt-trap\nlibraries: (chezscheme)\n" "To support interrupts, including keyboard, timer, and collect request\ninterrupts, the compiler inserts a short sequence of instructions at the\nentry to each nonleaf procedure (Section 12.2).\nThis small overhead may be eliminated by setting\ngenerate-interrupt-trap to #f.\nThe default value of this parameter is #t.\n" "\nIt is rarely a good idea to compile code without interrupt trap\ngeneration, since a tight loop in the generated code may completely\nprevent interrupts from being serviced, including the collect request\ninterrupt that causes garbage collections to occur automatically.\nDisabling trap generation may be useful, however, for routines that act\nsimply as \"wrappers\" for other routines for which code is presumably\ngenerated with interrupt trap generation enabled.\nIt may also be useful for short performance-critical routines with\nembedded loops or recursions that are known to be short running and\nthat make no other calls.\n\n") ("system:s112" "\nthread parameter: compile-interpret-simple\nlibraries: (chezscheme)\n" "At all optimize levels, when the value of\ncompile-interpret-simple is set to a true value (the default),\ncompile interprets simple\nexpressions.\nA simple expression is one that creates no procedures.\nThis can save a significant amount of time over the course of many\ncalls to compile or eval (with current-eval\nset to compile, its default value).\nWhen set to false, compile compiles all expressions.\n\n") ("system:s114" "\ndesc:generate-inspector-information\nthread parameter: generate-inspector-information\nlibraries: (chezscheme)\n" "When this parameter is set to a true value (the default), information\nabout the source and contents of procedures and continuations is\ngenerated during compilation and retained in tables associated with\neach code segment.\nThis information allows the inspector to provide more complete\ninformation, at the expense of using more memory and producing\nlarger object files (via compile-file).\nAlthough compilation and loading may be slower when inspector\ninformation is generated, the speed of the compiled code is not\naffected.\nIf this parameter is changed during the compilation of a file, the\noriginal value will be restored.\nFor example, if:\n" "\n" "(eval-when (compile) (generate-inspector-information #f))\n" "is included in a file, generation of inspector information will be\ndisabled only for the remainder of that particular file.\n") ("system:s115" "\ndesc:generate-procedure-source-information\nthread parameter: generate-procedure-source-information\nlibraries: (chezscheme)\n" "When generate-inspector-information is set to #f and\nthis parameter is set to #t, then a source location is preserved\nfor a procedure, even though other inspector information is not preserved.\nSource information provides a small amount of debugging support at a\nmuch lower cost in memory and object-file size than full inspector information.\nIf this parameter is changed during the compilation of a file, the\noriginal value will be restored.\n") ("system:s116" "\nthread parameter: enable-cross-library-optimization\nlibraries: (chezscheme)\n" "This parameter controls whether information is included with the\nobject code for a compiled library to enable propagation of constants\nand inlining of procedures defined in the library into dependent\nlibraries.\nWhen set to #t (the default), this information is included;\nwhen set to #f, the information is not included.\nSetting the parameter to #f potentially reduces the sizes\nof the resulting object files and the exposure of near-source\ninformation via the object file.\n") ("system:s117" "\nthread parameter: generate-wpo-files\nlibraries: (chezscheme)\n" "When this parameter is set to #t (the default is #f),\ncompile-file, compile-library, compile-program,\nand compile-script produce whole-program optimization (wpo)\nfiles for use by compile-whole-program.\nThe name of the wpo file is derived from the output-file\nname by replacing the object-file extension (normally .so)\nwith .wpo, or adding the extension .wpo if the\nobject filename has no extension or has the extension .wpo.\n") ("system:s119" "\nthread parameter: compile-file-message\nlibraries: (chezscheme)\n" "When this parameter is set to true, the default, compile-file,\ncompile-library, compile-program, and\ncompile-script print a message of the form:\n" "\n" "compiling input-path with output to output-path\n" "When the parameter is set to #f, the message is not printed.\n") ("system:s120" "\ndesc:run-cp0\nthread parameter: run-cp0\nthread parameter: cp0-effort-limit\nthread parameter: cp0-score-limit\nthread parameter: cp0-outer-unroll-limit\nlibraries: (chezscheme)\n" "These parameters control the operation of cp0, a source\noptimization pass that runs after macro expansion and prior\nto most other compiler passes.\ncp0 performs procedure inlining, in which the code of one\nprocedure is inlined at points where it is called by other procedures,\nas well as copy propagation, constant folding, useless code\nelimination, and several related optimizations.\nThe algorithm used by the optimizer is described in detail in the paper\n\"Fast and effective procedure inlining\" [citation31].\n" "\nWhen cp0 is enabled, the programmer can count on the compiler\nto fold constants, eliminate unnecessary let bindings, and\neliminate unnecessary and inaccessible code.\nThis is particularly useful when writing macros, since the programmer\ncan usually handle only the general case and let the compiler simplify\nthe code when possible.\nFor example, the programmer can define case as follows:\n" "\n" "(define-syntax case\n  (syntax-rules ()\n    [(_ e [(k ...) a1 a2 ...] ... [else b1 b2 ...])\n     (let ([t e])\n       (cond\n         [(memv t '(k ...)) a1 a2 ...]\n         ...\n         [else b1 b2 ...]))]\n    [(_ e [(k ...) a1 a2 ...] ...)\n     (let ([t e])\n       (cond\n         [(memv t '(k ...)) a1 a2 ...]\n         ...))]))\n" "and count on the introduce let expression to be eliminated\nif e turns out to be an unassigned variable, and count on\nthe entire case expression to be folded if e turns\nout to be a constant.\n" "\nIt is possible to see what cp0 does with an expression\nvia the procedure expand/optimize,\nwhich expands its argument and passes the result through cp0, as\nillustrated by the following transcript.\n" "\n" "> (print-gensym #f)\n> (expand/optimize\n    '(lambda (x)\n       (case x [(a) 1] [(b c) 2] [(d) 3] [else 4])))\n(lambda (x)\n  (if (#2%memv x '(a))\n      1\n      (if (#2%memv x '(b c)) 2 (if (#2%memv x '(d)) 3 4))))\n> (expand/optimize\n    '(+ (let ([f (lambda (x)\n                (case x [(a) 1] [(b c) 2] [(d) 3] [else 4]))])\n          (f 'b))\n         15))\n17\n" "In the first example, the let expression produced by case\nis eliminated, and in the second, the entire expression is optimized down\nto the constant 17.\nAlthough not shown by expand/optimize, the memv calls\nin the output code for the first example will be replaced by calls to the\nless expensive eq? by a later pass of the compiler.\nAdditional examples are given in the description\nof expand/optimize.\n" "\nThe value of run-cp0 must be a procedure.\nWhenever the compiler is invoked on a Scheme form, the value p\nof this parameter is called to determine whether and how\ncp0 is run.\np receives two arguments: cp0, the entry point into\ncp0, and x, the form being compiled.\nThe default value of run-cp0 simply invokes cp0 on\nx, then cp0 again on the result.\nThe second run is useful in some cases because the first run\nmay not eliminate bindings for certain variables that appear to be\nreferenced but are not actually referenced after inlining.\nThe marginal benefit of the second run is usually minimal, but so is the\ncost.\n" "\nInteresting variants include\n" "\n" "(run-cp0 (lambda (cp0 x) x))\n" "which bypasses (disables) cp0, and\n" "\n" "(run-cp0 (lambda (cp0 x) (cp0 x)))\n" "which runs cp0 just once.\n" "\nThe value of cp0-effort-limit determines the maximum amount\nof effort spent on each inlining attempt.\nThe time spent optimizing a program is a linear function of this limit and the\nnumber of calls in the program's source, so small values for this parameter\nenforce a tighter bound on compile time.\nWhen set to zero, inlining is disabled except when the name of a procedure\nis referenced only once.\nThe value of cp0-score-limit determines the maximum amount of\ncode produced per inlining attempt.\nSmall values for this parameter limit the amount of overall code expansion.\nThese parameters must be set to nonnegative fixnum values.\n" "\nThe parameter cp0-outer-unroll-limit\ncontrols the amount of inlining performed by the optimizer for\nrecursive procedures.\nWith the parameter's value set to the default value of 0, recursive\nprocedures are not inlined.\nA nonzero value for the outer unroll limit allows calls external to\na recursive procedure to be inlined.\nFor example, the expression\n" "\n" "(letrec ([fact (lambda (x) (if (zero? x) 1 (* x (fact (- x 1)))))])\n  (fact 10))\n" "would be left unchanged with the outer unroll limit set to zero, but would\nbe converted into\n" "\n" "(letrec ([fact (lambda (x) (if (zero? x) 1 (* x (fact (- x 1)))))])\n  (* 10 (fact 9)))\n" "with the outer unroll limit set to one.\n" "\nInteresting effects can be had by varying several of these parameters at\nonce.\nFor example, setting the\neffort and outer unroll limits to large values and the score limit\nto 1 has the effect of inlining even complex recursive procedures\nwhose values turn out to be constant at compile time without risking\nany code expansion.\nFor example,\n" "\n" "(letrec ([fact (lambda (x) (if (zero? x) 1 (* x (fact (- x 1)))))])\n  (fact 10))\n" "would be reduced to 3628800, but\n" "\n" "(letrec ([fact (lambda (x) (if (zero? x) 1 (* x (fact (- x 1)))))])\n  (fact z))\n" "would be left unchanged, although the optimizer may take a while to\nreach this decision if the effort and outer unroll limits are large.\n") ("system:s122" "\nthread parameter: commonization-level\nlibraries: (chezscheme)\n" "After running the main source optimization pass (cp0) for the last time, the\ncompiler optionally runs a commonization pass.\nThe pass commonizes the code for lambda expressions that have\nidentical structure by abstracting differences at certain leaves\nof the program, namely constants, references to unassigned variables,\nand references to primitives.\nThe parameter commonization-level controls whether commonization\nis run and, if so, how aggressive it is.\nIts value must be a nonnegative exact integer ranging from 0 through 9.\nWhen the parameter is set to 0, the default, commonization is not run.\nOtherwise, higher values result in more commonization.\n" "\nCommonization can undo some of the effects of cp0's inlining, can\nadd run-time overhead, and can complicate debugging, particularly\nat higher commonization levels, which is why it is disabled by\ndefault.\nOn the other hand, for macros or other meta programs that can\ngenerate large, mostly similar lambda expressions, enabling\ncommonization can result in significant savings in object-code size\nand even reduce run-time overhead by making more efficient use of\ninstruction caches.\n") ("system:s123" "\nthread parameter: undefined-variable-warnings\nlibraries: (chezscheme)\n" "When undefined-variable-warnings is set to #t, the\ncompiler issues a warning message whenever it cannot determine that\na variable bound by letrec, letrec*, or an internal\ndefinition will not be referenced before it is defined.\nThe default value is #f.\n" "\nRegardless of the setting of this parameter, the compiler inserts code\nto check for the error, except at optimize level 3.\nThe check is fairly inexpensive and does not typically inhibit inlining\nor other optimizations.\nIn code that must be carefully tuned, however, it is sometimes useful\nto reorder bindings or make other changes to eliminate the checks.\nEnabling undefined-variable warnings can facilitate this process.\n" "\nThe checks are also visible in the output of expand/optimize.\n") ("system:s124" "\ndesc:expand-outputdesc:expand/optimize-output\nthread parameter: expand-output\nthread parameter: expand/optimize-output\nlibraries: (chezscheme)\n" "The parameters expand-output and expand/optimize-output\ncan be used to request that the compiler and interpreter print\nexpander and source-optimizer output produced during the compilation or\ninterpretation process.\nEach parameter must be set to either #f (the default) or a\ntextual output port.\n" "\nWhen expand-output is set to a textual output port, the output\nof the expander is printed to the port as a side effect of running\ncompile, interpret, or any of the file compiling\nprimitives, e.g., compile-file or compile-library.\nSimilarly, when expand/optimize-output is set to a textual\noutput port, the output of the source optimizer is printed.\n" "\nSee also expand (page 349) and\nexpand-optimize (page 350), which\ncan be used to run the expander or the expander and source optimizer\ndirectly on an individual form.\n") ("system:s127" "\nsyntax: (pariah expr1 expr2 ...)\nreturns: the values of the last subexpression\nlibraries: (chezscheme)\n" "A pariah expression is just like a begin expression\nexcept that it informs the compiler that the code is expected to\nbe executed infrequently.\nThe compiler uses this information to optimize code layout, register\nassignments, and other aspects of the generated code.\nThe pariah form can be used in performance-critical code\nto mark the branches of a conditional (e.g., if, cond,\nor case) that are less likely to be executed than the\nothers.\n\n") ("system:s140" "\nthread parameter: compile-profile\nlibraries: (chezscheme)\n" "When this parameter is set to the symbol source or the\nboolean value #t, the compiler instruments the code it\ngenerates with instructions that count the number of times each\nsection of source code is executed.\nWhen set to the symbol block, the compiler similarly\ninstruments the code it generates with instructions that count the\nnumber of times each block of code is executed.\nWhen set to #f (the default), the compiler does not insert\nthese instructions.\n" "\nThe general description of profiling above describes how the source\nand block profile information can be viewed or used for optimization.\n" "\nThe code generated when compile-profile is non-false is\nlarger and less efficient, so this parameter should be set only\nwhen profile information is needed.\n" "\nThe profile counters for code compiled when profile instrumentation\nis enabled are retained indefinitely, even if the code with which\nthey are associated is reclaimed by the garbage collector.\nThis results in more complete and accurate profile data but can lead\nto space leaks in programs that dynamically generate or load code.\nSuch programs can avoid the potential space leak by releasing the\ncounters explicitly via the procedure\nprofile-release-counters.\n\n") ("system:s142" "\nthread parameter: generate-covin-files\nlibraries: (chezscheme)\n" "When this parameter is set to #t, the compiler generates\n\"coverage-information\" (covin) files that can be used in connection with\nprofile information to measure coverage of a source-code base by a\nset of tests.\nOne covin file is created for each object file, with the object-file\nextension replaced by the extension .covin.\nEach covin file contains the printed representation of a source table\n(Section 11.12), compressed using the compression\nformat and level specified by compress-format and\ncompress-level.\nThis information can be read via\nget-source-table! and used\nas a universe of source expressions to identify source expressions\nthat are not evaluated during the running of a set of tests.\n\n") ("system:s144" "\nsyntax: (profile source-object)\nreturns: unspecified\nlibraries: (chezscheme)\n" "A profile form has the effect of accounting to the source\nposition identified by source-object the number of times the\nprofile form is executed.\nProfile forms are generated implicitly by the expander for source\nexpressions in annotated input, e.g., input read by the compiler or\ninterpreter from a Scheme source file, so this form is typically\nuseful only when unannotated source code is produced by the front\nend for some language that targets Scheme.\n") ("system:s145" "\nthread parameter: (generate-profile-forms)\nlibraries: (chezscheme)\n" "When this parameter is set to #t, the default, the expander\nimplicitly introduces profile forms for each annotated input\nexpression, unless the annotation has not been marked for use in\nprofiling  (Section 11.11).\nIt can be set to #f to inhibit the expander's implicit\ngeneration of profile forms, typically when explicit\nprofile forms are already present for all source positions\nthat should be profiled.\n") ("system:s146" "\nprocedure: (profile-clear)\nreturns: unspecified\nlibraries: (chezscheme)\n" "Calling this procedure causes profile information to be cleared, i.e.,\nthe counts associated with each section of code are set to zero.\n") ("system:s147" "\nprocedure: (profile-release-counters)\nreturns: unspecified\nlibraries: (chezscheme)\n" "Calling this procedure causes profile information associated with reclaimed\ncode objects to be dropped.\n") ("system:s148" "\nprocedure: (profile-dump)\nreturns: a list of pairs of source-object and count\nlibraries: (chezscheme)\n" "This procedure produces a dump of all\nprofile information gathered since startup or the last call to\nprofile-clear.\nIt returns a list of pairs, where the car of each pair\nis a source object (Section 11.11) and the\ncdr is an exact nonnegative integer count.\n" "\nThe list might contain more than one entry per source object due\nto macro expansion and procedure inlining, and it might contain\nmore than one (non-eq) source object per file and source position\ndue to separate compilation.\nIn such cases, the counts are not overlapping and can be summed\ntogether to obtain the full count.\n" "\nThe advantage of profile-dump over profile-dump-list\nis that profile-dump performs only minimal processing and\npreserves complete source objects, including their embedded source-file\ndescriptors.\nIt might be used, for example, to dump profile information to a\nfasl file on one machine for subsequent processing on another.\n" "\nwith-profile-tracker\ncan be used to obtain the same set of counts as a source table.\n\n") ("system:s150" "\nprocedure: (with-profile-tracker thunk)\nprocedure: (with-profile-tracker preserve-existing? thunk)\nreturns: a source table and the values returned by thunk\nlibraries: (chezscheme)\n" "thunk must be a procedure and should accept zero arguments.\nIt may return any number of values.\n" "\nwith-profile-tracker invokes thunk without arguments.\nIf thunk returns n values x1, x2, ..., xn, with-profile-tracker\nreturns n + 1 values st, x1, x2, ..., xn, where st is a\nsource table associating source objects with profile counts.\nIf preserve-existing? is absent or #f, each count\nrepresents the number of times the source expression represented\nby the associated source object is evaluated during the invocation\nof thunk.\nOtherwise, each count represents the number of times the source\nexpression represented by the associated source object is evaluated\nbefore or during the invocation of thunk.\n" "\nProfile data otherwise cleared by a call to\nprofile-clear or\nprofile-release-counters\nduring the invocation of thunk is included in the\nresulting table.\nThat is, invoking these procedures while thunk is running has\nno effect on the resulting counts.\nOn the other hand, profile data cleared before with-profile-tracker\nis invoked is not included in the resulting table.\n" "\nThe idiom (with-profile-tracker #t values) can be used to obtain\nthe current set of profile counts as a source table.\n\n") ("system:s153" "\nprocedure: (source-table-dump source-table)\nreturns: a list of pairs of source objects and their associated values in source-table\nlibraries: (chezscheme)\n" "This procedure can be used to convert a source-table produced by\nwith-profile-tracker or some other mechanism into the form returned\nby profile-dump for use as an argument to\nprofile-dump-html,\nprofile-dump-list,\nor\nprofile-dump-data.\n") ("system:s159" "\nprocedure: (profile-dump-html)\nprocedure: (profile-dump-html prefix)\nprocedure: (profile-dump-html prefix dump)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure produces one or more HTML files, including\nprofile.html, which contains color-coded summary information,\nand one file source.html for each source\nfile source containing a color-coded copy of the\nsource code, as described in the lead-in to this section.\nIf prefix is specified, it must be a string and is prepended\nto the names of the generated HTML files.\nFor example, if prefix is \"/tmp/\", the generated\nfiles are placed in the directory /tmp.\nThe raw profile information is obtained from dump, which\ndefaults to the value returned by profile-dump.\n") ("system:s160" "\nthread parameter: (profile-palette)\nlibraries: (chezscheme)\n" "This value of this parameter must be a nonempty vector of at least\nthree pairs.\nThe car of each pair is a background color and the cdr is a foreground\n(text) color.\nEach color must be a string, and each string should contain an HTML\ncascading style sheet (CSS) color specifier.\nThe first pair is used for unprofiled code, and the second is used\nfor unexecuted profiled code.\nThe third is used for code that is executed least frequently, the fourth\nfor code executed next-least frequently, and so on, with the last\nbeing used for code that is executed most frequently.\nProgrammers may wish to supply their own palette to enhance visibility\nor to change the number of colors used.\n" "\nBy default, a black background is used for unprofiled code, and a gray\nbackground is used for unexecuted profiled code.\nBackground colors ranging from purple to red are used for executed\nprofiled code, depending on frequency of execution, with red for the most\nfrequently executed code.\n" "\n" "(profile-palette) -->\n  #((\"#111111\" . \"white\") (\"#607D8B\" . \"white\")\n    (\"#9C27B0\" . \"black\") (\"#673AB7\" . \"white\")\n    (\"#3F51B5\" . \"white\") (\"#2196F3\" . \"black\")\n    (\"#00BCD4\" . \"black\") (\"#4CAF50\" . \"black\")\n    (\"#CDDC39\" . \"black\") (\"#FFEB3B\" . \"black\")\n    (\"#FFC107\" . \"black\") (\"#FF9800\" . \"black\")\n    (\"#F44336\" . \"white\"))\n(profile-palette\n ; set palette with rainbow colors and black text\n ; for all but unprofiled or unexecuted code\n  '#((\"#000000\" . \"white\")    ; black\n     (\"#666666\" . \"white\")    ; gray\n     (\"#8B00FF\" . \"black\")    ; violet\n     (\"#6600FF\" . \"black\")    ; indigo\n     (\"#0000FF\" . \"black\")    ; blue\n     (\"#00FF00\" . \"black\")    ; green\n     (\"#FFFF00\" . \"black\")    ; yellow\n     (\"#FF7F00\" . \"black\")    ; orange\n     (\"#FF0000\" . \"black\")))  ; red\n") ("system:s161" "\nthread parameter: (profile-line-number-color)\nlibraries: (chezscheme)\n" "This value of this parameter must be a string or #f.\nIf it is a string, the string should contain an HTML cascading style sheet (CSS)\ncolor specifier.\nIf the parameter is set to a string, profile-dump-html includes line numbers\nin its html rendering of each source file, using the specified color.\nIf the parameter is set to #f, no line numbers are included.\n") ("system:s162" "\nprocedure: (profile-dump-list)\nprocedure: (profile-dump-list warn?)\nprocedure: (profile-dump-list warn? dump)\nreturns: a list of profile entries (see below)\nlibraries: (chezscheme)\n" "This procedure produces a dump of all\nprofile information present in dump, which defaults to\nthe value returned by profile-dump.\nIt returns a list of entries, each of which is itself a list containing the\nfollowing elements identifying one block of code and how many times it\nhas been executed.\n" "\n execution count\n pathname\n beginning file position in characters (inclusive)\n ending file position in characters (exclusive)\n line number of beginning file position\n character position of beginning file position\n" "\n" "\nprofile-dump-list may be unable to locate an unmodified copy\nof the file in the current source directories\nor at the absolute address, if an absolute address was used when\nthe file was compiled or loaded.\nIf this happens, the line number and character position of the beginning\nfile position are #f and the pathname is the pathname originally\nused.\nA warning is also issued (an exception with condition type\n&warning is raised) unless the warn? argument is provided\nand is false.\n" "\nOtherwise, the pathname is the path to an unmodified copy of the source\nand the line and character positions are set to exact nonnegative integers.\n" "\nIn either case, the execution count, beginning file position, and ending\nfile position are all exact nonnegative integers, and the pathname is a string.\n" "\nFor source positions in files that cannot be found, the list might\ncontain more than one entry per position due to macro expansion,\nprocedure inlining, and separate compilation.\nIn such cases, the counts are not overlapping and can be summed\ntogether to obtain the full count.\n" "\nThe information returned by profile-dump-list can be used to\nimplement a custom viewer or used as input for offline analysis of\nprofile information.\n" "\nThe advantage of profile-dump-list over profile-dump\nis that it attempts to determine the line number and character\nposition for each source point and, if successful, aggregates\nmultiple counts for the source point into a single entry.\n") ("system:s163" "\nprocedure: (profile-dump-data path)\nprocedure: (profile-dump-data path dump)\nreturns: unspecified\nlibraries: (chezscheme)\n" "path must be a string.\n" "\nThis procedure writes, in a machine-readable form consumable by\nprofile-load-data, profile counts represented by dump\nto the file named by path, replacing the file if it already exists.\ndump defaults to the value returned by profile-dump.\n") ("system:s164" "\nprocedure: (profile-load-data path ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "Each path must be a string.\n" "\nThis procedure reads profile information from the files named by\npath ... and stores it in the compiler's internal\ndatabase of profile information.\nThe contents of the files must have been created originally by\nprofile-dump-data using the same version of Chez Scheme.\n" "\nThe database stores a weight for each source expression or block\nrather than the actual count.\nWhen a single file is loaded into the database, the weight is the\nproportion of the actual count over the maximum count for all\nexpressions or blocks represented in the file.\nWhen more than one file is loaded, either by one or multiple calls\nto profile-load-data, the weights are averaged.\n") ("system:s165" "\nprocedure: (profile-query-weight obj)\nreturns: obj's profile weight, or #f if obj is not in the database\nlibraries: (chezscheme)\n" "The compiler's profile database maps source objects\n(Section 11.11) to weights.\nIf obj is a source object, the profile-query-weight returns\nthe weight associated with the source object or #f if the database\ndoes not have a weight recorded for the source object.\nobj can also be an annotation or syntax object, in which case\nprofile-query-weight first extracts the source object, if any,\nusing syntax->annotation and annotation-source,\nreturning #f if no source-object is found.\n" "\nA weight is a flonum in the range 0.0 to 1.0, inclusive, and denotes the\nratio of the actual count to the maximum count as described in the\ndescription of profile-load-data.\n" "\nprofile-query-weight can be used by a macro to determine\nthe relative frequency with which its subexpressions were executed\nin the run or runs that generated the information in the database.\nThis information can be used to guide the generation of code that\nis likely to be more efficient.\nFor example, the case macro uses profile information, when\navailable, to order the clauses so that those whose keys matched\nmore frequently are tested before those whose keys matched less\nfrequently.\n") ("system:s166" "\nprocedure: (profile-clear-database)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure clears the compiler's profile database.\nIt has no impact on the counts associated with individual sections\nof instrumented code; profile-clear can be used to reset\nthose counts.\n") ("system:s167" "\nprocedure: (new-cafe)\nprocedure: (new-cafe eval-proc)\nreturns: see below\nlibraries: (chezscheme)\n" "Chez Scheme interacts with the user\nthrough a waiter, or read-eval-print loop (REPL).\nThe waiter operates within a context called a caf.\nWhen the system starts up, the user is placed in a caf and\ngiven a waiter.\nnew-cafe opens a new Scheme caf, stacked on top of the old one.\nIn addition to starting the waiter, new-cafe sets up the caf's\nreset and exit handlers (see reset-handler and exit-handler).\nExiting a caf resumes the continuation of the call\nto new-cafe that created the caf.\nExiting from the initial caf leaves Scheme altogether.\nA caf may be exited from either by an explicit call to exit or\nby receipt of end-of-file (\"control-D\" on Unix systems) in response\nto the waiter's prompt.\nIn the former case, any values passed to exit are returned from\nnew-cafe.\n" "\nIf the optional eval-proc argument is specified, eval-proc\nis used to evaluate forms entered from the console.\nOtherwise, the value of the parameter current-eval is used.\neval-proc must accept one argument, the expression to evaluate.\n" "\nInteresting values for eval-proc include expand,\nwhich causes the macro expanded value of each expression entered to\nbe printed and (lambda (x) x), which simply causes each expression\nentered to be printed.\nAn arbitrary procedure of one argument may be used to facilitate\ntesting of a program on a series of input values.\n" "\n" "> (new-cafe (lambda (x) x))\n>> 3\n3\n>> (a . (b . (c . ())))\n(a b c)\n" "\n" "(define sum\n  (lambda (ls)\n    (if (null? ls)\n        0\n        (+ (car ls) (sum (cdr ls))))))\n> (new-cafe sum)\n>> (1 2 3)\n6\n" "The default waiter reader (see waiter-prompt-and-read) displays\nthe current waiter prompt (see waiter-prompt-string)\nto the current value of console-output-port and\nreads\nfrom the current value of console-input-port.\nThe default waiter printer (see waiter-write) sends output\nto the current value of console-output-port.\nThese parameters, along with current-eval,\ncan be modified to change the behavior of the waiter.\n") ("system:s174" "\nthread parameter: waiter-prompt-string\nlibraries: (chezscheme)\n" "The value of waiter-prompt-string must be a string.\nIt is used by the default waiter prompter (see the parameter\nwaiter-prompt-and-read) to print a prompt.\nNested cafs\nare marked by repeating the prompt string once for each nesting level.\n" "\n" "> (waiter-prompt-string)\n\">\"\n> (waiter-prompt-string \"%\")\n% (waiter-prompt-string)\n\"%\"\n% (new-cafe)\n%% (waiter-prompt-string)\n\"%\"\n") ("system:s175" "\nthread parameter: waiter-prompt-and-read\nlibraries: (chezscheme)\n" "waiter-prompt-and-read must be set to a procedure.\nIt is used by the waiter to\nprint a prompt and read an expression.\nThe value of waiter-prompt-and-read is called by the waiter with a\npositive integer that indicates the caf nesting level.\nIt should return an expression to be evaluated by the current\nevaluator (see new-cafe and current-eval).\n") ("system:s176" "\nprocedure: (default-prompt-and-read level)\nlibraries: (chezscheme)\n" "level must be a positive integer indicating the cafe nesting\nlevel as described above.\n" "\nThis procedure is the default value of the waiter-prompt-and-read\nparameter whenever the expression editor\n(Section 2.2, Chapter 14) is\nnot enabled.\nIt might be defined as follows.\n" "\n" "(define default-prompt-and-read\n  (lambda (n)\n    (unless (and (integer? n) (>= n 0))\n       (assertion-violationf 'default-prompt-and-read\n         \"~s is not a nonnegative integer\"\n         n))\n    (let ([prompt (waiter-prompt-string)])\n      (unless (string=? prompt \"\")\n        (do ([n n (- n 1)])\n            ((= n 0)\n             (write-char #\\space (console-output-port))\n             (flush-output-port (console-output-port)))\n            (display prompt (console-output-port))))\n      (let ([x (read (console-input-port))])\n         (when (and (eof-object? x) (not (string=? prompt \"\")))\n            (newline (console-output-port))\n            (flush-output-port (console-output-port)))\n         x))))\n") ("system:s177" "\nthread parameter: waiter-write\nlibraries: (chezscheme)\n" "The value of waiter-write must be a procedure.\nThe waiter uses the value of waiter-write to print the results\nof each expression read and evaluated by the waiter.\nThe following example installs a procedure equivalent to the default\nwaiter-write:\n" "\n" "(waiter-write\n  (lambda (x)\n    (unless (eq? x (void))\n      (pretty-print x (console-output-port)))\n    (flush-output-port (console-output-port))))\n") ("system:s178" "\nprocedure: (reset)\nreturns: does not return\nlibraries: (chezscheme)\n" "reset invokes the current reset handler (see reset-handler)\nwithout arguments.\n\n") ("system:s179" "\nthread parameter: reset-handler\nlibraries: (chezscheme)\n" "The value of this parameter must be a procedure and should accept zero\narguments.\nThe current reset handler is called by reset.\nThe default reset handler resets to the current caf.\n\n") ("system:s180" "\nprocedure: (exit obj ...)\nreturns: does not return\nlibraries: (chezscheme)\n" "exit invokes the current exit handler (see\nexit-handler), passing along its arguments, if any.\n\n") ("system:s181" "\nthread parameter: exit-handler\nlibraries: (chezscheme)\n" "The value of this parameter must be a procedure and should accept any\nnumber of arguments.\nThe current exit handler is called by exit.\n" "\nThe default exit handler exits from the current caf,\nreturning its arguments as the values of the call to\nnew-cafe that created the current caf.\nIf the current caf is the original caf, or if exit\nis called from a script, exit exits from Scheme.\nIn this case, the exit code for the Scheme process is 0 if\nno arguments were supplied or if the first argument is void,\nthe value of the first argument cast to a C int if\nit is an exact integer of the host machine's bit width, and 1 otherwise.\n") ("system:s182" "\nprocedure: (abort)\nprocedure: (abort obj)\nreturns: does not return\nlibraries: (chezscheme)\n" "abort invokes the current abort handler (see abort-handler),\npassing along its argument, if any.\n\n") ("system:s183" "\nthread parameter: abort-handler\nlibraries: (chezscheme)\n" "The value of this parameter must be a procedure and should accept either\nzero arguments or one argument.\nThe current abort handler is called by abort.\n" "\nThe default abort handler exits the Scheme process.\nThe exit code for the Scheme process is -1 if no arguments were supplied,\n0 if the first argument is void, the value of the first argument if it is\na 32-bit exact integer, and -1 otherwise.\n\n") ("system:s184" "\nglobal parameter: scheme-start\nlibraries: (chezscheme)\n" "The value of scheme-start is a procedure that determines the\nsystem's action upon start-up.\nThe procedure receives zero or more arguments, which are strings\nrepresenting the file names (or command-line arguments not recognized\nby the Scheme executable) after given on the command line.\nThe default value first loads the files named by the arguments, then\nstarts up the initial caf:\n" "\n" "(lambda fns\n  (for-each load fns)\n  (new-cafe))\n" "scheme-start may be altered to start up an application or to\nperform customization prior to normal system start-up.\n" "\nTo have any effect, this parameter must be set within a boot file.\n(See Chapter 2.)\n") ("system:s185" "\nglobal parameter: scheme-script\nlibraries: (chezscheme)\n" "The value of scheme-script is a procedure that determines the\nsystem's action upon start-up,\nwhen the --script option is used.\nThe procedure receives one or more arguments.\nThe first is a string identifying the script filename and the remainder\nare strings representing the remaining file names (or command-line\narguments not recognized by the Scheme executable) given on the command\nline.\nThe default value of this parameter is a procedure that sets the\ncommand-line and command-line-arguments parameters,\nloads the script using load, and returns void, which is\ntranslated into a 0 exit status for the script process.\n" "\n" "(lambda (fn . fns)\n  (command-line (cons fn fns))\n  (command-line-arguments fns)\n  (load fn))\n" "scheme-script may be altered to start up an application or to\nperform customization prior to normal system start-up.\n" "\nTo have any effect, this parameter must be set within a boot file.\n(See Chapter 2.)\n\n") ("system:s189" "\nglobal parameter: scheme-program\nlibraries: (chezscheme)\n" "The value of scheme-program is a procedure that determines the\nsystem's action upon start-up\nwhen the --program (RNRS top-level program) option is used.\nThe procedure receives one or more arguments.\nThe first is a string identifying the program filename and the remainder\nare strings representing the remaining file names (or command-line\narguments not recognized by the Scheme executable) given on the command\nline.\nThe default value of this parameter is a procedure that sets the\ncommand-line and command-line-arguments parameters,\nloads the program using load-program, and returns void, which is\ntranslated into a 0 exit status for the script process.\n" "\n" "(lambda (fn . fns)\n  (command-line (cons fn fns))\n  (command-line-arguments fns)\n  (load-program fn))\n" "scheme-program may be altered to start up an application or to\nperform customization prior to normal system start-up.\n" "\nTo have any effect, this parameter must be set within a boot file.\n(See Chapter 2.)\n\n") ("system:s193" "\nglobal parameter: command-line\nlibraries: (chezscheme)\n" "This parameter is set by the default values of scheme-script\nand scheme-program\nto a list representing the command line, with the script name followed\nby the command-line arguments, when the --script or\n--program option is used on system startup.\n") ("system:s195" "\nglobal parameter: command-line-arguments\nlibraries: (chezscheme)\n" "This parameter is set by the default values of scheme-script\nand scheme-program\nto a list of the command-line arguments when the --script\nor --program option is used on system startup.\n") ("system:s197" "\nglobal parameter: suppress-greeting\nlibraries: (chezscheme)\n" "The value of suppress-greeting is a boolean value that determines\nwhether Chez Scheme prints an identifying banner and copyright notice.\nThe parameter defaults to #f but may be set to #t for\nuse in batch processing applications where the banner would be disruptive.\n" "\nTo have any effect, this parameter must be set within a boot file.\n(See Chapter 2.)\n\n") ("system:s199" "\ndesc:transcript-on\nprocedure: (transcript-on path)\nreturns: unspecified\nlibraries: (chezscheme)\n" "path must be a string.\n" "\ntranscript-on opens the file named by path for output,\nand it copies to this file all input from the current input port and\nall output to the current output port.\nAn exception is raised with condition-type i/o-filename if the\nfile cannot be opened for output.\n\n") ("system:s200" "\nprocedure: (transcript-off)\nreturns: unspecified\nlibraries: (chezscheme)\n" "transcript-off ends transcription and closes the transcript file.\n\n") ("system:s201" "\nprocedure: (transcript-cafe path)\nlibraries: (chezscheme)\n" "path must be a string.\ntranscript-cafe opens a transcript file as with\ntranscript-on and\nenters a new caf; exiting\nfrom this caf (see exit) also ends transcription and closes the\ntranscript file.\nInvoking transcript-off while in a transcript caf ends transcription\nand closes the transcript file but does not cause an exit from the\ncaf.\n\n") ("system:s202" "\nprocedure: (current-time)\nprocedure: (current-time time-type)\nreturns: a time object representing the current time\nlibraries: (chezscheme)\n" "time-type must be one of the time-type symbols listed above\nand defaults to time-utc.\n" "\n" "(current-time) --> #<time-utc 1198815722.473668000>\n(current-time 'time-process) --> #<time-process 0.120534264>\n") ("system:s203" "\nprocedure: (make-time type nsec sec)\nreturns: a time object\nlibraries: (chezscheme)\n" "type must be one of the time-type symbols listed above.\nnsec represents nanoseconds and must be an exact nonnegative\ninteger less than 109.\nsec represents seconds and must be an exact integer.\n" "\n" "(make-time 'time-utc 787511000 1198783214)\n(make-time 'time-duration 10 5)\n(make-time 'time-duration 10 -5)\n") ("system:s204" "\nprocedure: (time? obj)\nreturns: #t if obj is a time object, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(time? (current-time)) --> #t\n(time? (make-time 'time-utc 0 0)) --> #t\n(time? \"1400 hours\") --> #f\n") ("system:s205" "\nprocedure: (time-type time)\nreturns: the time type of time\nprocedure: (time-nanosecond time)\nreturns: the nanosecond of time\nprocedure: (time-second time)\nreturns: the second of time\nlibraries: (chezscheme)\n" "time must be a time object.\n" "\n" "(time-type (current-time)) --> time-utc\n(time-type (current-time 'time-process)) --> time-process\n(time-type (make-time 'time-duration 0 50)) --> time-duration\n(time-second (current-time)) --> 1198816497\n(time-nanosecond (current-time)) --> 2399000\n(time-second (make-time 'time-duration 10 -5)) --> -5\n(time-nanosecond (make-time 'time-duration 10 -5)) --> 10\n") ("system:s206" "\nprocedure: (set-time-type! time type)\nreturns: unspecified\nprocedure: (set-time-nanosecond! time nsec)\nreturns: unspecified\nprocedure: (set-time-second! time sec)\nreturns: unspecified\nlibraries: (chezscheme)\n" "time must be a time object.\ntype must be one of the time-type symbols listed above.\nnsec represents nanoseconds and must be an exact nonnegative\ninteger less than 109.\nsec represents seconds and must be an exact integer.\n" "\nEach of these procedures modifies the time object, changing one aspect\nwhile leaving the others unaffected.\nFor example, set-time-nanosecond! changes the nanosecond of\ntime without changing the second or type.\nIn particular, no conversion of values is performed when the type of a time\nobject is changed.\n") ("system:s207" "\nprocedure: (time=? time1 time2)\nprocedure: (time<? time1 time2)\nprocedure: (time<=? time1 time2)\nprocedure: (time>=? time1 time2)\nprocedure: (time>? time1 time2)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (chezscheme)\n" "time1 and time2 must be time objects and must have\nthe same type.\n" "\n" "(let ([t (current-time)])\n  (time=? t t)) --> #t\n(let ([t (current-time)])\n  (let loop ()\n    (when (time=? (current-time) t))\n      (loop))\n  (time>? (current-time) t)) --> #t\n") ("system:s208" "\nprocedure: (copy-time time)\nreturns: a copy of time\nlibraries: (chezscheme)\n" "\n" "(define t1 (current-time))\n(define t2 (copy-time t1))\n(eq? t2 t1) --> #f\n(eqv? (time-second t2) (time-second t1)) --> #t\n(eqv? (time-nanosecond t2) (time-nanosecond t1)) --> #t\n") ("system:s209" "\nprocedure: (time-difference time1 time2)\nreturns: the result of subtracting time2 from time1\nprocedure: (time-difference! time1 time2)\nreturns: the result of subtracting time2 from time1\nprocedure: (add-duration time timed)\nreturns: the result of adding timed to time\nprocedure: (add-duration! time timed)\nreturns: the result of adding timed to time\nprocedure: (subtract-duration time timed)\nreturns: the result of subtracting timed from time\nprocedure: (subtract-duration! time timed)\nreturns: the result of subtracting timed from time\nlibraries: (chezscheme)\n" "For time-difference, time1 and time2 must\nhave the same time type, and the result is a time object with\ntime type time-duration.\nFor add-duration, add-duration!,\nsubtract-duration, and subtract-duration!,\ntimed must have time type time-duration,\nand the result is a time object with the same time type as\ntime.\ntime-difference!, add-duration!, and\nsubtract-duration! are potentially destructive, i.e., each\nmight modify and return its first argument, or it might allocate a\nnew time object.\n" "\n" "(let ([delay (make-time 'time-duration 0 1)])\n  (let ([t1 (current-time 'time-monotonic)])\n    (sleep delay)\n    (let ([t2 (current-time 'time-monotonic)])\n      (let ([t3 (time-difference t2 t1)])\n        (and\n          (eq? (time-type t3) 'time-duration)\n          (time>=? t3 delay)\n          (time=? (add-duration t1 t3) t2)\n          (time=? (subtract-duration t2 t3) t1)))))) --> #t\n") ("system:s210" "\nprocedure: (current-date)\nprocedure: (current-date offset)\nreturns: a date object representing the current date\nlibraries: (chezscheme)\n" "offset represents the time-zone offset in seconds east of UTC,\nas described above.\nIt must be an exact integer in the range -86400 to\n+86400, inclusive and defaults to the local time-zone offset.\nUTC may be obtained by passing an offset of zero.\n" "\nIf offset is not provided, then the current time zone's offset\nis used, and date-dst? and date-zone-name report\ninformation about the time zone. If offset is provided, then\ndate-dst? and date-zone-name on the resulting date\nobject produce #f.\n" "\nThe following examples assume the local time zone is EST.\n" "\n" "(current-date) --> #<date Thu Dec 27 23:23:20 2007>\n(current-date 0) --> #<date Fri Dec 28 04:23:20 2007>\n\n(date-zone-name (current-date)) --> \"EST\" or other system-provided string\n(date-zone-name (current-date 0)) --> #f\n") ("system:s211" "\nprocedure: (make-date nsec sec min hour day mon year)\nprocedure: (make-date nsec sec min hour day mon year offset)\nreturns: a date object\nlibraries: (chezscheme)\n" "nsec represents nanoseconds and must be an exact nonnegative integer\nless than 109.\nsec represents seconds and must be an exact nonnegative integer\nless than 62.\nmin represents minutes and must be an exact nonnegative integer\nless than 60.\nhour must be an exact nonnegative integer less than 24.\nday must be an exact integer, 1  day  31.\n(The actual upper limit may be less depending on the month and year.)\nmon represents the month must be an exact integer, 1  mon  12.\nyear must be an exact integer.\nIt should be at least 1970.\noffset represents the time-zone offset in seconds east of UTC,\nas described above.\nIt must be an exact integer in the range -86400 to +86400, inclusive.\nUTC may be specified by passing an offset of zero.\n" "\nIf offset is not provided, then the current time zone's offset\nis used, and date-dst? and date-zone-name report\ninformation about the time zone. If offset is provided, then\ndate-dst? and date-zone-name on the resulting date\nobject produce #f.\n" "\n" "(make-date 0 0 0 0 1 1 1970 0) --> #<date Thu Jan  1 00:00:00 1970>\n(make-date 0 30 7 9 23 9 2007 -14400) --> #<date Sun Sep 23 09:07:30 2007>\n\n(date-zone-name (make-date 0 30 7 9 23 9 2007 -14400)) --> #f\n(string? (date-zone-name (make-date 0 30 7 9 23 9 2007))) --> #t\n") ("system:s212" "\nprocedure: (date? obj)\nreturns: #t if obj is a date object, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(date? (current-date))\n(date? (make-date 0 30 7 9 23 9 2007 -14400))\n(date? \"Sun Sep 23 09:07:30 2007\") --> #f\n") ("system:s213" "\nprocedure: (date-nanosecond date)\nreturns: the nanosecond of date\nprocedure: (date-second date)\nreturns: the second of date\nprocedure: (date-minute date)\nreturns: the minute of date\nprocedure: (date-hour date)\nreturns: the hour of date\nprocedure: (date-day date)\nreturns: the day of date\nprocedure: (date-month date)\nreturns: the month of date\nprocedure: (date-year date)\nreturns: the year of date\nprocedure: (date-zone-offset date)\nreturns: the time-zone offset of date\nlibraries: (chezscheme)\n" "date must be a date object.\n" "\n" "(define d (make-date 0 30 7 9 23 9 2007 -14400))\n(date-nanosecond d) --> 0\n(date-second d) --> 30\n(date-minute d) --> 7\n(date-hour d) --> 9\n(date-day d) --> 23\n(date-month d) --> 9\n(date-year d) --> 2007\n(date-zone-offset d) --> -14400\n") ("system:s214" "\nprocedure: (date-week-day date)\nreturns: the week-day of date\nprocedure: (date-year-day date)\nreturns: the year-day of date\nlibraries: (chezscheme)\n" "These procedures allow the day-of-week or day-of-year to be determined for\nthe date represented by date.\nA week-day is an exact nonnegative integer less than 7, where\n0 represents Sunday, 1 represents Monday, and so on.\nA year-day is an exact nonnegative integer less than 367, where\n0 represents the first day of the year (January 1), 1 the\nsecond day, 2 the third, and so on.\n" "\n" "(define d1 (make-date 0 0 0 0 1 1 1970 -18000))\nd1 --> #<date Thu Jan  1 00:00:00 1970>\n(date-week-day d1) --> 4\n(date-year-day d1) --> 0\n\n(define d2 (make-date 0 30 7 9 23 9 2007 -14400))\nd2 --> #<date Sun Sep 23 09:07:30 2007>\n(date-week-day d2) --> 0\n(date-year-day d2) --> 265\n") ("system:s215" "\nprocedure: (date-dst? date)\nreturns: whether date is in Daylight Saving Time\nprocedure: (date-zone-name date)\nreturns: #f or a string naming the time zone of date\nlibraries: (chezscheme)\n" "These procedures report time-zone information for\nthe date represented by date for a date object that\nis constructed without an explicit time-zone offset. When\na date object is created instead with explicit time-zone offset,\nthese procedures produce #f.\n" "\nDaylight Saving Time status for the current time zone and a name\nstring for the time zone are computed using platform-specific routines.\nIn particular, the format of the zone name is platform-specific.\n" "\n" "(define d (make-date 0 30 7 9 23 9 2007))\n(date-zone-offset d) --> -14400 assuming Eastern U.S. time zone\n(date-dst? d) --> #t\n(date-zone-name d) --> \"EDT\" or some system-provided string\n") ("system:s216" "\nprocedure: (time-utc->date time)\nprocedure: (time-utc->date time offset)\nreturns: a date object corresponding to time\nprocedure: (date->time-utc date)\nreturns: a time object corresponding to date\nlibraries: (chezscheme)\n" "These procedures are used to convert between time and date objects.\nThe time argument to time-utc->date must have time-type\nutc, and date->time-utc always returns a time\nobject with time-type utc.\n" "\nFor time-utc->date,\noffset represents the time-zone offset in seconds east of UTC,\nas described at the beginning of this section.\nIt must be an exact integer in the range -86400 to\n+86400, inclusive and defaults to the local time-zone offset.\nUTC may be obtained by passing an offset of zero.\n" "\nIf offset is not provided to time-utc->date, then the current time zone's offset\nis used, and date-dst? and date-zone-name report\ninformation about the time zone. If offset is provided, then\ndate-dst? and date-zone-name on the resulting date\nobject produce #f.\n" "\n" "(define d (make-date 0 30 7 9 23 9 2007 -14400))\n(date->time-utc d) --> #<time-utc 1190552850.000000000>\n(define t (make-time 'time-utc 0 1190552850))\n(time-utc->date t) --> #<date Sun Sep 23 09:07:30 2007>\n(time-utc->date t 0) --> #<date Sun Sep 23 13:07:30 2007>\n") ("system:s217" "\nprocedure: (date-and-time)\nprocedure: (date-and-time date)\nreturns: a string giving the current date and time\nlibraries: (chezscheme)\n" "The string is always in the format illustrated by the examples below and\nalways has length 24.\n" "\n" "(date-and-time) --> \"Fri Jul 13 13:13:13 2001\"\n(define d (make-date 0 0 0 0 1 1 2007 0))\n(date-and-time d) --> \"Mon Jan 01 00:00:00 2007\"\n") ("system:s218" "\nprocedure: (sleep time)\nreturns: unspecified\nlibraries: (chezscheme)\n" "time must be a time object with type time-duration.\nsleep causes the invoking thread to suspend operation for\napproximately the amount of time indicated by the time object, unless\nthe process receives a signal that interrupts the sleep operation.\nThe actual time slept depends on the granularity of the system clock\nand how busy the system is running other threads and processes.\n\n") ("system:s219" "\nsyntax: (time expr)\nreturns: the values of expr\nlibraries: (chezscheme)\n" "time evaluates expr and, as a side-effect, prints (to the\nconsole-output port) the amount of cpu time, the amount of real time,\nthe number of bytes allocated, and the amount of collection overhead\nassociated with evaluating expr.\n" "\n" "> (time (collect))\n(time (collect))\n    1 collection\n    1 ms elapsed cpu time, including 1 ms collecting\n    1 ms elapsed real time, including 1 ms collecting\n    160 bytes allocated, including 8184 bytes reclaimed\n") ("system:s220" "\nprocedure: (display-statistics)\nprocedure: (display-statistics textual-output-port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure displays a running total of the amount of\ncpu time, real time, bytes allocated, and collection overhead.\nIf textual-output-port is not supplied, it defaults to the current output port.\n\n") ("system:s221" "\nprocedure: (cpu-time)\nreturns: the amount of cpu time consumed since system start-up\nlibraries: (chezscheme)\n" "The amount is in milliseconds.\nThe amount includes \"system\" as well as \"user\" time, i.e., time\nspent in the kernel on behalf of the process as well as time spent in\nthe process itself.\n" "\nSee also current-time, which returns more precise information.\n\n") ("system:s222" "\nprocedure: (real-time)\nreturns: the amount of real time that has elapsed since system start-up\nlibraries: (chezscheme)\n" "The amount is in milliseconds.\n" "\nSee also current-time, which returns more precise information.\n\n") ("system:s223" "\nprocedure: (bytes-allocated)\nprocedure: (bytes-allocated g)\nreturns: the number of bytes currently allocated\nlibraries: (chezscheme)\n" "If g is supplied, bytes-allocated returns the number of\nbytes currently allocated for Scheme objects in the specified generation.\ng must be a nonnegative exact integer no greater than the\nmaximum nonstatic generation, i.e., the\nvalue returned by collect-maximum-generation, or the symbol\nstatic.\nIf g is not supplied, bytes-allocated returns the total\nnumber of bytes allocated in all generations.\n\n") ("system:s224" "\nprocedure: (initial-bytes-allocated)\nreturns: the total number of bytes allocated after loading boot files\nlibraries: (chezscheme)\n") ("system:s225" "\nprocedure: (bytes-deallocated)\nreturns: the total number of bytes deallocated by the garbage collector\nlibraries: (chezscheme)\n" "The total number of bytes allocated by the current process, whether\nstill in use or not, can be obtained by summing\n(bytes-deallocated) and (bytes-allocated)\nand possibly subtracting (initial-bytes-allocated).\n") ("system:s226" "\nprocedure: (current-memory-bytes)\nreturns: the total number of bytes currently allocated, including overhead\nlibraries: (chezscheme)\n" "current-memory-bytes returns the total size of the heap\nin bytes, including not only the bytes occupied for Scheme objects\nbut also various forms of overhead, including fragmentation and\nreserved but not currently occupied memory, and is thus an accurate\nmeasure of the amount of heap memory currently reserved from the\noperating system for the current process.\n") ("system:s227" "\nprocedure: (maximum-memory-bytes)\nreturns: the maximum number of bytes ever allocated, including overhead\nlibraries: (chezscheme)\n" "maximum-memory-bytes returns the maximum size of the heap\nin bytes, i.e., the maximum value that current-memory-bytes\nreturned or could have returned, since the last call to\nreset-maximum-memory-bytes! or, if there has been no such\ncall, since the process started.\n") ("system:s228" "\nprocedure: (reset-maximum-memory-bytes!)\nreturns: unspecified\nlibraries: (chezscheme)\n" "reset-maximum-memory-bytes! resets the maximum recorded size\nof the heap to the current size of the heap.\n") ("system:s229" "\nprocedure: (collections)\nreturns: the number garbage collections so far\nlibraries: (chezscheme)\n") ("system:s230" "\nprocedure: (statistics)\nreturns: a sstats record containing current statistics\nlibraries: (chezscheme)\n" "statistics packages together various timing and allocation\nstatistics into a single sstats record.\nA sstats record has the following fields:\n" "\ncpu, the cpu time consumed,\nreal, the elapsed real time,\nbytes, the number of bytes allocated,\ngc-count, the number of collections,\ngc-cpu, the cpu time consumed during collections,\ngc-real, the elapsed real time during collections, and\ngc-bytes, the number of bytes reclaimed by the collector.\n\n" "\nAll values are computed since system start-up.\nThe time values are time objects (Section 12.10),\nand the bytes and count values are exact integers.\n" "\nstatistics might be defined as follows:\n" "\n" "(define statistics\n  (lambda ()\n    (make-sstats\n      (current-time 'time-thread)\n      (current-time 'time-monotonic)\n      (- (+ (bytes-allocated) (bytes-deallocated))\n         (initial-bytes-allocated))\n      (collections)\n      (current-time 'time-collector-cpu)\n      (current-time 'time-collector-real)\n      (bytes-deallocated))))\n") ("system:s231" "\nprocedure: (make-sstats cpu real bytes gc-count gc-cpu gc-real gc-bytes)\nreturns: a sstats record\nlibraries: (chezscheme)\n" "The time arguments (cpu, real, gc-cpu, and gc-real) must be time objects.\nThe other arguments must be exact integers.\n\n") ("system:s232" "\nprocedure: (sstats? obj)\nreturns: #t if obj is a sstats record, otherwise #f\nlibraries: (chezscheme)\n") ("system:s233" "\nprocedure: (sstats-cpu s)\nprocedure: (sstats-real s)\nprocedure: (sstats-bytes s)\nprocedure: (sstats-gc-count s)\nprocedure: (sstats-gc-cpu s)\nprocedure: (sstats-gc-real s)\nprocedure: (sstats-gc-bytes s)\nreturns: the value of the corresponding field of s\nlibraries: (chezscheme)\n" "s must be a sstats record.\n") ("system:s234" "\nprocedure: (set-sstats-cpu! s new-value)\nprocedure: (set-sstats-real! s new-value)\nprocedure: (set-sstats-bytes! s new-value)\nprocedure: (set-sstats-gc-count! s new-value)\nprocedure: (set-sstats-gc-cpu! s new-value)\nprocedure: (set-sstats-gc-real! s new-value)\nprocedure: (set-sstats-gc-bytes! s new-value)\nreturns: unspecified\nlibraries: (chezscheme)\n" "s must be a sstats record, the new-value arguments for the time fields\n(cpu, real, gc-cpu, and gc-real)\nmust be time objects, and\nthe other new-value arguments must be exact integers.\nEach procedure sets the value of the corresponding field of s to\nnew-value.\n\n") ("system:s235" "\nprocedure: (sstats-difference s1 s2)\nreturns: a sstats record representing the difference between s1 and s2\nlibraries: (chezscheme)\n" "s1 and s2 must be sstats records.\nsstats-difference subtracts each field of s2 from the\ncorresponding field of s1 to produce the resulting sstats\nrecord.\n") ("system:s236" "\nprocedure: (sstats-print s)\nprocedure: (sstats-print s textual-output-port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "s must be a sstats record.\nIf textual-output-port is not supplied, it defaults to the current output port.\nsstats-print displays the fields of s in a manner similar\nto display-statistics and time.\n\n") ("system:s237" "\nglobal parameter: enable-object-counts\nlibraries: (chezscheme)\n" "The value of enable-object-counts is a boolean value that\ndetermines whether the collector records object counts as it runs and\nhence whether the object counts returned by the procedure\nobject-counts are accurate.\nThe parameter is set to #f by default, since enabling object\ncounts adds overhead to collection.\n" "\nCounts for the static generation are always correct.\nCounts for a nonstatic generation n are correct immediately after a\ncollection of generation m  n (regardless of whether the target\ngeneration is m or m + 1) if enable-object-counts\nwas set to #t during the collection.\n" "\nOne strategy for collecting object counts with minimal overhead is\nto enable object counts only while collecting the maximum nonstatic\ngeneration and to obtain the object counts immediately after that\ncollection.\n") ("system:s238" "\nprocedure: (object-counts)\nreturns: see below\nlibraries: (chezscheme)\n" "The procedure object-counts returns a nested association list\nrepresenting object counts and bytes allocated for each heap-allocated\nprimitive type and record type with at least one live instance in one\nor more generations.\n(Heap-allocated primitive types include, e.g., pairs and vectors, but\nnot, e.g., fixnums or characters.)\nObject counts are gathered by the collector only when\nenable-object-counts is #t.\nThe description of enable-object-counts details the\ncircumstances under which the counts are accurate.\n" "\nThe association list returned by object-counts has the following\nstructure:\n" "\n" "((type (generation count . bytes) ...) ...)\n" "type is either the name of a primitive type, represented as a\nsymbol, e.g., pair, or a record-type descriptor (rtd).\ngeneration is a nonnegative fixnum between 0 and the value\nof (collect-maximum-generation), inclusive, or the symbol\nstatic representing the static generation.\ncount and bytes are nonnegative fixnums.\n" "\n" "(collect-request-handler void)\n(enable-object-counts #t)\n(define-record-type frob (fields x))\n(define x (make-frob (make-frob #f)))\n(collect 3 3)\n(cdr (assoc 3\n       (cdr (assoc (record-type-descriptor frob)\n              (object-counts)))))                --> (2 . 16)\n") ("system:s239" "\nthread parameter: generate-allocation-counts\nlibraries: (chezscheme)\n" "When this parameter has a true value, the compiler inserts a short sequence of\ninstructions at each allocation point in generated code to track the amount of\nallocation that occurs.\nThis parameter is initially false.\n") ("system:s240" "\nthread parameter: generate-instruction-counts\nlibraries: (chezscheme)\n" "When this parameter has a true value, the compiler inserts a short\nsequence of instructions in each block of generated code to track the\nnumber of instructions executed by that block.\nThis parameter is initially false.\n") ("system:s241" "\nprocedure: (make-cost-center)\nreturns: a new cost center\nlibraries: (chezscheme)\n" "The recorded costs of the new cost center are initialized to zero.\n") ("system:s242" "\nprocedure: (cost-center? obj)\nreturns: #t if obj is a cost center, otherwise #f\nlibraries: (chezscheme)\n") ("system:s243" "\nprocedure: (with-cost-center cost-center thunk)\nprocedure: (with-cost-center timed? cost-center thunk)\nreturns: see below\nlibraries: (chezscheme)\n" "thunk must be a procedure that accepts zero arguments.\nwith-cost-center invokes thunk without arguments and\nreturns its values.\nIt also tracks, dynamically, the bytes allocated, instructions executed,\nand cpu time elapsed while evaluating the invocation of thunk and\nadds the tracked costs to the cost center's running record of these costs.\n" "\nAs described above, allocation counts are tracked only for code\ncompiled with the parameter generate-allocation-counts set\nto true, and instruction counts are tracked only for code compiled\nwith generate-instruction-counts set to true.\nCpu time is tracked only if timed? is provided and not false and\nincludes cpu time spent in instrumented, uninstrumented, and non-Scheme\ncode.\n") ("system:s244" "\nprocedure: (cost-center-instruction-count cost-center)\nreturns: the number of instructions tracked by cost-center\nlibraries: (chezscheme)\n") ("system:s245" "\nprocedure: (cost-center-allocation-count cost-center)\nreturns: the number of allocated bytes tracked by cost-center\nlibraries: (chezscheme)\n") ("system:s246" "\nprocedure: (cost-center-time cost-center)\nreturns: the cpu time tracked by cost-center\nlibraries: (chezscheme)\n" "The cpu time is returned as a time object with time-type time-duration.\n") ("system:s247" "\nprocedure: (reset-cost-center! cost-center)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure resets the costs recorded by cost-center to zero.\n\n") ("system:s248" "\nprocedure: (make-parameter object)\nprocedure: (make-parameter object procedure)\nreturns: a parameter (procedure)\nlibraries: (chezscheme)\n" "make-parameter accepts one or two arguments.\nThe first argument is the initial value of the internal variable, and\nthe second, if present, is a filter applied to the initial value\nand all subsequent values.\nThe filter should accept one argument.\nIf the value is not appropriate, the filter should raise an exception or\nconvert the value into a more appropriate form.\n" "\nFor example, the default value of print-length is defined as\nfollows:\n" "\n" "(define print-length\n  (make-parameter\n    #f\n    (lambda (x)\n      (unless (or (not x) (and (fixnum? x) (fx>= x 0)))\n        (assertion-violationf 'print-length\n          \"~s is not a positive fixnum or #f\"\n          x))\n      x)))\n" "\n" "(print-length)  --> #f\n(print-length 3)\n(print-length)  --> 3\n(format \"~s\" '(1 2 3 4 5 6))  --> \"(1 2 3 ...)\"\n(print-length #f)\n(format \"~s\" '(1 2 3 4 5 6))  --> \"(1 2 3 4 5 6)\"\n" "The definition of make-parameter is straightforward using\ncase-lambda:\n" "\n" "(define make-parameter\n  (case-lambda\n    [(init guard)\n     (let ([v (guard init)])\n       (case-lambda\n         [() v]\n         [(u) (set! v (guard u))]))]\n    [(init)\n     (make-parameter init (lambda (x) x))]))\n" "In threaded versions of Chez Scheme, make-parameter creates\nglobal parameters.\nThe procedure make-thread-parameter, described in\nSection 15.7, may be used to make thread\nparameters.\n\n") ("system:s250" "\nsyntax: (parameterize ((param expr) ...) body1 body2 ...)\nreturns: the values of the body body1 body2 ...\nlibraries: (chezscheme)\n" "Using the syntactic form parameterize, the values of parameters can\nbe changed in a manner analogous to fluid-let for ordinary variables.\nEach param is set to the value of the corresponding\nexpr while the body is evaluated.\nWhen control leaves the body by normal return or by the invocation of a\ncontinuation created outside of the body, the parameters are restored to\ntheir original values.\nIf control returns to the body via a continuation created during the\nexecution of the body, the parameters are again set to their temporary\nvalues.\n" "\n" "(define test\n  (make-parameter 0))\n(test)  --> 0\n(test 1)\n(test)  --> 1\n(parameterize ([test 2])\n  (test))  --> 2\n(test)  --> 1\n(parameterize ([test 2])\n  (test 3)\n  (test))  --> 3\n(test)  --> 1\n(define k (lambda (x) x))\n(begin (set! k (call/cc k))\n       'k)  --> k\n(parameterize ([test 2])\n  (test (call/cc k))\n  (test))  --> k\n(test)  --> 1\n(k 3)  --> 3\n(test)  --> 1\n" "The definition of parameterize is similar to the definition of\nfluid-let (page 117):\n" "\n" "(define-syntax parameterize\n  (lambda (x)\n    (syntax-case x ()\n      [(_ () b1 b2 ...) #'(begin b1 b2 ...)]\n      [(_ ((x e) ...) b1 b2 ...)\n       (with-syntax ([(p ...) (generate-temporaries #'(x ...))]\n                     [(y ...) (generate-temporaries #'(x ...))])\n         #'(let ([p x] ... [y e] ...)\n             (let ([swap (lambda ()\n                           (let ([t (p)]) (p y) (set! y t))\n                           ...)])\n               (dynamic-wind swap (lambda () b1 b2 ...) swap))))])))\n") ("system:s251" "\nprocedure: (virtual-register-count)\nreturns: the number of virtual registers\nlibraries: (chezscheme)\n" "As of Version 9.0, the number of virtual registers is set at 16.\nIt cannot be changed except by recompiling Chez Scheme from\nsource.\n") ("system:s252" "\nprocedure: (set-virtual-register! k x)\nreturns: unspecified\nlibraries: (chezscheme)\n" "set-virtual-register! stores x in virtual register k.\nk must be a nonnegative fixnum less than the value of\n(virtual-register-count).\n") ("system:s253" "\nprocedure: (virtual-register k)\nreturns: see below\nlibraries: (chezscheme)\n" "virtual-register returns the value most recently\nstored in virtual register k (on the current thread, in\nthreaded versions of the system).\n\n") ("system:s254" "\nprocedure: (scheme-version)\nreturns: a version string\nlibraries: (chezscheme)\n" "The version string is in the form\n" "\n" "\"Chez Scheme Version version\"\n" "for Chez Scheme, and\n" "\n" "\"Petite Chez Scheme Version version\"\n" "for Petite Chez Scheme.\n") ("system:s255" "\nprocedure: (scheme-version-number)\nreturns: three values: the major, minor, and sub-minor version numbers\nlibraries: (chezscheme)\n" "Each of the three return values is a nonnegative fixnum.\n" "\nIn Chez Scheme Version 7.9.4:\n" "\n" "(scheme-version-number) --> 7\n                        gifs/ghostRightarrow.gif 9\n                        gifs/ghostRightarrow.gif 4\n") ("system:s256" "\nprocedure: (petite?)\nreturns: #t if called in Petite Chez Scheme, #f otherwise\nlibraries: (chezscheme)\n" "The only difference between Petite Chez Scheme and Chez Scheme is that\nthe compiler is not available in the former, so this predicate can serve as\na way to determine if the compiler is available.\n\n") ("system:s257" "\nprocedure: (threaded?)\nreturns: #t if called in a threaded version of the system, #f otherwise\nlibraries: (chezscheme)\n") ("system:s258" "\nprocedure: (interactive?)\nreturns: #t if system is run interactively, #f otherwise\nlibraries: (chezscheme)\n" "This predicate returns #t if the Scheme process's\nstdin and stdout are connected to a tty (Unix-based systems) or console\n(Windows).\nOtherwise, it returns #f.\n\n") ("system:s259" "\nprocedure: (get-process-id)\nreturns: the operating system process id of the current process\nlibraries: (chezscheme)\n") ("system:s260" "\nprocedure: (getenv key)\nreturns: environment value of key or #f\nlibraries: (chezscheme)\n" "key must be a string.\ngetenv returns the operating system shell's environment value\nassociated with key, or #f if no environment value\nis associated with key.\n" "\n" "(getenv \"HOME\") --> \"/u/freddy\"\n") ("system:s261" "\nprocedure: (putenv key value)\nreturns: unspecified\nlibraries: (chezscheme)\n" "key and value must be strings.\n" "\nputenv stores the key, value pair in the\nenvironment of the process,\nwhere it is available to the current process (e.g., via getenv)\nand any spawned processes.\n" "\n" "(putenv \"SCHEME\" \"rocks!\")\n(getenv \"SCHEME\") --> \"rocks!\"\n") ("system:s262" "\nprocedure: (get-registry key)\nreturns: registry value of key or #f\nprocedure: (put-registry! key val)\nprocedure: (remove-registry! key)\nreturns: unspecified\nlibraries: (chezscheme)\n" "key and val must be strings.\n" "\nget-registry returns a string containing the registry\nvalue of key if the value exists.\nIf no registry value for key exists, get-registry returns\n#f.\n" "\nput-registry! sets the registry\nvalue of key to val.\nIt raises an exception with condition type &assertion if the\nvalue cannot be set, which may happen if\nthe user has insufficient access.\n" "\nremove-registry! removes the registry\nkey or value named by key.\nIt raises an exception with condition type &assertion if the\nvalue cannot be removed.\nReasons for failure include the key not being present, the user having\ninsufficient access, or key being a key with subkeys.\n" "\nThese routines are defined for Windows only.\n" "\n" "(get-registry \"hkey_local_machine\\\\Software\\\\North\\\\South\") --> #f\n(put-registry! \"hkey_local_machine\\\\Software\\\\North\\\\South\" \"east\")\n(get-registry \"hkey_local_machine\\\\Software\\\\North\\\\South\") --> \"east\"\n(remove-registry! \"hkey_local_machine\\\\Software\\\\North\")\n(get-registry \"hkey_local_machine\\\\Software\\\\North\\\\South\") --> #f\n") ("system:s263" "\nthread parameter: subset-mode\nlibraries: (chezscheme)\n") ("control:s0" "\nsyntax: (exclusive-cond clause1 clause2 ...)\nreturns: see below\nlibraries: (chezscheme)\n" "exclusive-cond is a version of cond\n(Section http://scheme.com/tspl4/./control.html#g995.3 of TSPLFOUR) that differs\nfrom cond in that the tests embedded within the clauses\nare assumed to be exclusive in the sense that if one of the tests\nis true, the others are not.\nThis allows the implementation to reorder clauses when profiling\ninformation is available at expansion time (Section 12.7).\n" "\nThe (test) form of clause is not supported.\nThe order chosen when profiling information is available is based\non the relative numbers of times the RHS of each clause is executed,\nand (test) has no RHS.\n(test => values) is equivalent, albeit less concise.\n") ("control:s1" "\nsyntax: (case expr0 clause1 clause2 ...)\nreturns: see below\nlibraries: (chezscheme)\n" "Each clause but the last must take one of the forms:\n" "\n" "((key ...) expr1 expr2 ...)\n(key expr1 expr2 ...)\n" "where each key is a datum distinct from the other keys.\nThe last clause may be in the above form or it may be an\nelse clause of the form\n" "\n" "(else expr1 expr2 ...)\n" "expr0 is evaluated and the result is compared\n(using equal?) against the keys of each clause in order.\nIf a clause containing a matching key is found, the\nexpressions expr1 expr2 ... are evaluated in sequence\nand the values of the last expression are returned.\n" "\nIf none of the clauses contains a matching key and an else clause\nis present, the expressions expr1 expr2 ... of the\nelse clause are evaluated in sequence and the values of the last\nexpression are returned.\n" "\nIf none of the clauses contains a matching key and no else clause\nis present, the value or values are unspecified.\n" "\nThe Revised6 Report version of case does not support singleton\nkeys (the second of the first two clause forms above) and uses\neqv? rather than equal? as the comparison procedure.\nBoth versions are defined in terms of exclusive-cond so that\nif profiling information is available at expansion time, the clauses will\nbe reordered to put those that are most frequently executed first.\n" "\n" "(let ([ls '(ii iv)])\n  (case (car ls)\n    [i 1]\n    [ii 2]\n    [iii 3]\n    [(iiii iv) 4]\n    [else 'out-of-range])) --> 2\n\n(define p\n  (lambda (x)\n    (case x\n      [(\"abc\" \"def\") 'one]\n      [((a b c)) 'two]\n      [else #f])))\n\n(p (string #\\d #\\e #\\f)) --> one\n(p '(a b c)) --> two\n") ("control:s3" "\nsyntax: (record-case expr clause1 clause2 ...)\nreturns: see explanation\nlibraries: (chezscheme)\n" "record-case is a restricted form of case that supports the\ndestructuring of records, or tagged lists.\nA record has as its first element a tag that determines what \"type\"\nof record it is; the remaining elements are the fields of the record.\n" "\nEach clause but the last must take the form\n" "\n" "((key ...) formals body1 body2 ...)\n" "where each key is a datum distinct from the other keys.\nThe last clause may be in the above form or it may be an\nelse clause of the form\n" "\n" "(else body1 body2 ...)\n" "expr must evaluate to a pair.\nexpr is evaluated and the car of its value is compared\n(using eqv?) against the keys of each clause in order.\nIf a clause containing a matching key is found, the variables in\nformals are bound to the remaining elements\nof the list and the expressions\nbody1 body2 ... are evaluated in sequence.\nThe value of the last expression is returned.\nThe effect is identical to the application of\n" "\n" "(lambda formals body1 body2 ...)\n" "to the cdr of the list.\n" "\nIf none of the clauses contains a matching key and an else clause\nis present, the expressions body1 body2 ... of the\nelse clause are evaluated in sequence and the value of the last\nexpression is returned.\n" "\nIf none of the clauses contains a matching key and no else clause\nis present, the value is unspecified.\n\n" "\n" "(define calc\n  (lambda (x)\n    (record-case x\n      [(add) (x y) (+ x y)]\n      [(sub) (x y) (- x y)]\n      [(mul) (x y) (* x y)]\n      [(div) (x y) (/ x y)]\n      [else (assertion-violationf 'calc \"invalid expression ~s\" x)])))\n\n(calc '(add 3 4)) --> 7\n(calc '(div 3 4)) --> 3/4\n") ("control:s7" "\nprocedure: (ormap procedure list1 list2 ...)\nreturns: see explanation\nlibraries: (chezscheme)\n" "ormap is identical to the Revised6 Report exists.\n") ("control:s8" "\nprocedure: (andmap procedure list1 list2 ...)\nreturns: see explanation\nlibraries: (chezscheme)\n" "andmap is identical to the Revised6 Report for-all.\n\n") ("control:s9" "\nprocedure: (call/1cc procedure)\nreturns: see below\nlibraries: (chezscheme)\n" "call/1cc obtains its continuation and passes it to procedure,\nwhich should accept one argument.\nThe continuation itself is represented by a procedure.\nThis procedure normally takes one argument but may take an arbitrary\nnumber of arguments depending upon whether the context of the call\nto call/1cc\nexpects multiple return values or not.\nWhen this procedure is applied to a value or values, it returns the values\nto the continuation of the call/1cc application.\n" "\nThe continuation obtained by call/1cc is a\n\"one-shot continuation.\"\nA one-shot continuation should not be returned to multiple times, either\nby invoking the continuation or returning normally from procedure more\nthan once.\nA one-shot continuation is \"promoted\" into a normal (multishot)\ncontinuation, however, if it is \nstill active when a\nnormal continuation is obtained by call/cc.\nAfter a one-shot continuation is promoted into a multishot continuation,\nit behaves exactly as if it had been obtained via call/cc.\nThis allows call/cc and call/1cc to be used together\ntransparently in many applications.\n" "\nOne-shot continuations may be more efficient for some applications than\nmultishot continuations.\nSee the paper \"Representing control in the presence of one-shot\ncontinuations\" [citation3] for more information about\none-shot continuations, including how they are implemented in\nChez Scheme.\n" "\nThe following examples highlight the similarities and differences\nbetween one-shot and normal continuations.\n" "\n" "(define prod\n ; compute the product of the elements of ls, bugging out\n ; with no multiplications if a zero element is found\n  (lambda (ls)\n    (lambda (k)\n      (if (null? ls)\n          1\n          (if (= (car ls) 0)\n              (k 0)\n              (* (car ls) ((prod (cdr ls)) k)))))))\n\n(call/cc (prod '(1 2 3 4))) --> 24\n(call/1cc (prod '(1 2 3 4))) --> 24\n\n(call/cc (prod '(1 2 3 4 0))) --> 0\n(call/1cc (prod '(1 2 3 4 0))) --> 0\n\n(let ([k (call/cc (lambda (x) x))])\n  (k (lambda (x) 0))) --> 0\n\n(let ([k (call/1cc (lambda (x) x))])\n  (k (lambda (x) 0))) --> exception\n") ("control:s11" "dynamic-wind\nprocedure: (dynamic-wind in body out)\nprocedure: (dynamic-wind critical? in body out)\nreturns: values resulting from the application of body\nlibraries: (chezscheme)\n" "The first form is identical to the Revised6 Report dynamic-wind.\nWhen the optional critical? argument is present and non-false,\nthe in thunk is invoked in a critical section along with the code\nthat records that the body has been entered, and the out thunk is\ninvoked in a critical section along with the code that records\nthat the body has been exited.\nExtreme caution must be taken with this form of dynamic-wind,\nsince an error or long-running computation can leave interrupts\nand automatic garbage collection disabled.\n") ("control:s16" "\nprocedure: (make-engine thunk)\nreturns: an engine\nlibraries: (chezscheme)\n" "An engine is created by passing a thunk (no argument procedure)\nto make-engine.\nThe body of the thunk is the computation to be performed by the engine.\nAn engine itself is a procedure of three arguments:\n" "\nticks:\na positive integer that specifies\nthe amount of fuel to be given\nto the engine.\nAn engine executes until this fuel runs out or until its computation\nfinishes.\n" "\ncomplete:\na procedure of one or more\narguments that\nspecifies what to do if the computation finishes.\nIts arguments are the amount of fuel left over and the\nvalues produced by the computation.\n" "\nexpire:\na procedure of one argument that\nspecifies what to do if the fuel runs\nout before the computation finishes.\nIts argument is a new engine capable of continuing the computation\nfrom the point of interruption.\n\n" "\nWhen an engine is applied to its arguments, it sets up a timer\nto fire in ticks time units.\n(See set-timer on page 330.)\nIf the engine computation completes before the timer expires, the\nsystem invokes complete, passing \nit the number of ticks left over and\nthe values produced by the computation.\nIf, on the other hand, the timer goes off before the engine computation\ncompletes, the system creates a new engine from the continuation of\nthe interrupted computation and passes this engine to expire.\ncomplete and expire are invoked in the continuation\nof the engine invocation.\n" "\nAn implementation of engines is given\nin Section http://scheme.com/tspl4/./examples.html#g20812.11.\nof The Scheme Programming Language, 4th Edition.\n" "\nDo not use the timer interrupt (see set-timer) and engines\nat the same time, since engines are implemented in terms of the timer.\n" "\nThe following example creates an engine from a trivial computation,\n3, and gives the engine 10 ticks.\n" "\n" "(define eng\n  (make-engine\n    (lambda () 3)))\n\n(eng 10\n     (lambda (ticks value) value)\n     (lambda (x) x)) --> 3\n" "It is often useful to pass list as the complete\nprocedure to an engine, causing an engine that completes to return a\nlist whose first element is the ticks remaining and whose remaining elements\nare the values returned by the computation.\n" "\n" "(define eng\n  (make-engine\n    (lambda () 3)))\n\n(eng 10\n     list\n     (lambda (x) x)) --> (9 3)\n" "In the example above, the value is 3 and there are 9 ticks left over,\ni.e., it takes one unit of fuel to evaluate 3.\n(The fuel amounts given here are for illustration only.\nYour mileage may vary.)\n" "\nTypically, the engine computation does not finish in one try.\nThe following example displays the use of an engine to\ncompute the 10th Fibonacci number in steps.\n" "\n" "(define fibonacci\n  (lambda (n)\n    (let fib ([i n])\n      (cond\n        [(= i 0) 0]\n        [(= i 1) 1]\n        [else (+ (fib (- i 1))\n                 (fib (- i 2)))]))))\n\n(define eng\n  (make-engine\n    (lambda ()\n      (fibonacci 10))))\n\n(eng 50\n     list\n     (lambda (new-eng)\n       (set! eng new-eng)\n       \"expired\")) --> \"expired\"\n\n(eng 50\n     list\n     (lambda (new-eng)\n       (set! eng new-eng)\n       \"expired\")) --> \"expired\"\n\n(eng 50\n     list\n     (lambda (new-eng)\n       (set! eng new-eng)\n       \"expired\")) --> \"expired\"\n\n(eng 50\n     list\n     (lambda (new-eng)\n       (set! eng new-eng)\n       \"expired\")) --> (21 55)\n" "Each time the engine's fuel runs out, the expire procedure assigns\neng to the new engine.\nThe entire computation requires four blocks of 50 ticks to complete; of the\nlast 50 it uses all but 21.\nThus, the total amount of fuel used is 179 ticks.\nThis leads to the following procedure, mileage, which \"times\" a\ncomputation using engines:\n" "\n" "(define mileage\n  (lambda (thunk)\n    (let loop ([eng (make-engine thunk)] [total-ticks 0])\n      (eng 50\n           (lambda (ticks . values)\n             (+ total-ticks (- 50 ticks)))\n           (lambda (new-eng)\n             (loop new-eng\n                   (+ total-ticks 50)))))))\n\n(mileage (lambda () (fibonacci 10))) --> 179\n" "The choice of 50 for the number of ticks to use each time is\narbitrary, of course.\nIt might make more sense to pass a much larger number, say 10000,\nin order to reduce the number of times the computation is interrupted.\n" "\nThe next procedure is similar to mileage, but it returns a list\nof engines, one for each tick it takes to complete the computation.\nEach of the engines in the list represents a \"snapshot\" of the\ncomputation, analogous to a single frame of a moving picture.\nsnapshot might be useful for \"single stepping\" a computation.\n" "\n" "(define snapshot\n  (lambda (thunk)\n    (let again ([eng (make-engine thunk)])\n      (cons eng\n            (eng 1 (lambda (t . v) '()) again)))))\n" "The recursion embedded in this procedure is rather strange.\nThe complete procedure performs the base case, returning the empty\nlist, and the expire procedure performs the recursion.\n" "\nThe next procedure, round-robin, could be the basis for a simple\ntime-sharing operating system.\nround-robin maintains a queue of processes (a list of engines),\ncycling through the queue in a round-robin fashion, allowing each\nprocess to run for a set amount of time.\nround-robin returns a list of the values returned by the engine\ncomputations in the order that the computations complete.\nEach computation is assumed to produce exactly one value.\n" "\n" "(define round-robin\n  (lambda (engs)\n    (if (null? engs)\n        '()\n        ((car engs)\n         1\n         (lambda (ticks value)\n           (cons value (round-robin (cdr engs))))\n         (lambda (eng)\n           (round-robin\n             (append (cdr engs) (list eng))))))))\n" "Since the amount of fuel supplied each time, one tick, is constant,\nthe effect of round-robin is to return a list of the values sorted\nfrom the quickest to complete to the slowest to complete.\nThus, when we call round-robin on a list of engines, each computing\none of the Fibonacci numbers, the output list is sorted with the earlier\nFibonacci numbers first, regardless of the order of the input list.\n" "\n" "(round-robin\n  (map (lambda (x)\n         (make-engine\n           (lambda ()\n             (fibonacci x))))\n       '(4 5 2 8 3 7 6 2))) --> (1 1 2 3 5 8 13 21)\n" "More interesting things can happen if the amount of fuel varies\neach time through the loop.\nIn this case, the computation would\nbe nondeterministic, i.e., the results would vary from call to call.\n" "\nThe following syntactic form, por (parallel-or), returns the\nfirst of its expressions to complete with a true value.\npor is implemented with the procedure first-true, which is\nsimilar to round-robin but quits when any of the engines\ncompletes with a true value.\nIf all of the engines complete, but none with a true value,\nfirst-true (and hence por) returns #f.\nAlso, although first-true passes a fixed amount of fuel to each\nengine, it chooses the next engine to run at random, and is thus\nnondeterministic.\n" "\n" "(define-syntax por\n  (syntax-rules ()\n    [(_ x ...)\n     (first-true\n       (list (make-engine (lambda () x)) ...))]))\n\n(define first-true\n  (let ([pick\n         (lambda (ls)\n           (list-ref ls (random (length ls))))])\n    (lambda (engs)\n      (if (null? engs)\n          #f\n          (let ([eng (pick engs)])\n            (eng 1\n                 (lambda (ticks value)\n                   (or value\n                       (first-true\n                         (remq eng engs))))\n                 (lambda (new-eng)\n                   (first-true\n                     (cons new-eng\n                           (remq eng engs))))))))))\n" "The list of engines is maintained with pick, which randomly\nchooses an element of the list, and remq, which removes the\nchosen engine from the list.\nSince por is nondeterministic, subsequent uses with the same\nexpressions may not return the same values.\n" "\n" "(por 1 2 3) --> 2\n(por 1 2 3) --> 3\n(por 1 2 3) --> 2\n(por 1 2 3) --> 1\n" "Furthermore, even if one of the expressions is an infinite loop,\npor still finishes as long as one of the other expressions\ncompletes and returns a true value.\n" "\n" "(por (let loop () (loop)) 2) --> 2\n" "With engine-return and engine-block, it is possible to\nterminate an engine explicitly.\nengine-return causes the engine to complete, as if the\ncomputation had finished.\nIts arguments are passed to the complete procedure along with the\nnumber of ticks remaining.\nIt is essentially a nonlocal exit from the engine.\nSimilarly, engine-block causes the engine to expire, as if the\ntimer had run out.\nA new engine is made from the continuation of the call to engine-block\nand passed to the expire procedure.\n\n") ("control:s27" "\nprocedure: (engine-block)\nreturns: does not return\nlibraries: (chezscheme)\n" "This causes a running engine to stop, create a new engine capable\nof continuing the computation, and pass the new engine to the original\nengine's third argument\n(the expire procedure).\nAny remaining fuel is forfeited.\n" "\n" "(define eng\n  (make-engine\n    (lambda ()\n      (engine-block)\n      \"completed\")))\n\n(eng 100\n     (lambda (ticks value) value)\n     (lambda (x)\n        (set! eng x)\n        \"expired\")) --> \"expired\"\n\n(eng 100\n     (lambda (ticks value) value)\n     (lambda (x)\n        (set! eng x)\n        \"expired\")) --> \"completed\"\n") ("control:s28" "\nprocedure: (engine-return obj ...)\nreturns: does not return\nlibraries: (chezscheme)\n" "This causes a running engine to stop and pass control to the\nengine's complete argument.\nThe first argument passed to the complete procedure is the amount of\nfuel remaining, as usual, and\nthe remaining arguments are the objects obj ...\npassed to engine-return.\n" "\n" "(define eng\n  (make-engine\n    (lambda ()\n      (reverse (engine-return 'a 'b 'c)))))\n\n(eng 100\n     (lambda (ticks . values) values)\n     (lambda (new-eng) \"expired\")) --> (a b c)\n") ("syntax:s0" "\nsyntax: (fluid-let-syntax ((keyword expr) ...) form1 form2 ...)\nreturns: see explanation\nlibraries: (chezscheme)\n" "Each expr must evaluate to a transformer.\nfluid-let-syntax is similar to the standard let-syntax, except\nthat instead of introducing new bindings for the keywords\nkeyword ...,\nfluid-let-syntax temporarily alters the existing bindings\nfor the keywords during the expansion of its body.\nThat is, during the expansion of form1 form2 ...,\nthe visible lexical (or top-level) binding\nfor each keyword is temporarily replaced by a new association\nbetween the keyword and the corresponding transformer.\nThis affects any references to the keyword that resolve\nto the same lexical (or top-level) binding whether the references occur\nin the text of the body or are introduced during its expansion.\nIn contrast, let-syntax captures only those references that\noccur within the text of its body.\n" "\nThe following example shows how fluid-let-syntax\ndiffers from let-syntax.\n" "\n" "(let ([f (lambda (x) (+ x 1))])\n  (let-syntax ([g (syntax-rules ()\n                    [(_ x) (f x)])])\n    (let-syntax ([f (syntax-rules ()\n                      [(_ x) x])])\n      (g 1)))) --> 2\n\n(let ([f (lambda (x) (+ x 1))])\n  (let-syntax ([g (syntax-rules ()\n                    [(_ x) (f x)])])\n    (fluid-let-syntax ([f (syntax-rules ()\n                            [(_ x) x])])\n      (g 1)))) --> 1\n" "The two expressions are identical except that the inner\nlet-syntax form\nin the first expression is a fluid-let-syntax form in the second.\nIn the first expression, the f occurring in the expansion of\n(g 1) refers to\nthe let-bound variable f, whereas in the second it refers\nto the keyword f by virtue of the fluid syntax binding for\nf.\n" "\nThe following code employs fluid-let-syntax in the definition\nof a define-integrable form that is similar\nto define for procedure definitions except that it causes the\ncode for the procedure to be integrated, or inserted, wherever\na direct call to the procedure is found.\nNo semantic difference is visible between procedures defined with\ndefine-integrable and those defined with define, except that\na top-level define-integrable form must appear before the first\nreference to the defined identifier.\nLexical scoping is preserved, the actual parameters\nin an integrated call are evaluated once and at the proper time,\nintegrable procedures may be used as first-class values, and\nrecursive procedures do not cause indefinite recursive expansion.\n" "\n" "(define-syntax define-integrable\n  (syntax-rules (lambda)\n    [(_ name (lambda formals form1 form2 ...))\n     (begin\n       (define xname\n         (fluid-let-syntax ([name (identifier-syntax xname)])\n           (lambda formals form1 form2 ...)))\n       (define-syntax name\n         (lambda (x)\n           (syntax-case x ()\n             [_ (identifier? x) #'xname]\n             [(_ arg (... ...))\n              #'((fluid-let-syntax ([name (identifier-syntax xname)])\n                   (lambda formals form1 form2 ...))\n                  arg\n                  (... ...))]))))]))\n" "A define-integrable has the following form.\n" "\n" "(define-integrable name lambda-expression)\n" "A define-integrable form expands into a pair of definitions: a syntax\ndefinition of name and a variable definition of xname.\nThe transformer for name converts apparent calls to\nname into direct calls to lambda-expression.\nSince the resulting forms are merely direct lambda applications\n(the equivalent of let expressions),\nthe actual parameters are evaluated exactly once and before evaluation\nof the procedure's body, as required.\nAll other references to name are replaced with references to\nxname.\nThe definition of xname binds it to the value of\nlambda-expression.\nThis allows the procedure to be used as a first-class value.\nBecause xname is introduced by the transformer, the binding for\nxname is not visible anywhere except where references to it\nare introduced by the transformer for name.\n" "\nWithin lambda-expression, wherever it appears, name\nis rebound to a transformer that expands all references into references\nto xname.\nThe use of fluid-let-syntax\nfor this purpose prevents indefinite\nexpansion from indirect recursion among integrable procedures.\nThis allows the procedure to be recursive without causing indefinite\nexpansion.\nNothing special is done by define-integrable to maintain lexical\nscoping, since lexical scoping is maintained automatically by the\nexpander.\n" "\nChez Scheme integrates locally defined procedures automatically when it is\nappropriate to do so.\nIt cannot integrate procedures defined at top-level,\nhowever, since code that assigns top-level variables can be introduced\ninto the system (via eval or load) at any time.\ndefine-integrable can be used to force the integration of\nprocedures bound at top-level, even if the integration of locally bound\nprocedures is left to the compiler.\nIt can also be used to force the integration of large procedures that\nthe compiler would not normally integrate.\n(The expand/optimize procedure is useful for determining when\nintegration does or does not take place.)\n") ("syntax:s4" "\nsyntax: (syntax-rules (literal ...) clause ...)\nreturns: a transformer\nlibraries: (chezscheme)\n" "Each literal must be an identifier other than\nan underscore ( _ ) or ellipsis ( ... ).\nEach clause must take the form below.\n" "\n" "(pattern template)\n(pattern fender template)\n" "The first form is the only form supported by the Revised6 Report.\n\n") ("syntax:s6" "\nprocedure: (syntax->list syntax-object)\nreturns: a list of syntax objects\nlibraries: (chezscheme)\n" "This procedure takes a syntax object representing\na list-structured form and returns a list of syntax objects, each representing\nthe corresponding subform of the input form.\n\n" "\nsyntax->list may be defined as follows.\n" "\n" "(define syntax->list\n  (lambda (ls)\n    (syntax-case ls ()\n      [() '()]\n      [(x . r) (cons #'x (syntax->list #'r))])))\n\n#'(a b c) --> #<syntax (a b c)>\n(syntax->list #'(a b c)) --> (#<syntax a> #<syntax b> #<syntax c>)\n" "syntax->list is not required for list structures constructed\nfrom individual pattern variable values or sequences of pattern-variable\nvalues, since such structures are already lists.\nFor example:\n" "\n" "(list? (with-syntax ([x #'a] [y #'b] [z #'c]) #'(x y z)))) --> #t\n(list? (with-syntax ([(x ...) #'(a b c)]) #'(x ...))) --> #t\n") ("syntax:s7" "\nprocedure: (syntax->vector syntax-object)\nreturns: a vector of syntax objects\nlibraries: (chezscheme)\n" "This procedure takes a syntax object representing\na vector-structured form and returns a vector of syntax objects, each representing\nthe corresponding subform of the input form.\n\n" "\nsyntax->vector may be defined as follows.\n" "\n" "(define syntax->vector\n  (lambda (v)\n    (syntax-case v ()\n      [#(x ...) (apply vector (syntax->list #'(x ...)))])))\n\n#'#(a b c) --> #<syntax #(a b c)>\n(syntax->vector #'#(a b c)) --> #(#<syntax a> #<syntax b> #<syntax c>)\n" "syntax->vector is not required for vector structures constructed\nfrom individual pattern variable values or sequences of pattern-variable\nvalues, since such structures are already vectors.\nFor example:\n" "\n" "(vector? (with-syntax ([x #'a] [y #'b] [z #'c]) #'#(x y z)))) --> #t\n(vector? (with-syntax ([(x ...) #'(a b c)]) #'#(x ...))) --> #t\n") ("syntax:s8" "\nprocedure: (syntax-object->datum obj)\nreturns: obj stripped of syntactic information\nlibraries: (chezscheme)\n" "syntax-object->datum is identical to the Revised6 Report\nsyntax->datum.\n\n") ("syntax:s9" "\nsyntax: (datum template)\nreturns: see below\nlibraries: (chezscheme)\n" "(datum template) is a convenient shorthand syntax for\n" "\n" "(syntax->datum (syntax template))\n" "datum may be defined simply as follows.\n" "\n" "(define-syntax datum\n  (syntax-rules ()\n    [(_ t) (syntax->datum #'t)]))\n\n(with-syntax ((a #'(a b c))) (datum a)) --> (a b c)\n") ("syntax:s10" "\nprocedure: (datum->syntax-object template-identifier obj)\nreturns: a syntax object\nlibraries: (chezscheme)\n" "datum->syntax-object is identical to the Revised6 Report\ndatum->syntax.\n") ("syntax:s11" "\nsyntax: (with-implicit (id0 id1 ...) body1 body2 ...)\nreturns: see below\nlibraries: (chezscheme)\n" "This form abstracts over the common usage of datum->syntax\nfor creating implicit identifiers (see above).\nThe form\n" "\n" "(with-implicit (id0 id1 ...)\n  body1 body2 ...)\n" "is equivalent to\n" "\n" "(with-syntax ([id1 (datum->syntax #'id0 'id1)] ...)\n  body1 body2 ...)\n" "with-implicit can be defined simply as follows.\n" "\n" "(define-syntax with-implicit\n  (syntax-rules ()\n    [(_ (tid id ...) b1 b2 ...)\n     (with-syntax ([id (datum->syntax #'tid 'id)] ...)\n       b1 b2 ...)]))\n" "We can use with-implicit to simplify the (correct version of)\nloop above.\n" "\n" "(define-syntax loop\n  (lambda (x)\n    (syntax-case x ()\n      [(k e ...)\n       (with-implicit (k break)\n         #'(call-with-current-continuation\n             (lambda (break)\n               (let f () e ... (f)))))])))\n") ("syntax:s12" "\nsyntax: (include path)\nreturns: unspecified\nlibraries: (chezscheme)\n" "path must be a string.\ninclude expands into a begin expression containing\nthe forms found in the file named by path.\nFor example, if the file f-def.ss contains\n(define f (lambda () x)), the expression\n" "\n" "(let ([x \"okay\"])\n  (include \"f-def.ss\")\n  (f))\n" "evaluates to \"okay\".\nAn include form is treated as a definition if it appears within a\nsequence of definitions and the forms on the file named by\npath are all definitions, as in the above example.\nIf the file contains expressions instead, the include form is\ntreated as an expression.\n" "\ninclude may be defined portably as follows, although\nChez Scheme uses an implementation-dependent definition that allows\nit to capture and maintain source information for included code.\n" "\n" "(define-syntax include\n  (lambda (x)\n    (define read-file\n      (lambda (fn k)\n        (let ([p (open-input-file fn)])\n          (let f ([x (read p)])\n            (if (eof-object? x)\n                (begin (close-input-port p) '())\n                (cons (datum->syntax k x)\n                      (f (read p))))))))\n    (syntax-case x ()\n      [(k filename)\n       (let ([fn (datum filename)])\n         (with-syntax ([(exp ...) (read-file fn #'k)])\n           #'(begin exp ...)))])))\n" "The definition of include uses datum->syntax to convert\nthe objects read from the file into syntax objects in the proper\nlexical context, so that identifier references and definitions within\nthose expressions are scoped where the include form appears.\n" "\nIn Chez Scheme's implementation of include,\nthe parameter source-directories (Section 12.5)\ndetermines the set of directories searched for source files not identified\nby absolute path names.\n\n") ("syntax:s13" "\ndesc:syntax-error\nprocedure: (syntax-error obj string ...)\nreturns: does not return\nlibraries: (chezscheme)\n" "Syntax errors may be reported with syntax-error, which produces\na message by concatenating string ... and a printed\nrepresentation of obj.\nIf no string arguments are provided, the string \"invalid syntax\"\nis used instead.\nWhen obj is a syntax object, the syntax-object wrapper is\nstripped (as with syntax->datum) before the printed representation\nis created.\nIf source file information is present in the syntax-object wrapper,\nsyntax-error incorporates this information into the error\nmessage.\n" "\nsyntax-case and syntax-rules call syntax-error\nautomatically if the input fails to match one of the clauses.\n" "\nWe can use syntax-error to precisely report the cause\nof the errors detected in the following definition of\n(unnamed) let.\n" "\n" "(define-syntax let\n  (lambda (x)\n    (define check-ids!\n      (lambda (ls)\n        (unless (null? ls)\n          (unless (identifier? (car ls))\n            (syntax-error (car ls) \"let cannot bind non-identifier\"))\n          (check-ids! (cdr ls)))))\n    (define check-unique!\n      (lambda (ls)\n        (unless (null? ls)\n          (let ([x (car ls)])\n            (when (let mem? ([ls (cdr ls)])\n                    (and (not (null? ls))\n                         (or (bound-identifier=? x (car ls))\n                             (mem? (cdr ls)))))\n              (syntax-error x \"let cannot bind two occurrences of\")))\n          (check-unique! (cdr ls)))))\n    (syntax-case x ()\n      [(_ ((i e) ...) b1 b2 ...)\n       (begin\n         (check-ids! #'(i ...))\n         (check-unique! #'(i ...))\n         #'((lambda (i ...) b1 b2 ...) e ...))])))\n" "With this change, the expression\n" "\n" "(let ([a 3] [a 4]) (+ a a))\n" "produces the error message \"let cannot bind two occurrences of a.\"\n") ("syntax:s14" "\nprocedure: (literal-identifier=? identifier1 identifier2)\nreturns: see below\nlibraries: (chezscheme)\n" "This procedure is identical to the Revised6 Report\nfree-identifier=?, and is provided for backward\ncompatibility only.\n") ("syntax:s15" "\nprocedure: (make-compile-time-value obj)\nreturns: a compile-time value\nlibraries: (chezscheme)\n" "A compile time value is a kind of transformer with which a keyword may\nbe associated by any of the keyword binding constructs, e.g., define-syntax\nor let-syntax.\nThe transformer encapsulates the supplied obj.\nThe encapsulated object may be retrieved as described above.\n" "\nThe following example illustrates how this feature might be used to define\na simple syntactic record-definition mechanism where the record type descriptor\nis generated at expansion time.\n" "\n" "(define-syntax drt\n  (lambda (x)\n    (define construct-name\n      (lambda (template-identifier . args)\n        (datum->syntax template-identifier\n          (string->symbol\n            (apply string-append\n              (map (lambda (x)\n                     (if (string? x)\n                         x\n                         (symbol->string (syntax->datum x))))\n                   args))))))\n    (define do-drt\n      (lambda (rname fname* prtd)\n        (with-syntax ([rname rname]\n                      [rtd (make-record-type-descriptor\n                             (syntax->datum rname) prtd #f #f #f\n                             (list->vector\n                               (map (lambda (fname)\n                                      `(immutable ,(syntax->datum fname)))\n                                    fname*)))]\n                      [make-rname (construct-name rname \"make-\" rname)]\n                      [rname? (construct-name rname rname \"?\")]\n                      [(rname-fname ...)\n                       (map (lambda (fname)\n                              (construct-name fname rname \"-\" fname))\n                            fname*)]\n                      [(i ...) (enumerate fname*)])\n          #'(begin\n              (define-syntax rname (make-compile-time-value 'rtd))\n              (define rcd (make-record-constructor-descriptor 'rtd #f #f))\n              (define make-rname (record-constructor rcd))\n              (define rname? (record-predicate 'rtd))\n              (define rname-fname (record-accessor 'rtd i))\n              ...))))\n    (syntax-case x (parent)\n      [(_ rname (fname ...))\n       (for-all identifier? #'(rname fname ...))\n       (do-drt #'rname #'(fname ...) #f)]\n      [(_ rname pname (fname ...))\n       (for-all identifier? #'(rname pname fname ...))\n       (lambda (lookup)\n         (let ([prtd (lookup #'pname)])\n           (unless (record-type-descriptor? prtd)\n             (syntax-error #'pname \"unrecognized parent record type\"))\n           (do-drt #'rname #'(fname ...) prtd)))])))\n" "\n" "(drt prec (x y))\n(drt crec prec (z))\n(define r (make-crec 1 2 3))\n(prec? r) --> #t\n(prec-x r) --> 1\n(crec-z r) --> 3\nprec --> exception: invalid syntax prec\n") ("syntax:s16" "\nprocedure: (compile-time-value? obj)\nreturns: #t if obj is a compile-time value; #f otherwise\nlibraries: (chezscheme)\n" "\n" "(define-syntax x (make-compile-time-value \"eggs\"))\n(compile-time-value? (top-level-syntax 'x)) --> #t\n") ("syntax:s17" "\nprocedure: (compile-time-value-value ctv)\nreturns: the value of a compile-time value\nlibraries: (chezscheme)\n" "\n" "(define-syntax x (make-compile-time-value \"eggs\"))\n(compile-time-value-value (top-level-syntax 'x)) --> \"eggs\"\n") ("syntax:s18" "\nsyntax: (define-property id key expr)\nreturns: unspecified\nlibraries: (chezscheme)\n" "A define-property form attaches a property to an\nexisting identifier binding without disturbing the existing meaning\nof the identifier in the scope of that binding.\nIt is typically used by one macro to record information about a binding\nfor use by another macro.\nBoth id and key must be identifiers.\nThe expression expr is evaluated when the define-property\nform is expanded, and a new property associating key with the\nvalue of expr is attached to the existing binding of\nid, which must have a visible local or top-level binding.\n" "\ndefine-property is a definition and can appear anywhere\nother definitions can appear.\nThe scope of a property introduced by define-property is the\nentire body in which the define-property form appears or global\nif it appears at top level, except\nwhere it is replaced by a property for the same id and\nkey or where the binding to which it is attached is shadowed.\nAny number of properties can be attached to the same binding with\ndifferent keys.\nAttaching a new property with the same name as an property already\nattached to a binding shadows the existing property with the new\nproperty.\n" "\nThe following example defines a macro, get-info, that retrieves\nthe info property of a binding, defines the variable x,\nattaches an info property to the binding of x, retrieves\nthe property via get-info, references x to show that\nits normal binding is still intact, and uses get-info again\nwithin the scope of a different binding of x to show that the\nproperties are shadowed as well as the outer binding of x.\n" "\n" "(define info)\n(define-syntax get-info\n  (lambda (x)\n    (lambda (lookup)\n      (syntax-case x ()\n        [(_ q)\n         (let ([info-value (lookup #'q #'info)])\n           #`'#,(datum->syntax #'* info-value))]))))\n(define x \"x-value\")\n(define-property x info \"x-info\")\n(get-info x) --> \"x-info\"\nx --> \"x-value\"\n(let ([x \"inner-x-value\"]) (get-info x)) --> #f\n" "For debugging, it is often useful to have a form that retrieves\nan arbitrary property, given an identifier and a key.\nThe get-property macro below does\njust that.\n" "\n" "(define-syntax get-property\n  (lambda (x)\n    (lambda (r)\n      (syntax-case x ()\n        [(_ id key)\n         #`'#,(datum->syntax #'* (r #'id #'key))]))))\n(get-property x info) --> \"x-info\"\n" "The bindings for both identifiers must be visible where\nget-property is used.\n" "\nThe version of drt defined below is like the one defined using\nmake-compile-time-value above, except that it defines the\nrecord name as a macro that raises an exception with a more descriptive\nmessage, while attaching the record type descriptor to the binding as a\nseparate property.\nThe variable drt-key defined along with drt is used\nonly as the key for the property that drt attaches to a record\nname.\nBoth drt-key and drt are defined within a module that\nexports only the latter, ensuring that the properties used by drt\ncannot be accessed or forged.\n" "\n" "(library (drt) (export drt) (import (chezscheme))\n  (define drt-key)\n  (define-syntax drt\n    (lambda (x)\n      (define construct-name\n        (lambda (template-identifier . args)\n          (datum->syntax template-identifier\n            (string->symbol\n              (apply string-append\n                (map (lambda (x)\n                       (if (string? x)\n                           x\n                           (symbol->string (syntax->datum x))))\n                     args))))))\n      (define do-drt\n        (lambda (rname fname* prtd)\n          (with-syntax ([rname rname]\n                        [rtd (make-record-type-descriptor\n                               (syntax->datum rname) prtd #f #f #f\n                               (list->vector\n                                 (map (lambda (fname)\n                                        `(immutable ,(syntax->datum fname)))\n                                      fname*)))]\n                        [make-rname (construct-name rname \"make-\" rname)]\n                        [rname? (construct-name rname rname \"?\")]\n                        [(rname-fname ...)\n                         (map (lambda (fname)\n                                (construct-name fname rname \"-\" fname))\n                              fname*)]\n                        [(i ...) (enumerate fname*)])\n            #'(begin\n                (define-syntax rname\n                  (lambda (x)\n                    (syntax-error x \"invalid use of record name\")))\n                (define rcd (make-record-constructor-descriptor 'rtd #f #f))\n                (define-property rname drt-key 'rtd)\n                (define make-rname (record-constructor rcd))\n                (define rname? (record-predicate 'rtd))\n                (define rname-fname (record-accessor 'rtd i))\n                ...))))\n      (syntax-case x (parent)\n        [(_ rname (fname ...))\n         (for-all identifier? #'(rname fname ...))\n         (do-drt #'rname #'(fname ...) #f)]\n        [(_ rname pname (fname ...))\n         (for-all identifier? #'(rname pname fname ...))\n         (lambda (lookup)\n           (let ([prtd (lookup #'pname #'drt-key)])\n             (unless prtd\n               (syntax-error #'pname \"unrecognized parent record type\"))\n             (do-drt #'rname #'(fname ...) prtd)))]))))\n" "\n" "(import (drt))\n(drt prec (x y))\n(drt crec prec (z))\n(define r (make-crec 1 2 3))\n(prec? r) --> #t\n(prec-x r) --> 1\n(crec-z r) --> 3\nprec --> exception: invalid use of record name prec\n") ("syntax:s21" "\nsyntax: (module name interface defn ... init ...)\nsyntax: (module interface defn ... init ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "name is an identifier, defn ...\nare definitions, and init ... are expressions.\ninterface is a list of exports (export ...),\nwhere each export is either an identifier identifier\nor of the form (identifier export ...).\n" "\nThe first syntax for module establishes a named scope that\nencapsulates a set of identifier bindings.\nThe exported bindings may be made visible via import or\nimport-only (Section 10.4)\nanywhere the module name is visible.\nThe second syntax for module introduces an anonymous module\nwhose bindings are implicitly imported (as if by import of a\nhidden module name) where the module form appears.\n" "\nA module consists of a (possibly empty) set of\ndefinitions and a (possibly empty) sequence of initialization expressions.\nThe identifiers defined within a module are visible within the body\nof the module and, if exported, within the scope of an import for the\nmodule.\nEach identifier listed in a module's interface must be defined within\nor imported into that module.\nA module form is a definition and can appear anywhere other\ndefinitions can appear, including\nat the top level of a program, nested within the bodies of\nlambda expressions, nested within library and\ntop-level program forms, and nested within other modules.\nAlso, because module names are scoped like other identifiers,\nmodules and libraries may export module names as well as variables and keywords.\n" "\nWhen an interface contains an export of the form\n(identifier export ...), only identifier is\nvisible in the importing context.\nThe identifiers within export ... are\nindirect imports, as if declared via an\nindirect-export form (Section 10.4).\n" "\nModule names occupy the same namespace as other identifiers and follow\nthe same scoping rules.\nUnless exported, identifiers defined within a module are visible only\nwithin that module.\n" "\nExpressions within a module can reference identifiers bound outside of\nthe module.\n" "\n" "(let ([x 3])\n  (module m (plusx)\n    (define plusx (lambda (y) (+ x y))))\n  (import m)\n  (let ([x 4])\n    (plusx 5))) --> 8\n" "Similarly, import does not prevent access to identifiers that\nare visible where the import form appears, except for those variables\nshadowed by the imported identifiers.\n" "\n" "(module m (y) (define y 'm-y))\n(let ([x 'local-x] [y 'local-y])\n  (import m)\n  (list x y)) --> (local-x m-y)\n" "On the other hand, use of import-only within a module\nestablishes an isolated scope in\nwhich the only visible identifiers are those exported by the\nimported module.\n" "\n" "(module m (y) (define y 'm-y))\n(let ([x 'local-x] [y 'local-y])\n  (import-only m)\n  x) --> Error: x is not visible\n" "This is sometimes desirable for static verification that no\nidentifiers are used except those explicitly imported into a\nmodule or local scope.\n" "\nUnless a module imported via import-only exports\nimport or\nimport-only and the name of at least one module, subsequent\nimports within the scope of the import-only form are not\npossible.\nTo create an isolated scope containing the exports of more than one\nmodule without making import or import-only\nvisible, all of the modules to be imported must be listed in the\nsame import-only form.\n" "\nAnother solution is to create a single module that contains\nthe exports of each of the other modules.\n" "\n" "(module m2 (y) (define y 'y))\n(module m1 (x) (define x 'x))\n(module mega-module (cons x y)\n  (import m1)\n  (import m2)\n  (import scheme))\n(let ([y 3])\n  (import-only mega-module)\n  (cons x y)) --> (x . y)\n" "" "Before it is compiled, a source program is translated into\na core language program containing no syntactic abstractions, syntactic\ndefinitions, library definitions, module definitions, or import forms.\nTranslation is performed by a syntax expander that\nprocesses the forms in the source program via recursive descent.\n" "\nA define-syntax form associates a keyword\nwith a transformer in a translation-time environment.\nWhen the expander encounters a keyword, it invokes the\nassociated transformer and reprocesses the resulting form.\nA module form associates a module name with an interface.\nWhen the expander encounters an import form, it extracts the\ncorresponding module interface from the translation-time environment and makes\nthe exported bindings visible in the scope where the import form\nappears.\n" "\nInternal definitions and definitions within a module\nbody are processed from left to right so that a module's definition\nand import may appear within the same sequence of definitions.\nExpressions appearing within a body and the right-hand sides of variable\ndefinitions, however, are translated\nonly after the entire set of definitions has been processed, allowing\nfull mutual recursion among variable and syntactic definitions.\n" "\nModule and import forms affect only the visibility of identifiers in\nthe source program, not their meanings.\nIn particular, variables are bound to locations whether defined within or\noutside of a module, and import does not introduce new locations.\nLocal variables are renamed as necessary to preserve the scoping\nrelationships established by both modules and syntactic abstractions.\nThus, the expression:\n" "\n" "(let ([x 1])\n  (module m (x setter)\n    (define-syntax x (identifier-syntax z))\n    (define setter (lambda (x) (set! z x)))\n    (define z 5))\n  (let ([y x] [z 0])\n    (import m)\n    (setter 3)\n    (+ x y z))) --> 4\n" "is equivalent to the following program\nin which identifiers have been consistently renamed as indicated by\nsubscripts.\n" "\n" "(let ([x0 1])\n  (define-syntax x1 (identifier-syntax z1))\n  (define setter1 (lambda (x2) (set! z1 x2)))\n  (define z1 5)\n  (let ([y3 x0] [z3 0])\n    (setter1 3)\n    (+ x1 y3 z3)))\n" "Definitions within a top-level begin, lambda, top-level program,\nlibrary, or module body\nare processed from left to right by the expander at expand time, and the\nvariable definitions are evaluated from left-to-right at run time.\nInitialization expressions appearing within a module body\nare evaluated in sequence after the evaluation of the variable\ndefinitions.\n" "\nMutually recursive modules can be defined in several ways.\nIn the following program, a and b are mutually recursive\nmodules exported by an anonymous module whose local scope is used to\nstatically link the two.\nFor example,\nthe free variable y within module a refers to\nthe binding for y, provided by importing b,\nin the enclosing module.\n" "\n" "(module (a b)\n  (module a (x) (define x (lambda () y)))\n  (module b (y) (define y (lambda () x)))\n  (import a)\n  (import b))\n" "The following syntactic abstraction generalizes this pattern to\npermit the definition of multiple mutually recursive modules.\n" "\n" "(define-syntax rec-modules\n  (syntax-rules (module)\n    [(_ (module m (id ...) form ...) ...)\n     (module (m ...)\n       (module m (id ...) form ...) ...\n       (import m) ...)]))\n" "Because a module can re-export imported bindings,\nit is quite easy to provide multiple views on a single\nmodule, as s and t provide for r\nbelow, or to combine several modules into a compound,\nas r does.\n" "\n" "(module p (x y)\n  (define x 1) (define y 2))\n(module q (y z)\n  (define y 3) (define z 4))\n(module r (a b c d)\n  (import* p (a x) (b y))\n  (import* q (c y) (d z)))\n(module s (a c) (import r))\n(module t (b d) (import r))\n" "To allow interfaces to be separated from implementations,\nthe following syntactic abstractions support the definition and use of\nnamed interfaces.\n" "\n" "(define-syntax define-interface\n  (syntax-rules ()\n    [(_ name (export ...))\n     (define-syntax name\n       (lambda (x)\n         (syntax-case x ()\n           [(_ n defs)\n            (with-implicit (n export ...)\n              #'(module n (export ...) .\n                  defs))])))]))\n\n(define-syntax define-module\n  (syntax-rules ()\n    [(_ name interface defn ...)\n     (interface name (defn ...))]))\n" "define-interface creates an interface macro that, given a module\nname and a list of definitions, expands into a module definition with\na concrete interface.\n" "\nwith-implicit is used to ensure that the introduced\nexport identifiers are visible in the same scope as the name of\nthe module in the define-module form.\n" "\ndefine-interface and define-module can be used as\nfollows.\n" "\n" "(define-interface simple (a b))\n(define-module m simple\n  (define-syntax a (identifier-syntax 1))\n  (define b (lambda () c))\n  (define c 2))\n(let () (import m) (+ a (b))) --> 3\n" "The abstract module facility defined below allows a module interface to\nbe satisfied incrementally when module forms are evaluated.\nThis permits flexibility in the separation between the interface and\nimplementation, supports separate compilation of mutually recursive\nmodules, and permits redefinition of module implementations.\n" "\n" "(define-syntax abstract-module\n  (syntax-rules ()\n    [(_ name (ex ...) (kwd ...) defn ...)\n     (module name (ex ... kwd ...)\n       (declare ex) ...\n       defn ...)]))\n\n(define-syntax implement\n  (syntax-rules ()\n    [(_ name form ...)\n     (module () (import name) form ...)]))\n" "Within an abstract-module form,\neach of the exports in the list ex ... must be\nvariables.\nThe values of these variables are supplied by one or more separate\nimplement forms.\nSince keyword bindings must be present at compile time,\nthey cannot be satisfied incrementally and are instead listed as\nseparate exports and defined within the abstract module.\n" "\nWithin an implement form,\nthe sequence of forms form ... is a sequence of\nzero or more definitions followed by a sequence of zero or more\nexpressions.\nSince the module used in the expansion of implement does\nnot export anything, the definitions are all local to the\nimplement form.\nThe expressions may be arbitrary expressions, but should include\none satisfy form for each variable whose definition is\nsupplied by the implement form.\nA satisfy form has the syntax\n" "\n" "(satisfy variable expr)\n" "declare and satisfy may simply be the equivalents of\ndefine and set!.\n" "\n" "(define-syntax declare (identifier-syntax define))\n(define-syntax satisfy (identifier-syntax set!))\n" "Alternatively, declare can initialize the declared variable to\nthe value of a flag known only to declare and satisfy,\nand satisfy can verify that this flag is still present to insure\nthat only one attempt to satisfy the value of a given identifier is\nmade.\n" "\n" "(module ((declare cookie) (satisfy cookie))\n  (define cookie \"chocolate chip\")\n  (define-syntax declare\n    (syntax-rules () [(_ var) (define var cookie)]))\n  (define-syntax satisfy\n    (syntax-rules ()\n      [(_ var exp)\n       (if (eq? var cookie)\n           (set! var exp)\n           (assertion-violationf 'satisfy\n             \"value of variable ~s has already been satisfied\"\n             'var))])))\n" "Using abstract-module and implement, we can define\nmutually recursive and separately compilable modules as follows.\n" "\n" "(abstract-module e (even?) (pred)\n  (define-syntax pred\n    (syntax-rules () [(_ exp) (- exp 1)])))\n\n(abstract-module o (odd?) ())\n\n(implement e\n  (import o)\n  (satisfy even?\n    (lambda (x)\n      (or (zero? x) (odd? (pred x))))))\n\n(implement o\n  (import e)\n  (satisfy odd?\n    (lambda (x) (not (even? x)))))\n\n(let () (import-only e) (even? 38)) --> #t\n") ("syntax:s22" "\nsyntax: only\nsyntax: except\nsyntax: add-prefix\nsyntax: drop-prefix\nsyntax: rename\nsyntax: alias\nlibraries: (chezscheme)\n" "These identifiers are auxiliary keywords for import\nand import-only.\nIt is a syntax violation to reference these identifiers except in\ncontexts where they are recognized as auxiliary keywords.\n") ("syntax:s28" "\nmodule: scheme\nlibraries: (chezscheme)\n" "scheme contains all user-visible top-level bindings\n(variables, keywords, and module names) built into Chez Scheme.\n") ("syntax:s29" "\nmodule: r5rs\nlibraries: (chezscheme)\n" "r5rs contains all top-level bindings\n(variables and keywords) defined in the\nRevised5 Report on Scheme.\nThe bindings exported from r5rs are precisely those that are\navailable within an expression evaluated via eval with the\nenvironment specifier returned by\nscheme-report-environment.\n") ("syntax:s31" "\nmodule: r5rs-syntax\nlibraries: (chezscheme)\n" "r5rs-syntax contains all top-level keyword bindings\ndefined in the Revised5 Report on Scheme.\nThe bindings exported from r5rs-syntax are precisely those that are\navailable within an expression evaluated via eval with the\nenvironment specifier returned by\nnull-environment.\n") ("syntax:s33" "\nmodule: ieee\nlibraries: (chezscheme)\n" "ieee contains all top-level bindings\n(variables and keywords) defined in the\nANSI/IEEE standard for Scheme.\nThe bindings exported from ieee are precisely those that are\navailable within an expression evaluated via eval with the\nenvironment specifier returned by\nieee-environment.\n\n") ("syntax:s35" "\nmodule: $system\nlibraries: (chezscheme)\n" "$system contains all user-visible top-level bindings built\ninto Chez Scheme along with various undocumented system bindings.\n\n") ("syntax:s36" "\nsyntax: (meta . definition)\nreturns: unspecified\nlibraries: (chezscheme)\n" "The meta keyword is actually a prefix that can be placed in\nfront of any definition keyword, e.g.,\n" "\n" "(meta define x 3)\n" "It tells the expander that any variable definition resulting\nfrom the definition is to be an expand-time definition available only\nto the right-hand sides of other meta definitions and, most importantly,\ntransformer expressions.\nIt is used to define expand-time helpers and other information for use\nby one or more syntax-case transformers.\n\n" "\n" "(module M (helper1 a b)\n  (meta define helper1\n    (lambda (---)\n      ---))\n  (meta define helper2\n    (lambda (---)\n      --- (helper2 ---) ---))\n  (define-syntax a\n    (lambda (x)\n      --- (helper1 ---) ---))\n  (define-syntax b\n    (lambda (x)\n      --- (helper1 ---) ---\n      --- (helper2 ---) ---)))\n" "The right-hand-side expressions of a syntax definition or meta definition\ncan refer only to identifiers whose values are already available in the\ncompile-time environment.\nBecause of the left-to-right expansion order for library,\nmodule, lambda, and similar bodies, this implies a\nsemantics similar to let* for a sequence of meta definitions,\nin which each right-hand side can refer only to the variables defined\nearlier in the sequence.\nAn exception is that the right-hand side of a meta definition can refer\nto its own name as long as the reference is not evaluated until after\nthe value of the expression has been computed.\nThis permits meta definitions to be self-recursive but not mutually\nrecursive.\nThe right-hand side of a meta definition can, however, build syntax\nobjects containing occurrences of any identifiers defined in the body\nin which the meta definition appears.\n" "\nMeta definitions propagate through macro expansion, so one can write,\nfor example:\n" "\n" "(module (a)\n  (meta define-record foo (x))\n  (define-syntax a\n    (let ([q (make-foo #''q)])\n      (lambda (x) (foo-x q)))))\na --> q\n" "where define-record is a macro that expands into a set of defines.\n" "\nIt is also sometimes convenient to write\n" "\n" "(meta begin defn ...)\n" "or\n" "\n" "(meta module {exports} defn ...)\n" "or\n" "\n" "(meta include \"path\")\n" "to create groups of meta bindings.\n") ("syntax:s37" "\nsyntax: (meta-cond clause1 clause2 ...)\nreturns: see below\nlibraries: (chezscheme)\n" "Each clause but the last must take the form:\n" "\n" "(test expr1 expr2 ...)\n" "The last may take the same form or be an else clause of the form:\n" "\n" "(else expr1 expr2 ...)\n" "During expansion, the test expressions are evaluated in order until\none evaluates to a true value or until all of the tests have been\nevaluated.\nIf a test evaluates to a true value, the meta-cond form\nexpands to a begin form containing the corresponding\nexpressions expr1 expr2 ....\nIf no test evaluates to a true value and an else clause\nis present, the meta-cond form expands to a begin form\ncontaining the expressions expr1 expr2 ... from\nthe else clause.\nOtherwise the meta-cond expression expands into a call to\nthe void procedure.\n" "\nmeta-cond might be defined as follows.\n" "\n" "(define-syntax meta-cond\n  (syntax-rules ()\n    [(_ [a0 a1 a2 ...] [b0 b1 b2 ...] ...)\n     (let-syntax ([expr (cond\n                          [a0 (identifier-syntax (begin a1 a2 ...))]\n                          [b0 (identifier-syntax (begin b1 b2 ...))]\n                          ...)])\n       expr)]))\n" "meta-cond is used to choose, at expansion time, from among a\nset of possible forms.\nFor example, one might have safe (error-checking) and unsafe\n(non-error-checking) versions of a procedure and decide which to\ncall based on the compile-time optimization level, as shown\nbelow.\n" "\n" "(meta-cond\n  [(= (optimize-level) 3) (unsafe-frob x)]\n  [else (safe-frob x)])\n") ("syntax:s38" "\nsyntax: (alias id1 id2)\nreturns: unspecified\nlibraries: (chezscheme)\n" "alias is a definition and can appear anywhere\nother definitions can appear.\nIt is used to transfer the binding from one identifier to\nanother.\n" "\n" "(let ([x 3]) (alias y x) (set! y 4) (list x y)) --> (4 4)\n\n(module lisp (if)\n  (module (scheme:if)\n    (import scheme)\n    (alias scheme:if if))\n  (define-syntax if\n    (syntax-rules ()\n      [(_ e_1 e_2 e_3)\n       (scheme:if (not (memq e_1 '(#f ()))) e_2 e_3)])))\n(define (length ls)\n  (import lisp)\n  (if ls (+ (length (cdr ls)) 1) 0))\n(length '(a b c)) --> 3\n" "Because of left-to-right expansion order, aliases should appear after\nthe definition of the right-hand-side identifier, e.g.:\n" "\n" "(let ()\n  (import-only (chezscheme))\n  (define y 3)\n  (alias x y)\n  x) --> 3\n" "rather than:\n" "\n" "(let ()\n  (import-only (chezscheme))\n  (alias x y)\n  (define y 3)\n  x) --> exception: unbound identifier\n") ("syntax:s49" "\nprocedure: (make-annotation obj source-object stripped-obj)\nprocedure: (make-annotation obj source-object stripped-obj options)\nreturns: an annotation\nlibraries: (chezscheme)\n" "The annotation is formed with obj as its expression component,\nsource-object as its source-object component, and stripped-obj\nas its stripped component.\nobj should represent an expression, possibly with embedded\nannotations.\nstripped-obj should be a stripped version of obj, i.e.,\nequivalent to obj with each annotation replaced by its\nexpression component.\noptions, if present must be an enumeration set over\nthe symbols debug and profile, and defaults to an\nenumeration set containing both debug and profile.\nAnnotations marked debug are used for compile-time error\nreporting and run-time error reporting and inspection; annotations\nmarked profile are used for profiling.\n") ("syntax:s50" "\nprocedure: (annotation? obj)\nreturns: #t if obj is an annotation, otherwise #f\nlibraries: (chezscheme)\n") ("syntax:s51" "\nprocedure: (annotation-expression annotation)\nreturns: the expression component of annotation\nlibraries: (chezscheme)\n") ("syntax:s52" "\nprocedure: (annotation-source annotation)\nreturns: the source-object component of annotation\nlibraries: (chezscheme)\n") ("syntax:s53" "\nprocedure: (annotation-stripped annotation)\nreturns: the stripped component of annotation\nlibraries: (chezscheme)\n") ("syntax:s54" "\nprocedure: (annotation-options annotation)\nreturns: the options enumeration set of annotation\nlibraries: (chezscheme)\n") ("syntax:s55" "\nprocedure: (make-source-object sfd bfp efp)\nprocedure: (make-source-object sfd bfp efp line column)\nreturns: a source object\nlibraries: (chezscheme)\n" "sfd must be a source-file descriptor.\nbfp and efp must be exact nonnegative integers, and bfp\nshould not be greater than efp.\nline and column must be exact positive integers.\n") ("syntax:s56" "\nprocedure: (source-object? obj)\nreturns: #t if obj is a source object, otherwise #f\nlibraries: (chezscheme)\n") ("syntax:s57" "\nprocedure: (source-object-sfd source-object)\nreturns: the sfd component of source-object\nlibraries: (chezscheme)\n") ("syntax:s58" "\nprocedure: (source-object-bfp source-object)\nreturns: the bfp component of source-object\nlibraries: (chezscheme)\n") ("syntax:s59" "\nprocedure: (source-object-efp source-object)\nreturns: the efp component of source-object\nlibraries: (chezscheme)\n") ("syntax:s60" "\nprocedure: (source-object-line source-object)\nreturns: the line component of source-object if present, otherwise #f\nlibraries: (chezscheme)\n") ("syntax:s61" "\nprocedure: (source-object-column source-object)\nreturns: the column component of source-object if present, otherwise #f\nlibraries: (chezscheme)\n") ("syntax:s62" "\nthread parameter: current-make-source-object\nlibraries: (chezscheme)\n" "current-make-source-object is used by the reader to construct\na source object for an annotation. current-make-source-object\nis initially bound to make-source-object, and the reader always\ncalls the function bound to the paramater with three arguments.\n" "\nAdjust this parameter to, for example, eagerly convert a position integer\nto a file-position object, instead of delaying the conversion to\nlocate-source.\n") ("syntax:s63" "\nprocedure: (make-source-file-descriptor string binary-input-port)\nprocedure: (make-source-file-descriptor string binary-input-port reset?)\nreturns: a source-file descriptor\nlibraries: (chezscheme)\n" "To compute the checksum encapsulated in the source-file descriptor,\nthis procedure must read all of the data from\nbinary-input-port.\nIf reset? is present and #t, the port is reset to its\noriginal position, as if via port-position.\nOtherwise, it is left pointing at end-of-file.\n") ("syntax:s64" "\nprocedure: (source-file-descriptor? obj)\nreturns: #t if obj is a source-file descriptor, otherwise #f\nlibraries: (chezscheme)\n") ("syntax:s65" "\nprocedure: (source-file-descriptor-checksum sfd)\nreturns: the checksum component of sfd\nlibraries: (chezscheme)\n") ("syntax:s66" "\nprocedure: (source-file-descriptor-path sfd)\nreturns: the path component of sfd\nlibraries: (chezscheme)\n" "sfd must be a source-file descriptor.\n") ("syntax:s67" "\nprocedure: (source-file-descriptor path checksum)\nreturns: a new source-file-descriptor\nlibraries: (chezscheme)\n" "path must be a string, and checksum must be an exact nonnegative integer.\nThis procedure can be used to construct custom source-file descriptors or to reconstitute\nsource-file descriptors from the path and checksum components.\n") ("syntax:s68" "\nsyntax: (annotation-option-set symbol ...)\nreturns: an annotation-options enumeration set\nlibraries: (chezscheme)\n" "Annotation-options enumeration sets may be passed to make-annotation to\ncontrol whether the annotation is used for debugging, profiling, both, or neither.\nAccordingly, each symbol must be either debug or profile.\n") ("syntax:s69" "\nprocedure: (syntax->annotation obj)\nreturns: an annotation or #f\nlibraries: (chezscheme)\n" "If obj is an annotation or syntax-object encapsulating an annotation,\nthe annotation is returned.\n") ("syntax:s70" "\nprocedure: (get-datum/annotations textual-input-port sfd bfp)\nreturns: see below\nlibraries: (chezscheme)\n" "sfd must be a source-file descriptor.\nbfp must be an exact nonnegative integer and should be the\ncharacter position of the next character to be read from\ntextual-input-port.\n" "\nThis procedure returns two values: an annotated object and an ending\nfile position.\nIn most cases, bfp should be 0 for the first call\nto get-datum/annotation at the start of a file,\nand it should be the second return value of the preceding\ncall to get-datum/annotation for each subsequent\ncall.\nThis protocol is necessary to handle files containing multiple-byte\ncharacters, since file positions do not necessarily correspond\nto character positions.\n") ("syntax:s71" "\nprocedure: (open-source-file sfd)\nreturns: a port or #f\nlibraries: (chezscheme)\n" "sfd must be a source-file descriptor.\nThis procedure attempts to locate and open the source file identified\nby sfd.\nIt returns a textual input port, positioned at the beginning of the file,\nif successful, and #f otherwise.\nIt can fail even if a file with the correct name exists in one of\nthe source directories when the file's checksum does not match the\nchecksum recorded in sfd.\n") ("syntax:s72" "\nprocedure: (locate-source sfd pos)\nprocedure: (locate-source sfd pos use-cache?)\nreturns: see below\nlibraries: (chezscheme)\n" "sfd must be a source-file descriptor, and pos must be an\nexact nonnegative integer.\n" "\nThis procedure either uses cached information from a previous\nrequest for sfd (only when use-cache? is provided as true)\nor attempts to locate and open the source file identified\nby sfd.\nIf successful, it returns three values: a string path, an exact\nnonnegative integer line, and an exact nonnegative integer char\nrepresenting the absolute pathname, line, and character position within\nthe line represented by the specified source-file descriptor and file\nposition.\nIf unsuccessful, it returns zero values.\nIt can fail even if a file with the correct name exists in one of\nthe source directories when the file's checksum does not match the\nchecksum recorded in sfd.\n") ("syntax:s73" "\nprocedure: (locate-source-object-source source-object get-start? use-cache?)\nreturns: see below\nlibraries: (chezscheme)\n" "This procedure is similar to locate-source, but instead of\ntaking an sfd and a position, it takes a source object plus a request\nfor either the start or end location.\n" "\nIf get-start? is true and source-object has a line and column,\nthis procedure returns the path in\nsource-objects's sfd, source-object's line, and\nsource-objects's column.\n" "\nIf source-object has no line and column, then\nthis procedure calls locate-source on\nsource-object's sfd, either source-object's bfp or efp\ndepending on get-start?, and use-cache?.\n") ("syntax:s74" "\nthread parameter: current-locate-source-object-source\nlibraries: (chezscheme)\n" "current-locate-source-object-source determines the\nsource-location lookup function that is used by the system to report\nerrors based on source objects. This parameter is initially bound to\nlocate-source-object-object.\n" "\nAdjust this parameter to control the way that source locations are\nextracted from source objects, possibly using recorded information,\ncaches, and the filesystem in a way different from\nlocate-source-object-object.\n\n") ("syntax:s81" "\nprocedure: (make-source-table)\nreturns: a source table\nlibraries: (chezscheme)\n" "A source table contains associations between source objects and arbitrary\nvalues.  For purposes of the source-table operations described below, two\nsource objects are the same if they have the same source-file descriptor,\nequal beginning file positions and equal ending file positions.\nTwo source-file descriptors are the same if they have the same path and\nchecksum.\n") ("syntax:s82" "\nprocedure: (source-table? obj)\nreturns: #t if obj is a source-table; #f otherwise\nlibraries: (chezscheme)\n") ("syntax:s83" "\nprocedure: (source-table-set! source-table source-object obj)\nreturns: unspecified\nlibraries: (chezscheme)\n" "source-table-set! associates source-object\nwith obj in source-table, replacing the\nexisting association, if any.\n\n") ("syntax:s84" "\nprocedure: (source-table-ref source-table source-object default)\nreturns: see below\nlibraries: (chezscheme)\n" "default may be any Scheme value.\n" "\nsource-table-ref returns the value\nassociated with source-object in source-table.\nIf no value is associated with source-object in source-table,\nsource-table-ref returns default.\n\n") ("syntax:s85" "\nprocedure: (source-table-contains? source-table source-object)\nreturns: #t if an association for source-object exists in source-table, #f otherwise\nlibraries: (chezscheme)\n") ("syntax:s86" "\nprocedure: (source-table-cell source-table source-object default)\nreturns: a pair (see below)\nlibraries: (chezscheme)\n" "default may be any Scheme value.\n" "\nIf no value is associated with source-object in source-table,\nsource-table-cell modifies source-table to associate source-object with\ndefault.\nRegardless, it returns a pair whose car is source-object and whose cdr is\nthe associated value.\nChanging the cdr of this pair effectively updates the table to\nassociate source-object with a new value.\nThe car field of the pair should not be modified.\n\n") ("syntax:s87" "\nprocedure: (source-table-delete! source-table source-object)\nreturns: unspecified\nlibraries: (chezscheme)\n" "source-table-delete! drops the association\nfor source-object from source-table, if\none exists.\n\n") ("syntax:s88" "\nprocedure: (source-table-size source-table)\nreturns: the number of entries in source-table\nlibraries: (chezscheme)\n") ("syntax:s89" "\nprocedure: (put-source-table textual-output-port source-table)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure writes a representation of the information stored in source-table to the port.\n\n") ("syntax:s90" "\nprocedure: (get-source-table! textual-input-port source-table)\nprocedure: (get-source-table! textual-input-port source-table combine)\nreturns: unspecified\nlibraries: (chezscheme)\n" "The port must be positioned at a representation of source-table\ninformation written by some previous call to put-source-table,\nwhich reads the information and merges it into source-table.\n" "\nIf present and non-false, combine must be a procedure and\nshould accept two arguments.\nIt is called whenever associations for the same source object are\npresent both in source-table and in the information read from\nthe port.\nIn this case, combine is passed two arguments: the associated\nvalue from source-table and the associated value from the\nport (in that order) and must return one value, which is recorded\nas the new associated value for the source object in source-table.\n" "\nIf combine is not present, combine is #f, or\nno association for a source object read from the port already exists\nin source-table, the value read from the port is recorded as\nthe associated value of the source object in source-table.\n" "\n" "(define st (make-source-table))\n(call-with-port (open-input-file \"profile.out1\")\n  (lambda (ip) (get-source-table! ip st)))\n(call-with-port (open-input-file \"profile.out2\")\n  (lambda (ip) (get-source-table! ip st +)))\n") ("smgmt:s9" "\nprocedure: (collect)\nprocedure: (collect cg)\nprocedure: (collect cg max-tg)\nprocedure: (collect cg min-tg max-tg)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure causes the storage manager to perform a garbage\ncollection.\ncollect is invoked periodically without arguments by the\ndefault collect-request handler, but it may also be called explicitly,\ne.g., from a custom collect-request handler, between phases of a\ncomputation when collection is most likely to be successful, or\nbefore timing a computation.\nIn the threaded versions of Chez Scheme, the thread that invokes\ncollect must be the only active thread.\n" "\nWhen called without arguments, the system determines automatically\nwhich generations to collect and the target generation for each\ncollected generation as described in the lead-in to this section.\n" "\nWhen called with arguments, the system collects all and only objects\nin generations less than or equal to cg (the maximum collected\ngeneration) into the target generation or generations determined\nby min-tg (the minimum target generation) and max-tg\n(the maximum target generation).\nSpecifically, the target generation for any object in a collected\ngeneration g is\nmath/csug/5.gif, where\nstatic is taken to have the value one greater\nthan the maximum nonstatic generation.\n" "\nIf present, cg must be a nonnegative fixnum no greater than\nthe maximum nonstatic generation, i.e., the current value of the\nparameter collect-maximum-generation.\n" "\nIf present, max-tg must be a nonnegative fixnum or the symbol\nstatic and either equal to cg or one greater than\ncg, again treating static as having the value one\ngreater than the maximum nonstatic generation.\nIf max-tg is not present (but cg is), it defaults to\ncg if cg is equal to the maximum target generation and\nto one more than cg otherwise.\n" "\nIf present, min-tg must be a nonnegative fixnum or the symbol\nstatic and no greater than max-tg, again treating\nstatic as having the value one greater than the maximum\nnonstatic generation.\nUnless max-cg is the same as cg, min-tg must also\nbe greater than cg.\nIf min-tg is not present (but cg is), it defaults to\nthe same value as max-tg.\n") ("smgmt:s10" "\nprocedure: (collect-rendezvous)\nreturns: unspecified\nlibraries: (chezscheme)\n" "Requests a garbage collection in the same way as when the system\ndetermines that a collection should occur. All running threads are\ncoordinated so that one of them calls the collect-request handler, while\nthe other threads pause until the handler returns.\n" "\nNote that if the collect-request handler (see\ncollect-request-handler) does not call collect, then\ncollect-rendezvous does not actually perform a garbage\ncollection.\n\n") ("smgmt:s11" "\nglobal parameter: collect-notify\nlibraries: (chezscheme)\n" "If collect-notify is set to a true value, the collector prints\na message whenever a collection is run.\ncollect-notify is set to #f by default.\n\n") ("smgmt:s12" "\nglobal parameter: collect-trip-bytes\nlibraries: (chezscheme)\n" "This parameter determines the approximate amount of storage that is\nallowed to be allocated between garbage collections.\nIts value must be a positive fixnum.\n" "\nChez Scheme allocates memory internally in large chunks and\nsubdivides these chunks via inline operations for efficiency.\nThe storage manager determines whether to request a collection only\nonce per large chunk allocated.\nFurthermore, some time may elapse between when a collection is\nrequested by the storage manager and when the collect request is\nhonored, especially if interrupts are temporarily disabled via\nwith-interrupts-disabled\nor disable-interrupts.\nThus, collect-trip-bytes is an approximate measure only.\n\n") ("smgmt:s15" "\nglobal parameter: collect-generation-radix\nlibraries: (chezscheme)\n" "This parameter determines how often each generation is collected\nwhen collect is invoked without arguments, as by the default\ncollect-request handler.\nIts value must be a positive fixnum.\nGenerations are collected once every rg times a collection occurs,\nwhere r is the\nvalue of collect-generation-radix and g is the generation\nnumber.\n" "\nSetting collect-generation-radix to one forces all generations\nto be collected each time a collection occurs.\nSetting collect-generation-radix to a very large number\neffectively delays collection of older generations indefinitely.\n\n") ("smgmt:s16" "\nglobal parameter: collect-maximum-generation\nlibraries: (chezscheme)\n" "This parameter determines the maximum nonstatic generation, hence the\ntotal number of generations, currently in use.\nIts value is an exact integer in the range 1 through 254.\nWhen set to 1, only two nonstatic generations are used; when set to 2,\nthree nonstatic generations are used, and so on.\nWhen set to 254, 255 nonstatic generations are used, plus the single\nstatic generation for a total of 256 generations.\nIncreasing the number of generations effectively decreases how often old\nobjects are collected, potentially decreasing collection overhead but\npotentially increasing the number of inaccessible objects retained in the\nsystem and thus the total amount of memory required.\n\n") ("smgmt:s17" "\nglobal parameter: collect-request-handler\nlibraries: (chezscheme)\n" "The value of collect-request-handler must be a procedure.\nThe procedure is invoked without arguments whenever the\nsystem determines that a collection should occur, i.e., some time after\nan amount of storage determined by the parameter\ncollect-trip-bytes has been allocated since the last\ncollection.\n" "\nBy default, collect-request-handler simply invokes\ncollect without arguments.\n" "\nAutomatic collection may be disabled by setting\ncollect-request-handler to a procedure that does nothing,\ne.g.:\n" "\n" "(collect-request-handler void)\n" "Collection can also be temporarily disabled using\ncritical-section, which prevents any interrupts from\nbeing handled.\n" "\nIn the threaded versions of Chez Scheme, the collect-request\nhandler is invoked by a single thread with all other threads\ntemporarily suspended.\n\n") ("smgmt:s18" "\nglobal parameter: release-minimum-generation\nlibraries: (chezscheme)\n" "This parameter's value must be between 0 and the value of\ncollect-maximum-generation, inclusive, and defaults to the\nvalue of collect-maximum-generation.\n" "\nAs new data is allocated and collections occur, the storage-management\nsystem automatically requests additional virtual memory address space\nfrom the operating system.\nCorrespondingly, in the event the heap shrinks significantly, the system\nattempts to return some of the virtual-memory previously obtained from\nthe operating system back to the operating system.\nBy default, the system attempts to do so only after a collection that\ntargets the maximum nonstatic generation.\nThe system can be asked to do so after collections\ntargeting younger generations as well by altering the value\nrelease-minimum-generation to something less than the value\nof collect-maximum-generation.\nWhen the generation to which the parameter is set, or any older\ngeneration, is the target generation of a collection, the storage\nmanagement system attempts to return unneeded virtual memory to the\noperating system following the collection.\n" "\nWhen collect-maximum-generation is set to a new value g,\nrelease-minimum-generation is implicitly set to g as well\nif (a) the two parameters have the same value before the change, or (b)\nrelease-minimum-generation has a value greater than g.\n") ("smgmt:s19" "\nglobal parameter: heap-reserve-ratio\nlibraries: (chezscheme)\n" "This parameter determines the approximate amount of memory reserved (not\nreturned to the O/S as described in the entry for release-minimum-generation)\nin proportion to the amount currently occupied, excluding areas\nof memory that have been made static.\nIts value must be an inexact nonnegative flonum value; if set to an exact\nreal value, the exact value is converted to an inexact value.\nThe default value, 1.0, reserves one page of memory for each currently\noccupied nonstatic page.\nSetting it to a smaller value may result in a smaller average virtual\nmemory footprint, while setting it to a larger value may result in fewer\ncalls into the operating system to request and free memory space.\n\n") ("smgmt:s24" "\ndesc:weak-cons\nprocedure: (weak-cons obj1 obj2)\nreturns: a new weak pair\nlibraries: (chezscheme)\n" "obj1 becomes the car and obj2 becomes the cdr of the\nnew pair.\nWeak pairs are indistinguishable from ordinary pairs in all but two ways:\n" "\nweak pairs can be distinguished from pairs using the\nweak-pair? predicate, and\n\nweak pairs maintain a weak pointer to the object in the\ncar of the pair.\n" "\n" "\nThe weak pointer in the car of a weak pair is just like a normal\npointer as long as the object to which it points is accessible through\na normal (nonweak) pointer somewhere in the system.\nIf at some point the garbage collector recognizes that there are no\nnonweak pointers to the object, however, it replaces each weak pointer\nto the object with the \"broken weak-pointer\" object, #!bwp,\nand discards the object.\n" "\nThe cdr field of a weak pair is not a weak pointer, so\nweak pairs may be used to form lists of weakly held objects.\nThese lists may be manipulated using ordinary list-processing\noperations such as length, map, and assv.\n(Procedures like map that produce list structure always\nproduce lists formed from nonweak pairs, however, even when their input\nlists are formed from weak pairs.)\nWeak pairs may be altered using set-car! and set-cdr!; after\na set-car! the car field contains a weak pointer to the new\nobject in place of the old object.\nWeak pairs are especially useful for building association pairs\nin association lists or hash tables.\n" "\nWeak pairs are printed in the same manner as ordinary pairs; there\nis no reader syntax for weak pairs.\nAs a result, weak pairs become normal pairs when they are written\nand then read.\n" "\n" "(define x (cons 'a 'b))\n(define p (weak-cons x '()))\n(car p) --> (a . b)\n\n(define x (cons 'a 'b))\n(define p (weak-cons x '()))\n(set! x '*)\n(collect)\n(car p) --> #!bwp\n" "The latter example above may in fact return (a . b) if a\ngarbage collection promoting the pair into an older generation occurs\nprior to the assignment of x to *.\nIt may be necessary to force an older generation collection to allow\nthe object to be reclaimed.\nThe storage management system guarantees only that the object\nwill be reclaimed eventually once all nonweak pointers to it are\ndropped, but makes no guarantees about when this will occur.\n\n") ("smgmt:s25" "\nprocedure: (weak-pair? obj)\nreturns: #t if obj is a weak pair, #f otherwise\nlibraries: (chezscheme)\n" "\n" "(weak-pair? (weak-cons 'a 'b)) --> #t\n(weak-pair? (cons 'a 'b)) --> #f\n(weak-pair? \"oops\") --> #f\n") ("smgmt:s26" "desc:ephemeron-cons\nprocedure: (ephemeron-cons obj1 obj2)\nreturns: a new ephemeron pair\nlibraries: (chezscheme)\n" "obj1 becomes the car and obj2 becomes the cdr of the\nnew pair.\nEphemeron pairs are indistinguishable from ordinary pairs in all but two ways:\n" "\nephemeron pairs can be distinguished from pairs using the\nephemeron-pair? predicate, and\n\nephemeron pairs maintain a weak pointer to the object in the\ncar of the pair, and the cdr of the pair is preserved only as long\nas the car of the pair is preserved.\n" "\n" "\nAn ephemeron pair behaves like a weak pair, but the cdr is treated\nspecially in addition to the car: the cdr of an ephemeron is set to\n#!bwp at the same time that the car is set to #!bwp.\nSince the car and cdr fields are set to #!bwp at the same\ntime, then the fact that the car object may be referenced through the\ncdr object does not by itself imply that car must be preserved (unlike\na weak pair); instead, the car must be saved for some reason\nindependent of the cdr object.\n" "\nLike weak pairs and other pairs, ephemeron pairs may be altered using\nset-car! and set-cdr!, and ephemeron pairs are\nprinted in the same manner as ordinary pairs; there is no reader\nsyntax for ephemeron pairs.\n" "\n" "(define x (cons 'a 'b))\n(define p (ephemeron-cons x x))\n(car p) --> (a . b)\n(cdr p) --> (a . b)\n\n(define x (cons 'a 'b))\n(define p (ephemeron-cons x x))\n(set! x '*)\n(collect)\n(car p) --> #!bwp\n(cdr p) --> #!bwp\n\n(define x (cons 'a 'b))\n(define p (weak-cons x x)) ; not an ephemeron pair\n(set! x '*)\n(collect)\n(car p) --> (a . b)\n(cdr p) --> (a . b)\n" "As with weak pairs, the last two expressions of the middle example\nabove may in fact return (a . b) if a garbage collection\npromoting the pair into an older generation occurs prior to the\nassignment of x to *. In the last example above,\nhowever, the results of the last two expressions will always be\n(a . b), because the cdr of a weak pair holds a non-weak\nreference, and that non-weak reference prevents the car field from becoming\n#!bwp.\n") ("smgmt:s27" "\nprocedure: (ephemeron-pair? obj)\nreturns: #t if obj is a ephemeron pair, #f otherwise\nlibraries: (chezscheme)\n" "\n" "(ephemeron-pair? (ephemeron-cons 'a 'b)) --> #t\n(ephemeron-pair? (cons 'a 'b)) --> #f\n(ephemeron-pair? (weak-cons 'a 'b)) --> #f\n(ephemeron-pair? \"oops\") --> #f\n") ("smgmt:s28" "\nprocedure: (bwp-object? obj)\nreturns: #t if obj is the broken weak-pair object, #f otherwise\nlibraries: (chezscheme)\n" "\n" "(bwp-object? #!bwp) --> #t\n(bwp-object? 'bwp) --> #f\n\n(define x (cons 'a 'b))\n(define p (weak-cons x '()))\n(set! x '*)\n(collect (collect-maximum-generation))\n(car p) --> #!bwp\n(bwp-object? (car p)) --> #t\n") ("smgmt:s29" "\nprocedure: (make-guardian)\nreturns: a new guardian\nlibraries: (chezscheme)\n" "Guardians are represented by procedures that encapsulate groups of\nobjects registered for preservation.\nWhen a guardian is created, the group of registered objects is empty.\nAn object is registered with a guardian by passing the object as an\nargument to the guardian:\n" "\n" "(define G (make-guardian))\n(define x (cons 'aaa 'bbb))\nx --> (aaa . bbb)\n(G x)\n" "It is also possible to specify a \"representative\" object when\nregistering an object.\nContinuing the above example:\n" "\n" "(define y (cons 'ccc 'ddd))\ny --> (ccc . ddd)\n(G y 'rep)\n" "The group of registered objects associated with a guardian is logically\nsubdivided into two disjoint subgroups: a subgroup referred to\nas \"accessible\" objects, and one referred to \"inaccessible\" objects.\nInaccessible objects are objects that have been proven to be\ninaccessible (except through the guardian mechanism itself or through\nthe car field of a weak or ephemeron pair), and\naccessible objects are objects that have not been proven so.\nThe word \"proven\" is important here: it may be that some objects in\nthe accessible group are indeed inaccessible but\nthat this has not yet been proven.\nThis proof may not be made in some cases until long after the object\nactually becomes inaccessible (in the current implementation, until a\ngarbage collection of the generation containing the object occurs).\n" "\nObjects registered with a guardian are initially placed in the accessible\ngroup and are moved into the inaccessible group at some point after they\nbecome inaccessible.\nObjects in the inaccessible group are retrieved by invoking the guardian\nwithout arguments.\nIf there are no objects in the inaccessible group, the guardian returns\n#f.\nContinuing the above example:\n" "\n" "(G) --> #f\n(set! x #f)\n(set! y #f)\n(collect)\n(G) --> (aaa . bbb)   ; this might come out second\n(G) --> rep           ; and this first\n(G) --> #f\n" "The initial call to G returns #f, since the pairs bound\nto x and y are the\nonly object registered with G, and the pairs are still accessible\nthrough those bindings.\nWhen collect is called, the objects shift into the inaccessible group.\nThe two calls to G therefore return the pair previously bound to\nx and the representative of the pair previously bound to y,\nthough perhaps in the other order from the one shown.\n(As noted above for weak pairs, the call to collect may not actually be\nsufficient to prove the object inaccessible, if the object has\nmigrated into an older generation.)\n" "\nAlthough an object registered without a representative and returned from\na guardian has been proven otherwise\ninaccessible (except possibly via the car field of a weak or ephemeron pair), it has\nnot yet been reclaimed by the storage management system and will not be\nreclaimed until after the last nonweak pointer to it within or outside\nof the guardian system has been dropped.\nIn fact, objects that have been retrieved from a guardian have no\nspecial status in this or in any other regard.\nThis feature circumvents the problems that might otherwise arise with\nshared or cyclic structure.\nA shared or cyclic structure consisting of inaccessible objects is\npreserved in its entirety, and each piece registered for preservation\nwith any guardian is placed in the inaccessible set for that guardian.\nThe programmer then has complete control over the order in which pieces\nof the structure are processed.\n" "\nAn object may be registered with a guardian more than once, in which\ncase it will be retrievable more than once:\n" "\n" "(define G (make-guardian))\n(define x (cons 'aaa 'bbb))\n(G x)\n(G x)\n(set! x #f)\n(collect)\n(G) --> (aaa . bbb)\n(G) --> (aaa . bbb)\n" "It may also be registered with more than one guardian, and guardians\nthemselves can be registered with other guardians.\n" "\nAn object that has been registered with a guardian without a\nrepresentative and placed in\nthe car field of a weak or ephemeron pair remains in the car field of the\nweak or ephemeron pair until after it has been returned from the guardian and\ndropped by the program or until the guardian itself is dropped.\n" "\n" "(define G (make-guardian))\n(define x (cons 'aaa 'bbb))\n(define p (weak-cons x '()))\n(G x)\n(set! x #f)\n(collect)\n(set! y (G))\ny --> (aaa . bbb)\n(car p) --> (aaa . bbb)\n(set! y #f)\n(collect 1)\n(car p) --> #!bwp\n" "(The first collector call above would\npromote the object at least into generation 1, requiring the second\ncollector call to be a generation 1 collection.\nThis can also be forced by invoking collect several times.)\n" "\nOn the other hand, if a representative (other than the object itself)\nis specified, the guarded object is dropped from the car field of the\nweak or ephemeron pair at the same time as the representative becomes available\nfrom the guardian.\n" "\n" "(define G (make-guardian))\n(define x (cons 'aaa 'bbb))\n(define p (weak-cons x '()))\n(G x 'rep)\n(set! x #f)\n(collect)\n(G) --> rep\n(car p) --> #!bwp\n" "The following example illustrates that the object is deallocated and\nthe car field of the weak pair set to #!bwp when the guardian\nitself is dropped:\n" "\n" "(define G (make-guardian))\n(define x (cons 'aaa 'bbb))\n(define p (weak-cons x '()))\n(G x)\n(set! x #f)\n(set! G #f)\n(collect)\n(car p) --> #!bwp\n" "The example below demonstrates how guardians might be used to\ndeallocate external storage, such as storage managed by the C library\n\"malloc\" and \"free\" operations.\n" "\n" "(define malloc\n  (let ([malloc-guardian (make-guardian)])\n    (lambda (size)\n      ; first free any storage that has been dropped.  to avoid long\n      ; delays, it might be better to deallocate no more than, say,\n      ; ten objects for each one allocated\n      (let f ()\n        (let ([x (malloc-guardian)])\n          (when x\n            (do-free x)\n            (f))))\n      ; then allocate and register the new storage\n      (let ([x (do-malloc size)])\n        (malloc-guardian x)\n        x))))\n" "do-malloc must return a Scheme object \"header\" encapsulating a pointer to the\nexternal storage (perhaps as an unsigned integer), and all access to the\nexternal storage must be made through this header.\nIn particular, care must be taken that no pointers to the external storage\nexist outside of Scheme after the corresponding header has been\ndropped.\ndo-free must deallocate the external storage using the encapsulated\npointer.\nBoth primitives can be defined in terms of foreign-alloc\nand foreign-free or the C-library \"malloc\" and \"free\"\noperators, imported as foreign procedures.  (See\nChapter 4.)\n" "\nIf it is undesirable to wait until malloc is called to free dropped\nstorage previously allocated by malloc, a collect-request handler\ncan be used instead to check for and free dropped storage, as shown below.\n" "\n" "(define malloc)\n(let ([malloc-guardian (make-guardian)])\n  (set! malloc\n    (lambda (size)\n      ; allocate and register the new storage\n      (let ([x (do-malloc size)])\n        (malloc-guardian x)\n        x)))\n  (collect-request-handler\n    (lambda ()\n      ; first, invoke the collector\n      (collect)\n      ; then free any storage that has been dropped\n      (let f ()\n        (let ([x (malloc-guardian)])\n          (when x\n            (do-free x)\n            (f)))))))\n" "With a bit of refactoring, it would be possible to register\nthe encapsulated foreign address as a representative with\neach header, in which do-free would take just the\nforeign address as an argument.\nThis would allow the header to be dropped from the Scheme\nheap as soon as it becomes inaccessible.\n" "\nGuardians can also be created via\nftype-guardian, which\nsupports reference counting of foreign objects.\n") ("smgmt:s31" "\nprocedure: (guardian? obj)\nreturns: #t if obj is a guardian, #f otherwise\nlibraries: (chezscheme)\n" "\n" "(guardian? (make-guardian)) --> #t\n(guardian? (ftype-guardian iptr)) --> #t\n(guardian? (lambda x x)) --> #f\n(guardian? \"oops\") --> #f\n") ("smgmt:s32" "\nprocedure: (unregister-guardian guardian)\nreturns: see below\nlibraries: (chezscheme)\n" "unregister-guardian unregisters the\nas-yet unresurrected objects currently registered with the guardian,\nwith one caveat.\n" "\nThe caveat, which applies only to threaded versions of Chez Scheme,\nis that objects registered with the guardian by other threads since\nthe last garbage collection might not be unregistered.\nTo ensure that all objects are unregistered in a multithreaded\napplication, a single thread can be used both to register and\nunregister objects.\nAlternatively, an application can arrange to define a\ncollect-request\nhandler that calls unregister-guardian after it calls\ncollect.\n" "\nIn any case, unregister-guardian returns a list containing each object\n(or its representative, if specified) that it unregisters, with\nduplicates as appropriate if the same object is registered more\nthan once with the guardian.\nObjects already resurrected but not yet retrieved from the guardian\nare not included in the list but remain retrievable from the\nguardian.\n" "\nIn the current implementation, unregister-guardian takes time proportional\nto the number of unresurrected objects currently registered with\nall guardians rather than those registered just with\nthe corresponding guardian.\n" "\nThe example below assumes no collections occur except for those resulting from\nexplicit calls to collect.\n" "\n" "(define g (make-guardian))\n(define x (cons 'a 'b))\n(define y (cons 'c 'd))\n(g x)\n(g x)\n(g y)\n(g y)\n(set! y #f)\n(collect 0 0)\n(unregister-guardian g) --> ((a . b) (a . b))\n(g) --> (c . d)\n(g) --> (c . d)\n(g) --> #f\n" "unregister-guardian can also be used to unregister ftype\npointers registered with guardians created by\nftype-guardian\n(Section 15.6).\n\n") ("smgmt:s36" "\nprocedure: (lock-object obj)\nreturns: unspecified\nlibraries: (chezscheme)\n" "Locking an object prevents the storage manager from reclaiming or\nrelocating the object.\nLocking should be used sparingly, as it introduces memory fragmentation\nand increases storage management overhead.\n" "\nLocking can also lead to accidental retention of storage if objects\nare not unlocked.\nObjects may be unlocked via unlock-object or the equivalent\nC library procedure\nSunlock_object.\n" "\nLocking immediate values, such as fixnums, booleans, and characters,\nor objects that have been made static is unnecessary but harmless.\n\n") ("smgmt:s38" "\nprocedure: (unlock-object obj)\nreturns: unspecified\nlibraries: (chezscheme)\n" "An object may be locked more than once by successive calls to\nlock-object, Slock_object, or both, in which case it must\nbe unlocked by an equal number of calls to\nunlock-object or Sunlock_object before it is\ntruly unlocked.\n" "\nAn object contained within a locked object, such as an object in the\ncar of a locked pair, need not also be locked unless a separate C\npointer to the object exists.\nThat is, if the inner object is accessed only via an indirection of the\nouter object, it should be left unlocked so that the collector is free\nto relocate it during collection.\n" "\nUnlocking immediate values, such as fixnums, booleans, and characters,\nor objects that have been made static is unnecessary and ineffective but harmless.\n\n") ("smgmt:s39" "\nprocedure: (locked-object? obj)\nreturns: #t if obj is locked, immediate, or static\nlibraries: (chezscheme)\n") ("libraries:s13" "\nsyntax: (library name exports imports library-body)\nreturns: unspecified\nlibraries: (chezscheme)\n" "The library form defines a new library with the specified\nname, exports, imports, and body.\nDetails on the syntax and semantics of the library form are given in\nSection http://scheme.com/tspl4/./libraries.html#g14510.3 of The Scheme Programming Language, 4th Edition and in the Revised6\nReport.\n" "\nOnly one version of a library can be loaded at any given time, and an\nexception is raised if a library is implicitly loaded via import\nwhen another version of the library has already been loaded.\nChez Scheme permits a different version of the library, or a new\ninstance of the same version, to be entered explicitly into the REPL\nor loaded explicitly from a file, to facilitate interactive testing\nand debugging.\nThe programmer should take care to make sure that any code that uses\nthe library is also reentered or reloaded, to make sure that code\naccesses the bindings of the new instance of the library.\n" "\n" "(library (test (1)) (export x) (import (rnrs)) (define x 3))\n(import (test))\n(define f (lambda () x))\n(f) --> 3\n\n(library (test (1)) (export x) (import (rnrs)) (define x 4))\n(import (test))\n(f) --> 3    ; oops---forgot to redefine f\n(define f (lambda () x))\n(f) --> 4\n\n(library (test (2)) (export x) (import (rnrs)) (define x 5))\n(import (test))\n(define f (lambda () x))\n(f) --> 5\n" "As with module imports (Section 11.5), a library\nimport may appear anywhere a definition may appear, including at\ntop level in the REPL, in a file to be loaded by load, or within\na lambda, let, letrec, letrec*,\netc., body.\nThe same import form may be used to import from both libraries\nand modules.\n" "\n" "(library (foo) (export a) (import (rnrs)) (define a 'a-from-foo))\n(module bar (b) (define b 'b-from-bar))\n(let () (import (foo) bar) (list a b)) --> (a-from-foo b-from-bar)\n" "The import keyword is not visible within a library body\nunless the library imports it from the (chezscheme) library.\n") ("libraries:s14" "\nsyntax: (top-level-program imports body)\nreturns: unspecified\nlibraries: (chezscheme)\n" "A top-level-program form may be entered into the REPL or placed\nin a file to be loaded via load, where it behaves as if its\nsubforms were placed in a file and loaded via load-program.\nDetails on the syntax and semantics of a top-level program are given in\nSection http://scheme.com/tspl4/./libraries.html#g14510.3 of The Scheme Programming Language, 4th Edition and in the Revised6\nReport.\n" "\nThe following transcript illustrates a top-level-program being\ntested in the REPL.\n" "\n" "> (top-level-program (import (rnrs))\n    (display \"hello!\\n\"))\nhello!\n") ("libraries:s16" "\nsyntax: (import import-spec ...)\nsyntax: (import-only import-spec ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "An import or import-only form is a definition and can\nappear anywhere other definitions can appear, including\nat the top level of a program, nested within the bodies of\nlambda expressions, and nested within modules\nand libraries.\n" "\nEach import-spec must take one of the following forms.\n" "\n" "import-set\n(for import-set import-level ...)\n" "The for wrapper and import-level are described in \nChapter http://scheme.com/tspl4/./libraries.html#g14210 of The Scheme Programming Language, 4th Edition.\nThey are ignored by Chez Scheme, which determines\nautomatically the levels at which identifiers must\nbe imported, as permitted by the Revised6 Report.\nThis frees the programmer from the obligation\nto do so and results in more generality as well as more\nprecision in the set of libraries actually imported\nat compile and run time [citation21,citation19].\n" "\nAn import-set must take one of the following forms:\n" "\n" "library-spec\nmodule-name\n(only import-set identifier ...)\n(except import-set identifier ...)\n(prefix import-set prefix)\n(add-prefix import-set prefix)\n(drop-prefix import-set prefix)\n(rename import-set (import-name internal-name) ...)\n(alias import-set (import-name internal-name) ...)\n" "Several of these are specified by the Revised6 Report; the remainder\nare Chez Scheme extensions, including module-name and the\nadd-prefix, drop-prefix, and alias forms.\n" "\nAn import or import-only form makes the specified bindings\nvisible in the scope in which they appear.\nExcept at top level, they differ in that import leaves all bindings\nexcept for those shadowed by the imported names visible, whereas import-only\nhides all existing bindings, i.e., makes only the imported names visible.\nAt top level, import-only behaves like import.\n" "\nEach import-set identifies a set of names to make visible\nas follows.\n" "\nlibrary-spec:\nall exports of the library identified by the Revised6 Report library-spec\n(Chapter http://scheme.com/tspl4/./libraries.html#g14210).\n" "\nmodule-name:\nall exports of module named by the identifier module-name\n" "\n(only import-set identifier ...):\nof those specified by import-set, just identifier ...\n" "\n(except import-set identifier ...):\nall specified by import-set except identifier ...\n" "\n(prefix import-set prefix):\nall specified by import-set, each prefixed by prefix\n" "\n(add-prefix import-set prefix):\nall specified by import-set, each prefixed by prefix\n(just like prefix)\n" "\n(drop-prefix import-set prefix):\nall specified by import-set, with prefix prefix removed\n" "\n(rename import-set (import-name internal-name) ...):\nall specified by import-set, with each identifier import-name\nrenamed to the corresponding identifier internal-name\n" "\n(alias import-set (import-name internal-name) ...):\nall specified by import-set, with each internal-name as an alias\nfor import-name\n\n" "\nThe alias form differs from the rename form in that both\nimport-name and internal-name are in the resulting set,\nrather than just internal-name.\n" "\nIt is a syntax violation if the\ngiven selection or transformation cannot be made because of a missing\nexport or prefix.\n" "\nAn identifier made visible via an import of a module or library is scoped as if its\ndefinition appears where the import occurs.\nThe following example illustrates these scoping rules, using a local\nmodule m.\n" "\n" "(library (A) (export x) (import (rnrs)) (define x 0))\n(let ([x 1])\n  (module m (x setter)\n    (define-syntax x (identifier-syntax z))\n    (define setter (lambda (x) (set! z x)))\n    (define z 2))\n  (let ([y x] [z 3])\n    (import m (prefix (A) a:))\n    (setter 4)\n    (list x a:x y z))) --> (4 0 1 3)\n" "The inner let expression binds y to the value of\nthe x bound by the outer let.\nThe import of m makes the definitions of x\nand setter visible within the inner let.\nThe import of (A) makes the variable x exported\nfrom (A) visible as a:x within the body of the\ninner let.\nThus, in the expression (list x a:x y z), x refers to the\nidentifier macro exported from m while a:x refers to the\nvariable x exported from (A) and y and z\nrefer to the bindings established by the inner let.\nThe identifier macro x expands into a reference to\nthe variable z defined within the module.\n" "\nWith local import forms, it is rarely necessary to use the extended\nimport specifiers.\nFor example, an abstraction that encapsulates the import and reference\ncan easily be defined and used as follows.\n" "\n" "(define-syntax from\n  (syntax-rules ()\n    [(_ m id) (let () (import-only m) id)]))\n\n(library (A) (export x) (import (rnrs)) (define x 1))\n(let ([x 10])\n  (module M (x) (define x 2))\n  (cons (from (A) x) (from M x))) --> (1 . 2)\n" "The definition of from could use import rather than\nimport-only, but by using import-only we get feedback\nif an attempt is made to import an identifier from a library or\nmodule that does not export the identifier.\nWith import instead of import-only, the current binding,\nif any, would be visible if the library or module does not export the\nspecified name.\n" "\n" "(define-syntax lax-from\n  (syntax-rules ()\n    [(_ m id) (let () (import m) id)]))\n\n(library (A) (export x) (import (rnrs)) (define x 1))\n\n(let ([x 10])\n  (module M (x) (define x 2))\n  (+ (from (A) x) (from M y))) --> exception: unbound identifier y\n \n(let ([x 10] [y 20])\n  (module M (x) (define x 2))\n  (+ (lax-from (A) x) (lax-from M y))) --> 21\n" "Import visibility interacts with hygienic macro expansion in such a\nway that, as one might expect,\nan identifier x imported from a module M is treated in\nthe importing context as if the corresponding export identifier had\nbeen present in the import form along with M.\n" "\nThe from abstraction above works because both M and id\nappear in the input to the abstraction, so the imported id captures\nthe reference to id.\n" "\nThe following variant of from also works, because both names are\nintroduced into the output by the transformer.\n" "\n" "(module M (x) (define x 'x-of-M))\n(define-syntax x-from-M\n  (syntax-rules ()\n    [(_) (let () (import M) x)]))\n\n(let ([x 'local-x]) (x-from-M)) --> x-of-M\n" "On the other hand, imports of introduced module names do not capture\nfree references.\n" "\n" "(let ([x 'local-x])\n  (define-syntax alpha\n    (syntax-rules ()\n      [(_ var) (let () (import M) (list x var))]))\n \n  (alpha x)) --> (x-of-M local-x)\n" "Similarly, imports from free module names do not capture references\nto introduced variables.\n" "\n" "(let ([x 'local-x])\n  (define-syntax beta\n    (syntax-rules ()\n      [(_ m var) (let () (import m) (list x var))]))\n\n  (beta M x)) --> (local-x x-of-M)\n" "This semantics extends to prefixed, renamed, and aliased bindings\ncreated by the extended import specifiers prefix,\nrename, and alias.\n" "\nThe from abstraction\nworks for variables but not for exported keywords, record names,\nor module names, since the output is an expression and may thus appear only where\nexpressions may appear.\nA generalization of this technique is used in the following definition\nof import*, which supports renaming of imported bindings and\nselective import of specific bindings---without the use of the built-in\nimport subforms for selecting and renaming identifiers\n" "\n" "(define-syntax import*\n  (syntax-rules ()\n    [(_ m) (begin)]\n    [(_ m (new old))\n     (module (new)\n       (module (tmp)\n         (import m)\n         (alias tmp old))\n       (alias new tmp))]\n    [(_ m id) (module (id) (import m))]\n    [(_ m spec0 spec1 ...)\n     (begin (import* m spec0) (import* m spec1 ...))]))\n" "To selectively import an identifier from module or library m, the\nimport* form expands into an anonymous module that first\nimports all exports of m then re-exports only the selected\nidentifier.\nTo rename on import the macro expands into an anonymous module that\ninstead exports an alias (Section 11.10) bound to the new name.\n" "\nIf the output placed the definition of new in the same\nscope as the import of m, a naming conflict would arise\nwhenever new is also present in the interface\nof m.\nTo prevent this, the output instead places the import within a nested\nanonymous module and links old and new\nby means of an alias for the introduced identifier tmp.\n" "\nThe macro expands recursively to handle multiple import specifications.\nEach of the following examples imports cons as + and + as\ncons, which is probably not a very good idea.\n" "\n" "(let ()\n  (import* scheme (+ cons) (cons +))\n  (+ (cons 1 2) (cons 3 4))) --> (3 . 7)\n\n(let ()\n  (import* (rnrs) (+ cons) (cons +))\n  (+ (cons 1 2) (cons 3 4))) --> (3 . 7)\n") ("libraries:s17" "\nsyntax: (export export-spec ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "An export form is a definition and can appear with other\ndefinitions at the front of a library or module.\nIt is a syntax error for an export form to appear in other\ncontexts, including at top level or among the definitions of a\ntop-level program or lambda body.\n" "\nEach export-spec must take one of the following forms.\n" "\n" "identifier\n(rename (internal-name export-name) ...)\n(import import-spec ...)\n" "where each internal-name and export-name is an identifier.\nThe first two are syntactically identical to library\nexport-specs, while the third is syntactically\nidentical to a Chez Scheme import form, which is an extension of the\nR6RS library import subform.\nThe first form names a single export, identifier, whose export\nname is the same as its internal name.\nThe second names a set of exports, each of whose export name is\ngiven explicitly and may differ from its internal name.\n" "\nFor the third, the identifiers identified by the import form\nbecome exports, with aliasing, renaming, prefixing, etc., as specified by the\nimport-specs.\nThe module or library whose bindings are exported by an import\nform appearing within an export form can\nbe defined within or outside the exporting module or library and need\nnot be imported elsewhere within the exporting module or library.\n" "\nThe following library exports a two-armed-only variant of if\nalong with all remaining bindings of the (rnrs) library.\n" "\n" "(library (rnrs-no-one-armed-if) (export) (import (except (chezscheme) if))\n  (export if (import (except (rnrs) if)))\n  (define-syntax if\n    (let ()\n      (import (only (rnrs) if))\n      (syntax-rules ()\n        [(_ tst thn els) (if tst thn els)]))))\n\n(import (rnrs-no-one-armed-if))\n(if #t 3 4) --> 3\n(if #t 3) --> exception: invalid syntax\n" "Another way to define the same library would be to define the\ntwo-armed-only if with a different internal name and use\nrename to export it under the name if:\n" "\n" "(library (rnrs-no-one-armed-if) (export) (import (chezscheme))\n  (export (rename (two-armed-if if)) (import (except (rnrs) if)))\n  (define-syntax two-armed-if\n    (syntax-rules ()\n      [(_ tst thn els) (if tst thn els)])))\n\n(import (rnrs-no-one-armed-if))\n(if #t 3 4) --> 3\n(if #t 3) --> exception: invalid syntax\n" "The placement of the export form in the library body is\nirrelevant, e.g., the export form can appear after the\ndefinition in the examples above.\n\n") ("libraries:s18" "\nsyntax: (indirect-export id indirect-id ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This form is a definition and can appear wherever any other definition\ncan appear.\n" "\nAn indirect-export form declares that the named\nindirect-ids are indirectly exported to top level if id\nis exported to top level.\n" "\nIn general, if an identifier is not directly exported by a library or\nmodule, it can be referenced outside of the library or module only in\nthe expansion of a macro defined within and exported from the library\nor module.\nEven this cannot occur for libraries or modules defined at top level\n(or nested within other libraries or modules), unless either (1)\nthe library or module has been set up to implicitly export all\nidentifiers as indirect exports, or (2) each indirectly exported\nidentifier is explicitly declared as an indirect export of some\nother identifier that is exported, either directly or indirectly, from\nthe library or module, via an indirect-export or the built-in\nindirect export feature of a module export subform.\nBy default, (1) is true for a library and false for a module, but the\ndefault can be overridden via the implicit-exports\nform, which is described below.\n" "\nThis form is meaningful only within a top-level library, top-level module,\nor module enclosed within a library or top-level module, although it\nhas no effect if the library or module already implicitly exports all\nbindings.\nIt is allowed anywhere else definitions can appear, however, so macros\nthat expand into indirect export forms can be used in any definition\ncontext.\n" "\nIndirect exports are listed so the compiler can determine the\nexact set of bindings (direct and indirect) that must be inserted\ninto the top-level environment, and conversely, the set of bindings\nthat may be treated more efficiently as local bindings (and\nperhaps discarded, if they are not used).\n" "\nIn the example below, indirect-export is used to indirectly\nexport count to top level when current-count is\nexported to top level.\n" "\n" "(module M (bump-count current-count)\n  (define-syntax current-count (identifier-syntax count))\n  (indirect-export current-count count)\n  (define count 0)\n  (define bump-count\n    (lambda ()\n      (set! count (+ count 1)))))\n\n(import M)\n(bump-count)\ncurrent-count --> 1\ncount --> exception: unbound identifier count\n" "An indirect-export form is not required to make count\nvisible for bump-count, since it is a procedure whose code\nis contained within the module rather than a macro that might expand\ninto a reference to count somewhere outside the module.\n" "\nIt is often useful to use indirect-export in the output\nof a macro that expands into another macro named a if\na expands into references to identifiers that might not\nbe directly exported, as illustrated by the alternative definition\nof module M above.\n" "\n" "(define-syntax define-counter\n  (syntax-rules ()\n    [(_ getter bumper init incr)\n     (begin\n       (define count init)\n       (define-syntax getter (identifier-syntax count))\n       (indirect-export getter count)\n       (define bumper\n         (lambda ()\n           (set! count (incr count)))))]))\n\n(module M (bump-count current-count)\n  (define-counter current-count bump-count 0 add1))\n") ("libraries:s19" "\nsyntax: (implicit-exports #t)\nsyntax: (implicit-exports #f)\nreturns: unspecified\nlibraries: (chezscheme)\n" "An implicit-exports form is a definition and can appear with other\ndefinitions at the front of a library or module.\nIt is a syntax error for an implicit-exports form to appear in other\ncontexts, including at top level or among the definitions of a\ntop-level program or lambda body.\n" "\nThe implicit-exports form determines whether identifiers\nnot directly exported from a module or library are automatically\nindirectly exported to the top level if any meta-binding (keyword, meta\ndefinition, or property definition) is directly exported to top level\nfrom the library or module.\nThe default for libraries is #t, to match the behavior required\nby the Revised6 Report, while the default for modules is #f.\nThe implicit-exports form is meaningful only within a library,\ntop-level module, or module enclosed within a library or top-level module.\nIt is allowed in a module enclosed within a lambda, let,\nor similar body, but ignored there because none of that module's bindings\ncan be exported to top level.\n" "\nThe advantage of (implicit-exports #t) is that indirect exports\nneed not be listed explicitly, which is convenient.\nA disadvantage is that it often results in more bindings than necessary\nbeing elevated to top level where they cannot be discarded as useless\nby the optimizer.\nFor modules, another disadvantage is such bindings\ncannot be proven immutable, which inhibits important optimizations such\nas procedure inlining.\nThis can result in significantly lower run-time performance.\n") ("libraries:s20" "\nprocedure: (invoke-library libref)\nreturns: unspecified\nlibraries: (chezscheme)\n" "libref must be an s-expression in the form of a library reference.\nThe syntax for library references is given in\nChapter http://scheme.com/tspl4/./libraries.html#g14210 of The Scheme Programming Language, 4th Edition and in the Revised6\nReport.\n" "\nA library is implicitly invoked when or before some expression\noutside the library (e.g., in another library or in a top-level\nprogram) evaluates a reference to one of the library's exported\nvariables.\nWhen the library is invoked, its body expressions (the right-hand-sides\nof the library's variable definitions and its initialization\nexpressions) are evaluated.\nOnce invoked, the library is not invoked again within the same process,\nunless it is first explicitly redefined or reloaded.\n" "\ninvoke-library explicitly invokes the library specified\nby libref if it has not already been invoked or has since\nbeen redefined or reloaded.\nIf the library has not yet been loaded, invoke-library\nfirst loads the library via the process described in\nSection 2.4.\n" "\ninvoke-library is typically only useful for libraries whose\nbody expressions have side effects.\nIt is useful to control when the side effects occur and to force\ninvocation of a library that has no exported variables.\nInvoking a library does not force the compile-time code (macro\ntransformer expressions and meta definitions) to be loaded or\nevaluated, nor does it cause the library's bindings to become\nvisible.\n" "\nIt is good practice to avoid externally visible side effects in\nlibrary bodies so the library can be used equally well at compile\ntime and run time.\nWhen feasible, consider moving the side effects of a library body\nto an initialization routine and adding a top-level program that\nimports the library and calls the initialization routine.\nWith this structure, calls to invoke-library on the\nlibrary can be replaced by calls to \nload-program on the\ntop-level program.\n") ("libraries:s23" "\nthread parameter: library-directories\nthread parameter: library-extensions\nlibraries: (chezscheme)\n" "The parameter library-directories determines where the files\ncontaining library source and object code are located in the file system,\nand the parameter library-extensions determines the filename\nextensions for the files holding the code, as described in\nsection 2.4.\nThe values of both parameters are lists of pairs of strings.\nThe first string in each library-directories pair identifies a\nsource-file root directory, and the second identifies the corresponding\nobject-file root directory.\nSimilarly, the first string in each library-extensions pair\nidentifies a source-file extension, and the second identifies the\ncorresponding object-file extension.\nThe full path of a library source or object file consists of the source or\nobject root followed by the components of the library name prefixed by\nslashes, with the library extension added on the end.\nFor example, for root /usr/lib/scheme, library name\n(app lib1), and extension .sls, the full path is\n/usr/lib/scheme/app/lib1.sls.\nIf the library name portion forms an absolute pathname, e.g.,\n~/.myappinit, the library-directories parameter is\nignored and no prefix is added.\n" "\nThe initial values of these parameters are shown below.\n" "\n" "(library-directories) --> ((\".\" . \".\"))\n\n(library-extensions) --> ((\".chezscheme.sls\" . \".chezscheme.so\")\n                     gifs/ghostRightarrow.gif  (\".ss\" . \".so\")\n                     gifs/ghostRightarrow.gif  (\".sls\" . \".so\")\n                     gifs/ghostRightarrow.gif  (\".scm\" . \".so\")\n                     gifs/ghostRightarrow.gif  (\".sch\" . \".so\"))\n" "As a convenience, when either of these parameters is set, any element of\nthe list can be specified as a single source string, in which case the\nobject string is determined automatically.\nFor library-directories, the object string is the same as\nthe source string, effectively naming the\nsame directory as a source- and object-code root.\nFor library-extensions, the object string is the result of\nremoving the last (or only) extension from the string and appending\n\".so\".\nThe library-directories and library-extensions\nparameters also accept as input strings in the format described\nin Section 2.5\nfor the\n--libdirs and\n--libexts command-line\noptions.\n") ("libraries:s26" "\nthread parameter: compile-imported-libraries\nlibraries: (chezscheme)\n" "When the value of this parameter is #t, import\nautomatically calls the value of the compile-library-handler parameter (which defaults\nto a procedure that simply calls compile-library) on any imported library if\nthe object file is missing, older than the corresponding source file,\nolder than any source files included (via include) when the\nobject file was created, or itself requires a library that has or must\nbe recompiled, as described in Section 2.4.\nThe default initial value of this parameter is #f.\nIt can be set to #t via the command-line option\n--compile-imported-libraries.\n" "\nWhen import compiles a library via this mechanism, it does not\nalso load the compiled library, because this would cause portions of\nlibrary to be reevaluated.\nBecause of this, run-time expressions in the file outside of a\nlibrary form will not be evaluated.\nIf such expressions are present and should be evaluated, the library\nshould be loaded explicitly.\n") ("libraries:s29" "\nthread parameter: import-notify\nlibraries: (chezscheme)\n" "When the new parameter import-notify is set to a true value,\nimport displays messages to the console-output port as it\nsearches for the file containing each library it needs to load.\nThe default value of this parameter is #f.\n") ("libraries:s30" "\nthread parameter: library-search-handler\nlibraries: (chezscheme)\n" "The value of parameter must be a procedure that follows the protocol described\nbelow for default-library-search-handler, which is the default value\nof this parameter.\n" "\nThe value of this parameter is invoked to locate the source or object code for\na library during import, compile-whole-program, or\ncompile-whole-library.\n") ("libraries:s31" "\nprocedure: (default-library-search-handler who library directories extensions)\nreturns: see below\nlibraries: (chezscheme)\n" "This procedure is the default value of the library-search-handler,\nwhich is\ncalled to locate the source or object code for a library\nduring import,\ncompile-whole-program, or compile-whole-library.\nwho is a symbol that provides context in import-notify messages.\nlibrary is the name of the desired library.\ndirectories is a list of source and object directory pairs in\nthe form returned by library-directories.\nextensions is a list of source and object extension pairs in the form\nreturned by library-extensions.\n" "\nThis procedure searches the specified directories until it finds a library source or\nobject file with one of the specified extensions.\nIf it finds the source file first, it constructs the corresponding\nobject file path and checks whether the file exists.\nIf it finds the object file first, the procedure looks for a corresponding\nsource file with one of the given source extensions in a source directory paired\nwith that object directory.\nThe procedure returns three values:\nthe file-system path of the library source file or #f if not found,\nthe file-system path of the corresponding object file, which may be #f,\nand a boolean that is true if the object file exists.\n") ("libraries:s32" "\nprocedure: (library-list)\nreturns: a list of the libraries currently defined\nlibraries: (chezscheme)\n" "The set of libraries initially defined includes those listed in\nSection 10.1 above.\n") ("libraries:s33" "\nprocedure: (library-version libref)\nreturns: the version of the specified library\nprocedure: (library-exports libref)\nreturns: a list of the exports of the specified library\nprocedure: (library-requirements libref)\nreturns: a list of libraries required by the specified library\nprocedure: (library-requirements libref options)\nreturns: a list of libraries required by the specified library, filtered by options\nprocedure: (library-object-filename libref)\nreturns: the name of the object file holding the specified library, if any\nlibraries: (chezscheme)\n" "Information can be obtained only for built-in libraries or libraries\npreviously loaded into the system.\nlibref must be an s-expression in the form of a library reference.\nThe syntax for library references is given in\nChapter http://scheme.com/tspl4/./libraries.html#g14210 of The Scheme Programming Language, 4th Edition and in the Revised6\nReport.\n" "\nThe library-version return value is a list of numbers\n(possibly empty) representing the library's version.\n" "\nThe list of exports returned by library-exports is a list of\nsymbols, each identifying one of the library's exports.\nThe order in which the elements appear is unspecified.\n" "\nWhen the optional options argument is supplied, it must be\nan enumeration set over the symbols constituting\nvalid library-requirements options, as described in the\nlibrary-requirements-options entry below.\nIt defaults to a set containing all of the options.\nEach element of the list of libraries returned by\nlibrary-requirements is an s-expression form of a library\nreference.\nThe library reference includes the actual version of the library that is\npresent in the system (if nonempty), even if a version was not specified\nwhen it was imported.\nThe order in which the libraries appear in the list returned by\nlibrary-requirements is unspecified.\n" "\nlibrary-object-filename returns a string naming the object\nfile if the specified library was loaded from or compiled to an object\nfile.\nOtherwise, it returns #f.\n\n" "\n" "(with-output-to-file \"A.ss\"\n  (lambda ()\n    (pretty-print\n      '(library (A (1 2)) (export x z)\n         (import (rnrs))\n         (define x 'ex)\n         (define y 23)\n         (define-syntax z\n           (syntax-rules ()\n             [(_ e) (+ y e)])))))\n  'replace)\n(with-output-to-file \"B.ss\"\n  (lambda ()\n    (pretty-print\n      '(library (B) (export x w)\n         (import (rnrs) (A))\n         (define w (cons (z 12) x)))))\n  'replace)\n(compile-imported-libraries #t)\n(import (B))\n(library-exports '(A)) --> (x z) ; or (z x)\n(library-exports '(A (1 2))) --> (x z) ; or (z x)\n(library-exports '(B)) --> (x w) ; or (w x)\n(library-version '(A)) --> (1 2)\n(library-version '(B)) --> ()\n(library-requirements '(A)) --> ((rnrs (6)))\n(library-requirements '(B)) --> ((rnrs (6)) (A (1 2)))\n(library-object-filename '(A)) --> \"A.so\"\n(library-object-filename '(B)) --> \"B.so\"\n") ("libraries:s34" "\nsyntax: (library-requirements-options symbol ...)\nreturns: a library-requirements-options enumeration set\nlibraries: (chezscheme)\n" "Library-requirements-options enumeration sets are passed to\nlibrary-requirements to determine the library requirements\nto be listed.  The available options are described below.\n" "\nimport:\nInclude the libraries that must be imported when the specified library\nis imported.\n" "\nvisit@visit:\nIncludes the libraries that must be visited when the specified library\nis visited.\n" "\ninvoke@visit:\nInclude the libraries that must be invoked when the specified library\nis visited.\n" "\ninvoke:\nIncludes the libraries that must be invoked when the specified library\nis invoked.\n\n") ("expeditor:s0" "\nmodule: expression-editor\nlibraries: (chezscheme)\n" "The expression-editor module exports a set of bindings for\nparameters and other procedures that can be used to modify how the\nexpression editor interacts with the user, including the particular keys\nused to invoke the various editing commands.\n" "\n" "Basic use of the expression editor is described in Section 2.2.\n\n") ("expeditor:s1" "\nglobal parameter: ee-auto-indent\n" "\n" "The value of ee-auto-indent is a boolean value that determines\nwhether the expression editor indents expressions as they are entered.\nIts default value is #t.\n\n") ("expeditor:s2" "\nglobal parameter: ee-standard-indent\n" "\n" "The value of ee-standard-indent is a nonnegative fixnum\nvalue that determines the amount (in single spaces) by which each\nexpression is indented relative to the enclosing expression, if\nnot aligned otherwise by one of the indenter's other heuristics,\nwhen ee-auto-indent is true or when one of the indentation\ncommands is invoked explicitly.\nIt's default value is 2.\n\n") ("expeditor:s3" "\nglobal parameter: ee-auto-paren-balance\n" "\n" "The value of ee-auto-paren-balance is a boolean value that determines\nwhether the expression editor automatically corrects a close\nparenthesis or bracket, when typed, to match the corresponding open\nparenthesis or bracket, if any.\nIts default value is #t.\n\n") ("expeditor:s4" "\nglobal parameter: ee-flash-parens\n" "\n" "The value of ee-flash-parens is a boolean value that determines\nwhether the expression editor briefly moves the cursor when an open\nor close parenthesis or bracket is typed to the\nmatching close or open parenthesis or bracket (if any).\nIts default value is #t.\n\n") ("expeditor:s5" "\nglobal parameter: ee-paren-flash-delay\n" "\n" "The value of ee-paren-flash-delay is a nonnegative fixnum\nvalue that determines the amount of time (in milliseconds) that the\nexpression editor pauses when the cursor is moved to the matching\nparenthesis or bracket, if any, when a parenthesis or bracket is\nentered.\nThe value is ignored if the ee-flash-parens is false.\nIts default value is 100.\n\n") ("expeditor:s6" "\nglobal parameter: ee-default-repeat\n" "\n" "The value of ee-default-repeat is a nonnegative fixnum\nvalue that determines the number of times the next command is\nrepeated after the ee-command-repeat editing command\n(bound to Esc-^U by default) is used and not\nfollowed by a sequence of digits.\nIt's default value is 4.\n\n") ("expeditor:s7" "\nglobal parameter: ee-noisy\n" "\n" "The value of ee-noisy is a boolean value that determines\nwhether the expression editor emits a beep (bell) when an error\noccurs, such as an attempt to find the matching delimiter for a\nnon-delimiter character.\nIts default value is #f.\n\n") ("expeditor:s8" "\nglobal parameter: ee-history-limit\n" "\n" "The value of ee-history-limit is a nonnegative fixnum value\nthat determines the number of history entries retained by the\nexpression editor during and across sessions.\nOnly the last (ee-history-limit) entries are retained.\n\n") ("expeditor:s9" "\nglobal parameter: ee-common-identifiers\n" "\n" "The value of ee-common-identifiers is list of symbols that\nare considered common enough that they should appear early when\none of the incremental identifier-completion editing commands is\ninvoked.\nIts default value contains a few dozen entries.\nThey are all more than a few characters long (under the theory that\nusers will most likely type short ones out fully) and all would\nappear later than they likely should when incremental\nidentifier-completion is used.\n\n") ("expeditor:s10" "\nprocedure: (ee-bind-key key procedure)\n" "\nreturns: unspecified\n" "The ee-bind-key procedure is used to add to or change the\nset of key bindings recognized by the expression editor.\n" "\nThe key must be a character or string; if it is a string, it\nmust have the following form.\n" "\n  \n  \n  \n<key-string>centermath/csug/2.gif\"<key-char>+\"\n\n" "\nwhere\n" "\n  \n  \n  \n<key-char>centermath/csug/2.gif\\\\e (specifying an escape character)\n  center|^x (specifying control-x)\n  center|\\\\^ (specifying caret)\n  center|\\\\\\\\ (specifying back slash)\n  center|plain char (any character other than \\ or ^)\n\n" "\nNote that each double-backslash in the syntax actually denotes just\none backslash in the string.\n" "\nFor example, the key \"\\\\eX\" represents the two-character\nsequence Escape-x, i.e., the \"escape\" key followed by the (capital)\n\"X\" key.\nSimilarly, they key \"\\\\e^X\" represents the two-character\nsequence Escape-Control-x, i.e., the \"escape\" key followed by\nControl-X.\n" "\nCharacter keys and string keys consisting of a single plain character\nalways represent a single keystroke.\n" "\nThe procedure argument should normally be one of the built-in editing\ncommands described below.\nIt is also possible to define new editing commands with\nee-string-macro\nand ee-compose.\n\n") ("expeditor:s77" "\nprocedure: (ee-string-macro string)\n" "\nreturns: a new editing command\n" "The new editing command produced inserts string before the current\ncursor position.\n" "\nTwo string macros are predefined:\n" "\nleft\n(ee-string-macro \"(define \") left   escape-dleft\n(ee-string-macro \"(lambda \") left   escape-l\n\n") ("expeditor:s78" "\nprocedure: (ee-compose ecmd ...)\n" "\nreturns: a new editing command\n" "Each ecmd must be an editing command.\n" "\nThe new editing command runs each of the editing commands\necmd ... in sequence.\n\n" "\nFor example, the following expression binds ^X-p to an editing\ncommand that behaves like ee-history-bwd-prefix but leaves the\ncursor at the end of the expression rather than at the end of the first\nline, causing the entire entry to be displayed.\n" "\n" "(let ()\n  (import expression-editor)\n  (ee-bind-key \"^Xp\"\n    (ee-compose ee-history-bwd ee-end-of-entry)))\n" "A command such as ee-id-completion that performs a different\naction when run twice in succession will not recognize that it has been\nrun twice in succession if run as part of a composite command.\n\n") ("debug:s0" "\nsyntax: (trace-lambda name formals body1 body2 ...)\nreturns: a traced procedure\nlibraries: (chezscheme)\n" "A trace-lambda expression is equivalent to a\nlambda expression with the same formals and body\nexcept that trace information is printed to the trace output port whenever\nthe procedure is invoked, using name to identify the procedure.\nThe trace information shows the value of the arguments passed to the\nprocedure and the values returned by the procedure, with indentation to\nshow the nesting of calls.\n" "\nThe traced procedure half defined below\nreturns the integer quotient of its argument and 2.\n" "\n" "(define half\n  (trace-lambda half (x)\n    (cond\n      [(zero? x) 0]\n      [(odd? x) (half (- x 1))]\n      [(even? x) (+ (half (- x 1)) 1)])))\n" "A trace of the call (half 5), which returns 2, is shown below.\n" "\n" "|(half 5)\n|(half 4)\n| (half 3)\n| (half 2)\n| |(half 1)\n| |(half 0)\n| |0\n| 1\n|2\n" "This example highlights the proper treatment of tail and nontail calls\nby the trace package.\nSince half tail calls itself when its argument is odd, the call\n(half 4) appears at the same level of indentation as the call\n(half 5).\nFurthermore, since the return values of (half 5) and\n(half 4) are necessarily the same, only one return value is\nshown for both calls.\n") ("debug:s3" "\nsyntax: (trace-case-lambda name clause ...)\nreturns: a traced procedure\nlibraries: (chezscheme)\n" "A trace-case-lambda expression is\nequivalent to a case-lambda expression with the same clauses\nexcept that trace information is printed to the trace output port whenever\nthe procedure is invoked, using name to identify the procedure.\nThe trace information shows the value of the arguments passed to the\nprocedure and the values returned by the procedure, with indentation to\nshow the nesting of calls.\n\n") ("debug:s5" "\nsyntax: (trace-let name ((var expr) ...) body1 body2 ...)\nreturns: the values of the body body1 body2 ...\nlibraries: (chezscheme)\n" "A trace-let expression is equivalent to a\nnamed let expression with the same name, bindings, and body\nexcept that trace information is printed to the trace output port on\nentry or reentry (via invocation of the procedure bound to name)\ninto the trace-let expression.\n" "\nA trace-let expression of the form\n" "\n" "(trace-let name ([var expr] ...)\n  body1 body2 ...)\n" "can be rewritten in terms of trace-lambda as follows:\n" "\n" "((letrec ([name\n           (trace-lambda name (var ...)\n             body1 body2 ...)])\n   name)\n expr ...)\n" "trace-let may be used to trace ordinary let expressions\nas well as let expressions as long as the name inserted along\nwith the trace-let keyword in place of let does not\nappear free within the body of the let expression.\nIt is also sometimes useful to insert a trace-let expression\ninto a program simply to display the value of an arbitrary expression\nat the current trace indentation.\nFor example, a call to the following variant of half\n" "\n" "(define half\n  (trace-lambda half (x)\n    (cond\n      [(zero? x) 0]\n      [(odd? x) (half (trace-let decr-value () (- x 1)))]\n      [(even? x) (+ (half (- x 1)) 1)])))\n" "with argument 5 results in the trace:\n" "\n" "|(half 5)\n| (decr-value)\n| 4\n|(half 4)\n| (half 3)\n| |(decr-value)\n| |2\n| (half 2)\n| |(half 1)\n| | (decr-value)\n| | 0\n| |(half 0)\n| 1\n|2\n") ("debug:s7" "\nsyntax: (trace-do ((var init update) ...) (test result ...) expr ...)\nreturns: the values of the last result expression\nlibraries: (chezscheme)\n" "A trace-do expression is equivalent to a\ndo expression with the same subforms,\nexcept that trace information is printed to the trace output port,\nshowing the values of var ... and each iteration and\nthe final value of the loop on termination.\nFor example, the expression\n" "\n" "(trace-do ([old '(a b c) (cdr old)]\n           [new '() (cons (car old) new)])\n  ((null? old) new))\n" "produces the trace\n" "\n" "|(do (a b c) ())\n|(do (b c) (a))\n|(do (c) (b a))\n|(do () (c b a))\n|(c b a)\n" "and returns (c b a).\n\n") ("debug:s9" "\nsyntax: (trace var1 var2 ...)\nreturns: a list of var1 var2 ...\nsyntax: (trace)\nreturns: a list of all currently traced top-level variables\nlibraries: (chezscheme)\n" "In the first form, trace reassigns the top-level values of\nvar1 var2 ..., whose values must be procedures,\nto equivalent procedures that display trace information in the manner\nof trace-lambda.\n" "\ntrace works by encapsulating the old value of each var in a\ntraced procedure.\nIt could be defined approximately as follows.  (The actual version\nrecords and returns information about traced variables.)\n" "\n" "(define-syntax trace\n  (syntax-rules ()\n    [(_ var ...)\n     (begin\n       (set-top-level-value! 'var\n         (let ([p (top-level-value 'var)])\n           (trace-lambda var args (apply p args))))\n       ...)]))\n" "Tracing for a procedure traced in this manner may be disabled via\nuntrace (see below), an assignment of the corresponding\nvariable to a different, untraced value, or a subsequent use of\ntrace for the same variable.\nBecause the value is traced and not the binding, however, a traced\nvalue obtained before tracing is disabled and retained after tracing is\ndisabled will remain traced.\n" "\ntrace without subexpressions evaluates to a list of all\ncurrently traced variables.\nA variable is currently traced if it has been traced and\nnot subsequently untraced or assigned to a different value.\n" "\nThe following transcript demonstrates the use of trace in\nan interactive session.\n" "\n" "> (define half\n    (lambda (x)\n      (cond\n        [(zero? x) 0]\n        [(odd? x) (half (- x 1))]\n        [(even? x) (+ (half (- x 1)) 1)])))\n> (half 5)\n2\n> (trace half)\n(half)\n> (half 5)\n|(half 5)\n|(half 4)\n| (half 3)\n| (half 2)\n| |(half 1)\n| |(half 0)\n| |0\n| 1\n|2\n2\n> (define traced-half half)\n> (untrace half)\n(half)\n> (half 2)\n1\n> (traced-half 2)\n|(half 2)\n|1\n1\n") ("debug:s10" "\nsyntax: (untrace var1 var2 ...)\nsyntax: (untrace)\nreturns: a list of untraced variables\nlibraries: (chezscheme)\n" "untrace restores the original (pre-trace) top-level values\nof each currently traced variable in\nvar1 var2 ...,\neffectively disabling the tracing of the values of these variables.\nAny variable in var1 var2 ... that is not\ncurrently traced is ignored.\nIf untrace is called without arguments, the values of all\ncurrently traced variables are restored.\n" "\nThe following transcript demonstrates the use of trace and\nuntrace in an interactive session to debug an incorrect\nprocedure definition.\n" "\n" "> (define square-minus-one\n    (lambda (x)\n      (- (* x x) 2)))\n> (square-minus-one 3)\n7\n> (trace square-minus-one * -)\n(square-minus-one * -)\n> (square-minus-one 3)\n|(square-minus-one 3)\n| (* 3 3)\n| 9\n|(- 9 2)\n|7\n7\n> (define square-minus-one\n    (lambda (x)\n      (- (* x x) 1))) ; change the 2 to 1\n> (trace)\n(- *)\n> (square-minus-one 3)\n|(* 3 3)\n|9\n|(- 9 1)\n|8\n8\n> (untrace square-minus-one)\n()\n> (untrace * -)\n(- *)\n> (square-minus-one 3)\n8\n" "The first call to square-minus-one indicates there is an error,\nthe second (traced) call indicates the step at which the error occurs,\nthe third call demonstrates that the fix works,\nand the fourth call demonstrates that\nuntrace does not wipe out the fix.\n\n") ("debug:s11" "\nthread parameter: trace-output-port\nlibraries: (chezscheme)\n" "trace-output-port is a parameter that determines the\noutput port to which tracing information is sent.\nWhen called with no arguments, trace-output-port returns the\ncurrent trace output port.\nWhen called with one argument, which must be a textual output port,\ntrace-output-port changes the value of the current\ntrace output port.\n\n") ("debug:s12" "\nthread parameter: trace-print\nlibraries: (chezscheme)\n" "The value of trace-print must be a procedure of two arguments,\nan object and an output port.\nThe trace package uses the value of trace-print to print the\narguments and return values for each call to a traced procedure.\ntrace-print is set to pretty-print by default.\n" "\nThe trace package sets\npretty-initial-indent\nto an appropriate value for the current nesting level before calling\nthe value of trace-print so that multiline output can be\nindented properly.\n\n") ("debug:s14" "\nsyntax: (trace-define var expr)\nsyntax: (trace-define (var . idspec) body1 body2 ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "trace-define is a convenient shorthand for defining variables bound\nto traced procedures of the same name.\nThe first form is equivalent to\n" "\n" "(define var\n  (let ([x expr])\n    (trace-lambda var args\n      (apply x args))))\n" "and the second is equivalent to\n" "\n" "(define var\n  (trace-lambda var idspec\n    body1 body2 ...))\n" "In the former case, expr must evaluate to a procedure.\n" "\n" "> (let ()\n    (trace-define plus\n      (lambda (x y) \n        (+ x y)))\n    (list (plus 3 4) (+ 5 6)))\n|(plus 3 4)\n|7\n(7 11)\n") ("debug:s15" "\nsyntax: (trace-define-syntax keyword expr)\nreturns: unspecified\nlibraries: (chezscheme)\n" "trace-define-syntax traces the input and output to the\ntransformer value of expr, stripped of the contextual\ninformation used by the expander to maintain lexical scoping.\n" "\n" "> (trace-define-syntax let*\n    (syntax-rules ()\n      [(_ () b1 b2 ...)\n       (let () b1 b2 ...)]\n      [(_ ((x e) m ...) b1 b2 ...)\n       (let ((x e))\n         (let* (m ...) b1 b2 ...))]))\n> (let* ([x 3] [y (+ x x)]) (list x y))\n|(let* (let* [(x 3) (y (+ x x))] [list x y]))\n|(let ([x 3]) (let* ([y (+ x x)]) (list x y)))\n|(let* (let* [(y (+ x x))] [list x y]))\n|(let ([y (+ x x)]) (let* () (list x y)))\n|(let* (let* () [list x y]))\n|(let () (list x y))\n(3 6)\n" "Without contextual information, the displayed forms are more readable\nbut less precise, since different identifiers with the same name are\nindistinguishable, as shown in the example below.\n" "\n" "> (let ([x 0])\n    (trace-define-syntax a\n      (syntax-rules ()\n        [(_ y) (eq? x y)]))\n    (let ([x 1])\n      (a x)))\n|(a (a x))\n|(eq? x x)\n#f\n") ("debug:s16" "\nprocedure: (debug)\nreturns: does not return\nlibraries: (chezscheme)\n" "When the default exception handler receives a serious or non-warning\ncondition, it displays the condition and resets to the current caf.\nBefore it resets, it saves the condition in the parameter\ndebug-condition.\nThe debug procedure may be used to inspect the condition.\nWhenever one of the built-in error-reporting mechanisms is used to\nraise an exception, the continuation at the point where the\nexception was raised can be inspected as well.\nMore generally, debug allows the continuation contained\nwithin any continuation condition created by\nmake-continuation-condition to be inspected.\n" "\nIf the parameter debug-on-exception is set to #t,\nthe default exception handler enters the debugger directly for all\nserious and non-warning conditions, delaying its reset until after\nthe debugger exits.\nThe --debug-on-exception\ncommand-line option may be used to set debug-on-exception to\n#t from the command line, which is particularly useful when\ndebugging scripts or top-level programs run via the\n--script or\n--program\ncommand-line options.\n\n") ("debug:s22" "\nprocedure: (inspect obj)\nreturns: unspecified\nlibraries: (chezscheme)\n" "Invokes the inspector on obj, as described above.\nThe commands recognized by the inspector are listed below, categorized\nby the type of the current object.\n\n" "\n\n" "\n" "Generally applicable commands" "" "help or h displays a brief description of how to use the\ninspector.\n" "\n" "? displays commands applicable to the current type of\nobject.\n" "\n" "?? displays the generally applicable commands.\n" "\n" "print or p prints the current object (using pretty-print).\n" "\n" "write or w writes the current object (using write).\n" "\n" "size writes the size in bytes occupied by the current object\n(determined via compute-size),\nincluding any objects accessible from the current object except those\nfor which the size was previously requested during the same interactive\ninspector session.\n" "\n" "find expr [ g ] evaluates expr, which should evaluate\nto a procedure of one argument, and searches\n(via make-object-finder)\nfor the first occurrence\nof an object within the current object for which the predicate returns\na true value, treating immediate values (e.g., fixnums), values in\ngenerations older than g, and values already visited during the\nsearch as leaves.\nIf g is not unspecified, it defaults to the current maximum\ngeneration, i.e., the value of collect-maximum-generation.\nIf specified, g must be an exact nonnegative integer less than or\nequal to the current maximum generation or the symbol static\nrepresenting the static generation.\nIf such an object is found, the inspector's focus moves to that object\nas if through a series of steps that lead from the current object to the\nlocated object, so that the up command can be used to determine\nwhere the object was found relative to the original object.\n" "\n" "find-next repeats the last find, locating an\noccurrence not previously found, if any.\n" "\n" "up or u n returns to the nth previous level.\nUsed to move outwards in the structure of the inspected object.\nn defaults to 1.\n" "\n" "top or t returns to the outermost level of the inspected\nobject.\n" "\n" "forward or f moves to the nth next expression.\nUsed to move from one element to another of an object containing\na sequence of elements, such as a list, vector, record, frame, or closure.\nn defaults to 1.\n" "\n" "back or b moves to the nth previous expression.\nUsed to move from one element to another of an object containing\na sequence of elements, such as a list, vector, record, frame, or closure.\nn defaults to 1.\n" "\n" "=> expr sends the current object to the procedure value\nof expr.\nexpr may begin on the current or following line and may\nspan multiple lines.\n" "\n" "file path opens the source file at the specified path for\nlisting.\nThe parameter source-directories (Section 12.5)\ndetermines the set of directories\nsearched for source files.\n" "\n" "list line count lists count lines of the\ncurrent source file (see file) starting at line.\nline defaults to the end of the previous set of lines listed and\ncount defaults to ten or the number of lines previously listed.\nIf line is negative, listing begins line lines before the\nprevious set of lines listed.\n" "\n" "files shows the currently open source files.\n" "\n" "mark or m m marks the current location with the\nsymbolic mark m.\nIf m is not specified, the current location is marked with\na unique default mark.\n" "\n" "goto or g m returns to the location marked m.\nIf m is not specified, the inspector returns to the location\nmarked with the default mark.\n" "\n" "new-cafe or n enters a new read-eval-print loop\n(caf), giving access to the normal top-level environment.\n" "\n" "quit or q exits from the inspector.\n" "\n" "reset or r resets to the current caf.\n" "\n" "abort or a x aborts from Scheme with exit\nstatus x, which defaults to -1.\n\n" "\n" "Continuation commands" "" "show-frames or sf shows the next n frames.\nIf n is not specified, all frames are displayed.\n" "\n" "depth displays the number of frames in the continuation.\n" "\n" "down or d n move to the nth frame down in the\ncontinuation.\nn defaults to 1.\n" "\n" "show or s shows the continuation (next frame) and,\nif available, the calling procedure source, the pending call source,\nthe closure, and the frame and free-variable values.\nSource is available only if generation of inspector information\nwas enabled during compilation of the corresponding lambda\nexpression.\n" "\n" "show-local or sl is like show or s\nexcept that free variable values are not shown.  (If present, free variable\nvalues can be found by inspecting the closure.)\n" "\n" "length or l displays the number of elements\nin the topmost frame of the continuation.\n" "\n" "ref or r moves to the nth or named\nframe element.  n defaults to 0.\nIf multiple elements have the same name, only one is\naccessible by name, and the others must be accessed by number.\n" "\n" "code or c moves to the source for the calling procedure.\n" "\n" "call moves to the source for the pending call.\n" "\n" "file opens the source file containing the pending call,\nif known.\nThe parameter source-directories (Section 12.5)\ndetermines the list of source directories searched for source files\nidentified by relative path names.\n" "\nFor absolute pathnames starting with a / (or \\ or a\ndirectory specifier under Windows), the inspector tries the absolute\npathname first, then looks for the last (filename) component of the path in\nthe list of source directories. \nFor pathnames starting with  (or .\\ under Windows)\nor ../ (or ..\\ under Windows), the inspector looks in\n\".\" or \"..\" first, as appropriate, then for the entire\n.- or ..-prefixed\npathname in the source directories, then for the last (filename)\ncomponent in the source directories.\nFor other (relative) pathnames, the inspector looks for the entire\nrelative pathname in the list of source directories, then the last\n(filename) component in the list of source directories. \n" "\nIf a file by the same name as but different contents from the original\nsource file is found during this process, it will be skipped over.\nThis typically happens because the file has been modified since it was\ncompiled.\nPass an explicit filename argument to force opening of a particular file\n(see the generally applicable commands above).\n\n" "\n" "eval or e expr evaluates the expression\nexpr in an environment containing bindings for the elements of\nthe frame.  Within the evaluated expression, the value of each frame\nelement n is accessible via the variable %n.\nNamed elements are accessible via their names as well.  Names are\navailable only if generation of inspector information was enabled\nduring compilation of the corresponding lambda expression.\n" "\n" "set! or ! n e sets the value of the nth frame\nelement to e, if the frame element corresponds to\nan assignable variable.\nn defaults to 0.\n\n" "\n" "Procedure commands" "" "show or s shows the source and free variables of the\nprocedure.\nSource is available only if generation of inspector information\nwas enabled during compilation of the corresponding lambda\nexpression.\n" "\n" "code or c moves to the source for the procedure.\n" "\n" "file opens the file containing the procedure's source code,\nif known.\nSee the description of the continuation file entry above for more\ninformation.\n" "\n" "length or l displays the number of free variables\nwhose values are recorded in the procedure object.\n" "\n" "ref or r moves to the nth or named\nfree variable.  n defaults to 0.\nIf multiple free variables have the same name, only one is\naccessible by name, and the others must be accessed by number.\n" "\n" "set! or ! n e sets the value of the nth free variable\nto e, if the variable is assignable.\nn defaults to 0.\n" "\n" "eval or e expr evaluates the expression\nexpr in an environment containing bindings for the free variables\nof the procedure.\nWithin the evaluated expression, the value of each free variable\nn is accessible via the variable %n.\nNamed free variables are accessible via their names as well.\nNames are available only if generation of inspector information was\nenabled during compilation of the corresponding lambda expression.\n\n" "\n" "Pair (list) commands" "" "show or s n shows the first n elements of the list.\nIf n is not specified, all elements are displayed.\n" "\n" "length or l displays the list length.\n" "\n" "car moves to the object in the car of the current object.\n" "\n" "cdr moves to the object in the cdr.\n" "\n" "ref or r n moves to the nth element of the list.\nn defaults to 0.\n" "\n" "tail n moves to the nth cdr of the list.\nn defaults to 1.\n\n" "\n" "Vector, Bytevector, and Fxvector commands" "" "show or s n shows the first n elements of the vector.\nIf n is not specified, all elements are displayed.\n" "\n" "length or l displays the vector length.\n" "\n" "ref or r n moves to the nth element of the vector.\nn defaults to 0.\n\n" "\n" "String commands" "" "show or s n shows the first n elements of the string.\nIf n is not specified, all elements are displayed.\n" "\n" "length or l displays the string length.\n" "\n" "ref or r n moves to the nth element of the string.\nn defaults to 0.\n" "\n" "unicode n displays the first n elements of the string\nas hexadecimal Unicode scalar values.\n" "\n" "ascii n displays the first n elements of the string\nas hexadecimal ASCII values, using -- to denote characters whose Unicode\nscalar values are not in the ASCII range.\n\n" "\n" "Symbol commands" "" "show or s shows the fields of the symbol.\n" "\n" "value or v moves to the top-level value of the symbol.\n" "\n" "name or n moves to the name of the symbol.\n" "\n" "property-list or pl moves to the property list\nof the symbol.\n" "\n" "ref or r n moves to the nth field of the symbol.\nField 0 is the top-level value of the symbol, field 1 \nis the symbol's name, and field 2 is its property list.\nn defaults to 0.\n\n\n" "\n" "Character commands" "" "unicode displays the hexadecimal Unicode scalar value for\nthe character.\n" "\n" "ascii displays the hexadecimal ASCII code for the character,\nusing -- to denote characters whose Unicode scalar values are not\nin the ASCII range.\n\n" "\n" "Box commands" "" "show or s shows the contents of the box.\n" "\n" "unbox or ref or r moves to the boxed object.\n\n" "\n" "Port commands" "" "show or s shows the fields of the port, including\nthe input and output size, index, and buffer fields.\n" "\n" "name moves to the port's name.\n" "\n" "handler moves to the port's handler.\n" "\n" "output-buffer or ob moves to the port's output buffer.\n" "\n" "input-buffer or ib moves to the port's input buffer.\n\n" "\n" "Record commands" "" "show or s shows the contents of the record.\n" "\n" "fields moves to the list of field names\nof the record.\n" "\n" "name moves to the name of the record.\n" "\n" "rtd moves to the record-type descriptor of the record.\n" "\n" "ref or r name moves to the named field of the\nrecord, if accessible.\n" "\n" "set! or ! name value sets the value\nof the named field of the record, if mutable.\n\n" "\n" "Transport Link Cell (TLC) commands" "" "show or s shows the fields of the TLC.\n" "\n" "keyval moves to the keyval of the TLC.\n" "\n" "tconc moves to the tconc of the TLC.\n" "\n" "next moves to the next link of the TLC.\n" "\n" "ref or r n moves to the nth field of the symbol.\nField 0 is the keyval, field 1 the tconc, and field 2 the next link.\nn defaults to 0.\n\n") ("debug:s25" "\nprocedure: (inspect/object object)\nreturns: an inspector object procedure\nlibraries: (chezscheme)\n" "inspect/object is used to turn an ordinary Scheme object into an\ninspector object.\nAll inspector objects accept the messages type, print,\nwrite, and size.\nThe type message returns a symbolic representation of the type of\nthe object.\nThe print and write messages must be accompanied by a port\nparameter.\nThey cause a representation of the object to be written to the port,\nusing the Scheme procedures pretty-print and write.\nThe size message returns a fixnum representing the size\nin bytes occupied by the object, including any objects accessible\nfrom the current object except those for which the size was already\nrequested via an inspector object derived from the argument of the\nsame inspect/object call.\n" "\nAll inspector objects except for variable inspector objects accept\nthe message value, which returns the actual object encapsulated\nin the inspector object.\n" "\n" "(define x (inspect/object '(1 2 3)))\n(x 'type) --> pair\n(define p (open-output-string))\n(x 'write p)\n(get-output-string p) --> \"(1 2 3)\"\n(x 'length) --> (proper 3)\n(define y (x 'car))\n(y 'type) --> simple\n(y 'value) --> 1\n" "\n" "\n\n" "\n" "Pair inspector objects.\nPair inspector objects contain Scheme pairs.\n" "\n" "(pair-object 'type)\nreturns the symbol pair.\n" "\n" "(pair-object 'car)\nreturns an inspector object containing the \"car\" field of the pair.\n" "\n" "(pair-object 'cdr)\nreturns an inspector object containing the \"cdr\" field of the pair.\n" "\n" "(pair-object 'length)\nreturns a list of the form (type count).\nThe type field contains the symbol proper, the symbol improper, or\nthe symbol circular, depending on the structure of the list.\nThe count field contains the number of distinct pairs in the list.\n" "\n" "Box inspector objects.\nBox inspector objects contain Chez Scheme boxes.\n" "\n" "(box-object 'type)\nreturns the symbol box.\n" "\n" "(box-object 'unbox)\nreturns an inspector object containing the contents of the box.\n" "\n" "TLC inspector objects.\nBox inspector objects contain Chez Scheme boxes.\n" "\n" "(tlc-object 'type)\nreturns the symbol tlc.\n" "\n" "(tlc-object 'keyval)\nreturns an inspector object containing the TLC's keyval.\n" "\n" "(tlc-object 'tconc)\nreturns an inspector object containing the TLC's tconc.\n" "\n" "(tlc-object 'next)\nreturns an inspector object containing the TLC's next link.\n" "\n" "Vector, String, Bytevector, and Fxvector inspector objects.\nVector (bytevector, string, fxvector) inspector objects contain Scheme\nvectors (bytevectors, strings, fxvectors).\n" "\n" "(vector-object 'type)\nreturns the symbol vector (string, bytevector, fxvector).\n" "\n" "(vector-object 'length)\nreturns the number of elements in the vector or string.\n" "\n" "(vector-object 'ref n)\nreturns an inspector object containing the nth element of the\nvector or string.\n" "\n" "Simple inspector objects.\nSimple inspector objects contain unstructured, unmodifiable objects.\nThese include numbers, booleans, the empty list, the end-of-file\nobject, and the void object.\nThey may be examined directly by asking for the value of the object.\n" "\n" "(simple-object 'type)\nreturns the symbol simple.\n" "\n" "Unbound inspector objects.\nAlthough unbound objects are not normally accessible to Scheme programs,\nthey may be encountered when inspecting variables.\n" "\n" "(unbound-object 'type)\nreturns the symbol unbound.\n" "\n" "Procedure inspector objects.\nProcedure inspector objects contain Scheme procedures.\n" "\n" "(procedure-object 'type)\nreturns the symbol procedure.\n" "\n" "(procedure-object 'length)\nreturns the number of free variables.\n" "\n" "(procedure-object 'ref n)\nreturns an inspector object containing the nth free variable of the\nprocedure.\nSee the description below of variable inspector objects.\nn must be nonnegative and less than the length of the procedure.\n" "\n" "(procedure-object 'eval expr)\nevaluates expr and returns its value.\nThe values of the procedure's free variables are bound within the\nevaluated expression to\nidentifiers of the form %n, where n is the location number\ndisplayed by the inspector.\nThe values of named variables are also bound to their names.\n" "\n" "(procedure-object 'code)\nreturns an inspector object containing the procedure's code object.\nSee the description below of code inspector objects.\n\n" "\n" "Continuation inspector objects.\nContinuations created by call/cc are actually\nprocedures.\nHowever, when inspecting such a procedure the underlying data structure\nthat embodies the continuation may be exposed.\nA continuation structure contains the location at which computation is\nto resume, the variable values necessary to perform the computation,\nand a link to the next continuation.\n" "\n" "(continuation-object 'type)\nreturns the symbol continuation.\n" "\n" "(continuation-object 'length)\nreturns the number of free variables.\n" "\n" "(continuation-object 'ref n)\nreturns an inspector object containing the nth free variable of the\ncontinuation.\nSee the description below of variable inspector objects.\nn must be nonnegative and less than the length of the continuation.\n" "\n" "(continuation-object 'eval expr)\nevaluates expr and returns its value.\nThe values of frame locations are bound within the\nevaluated expression to\nidentifiers of the form %n, where n is the location number\ndisplayed by the inspector.\nThe values of named locations are also bound to their names.\n" "\n" "(continuation-object 'code)\nreturns an inspector object containing the code object for the procedure\nthat was active when the current continuation frame was created.\nSee the description below of code inspector objects.\n" "\n" "(continuation-object 'depth)\nreturns the number of frames in the continuation.\n" "\n" "(continuation-object 'link)\nreturns an inspector object containing the next continuation frame.\nThe depth must be greater than 1.\n" "\n" "(continuation-object 'link* n)\nreturns an inspector object containing the nth continuation link.\nn must be less than the depth.\n" "\n" "(continuation-object 'source)\nreturns an inspector object containing the source information attached\nto the continuation (representing the source for the application that\nresulted in the formation of the continuation)\nor #f if no source information is attached.\n" "\n" "(continuation-object 'source-object)\nreturns an inspector object containing the source object for the\nprocedure application that resulted in the formation of the continuation\nor #f if no source object is attached.\n" "\n" "(continuation-object 'source-path)\nattempts to find the pathname of the file containing the source for\nthe procedure application that resulted in the formation of the continuation.\nIf successful, three values are returned to identify the file and position\nof the application within the file: path, line, and char.\nTwo values, a file name and an absolute character position, are returned\nif the file name is known but the named file cannot be found.\nThe search may be unsuccessful even if a file by the expected\nname is found in the path if the file has been modified since the source\ncode was compiled.\nIf no file name is known, no values are returned.\nThe parameter source-directories (Section 12.5)\ndetermines the set of directories\nsearched for source files identified by relative path names.\n\n" "\n" "Code inspector objects.\nCode inspector objects contain Chez Scheme code objects.\n" "\n" "(code-object 'type)\nreturns the symbol code.\n" "\n" "(code-object 'name)\nreturns a string or #f.\nThe name associated with a code inspector object is the name of the\nvariable to which the procedure was originally bound or assigned.\nSince the binding of a variable can be changed, this name association\nmay not always be accurate.\n#f is returned if the inspector cannot determine a name for the\nprocedure.\n" "\n" "(code-object 'source)\nreturns an inspector object containing the source information attached\nto the code object or #f if no source information is attached.\n" "\n" "(continuation-object 'source-object)\nreturns an inspector object containing the source object for the\ncode object or #f if no source object is attached.\n" "\n" "(code-object 'source-path)\nattempts to find the pathname of the file containing the source for\nthe lambda expression that produced the code object.\nIf successful, three values are returned to identify the file and position\nof the application within the file: path, line, and char.\nTwo values, a file name and an absolute character position, are returned\nif the file name is known but the named file cannot be found.\nThe search may be unsuccessful even if a file by the expected\nname is found in the path if the file has been modified since the source\ncode was compiled.\nIf no file name is known, no values are returned.\nThe parameter source-directories (Section 12.5)\ndetermines the set of directories\nsearched for source files identified by relative path names.\n" "\n" "(code-object 'free-count)\nreturns the number of free variables in any procedure for which this is\nthe corresponding code.\n\n" "\n" "Variable inspector objects.\nVariable inspector objects encapsulate variable bindings.\nAlthough the actual underlying representation varies, the variable\ninspector object provides a uniform interface.\n" "\n" "(variable-object 'type)\nreturns the symbol variable.\n" "\n" "(variable-object 'name)\nreturns a symbol or #f.\n#f is returned if the name is not available or if the variable is a\ncompiler-generated temporary variable.\nVariable names are not retained when the parameter\ngenerate-inspector-information\n(page 12.6)\nis false during compilation.\n" "\n" "(variable-object 'ref)\nreturns an inspector object containing the current value of the\nvariable.\n" "\n" "(variable-object 'set! e)\nreturns unspecified, after setting the current value of the\nvariable to e.\nAn exception is raised with condition type &assertion if the variable is not assignable.\n\n" "\n" "Port inspector objects.\nPort inspector objects contain ports.\n" "\n" "(port-object 'type)\nreturns the symbol port.\n" "\n" "(port-object 'input?)\nreturns #t if the port is an input port, #f otherwise.\n" "\n" "(port-object 'output?)\nreturns #t if the port is an output port, #f otherwise.\n" "\n" "(port-object 'binary?)\nreturns #t if the port is a binary port, #f otherwise.\n" "\n" "(port-object 'closed?)\nreturns #t if the port is closed, #f if the port is open.\n" "\n" "(port-object 'name)\nreturns an inspector object containing the port's name.\n" "\n" "(port-object 'handler)\nreturns a procedure inspector object encapsulating the port handler,\nsuch as would be returned by port-handler.\n" "\n" "(port-object 'output-size)\nreturns the output buffer size as a fixnum if the port is an\noutput port (otherwise the value is unspecified).\n" "\n" "(port-object 'output-index)\nreturns the output buffer index as a fixnum if the port is an\noutput port (otherwise the value is unspecified).\n" "\n" "(port-object 'output-buffer)\nreturns an inspector object containing the string used for buffered\noutput.\n" "\n" "(port-object 'input-size)\nreturns the input buffer size as a fixnum if the port is an\ninput port (otherwise the value is unspecified).\n" "\n" "(port-object 'input-index)\nreturns the input buffer index as a fixnum if the port is an\ninput port (otherwise the value is unspecified).\n" "\n" "(port-object 'input-buffer)\nreturns an inspector object containing the string used for buffered\ninput.\n\n" "\n" "Symbol inspector objects.\nSymbol inspector objects contain symbols.\nThese include gensyms.\n" "\n" "(symbol-object 'type)\nreturns the symbol symbol.\n" "\n" "(symbol-object 'name)\nreturns a string inspector object.\nThe string name associated with a symbol inspector object is the print\nrepresentation of a symbol, such as would be returned by the procedure\nsymbol->string.\n" "\n" "(symbol-object 'gensym?)\nreturns #t if the symbol is a gensym, #f otherwise.\nGensyms are created by gensym.\n" "\n" "(symbol-object 'top-level-value)\nreturns an inspector object containing the global value of the symbol.\n" "\n" "(symbol-object 'property-list)\nreturns an inspector object containing the property list for the\nsymbol.\n\n" "\n" "Record inspector objects.\nRecord inspector objects contain records.\n" "\n" "(record-object 'type)\nreturns the symbol record.\n" "\n" "(record-object 'name)\nreturns a string inspector object corresponding to the name of\nthe record type.\n" "\n" "(record-object 'fields)\nreturns an inspector object containing a list of the field names of\nthe record type.\n" "\n" "(record-object 'length)\nreturns the number of fields.\n" "\n" "(record-object 'rtd)\nreturns an inspector object containing the record-type descriptor of the\nrecord type.\n" "\n" "(record-object 'accessible? name)\nreturns #t if the named field is accessible, #f otherwise.\nA field may be inaccessible if optimized away by the compiler.\n" "\n" "(record-object 'ref name)\nreturns an inspector object containing the value of the named field.\nAn exception is raised with condition type &assertion if the named field is not accessible.\n" "\n" "(record-object 'mutable? name)\nreturns #t if the named field is mutable, #f otherwise.\nA field is immutable if it is not declared mutable or if the compiler\noptimizes away all assignments to the field.\n" "\n" "(record-object 'set! name value)\nsets the value of the named field to value.\nAn exception is raised with condition type &assertion if the named field is not assignable.\n") ("debug:s26" "\nprocedure: (make-object-finder pred)\nprocedure: (make-object-finder pred g)\nprocedure: (make-object-finder pred x g)\nreturns: see below\nlibraries: (chezscheme)\n" "The procedure make-object-finder takes a predicate pred and two optional\narguments: a starting point x and a maximum generation g.\nThe starting point defaults to the value of the procedure oblist,\nand the maximum generation defaults to the value of the parameter\ncollect-maximum-generation.\nmake-object-finder returns an object finder p that can be used to\nsearch for objects satisfying pred within the starting-point object x.\nImmediate objects and objects in generations older than g are treated\nas leaves.\np is a procedure accepting no arguments.\nIf an object y satisfying pred can be found starting with x,\np returns a list whose first element is y and whose remaining\nelements represent the path of objects from x to y, listed\nin reverse order.\np can be invoked multiple times to find additional objects satisfying\nthe predicate, if any.\np returns #f if no more objects matching the predicate\ncan be found.\n" "\np maintains internal state recording where it has been so it\ncan restart at the point of the last found object and not return\nthe same object twice.\nThe state can be several times the size of the starting-point object\nx and all that is reachable from x.\n" "\nThe interactive inspector provides a convenient interface to the object\nfinder in the form of find and find-next commands.\n" "\nRelocation tables for static code objects are discarded by default, which\nprevents object finders from providing accurate results when static code\nobjects are involved.\nThat is, they will not find any objects pointed to directly from a code\nobject that has been promoted to the static generation.\nIf this is a problem, the command-line argument\n--retain-static-relocation\ncan be used to prevent the relocation tables from being discarded.\n\n") ("debug:s30" "\nprocedure: (compute-size object)\nprocedure: (compute-size object generation)\nreturns: see below\nlibraries: (chezscheme)\n" "object can be any object.\ngeneration must be a fixnum between 0 and the value of\ncollect-maximum-generation, inclusive, or the symbol\nstatic.\nIf generation is not supplied, it defaults to the value of\ncollect-maximum-generation.\n" "\ncompute-size returns the amount of memory, in bytes, occupied by\nobject and anything reachable from object in any generation\nless than or equal to generation.\nImmediate values such as fixnums, booleans, and characters have zero size.\n" "\nThe following examples are valid for machines with 32-bit pointers.\n" "\n" "(compute-size 0) --> 0\n(compute-size (cons 0 0)) --> 8\n(compute-size (cons (vector #t #f) 0)) --> 24\n\n(compute-size\n  (let ([x (cons 0 0)])\n    (set-car! x x)\n    (set-cdr! x x)\n    x))                  --> 8\n\n(define-record-type frob (fields x))\n(collect 1 1) ; force rtd into generation 1\n(compute-size\n  (let ([x (make-frob 0)])\n    (cons x x))\n  0)                       --> 16\n") ("debug:s31" "\nprocedure: (compute-composition object)\nprocedure: (compute-composition object generation)\nreturns: see below\nlibraries: (chezscheme)\n" "object can be any object.\ngeneration must be a fixnum between 0 and the value of\ncollect-maximum-generation, inclusive, or the symbol\nstatic.\nIf generation is not supplied, it defaults to the value of\ncollect-maximum-generation.\n" "\ncompute-composition returns an association list representing\nthe composition of object, including anything reachable from it\nin any generation less than or equal to generation.\nThe association list has the following structure:\n" "\n" "((type count . bytes) ...)\n" "type is either the name of a primitive type, represented as a\nsymbol, e.g., pair, or a record-type descriptor (rtd).\ncount and bytes are nonnegative fixnums.\n" "\nImmediate values such as fixnums, booleans, and characters are not\nincluded in the composition.\n" "\nThe following examples are valid for machines with 32-bit pointers.\n" "\n" "(compute-composition 0) --> ()\n(compute-composition (cons 0 0)) --> ((pair 1 . 8))\n(compute-composition\n  (cons (vector #t #f) 0)) --> ((pair 1 . 8) (vector 1 . 16))\n\n(compute-composition\n  (let ([x (cons 0 0)])\n    (set-car! x x)\n    (set-cdr! x x)\n    x))                 --> ((pair 1 . 8)\n\n(define-record-type frob (fields x))\n(collect 1 1) ; force rtd into generation 1\n(compute-composition\n  (let ([x (make-frob 0)])\n    (cons x x))\n  0)                       --> ((pair 1 . 8)\n                                (#<record type frob> 1 . 8))\n") ("binding:s15" "\nthread parameter: internal-defines-as-letrec*\nlibraries: (chezscheme)\n" "When this parameter is set to #t (the default), internal variable\ndefinitions are evaluated using letrec* semantics.\nIt may be set to #f to revert to the letrec semantics\nfor internal variable definitions, for backward compatibility.\n\n") ("binding:s16" "\nsyntax: (define-values formals expr)\nlibraries: (chezscheme)\n" "A define-values form is a definition and can appear anywhere\nother definitions can appear.\nIt is like a define form but permits an arbitrary formals list\n(like lambda) on the left-hand side.\nIt evaluates expr and binds the variables appearing in formals\nto the resulting values, in the same manner as the formal parameters of a\nprocedure are bound to its arguments.\n" "\n" "(let ()\n  (define-values (x y) (values 1 2))\n  (list x y)) --> (1 2)\n(let ()\n  (define-values (x y . z) (values 1 2 3 4))\n  (list x y z)) --> (1 2 (3 4))\n" "A define-values form expands into a sequence of definitions, the\nfirst for a hidden temporary bound to a data structure holding the values\nreturned by expr and the remainder binding each of the formals to\nthe corresponding value or list of values, extracted from the data\nstructure via a reference to the temporary.\nBecause the temporary must be defined before the other variables are\ndefined, this works for internal define-values forms only if\ninternal-defines-as-letrec* is set to the default value\n#t.\n\n") ("binding:s17" "\nsyntax: (rec var expr)\nreturns: value of expr\nlibraries: (chezscheme)\n" "The syntactic form rec creates a recursive object from expr by\nestablishing a binding of var within expr to the value of expr.\nIn essence, it is a special case of letrec for self-recursive objects.\n" "\nThis form is useful for creating recursive objects (especially procedures)\nthat do not depend on external variables for the recursion, which are\nsometimes undesirable because the external bindings can change.\nFor example, a recursive procedure defined at top level depends on the value\nof the top-level variable given as its name.\nIf the value of this variable should change, the meaning of the procedure\nitself would change.\nIf the procedure is defined instead with rec, its meaning is independent\nof the variable to which it is bound.\n" "\n" "(map (rec sum\n       (lambda (x)\n         (if (= x 0)\n             0\n             (+ x (sum (- x 1))))))\n     '(0 1 2 3 4 5)) --> (0 1 3 6 10 15)\n\n(define cycle\n  (rec self\n    (list (lambda () self))))\n\n(eq? ((car cycle)) cycle) --> #t\n" "The definition below expands rec in terms of letrec.\n" "\n" "(define-syntax rec\n  (syntax-rules ()\n    [(_ x e) (letrec ((x e)) x)]))\n") ("binding:s19" "\nsyntax: (fluid-let ((var expr) ...) body1 body2 ...)\nreturns: the values of the body body1 body2 ...\nlibraries: (chezscheme)\n" "The syntactic form fluid-let\nprovides a way to temporarily assign values to a set of variables.\nThe new values are in effect only during the evaluation of the\nbody of the fluid-let expression.\nThe scopes of the variables are not determined by fluid-let; as with\nset!, the variables must be bound at top level or by an enclosing\nlambda or other binding form.\nIt is possible, therefore, to control the scope of a variable with\nlambda or let while establishing a temporary\nvalue with fluid-let.\n" "\nAlthough it is similar in appearance to let, its operation is more\nlike that of set!.\nEach var is assigned, as with set!, to the value of the\ncorresponding expr within the body body1 body2 ....\nShould the body\nexit normally or by invoking a continuation made outside of the body\n(see call/cc), the values in effect before the bindings were changed\nare restored.\nShould control return back to the body by the invocation of a continuation\ncreated within the body, the bindings are changed once again to the values\nin effect when the body last exited.\n" "\nFluid bindings are most useful for\nmaintaining variables that must be shared by a group of procedures.\nUpon entry to the group of procedures, the shared variables are fluidly\nbound to a new set of initial values so that on exit the original values\nare restored automatically.\nIn this way, the group of procedures itself can be reentrant; it may call\nitself directly or indirectly without affecting the values of its shared\nvariables.\n" "\nFluid bindings are similar to\nspecial bindings in Common Lisp [citation30], except that\n(1) there is a single namespace for both lexical and fluid bindings, and\n(2) the scope of a fluidly bound variable is not necessarily global.\n" "\n" "(let ([x 3])\n  (+ (fluid-let ([x 5])\n       x)\n     x)) --> 8\n\n(let ([x 'a])\n  (letrec ([f (lambda (y) (cons x y))])\n    (fluid-let ([x 'b])\n      (f 'c)))) --> (b . c)\n\n(let ([x 'a])\n  (call/cc\n    (lambda (k)\n       (fluid-let ([x 'b])\n         (letrec ([f (lambda (y) (k '*))])\n           (f '*)))))\n  x) --> a\n" "fluid-let may be defined in terms of dynamic-wind as follows.\n" "\n" "(define-syntax fluid-letdefn:fluid-let\n  (lambda (x)\n    (syntax-case x ()\n      [(_ () b1 b2 ...) #'(let () b1 b2 ...)]\n      [(_ ((x e) ...) b1 b2 ...)\n       (andmap identifier? #'(x ...))\n       (with-syntax ([(y ...) (generate-temporaries #'(x ...))])\n         #'(let ([y e] ...)\n             (let ([swap (lambda ()\n                           (let ([t x]) (set! x y) (set! y t))\n                           ...)])\n               (dynamic-wind swap (lambda () b1 b2 ...) swap))))])))\n") ("binding:s24" "\nprocedure: (define-top-level-value symbol obj)\nprocedure: (define-top-level-value symbol obj env)\nreturns: unspecified\nlibraries: (chezscheme)\n" "define-top-level-value is used to establish a binding\nfor the variable named by symbol to the value obj\nin the environment env.\nIf env is not provided, it defaults to the\nvalue of interaction-environment, i.e., the\ntop-level evaluation environment\n(Section 12.3).\n" "\nAn exception is raised with condition type &assertion if\nenv is not mutable.\n" "\nA call to define-top-level-value is similar to a top-level\ndefine form, except that a call to\ndefine-top-level-value need not occur at top-level and\nthe variable for which the binding is to be established can be\ndetermined at run time, as can the environment.\n" "\n" "(begin\n  (define-top-level-value 'xyz \"hi\")\n  xyz) --> \"hi\"\n\n(let ([var 'xyz])\n  (define-top-level-value var \"mom\")\n  (list var xyz)) --> (xyz \"mom\")\n") ("binding:s26" "\nprocedure: (set-top-level-value! symbol obj)\nprocedure: (set-top-level-value! symbol obj env)\nreturns: unspecified\nlibraries: (chezscheme)\n" "set-top-level-value! assigns \nthe variable named by symbol to the value obj\nin the environment env.\nIf env is not provided, it defaults to the\nvalue of interaction-environment, i.e., the\ntop-level evaluation environment\n(Section 12.3).\n" "\nAn exception is raised with condition type &assertion if the\nidentifier named by symbol is not defined as a variable in env\nor if the variable or environment is not mutable.\n" "\nset-top-level-value! is similar to\nset! when set!\nis used on top-level variables except that the variable to be assigned\ncan be determined at run time, as can the environment.\n" "\n" "(let ([v (let ([cons list])\n           (set-top-level-value! 'cons +)\n           (cons 3 4))])\n  (list v (cons 3 4))) --> ((3 4) 7)\n") ("binding:s29" "\nprocedure: (top-level-value symbol)\nprocedure: (top-level-value symbol env)\nreturns: the top-level value of the variable named by symbol in env\nlibraries: (chezscheme)\n" "If env is not provided, it defaults to the\nvalue of interaction-environment, i.e., the\ntop-level evaluation environment\n(Section 12.3).\n" "\nAn exception is raised with condition type &assertion if the\nidentifier named by symbol is not defined as a variable in env.\n" "\ntop-level-value is similar to a top-level variable reference\nexcept that the variable to be referenced can be determined at run time,\nas can the environment.\n" "\n" "(let ([cons +])\n  (list (cons 3 4)\n        ((top-level-value 'cons) 3 4))) --> (7 (3 . 4))\n\n(define e (copy-environment (scheme-environment)))\n(define-top-level-value 'pi 3.14 e)\n(top-level-value 'pi e) --> 3.14\n(set-top-level-value! 'pi 3.1416 e)\n(top-level-value 'pi e) --> 3.1416\n") ("binding:s30" "\nprocedure: (top-level-bound? symbol)\nprocedure: (top-level-bound? symbol env)\nreturns: #t if symbol is defined as a variable in env, #f otherwise\nlibraries: (chezscheme)\n" "If env is not provided, it defaults to the\nvalue of interaction-environment, i.e., the\ntop-level evaluation environment\n(Section 12.3).\n" "\nThis predicate is useful in an interpreter to check for the existence of\na top-level binding before requesting the value with\ntop-level-value.\n" "\n" "(top-level-bound? 'xyz) --> #f\n\n(begin\n  (define-top-level-value 'xyz 3)\n  (top-level-bound? 'xyz)) --> #t\n\n(define e (copy-environment (interaction-environment)))\n(define-top-level-value 'pi 3.14 e)\n(top-level-bound? 'pi) --> #f\n(top-level-bound? 'pi e) --> #t\n") ("binding:s31" "\nprocedure: (top-level-mutable? symbol)\nprocedure: (top-level-mutable? symbol env)\nreturns: #t if symbol is mutable in env, #f otherwise\nlibraries: (chezscheme)\n" "If env is not provided, it defaults to the\nvalue of interaction-environment, i.e., the\ntop-level evaluation environment\n(Section 12.3).\n" "\nThis predicate is useful in an interpreter to check whether a variable\ncan be assigned before assigning it with\nset-top-level-value!.\n" "\n" "(define xyz 3)\n(top-level-mutable? 'xyz) --> #t\n(set-top-level-value! 'xyz 4)\n(top-level-value 'xyz) --> 4\n\n(define e (copy-environment (interaction-environment) #f))\n(top-level-mutable? 'xyz e) --> #f\n(set-top-level-value! 'xyz e) --> exception: xyz is immutable\n") ("binding:s32" "\nprocedure: (define-top-level-syntax symbol obj)\nprocedure: (define-top-level-syntax symbol obj env)\nreturns: unspecified\nlibraries: (chezscheme)\n" "define-top-level-syntax is used to establish a top-level binding\nfor the identifier named by symbol to the value of obj\nin the environment env.\nThe value must be a procedure, the result of a call to\nmake-variable-transformer, or the result of a call to\ntop-level-syntax.\nIf env is not provided, it defaults to the\nvalue of interaction-environment, i.e., the\ntop-level evaluation environment\n(Section 12.3).\n" "\nAn exception is raised with condition type &assertion if\nenv is not mutable.\n" "\nA call to define-top-level-syntax is similar to a top-level\ndefine-syntax form, except that a call to\ndefine-top-level-syntax need not occur at top-level and\nthe identifier for which the binding is to be established can be\ndetermined at run time, as can the environment.\n" "\n" "(define-top-level-syntax 'let1\n  (syntax-rules ()\n    [(_ x e b1 b2 ...) (let ([x e]) b1 b2 ...)]))\n(let1 a 3 (+ a 1)) --> 4\n" "define-top-level-syntax can also be used to attach\nto an identifier arbitrary compile-time bindings obtained \nvia top-level-syntax.\n") ("binding:s34" "\nprocedure: (top-level-syntax symbol)\nprocedure: (top-level-syntax symbol env)\nreturns: unspecified\nlibraries: (chezscheme)\n" "top-level-syntax is used to retrieve the transformer, compile-time\nvalue, or other compile-time binding to which\nthe identifier named by symbol is bound in the environment env.\nIf env is not provided, it defaults to the\nvalue of interaction-environment, i.e., the\ntop-level evaluation environment\n(Section 12.3).\nAll identifiers bound in an environment have compile-time bindings, including\nvariables.\n" "\nAn exception is raised with condition type &assertion if the\nidentifier named by symbol is not defined as a keyword in env.\n" "\n" "(define-top-level-syntax 'also-let (top-level-syntax 'let))\n(also-let ([x 3] [y 4]) (+ x y)) --> 7\n\n(define foo 17)\n(define-top-level-syntax 'also-foo (top-level-syntax 'foo))\nalso-foo --> 17\n(set! also-foo 23)\nalso-foo --> 23\nfoo --> 23\n" "The effect of the last example can be had more clearly with alias:\n" "\n" "(define foo 17)\n(alias also-foo foo)\nalso-foo --> 17\n(set! also-foo 23)\nalso-foo --> 23\nfoo --> 23\n") ("binding:s35" "\nprocedure: (top-level-syntax? symbol)\nprocedure: (top-level-syntax? symbol env)\nreturns: #t if symbol is bound as a keyword in env, #f otherwise\nlibraries: (chezscheme)\n" "If env is not provided, it defaults to the\nvalue of interaction-environment, i.e., the\ntop-level evaluation environment\n(Section 12.3).\n" "\nAll identifiers bound in an environment have compile-time bindings, including\nvariables, so this predicate amounts to a bound check, but is more general\nthan top-level-bound?, which returns true only for bound variables.\n" "\n" "(define xyz 'hello)\n(top-level-syntax? 'cons) --> #t\n(top-level-syntax? 'lambda) --> #t\n(top-level-syntax? 'hello) --> #t\n\n(top-level-syntax? 'cons (scheme-environment)) --> #t\n(top-level-syntax? 'lambda (scheme-environment)) --> #t\n(top-level-syntax? 'hello (scheme-environment)) --> #f\n") ("numeric:s11" "\nprocedure: (bignum? obj)\nreturns: #t if obj is a bignum, otherwise #f\nlibraries: (chezscheme)\n" "\n" "\n(bignum? 0) --> #f\n(bignum? (most-positive-fixnum)) --> #f\n(bignum? (most-negative-fixnum)) --> #f\n(bignum? (* (most-positive-fixnum) 2)) --> #t\n(bignum? 3/4) --> #f\n(bignum? 'a) --> #f\n") ("numeric:s12" "\nprocedure: (ratnum? obj)\nreturns: #t if obj is a ratnum, otherwise #f\nlibraries: (chezscheme)\n" "\n" "\n(ratnum? 0) --> #f\n(ratnum? (* (most-positive-fixnum) 2)) --> #f\n(ratnum? 3/4) --> #t\n(ratnum? -10/2) --> #f\n(ratnum? -11/2) --> #t\n(ratnum? 'a) --> #f\n") ("numeric:s13" "\nprocedure: (cflonum? obj)\nreturns: #t if obj is an inexact complexnum or flonum, otherwise #f\nlibraries: (chezscheme)\n" "\n" "\n(cflonum? 0) --> #f\n(cflonum? 0.0) --> #t\n(cflonum? 3+4i) --> #f\n(cflonum? 3.0+4i) --> #t\n(cflonum? +i) --> #f\n(cflonum? +1.0i) --> #t\n") ("numeric:s14" "\nprocedure: (most-positive-fixnum)\nreturns: the most positive fixnum supported by the system\nprocedure: (most-negative-fixnum)\nreturns: the most negative fixnum supported by the system\nlibraries: (chezscheme)\n" "These procedures are identical to the Revised6 Report\ngreatest-fixnum and least-fixnum procedures.\n\n") ("numeric:s15" "\nprocedure: (fx= fixnum1 fixnum2 ...)\nprocedure: (fx< fixnum1 fixnum2 ...)\nprocedure: (fx> fixnum1 fixnum2 ...)\nprocedure: (fx<= fixnum1 fixnum2 ...)\nprocedure: (fx>= fixnum1 fixnum2 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (chezscheme)\n" "The predicate fx= returns #t if its arguments are equal.\nThe predicate fx< returns #t if its arguments are monotonically\nincreasing, i.e., each argument is greater than the preceding ones,\nwhile fx> returns #t if its arguments are monotonically decreasing.\nThe predicate fx<= returns #t if its arguments are monotonically\nnondecreasing, i.e., each argument is not less than the preceding ones,\nwhile fx>= returns #t if its arguments are monotonically nonincreasing.\nWhen passed only one argument, each of these predicates returns #t.\n" "\nThese procedures are similar to the Revised6 Report procedures\nfx=?, fx<?, fx>?, fx<=?,\nand fx>=? except that the Revised6 Report procedures\nrequire two or more arguments, and their names have the \"?\"\nsuffix.\n" "\n" "(fx= 0) --> #t\n(fx= 0 0) --> #t\n(fx< (most-negative-fixnum) 0 (most-positive-fixnum)) --> #t\n(let ([x 3]) (fx<= 0 x 9)) --> #t\n(fx<= 0 3 3) --> #t\n(fx>= 0 0 (most-negative-fixnum)) --> #t\n") ("numeric:s16" "\nprocedure: (fxnonpositive? fixnum)\nreturns: #t if fixnum is not greater than zero, #f otherwise\nprocedure: (fxnonnegative? fixnum)\nreturns: #t if fixnum is not less than zero, #f otherwise\nlibraries: (chezscheme)\n" "fxnonpositive? is equivalent to (lambda (x) (fx<= x 0)),\nand\nfxnonnegative? is equivalent to (lambda (x) (fx>= x 0)).\n" "\n" "(fxnonpositive? 128) --> #f\n(fxnonpositive? 0) --> #t\n(fxnonpositive? -1) --> #t\n\n(fxnonnegative? -65) --> #f\n(fxnonnegative? 0) --> #t\n(fxnonnegative? 1) --> #t\n") ("numeric:s17" "\nprocedure: (fx+ fixnum ...)\nreturns: the sum of the arguments fixnum ...\nlibraries: (chezscheme)\n" "When called with no arguments, fx+ returns 0.\n" "\n" "(fx+) --> 0\n(fx+ 1 2) --> 3\n(fx+ 3 4 5) --> 12\n(apply fx+ '(1 2 3 4 5)) --> 15\n") ("numeric:s18" "\nprocedure: (fx- fixnum1 fixnum2 ...)\nreturns: a fixnum\nlibraries: (chezscheme)\n" "When called with one argument, fx- returns the negative of fixnum1.\nThus, (fx- fixnum1) is an idiom for (fx- 0 fixnum1).\n" "\nWhen called with two or more arguments, fx- returns the result of\nsubtracting the sum of the numbers fixnum2 ... from\nfixnum1.\n" "\n" "(fx- 3) --> -3\n(fx- 4 3) --> 1\n(fx- 4 3 2 1) --> -2\n") ("numeric:s19" "\nprocedure: (fx* fixnum ...)\nreturns: the product of the arguments fixnum ...\nlibraries: (chezscheme)\n" "When called with no arguments, fx* returns 1.\n" "\n" "(fx*) --> 1\n(fx* 1 2) --> 2\n(fx* 3 -4 5) --> -60\n(apply fx* '(1 -2 3 -4 5)) --> 120\n") ("numeric:s20" "\nprocedure: (fx/ fixnum1 fixnum2 ...)\nreturns: see explanation\nlibraries: (chezscheme)\n" "When called with one argument, fx/ returns the reciprocal\nof fixnum1.\nThat is, (fx/ fixnum1) is an idiom for\n(fx/ 1 fixnum1).\n" "\nWhen called with two or more arguments, fx/ returns\nthe result of\ndividing fixnum1 by the product of the remaining arguments\nfixnum2 ....\n" "\n" "(fx/ 1) --> 1\n(fx/ -17) --> 0\n(fx/ 8 -2) --> -4\n(fx/ -9 2) --> -4\n(fx/ 60 5 3 2) --> 2\n") ("numeric:s21" "\nprocedure: (fx1+ fixnum)\nprocedure: (fx1- fixnum)\nreturns: fixnum plus 1 or fixnum minus 1\nlibraries: (chezscheme)\n" "\n" "(define fxplus\n  (lambda (x y)\n    (if (fxzero? x)\n        y\n        (fxplus (fx1- x) (fx1+ y)))))\n\n(fxplus 7 8) --> 15\n" "fx1+ and fx1- can be defined as follows:\n" "\n" "(define fx1+ (lambda (x) (fx+ x 1)))\n(define fx1- (lambda (x) (fx- x 1)))\n") ("numeric:s22" "\nprocedure: (fxquotient fixnum1 fixnum2 ...)\nreturns: see explanation\nlibraries: (chezscheme)\n" "fxquotient is identical to fx/.\nSee the description of fx/ above.\n\n") ("numeric:s23" "\nprocedure: (fxremainder fixnum1 fixnum2)\nreturns: the fixnum remainder of fixnum1 divided by fixnum2\nlibraries: (chezscheme)\n" "The result of fxremainder has the same sign as fixnum1.\n" "\n" "(fxremainder 16 4) --> 0\n(fxremainder 5 2) --> 1\n(fxremainder -45 7) --> -3\n(fxremainder 10 -3) --> 1\n(fxremainder -17 -9) --> -8\n") ("numeric:s24" "\nprocedure: (fxmodulo fixnum1 fixnum2)\nreturns: the fixnum modulus of fixnum1 and fixnum2\nlibraries: (chezscheme)\n" "The result of fxmodulo has the same sign as fixnum2.\n" "\n" "(fxmodulo 16 4) --> 0\n(fxmodulo 5 2) --> 1\n(fxmodulo -45 7) --> 4\n(fxmodulo 10 -3) --> -2\n(fxmodulo -17 -9) --> -8\n") ("numeric:s25" "\nprocedure: (fxabs fixnum)\nreturns: the absolute value of fixnum\nlibraries: (chezscheme)\n" "\n" "\n(fxabs 1) --> 1\n(fxabs -1) --> 1\n(fxabs 0) --> 0\n") ("numeric:s26" "\nprocedure: (flonum->fixnum flonum)\nreturns: the fixnum representation of flonum, truncated\nlibraries: (chezscheme)\n" "The truncated value of flonum must fall within the fixnum range.\nflonum->fixnum is a restricted version of\nexact,\nwhich converts any numeric representation\nto its exact equivalent.\n" "\n" "(flonum->fixnum 0.0) --> 0\n(flonum->fixnum 3.9) --> 3\n(flonum->fixnum -2.2) --> -2\n") ("numeric:s28" "\nprocedure: (fl= flonum1 flonum2 ...)\nprocedure: (fl< flonum1 flonum2 ...)\nprocedure: (fl> flonum1 flonum2 ...)\nprocedure: (fl<= flonum1 flonum2 ...)\nprocedure: (fl>= flonum1 flonum2 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (chezscheme)\n" "The predicate fl= returns #t if its arguments are equal.\nThe predicate fl< returns #t if its arguments are monotonically\nincreasing, i.e., each argument is greater than the preceding ones,\nwhile fl> returns #t if its arguments are monotonically decreasing.\nThe predicate fl<= returns #t if its arguments are monotonically\nnondecreasing, i.e., each argument is not less than the preceding ones,\nwhile fl>= returns #t if its arguments are monotonically nonincreasing.\nWhen passed only one argument, each of these predicates returns #t.\n" "\nIEEE NANs are not comparable, i.e., comparisons involving NANs always return\n#f.\n" "\nThese procedures are similar to the Revised6 Report procedures\nfl=?, fl<?, fl>?, fl<=?,\nand fl>=? except that the Revised6 Report procedures\nrequire two or more arguments, and their names have the \"?\"\nsuffix.\n" "\n" "(fl= 0.0) --> #t\n(fl= 0.0 0.0) --> #t\n(fl< -1.0 0.0 1.0) --> #t\n(fl> -1.0 0.0 1.0) --> #f\n(fl<= 0.0 3.0 3.0) --> #t\n(fl>= 4.0 3.0 3.0) --> #t\n(fl< 7.0 +inf.0) --> #t\n(fl= +nan.0 0.0) --> #f\n(fl= +nan.0 +nan.0) --> #f\n(fl< +nan.0 +nan.0) --> #f\n(fl> +nan.0 +nan.0) --> #f\n") ("numeric:s29" "\nprocedure: (flnonpositive? fl)\nreturns: #t if fl is not greater than zero, #f otherwise\nprocedure: (flnonnegative? fl)\nreturns: #t if fl is not less than zero, #f otherwise\nlibraries: (chezscheme)\n" "flnonpositive? is equivalent to (lambda (x) (fl<= x 0.0)),\nand\nflnonnegative? is equivalent to (lambda (x) (fl>= x 0.0)).\n" "\nEven if the flonum representation distinguishes -0.0 from +0.0, both\nare considered nonpositive and nonnegative.\n" "\n" "(flnonpositive? 128.0) --> #f\n(flnonpositive? 0.0) --> #t\n(flnonpositive? -0.0) --> #t\n(flnonpositive? -1.0) --> #t\n\n(flnonnegative? -65.0) --> #f\n(flnonnegative? 0.0) --> #t\n(flnonnegative? -0.0) --> #t\n(flnonnegative? 1.0) --> #t\n\n(flnonnegative? +nan.0) --> #f\n(flnonpositive? +nan.0) --> #f\n\n(flnonnegative? +inf.0) --> #t\n(flnonnegative? -inf.0) --> #f\n") ("numeric:s30" "\nprocedure: (decode-float x)\nreturns: see below\nlibraries: (chezscheme)\n" "x must be a flonum.\ndecode-float returns a vector with three integer elements,\nm, e, and s, such that\nx = sm2e.\nIt is useful primarily in the printing of floating-point numbers.\n" "\n" "(decode-float 1.0) --> #(4503599627370496 -52 1)\n(decode-float -1.0) --> #(4503599627370496 -52 -1)\n\n(define slow-identity\n  (lambda (x)\n    (inexact\n      (let ([v (decode-float x)])\n        (let ([m (vector-ref v 0)]\n              [e (vector-ref v 1)]\n              [s (vector-ref v 2)])\n          (* s m (expt 2 e)))))))\n\n(slow-identity 1.0) --> 1.0\n(slow-identity -1e20) --> -1e20\n") ("numeric:s31" "\nprocedure: (fllp flonum)\nreturns: see below\nlibraries: (chezscheme)\n" "fllp returns the 12-bit integer consisting of the exponent\nplus highest order represented bit of a flonum (ieee 64-bit\nfloating-point number).\nIt can be used to compute a fast approximation of the logarithm of\nthe number.\n" "\n" "(fllp 0.0) --> 0\n(fllp 1.0) --> 2046\n(fllp -1.0) --> 2046\n\n(fllp 1.5) --> 2047\n\n(fllp +inf.0) --> 4094\n(fllp -inf.0) --> 4094\n\n(fllp #b1.0e-1111111111) --> 1\n(fllp #b1.0e-10000000000) --> 0\n") ("numeric:s35" "\nprocedure: (fl-make-rectangular flonum1 flonum2)\nreturns: an inexact complexnum \nlibraries: (chezscheme)\n" "The inexact complexnum produced by fl-make-rectangular has real part equal\nto flonum1 and imaginary part equal to flonum2.\n" "\n" "(fl-make-rectangular 2.0 -3.0) --> 2.0-3.0i\n(fl-make-rectangular 2.0 0.0) --> 2.0+0.0i\n(fl-make-rectangular 2.0 -0.0) --> 2.0-0.0i\n") ("numeric:s36" "\nprocedure: (cfl-real-part cflonum)\nreturns: the real part of cflonum\nprocedure: (cfl-imag-part cflonum)\nreturns: the imaginary part of cflonum\nlibraries: (chezscheme)\n" "\n" "(cfl-real-part 2.0-3.0i) --> 2.0\n(cfl-imag-part 2.0-3.0i) --> -3.0\n(cfl-imag-part 2.0-0.0i) --> -0.0\n(cfl-imag-part 2.0-inf.0i) --> -inf.0\n") ("numeric:s37" "\nprocedure: (cfl= cflonum ...)\nreturns: #t if its arguments are equal, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(cfl= 7.0+0.0i 7.0) --> #t\n(cfl= 1.0+2.0i 1.0+2.0i) --> #t\n(cfl= 1.0+2.0i 1.0-2.0i) --> #f\n") ("numeric:s38" "\nprocedure: (cfl+ cflonum ...)\nprocedure: (cfl* cflonum ...)\nprocedure: (cfl- cflonum1 cflonum2 ...)\nprocedure: (cfl/ cflonum1 cflonum2 ...)\nreturns: a cflonum\nlibraries: (chezscheme)\n" "These procedures compute the sum, difference, product, or quotient\nof inexact complex quantities, whether these quantities are represented\nby flonums or inexact complexnums.\nFor example, if cfl+ receives two flonum arguments a and b, it\nreturns the sum a + b; in this case, it behaves the same as fl+.\nWith two inexact complexnum arguments a + bi and c + di, it returns\nthe sum (a + c) + (b + d)i.\nIf one argument is a flonum a and the other an inexact complexnum\nc + di, cfl+ returns (a + c) + di.\n" "\nWhen passed zero arguments, cfl+ returns 0.0 and\ncfl* returns 1.0.\nWhen passed one argument, cfl- returns the additive inverse\nof the argument, and cfl/ returns the multiplicative inverse\nof the argument.\nWhen passed three or more arguments, cfl- returns the\ndifference between its first and the sum of its remaining arguments,\nand cfl/ returns the quotient of its first and the product\nof its remaining arguments.\n\n" "\n" "(cfl+) --> 0.0\n(cfl*) --> 1.0\n(cfl- 5.0+1.0i) --> -5.0-1.0i\n(cfl/ 2.0+2.0i) --> 0.25-0.25i\n\n(cfl+ 1.0+2.2i -3.7+5.3i) --> -2.7+7.5i\n(cfl+ 1.0 -5.3) --> -4.3\n(cfl+ 1.0 2.0 -5.3i) --> 3.0-5.3i\n(cfl- 1.0+2.5i -3.7) --> 4.7+2.5i\n(cfl* 1.0+2.0i 3.0+4.0i) --> -5.0+10.0i\n(cfl/ -5.0+10.0i 1.0+2.0i 2.0) --> 1.5+2.0i\n") ("numeric:s39" "\nprocedure: (cfl-conjugate cflonum)\nreturns: complex conjugate of cflonum\nlibraries: (chezscheme)\n" "The procedure cfl-conjugate, when passed an inexact complex argument\na + bi, returns its complex conjugate a + (-b)i.\n" "\nSee also conjugate, which is a generic\nversion of this operator that returns the complex conjugate of any\nvalid representation for a complex number.\n" "\n" "(cfl-conjugate 3.0) --> 3.0\n(cfl-conjugate 3.0+4.0i) --> 3.0-4.0i\n(cfl-conjugate 1e-20-2e-30i) --> 1e-20+2e-30i\n") ("numeric:s41" "\nprocedure: (cfl-magnitude-squared cflonum)\nreturns: magnitude of cflonum squared\nlibraries: (chezscheme)\n" "The procedure cfl-magnitude-squared, when passed an inexact complex\nargument a + bi returns a flonum representing the magnitude of the\nargument squared, i.e., a2 + b2.\n" "\nSee also magnitude-squared,\nwhich is a generic version of this\noperator that returns the magnitude squared of any valid representation\nfor a complex number.\nBoth operations are similar to the magnitude procedure,\nwhich returns the magnitude, sqrt(a2 + b2), of its generic complex\nargument.\n" "\n" "(cfl-magnitude-squared 3.0) --> 9.0\n(cfl-magnitude-squared 3.0-4.0i) --> 25.0\n") ("numeric:s44" "\nprocedure: (logand int ...)\nreturns: the logical \"and\" of the arguments int ...\nlibraries: (chezscheme)\n" "The arguments must be exact integers (fixnums or bignums) and are treated\nas two's complement integers, regardless of the underlying representation.\nWith no arguments, logand returns -1, i.e., all bits set.\n" "\n" "(logand) --> -1\n(logand 15) --> 15\n(logand -1 -1) --> -1\n(logand -1 0) --> 0\n(logand 5 3) --> 1\n(logand #x173C8D95 7) --> 5\n(logand #x173C8D95 -8) --> #x173C8D90\n(logand #b1100 #b1111 #b1101) --> #b1100\n") ("numeric:s45" "\nprocedure: (logior int ...)\nprocedure: (logor int ...)\nreturns: the logical \"or\" of the arguments int ...\nlibraries: (chezscheme)\n" "The arguments must be exact integers (fixnums or bignums) and are treated\nas two's complement integers, regardless of the underlying representation.\nWith no arguments, logior returns 0, i.e., all bits reset.\n" "\n" "(logior) --> 0\n(logior 15) --> 15\n(logior -1 -1) --> -1\n(logior -1 0) --> -1\n(logior 5 3) --> 7\n(logior #b111000 #b101010) --> #b111010\n(logior #b1000 #b0100 #b0010) --> #b1110\n(apply logior '(1 2 4 8 16)) --> 31\n") ("numeric:s46" "\nprocedure: (logxor int ...)\nreturns: the logical \"exclusive or\" of the arguments int ...\nlibraries: (chezscheme)\n" "The arguments must be exact integers (fixnums or bignums) and are treated\nas two's complement integers, regardless of the underlying representation.\nWith no arguments, logxor returns 0, i.e., all bits reset.\n" "\n" "(logxor) --> 0\n(logxor 15) --> 15\n(logxor -1 -1) --> 0\n(logxor -1 0) --> -1\n(logxor 5 3) --> 6\n(logxor #b111000 #b101010) --> #b010010\n(logxor #b1100 #b0100 #b0110) --> #b1110\n") ("numeric:s47" "\nprocedure: (lognot int)\nreturns: the logical \"not\" of int\nlibraries: (chezscheme)\n" "The argument must be an exact integer (fixnum or bignum) and is treated\nas a two's complement integer, regardless of the underlying representation.\n" "\n" "(lognot -1) --> 0\n(lognot 0) --> -1\n(lognot 7) --> -8\n(lognot -8) --> 7\n") ("numeric:s48" "\nprocedure: (logbit? index int)\nreturns: #t if the specified bit is set, otherwise #f\nlibraries: (chezscheme)\n" "index must be a nonnegative exact integer.\nint must be an exact integer (fixnum or bignum) and is treated\nas a two's complement integer, regardless of the underlying representation.\n" "\nlogbit? returns #t if the bit at index index\nof int is set (one) and #f otherwise.\nThe index is zero-based, counting from the lowest-order toward\nhigher-order bits.\nThere is no upper limit on the index; for nonnegative values of int,\nthe bits above the highest order set bit are all considered to be zero,\nand for negative values, the bits above the highest order reset bit are\nall considered to be one.\n" "\nlogbit? is equivalent to\n" "\n" "(lambda (k n) (not (zero? (logand n (ash 1 k)))))\n" "but more efficient.\n" "\n" "(logbit? 0 #b1110) --> #f\n(logbit? 1 #b1110) --> #t\n(logbit? 2 #b1110) --> #t\n(logbit? 3 #b1110) --> #t\n(logbit? 4 #b1110) --> #f\n(logbit? 100 #b1110) --> #f\n\n(logbit? 0 -6) --> #f  ; the two's complement of -6 is 1...1010\n(logbit? 1 -6) --> #t\n(logbit? 2 -6) --> #f\n(logbit? 3 -6) --> #t\n(logbit? 100 -6) --> #t\n\n(logbit? (random 1000000) 0) --> #f\n(logbit? (random 1000000) -1) --> #t\n\n(logbit? 20000 (ash 1 20000)) --> #t\n") ("numeric:s49" "\nprocedure: (logtest int1 int2)\nreturns: #t if any common bits are set, otherwise #f\nlibraries: (chezscheme)\n" "The arguments must be exact integers (fixnums or bignums) and are treated\nas two's complement integers, regardless of the underlying representation.\n" "\nlogtest returns #t if any bit set in one argument is\nalso set in the other.\nIt returns #f if the two arguments have no set bits in common.\n" "\nlogtest is equivalent to\n" "\n" "(lambda (n1 n2) (not (zero? (logand n1 n2))))\n" "but more efficient.\n" "\n" "(logtest #b10001 #b1110) --> #f\n(logtest #b10101 #b1110) --> #t\n(logtest #b111000 #b110111) --> #t\n\n(logtest #b101 -6) --> #f  ; the two's complement of -6 is 1...1010\n(logtest #b1000 -6) --> #t\n(logtest 100 -6) --> #t\n\n(logtest (+ (random 1000000) 1) 0) --> #f\n(logtest (+ (random 1000000) 1) -1) --> #t\n\n(logtest (ash #b101 20000) (ash #b111 20000)) --> #t\n") ("numeric:s50" "\nprocedure: (logbit0 index int)\nreturns: the result of clearing bit index of int\nlibraries: (chezscheme)\n" "index must be a nonnegative exact integer.\nint must be an exact integer (fixnum or bignum) and is treated\nas a two's complement integer, regardless of the underlying representation.\n" "\nThe index is zero-based, counting from the lowest-order toward\nhigher-order bits.\nAs with logbit?, there is no upper limit on the index.\n" "\nlogbit0 is equivalent to\n" "\n" "(lambda (i n) (logand (lognot (ash 1 i)) n))\n" "but more efficient.\n" "\n" "(logbit0 3 #b10101010) --> #b10100010\n(logbit0 4 #b10101010) --> #b10101010\n(logbit0 0 -1) --> -2\n") ("numeric:s51" "\nprocedure: (logbit1 index int)\nreturns: the result of setting bit index of int\nlibraries: (chezscheme)\n" "index must be a nonnegative exact integer.\nint must be an exact integer (fixnum or bignum) and is treated\nas a two's complement integer, regardless of the underlying representation.\n" "\nThe index is zero-based, counting from the lowest-order toward\nhigher-order bits.\nAs with logbit?, there is no upper limit on the index.\n" "\nlogbit1 is equivalent to\n" "\n" "(lambda (i n) (logor (ash 1 i) n))\n" "but more efficient.\n" "\n" "(logbit1 3 #b10101010) --> #b10101010\n(logbit1 4 #b10101010) --> #b10111010\n(logbit1 4 0) --> #b10000\n(logbit1 0 -2) --> -1\n") ("numeric:s52" "\nprocedure: (ash int count)\nreturns: int shifted left arithmetically by count.\nlibraries: (chezscheme)\n" "Both arguments must be exact integers.\nThe first argument is treated as a two's complement integer, regardless\nof the underlying representation.\nIf count is negative, int is shifted right by\n-count bits.\n" "\n" "(ash 8 0) --> 8\n(ash 8 2) --> 32\n(ash 8 -2) --> 2\n(ash -1 2) --> -4\n(ash -1 -2) --> -1\n") ("numeric:s53" "\nprocedure: (fxlogand fixnum ...)\nreturns: the logical \"and\" of the arguments fixnum ...\nlibraries: (chezscheme)\n" "The arguments are treated as two's complement integers, regardless\nof the underlying representation.\nWith no arguments, fxlogand returns -1, i.e., all bits set.\n" "\n" "(fxlogand) --> -1\n(fxlogand 15) --> 15\n(fxlogand -1 -1) --> -1\n(fxlogand -1 0) --> 0\n(fxlogand 5 3) --> 1\n(fxlogand #b111000 #b101010) --> #b101000\n(fxlogand #b1100 #b1111 #b1101) --> #b1100\n") ("numeric:s54" "\nprocedure: (fxlogior fixnum ...)\nprocedure: (fxlogor fixnum ...)\nreturns: the logical \"or\" of the arguments fixnum ...\nlibraries: (chezscheme)\n" "The arguments are treated as two's complement integers, regardless\nof the underlying representation.\nWith no arguments, fxlogior returns 0, i.e., all bits reset.\n" "\n" "(fxlogior) --> 0\n(fxlogior 15) --> 15\n(fxlogior -1 -1) --> -1\n(fxlogior -1 0) --> -1\n(fxlogior #b111000 #b101010) --> #b111010\n(fxlogior #b1000 #b0100 #b0010) --> #b1110\n(apply fxlogior '(1 2 4 8 16)) --> 31\n") ("numeric:s55" "\nprocedure: (fxlogxor fixnum ...)\nreturns: the logical \"exclusive or\" of the arguments fixnum ...\nlibraries: (chezscheme)\n" "The arguments are treated as two's complement integers, regardless\nof the underlying representation.\nWith no arguments, fxlogxor returns 0, i.e., all bits reset.\n" "\n" "(fxlogxor) --> 0\n(fxlogxor 15) --> 15\n(fxlogxor -1 -1) --> 0\n(fxlogxor -1 0) --> -1\n(fxlogxor 5 3) --> 6\n(fxlogxor #b111000 #b101010) --> #b010010\n(fxlogxor #b1100 #b0100 #b0110) --> #b1110\n") ("numeric:s56" "\nprocedure: (fxlognot fixnum)\nreturns: the logical \"not\" of fixnum\nlibraries: (chezscheme)\n" "The argument is treated as a two's complement integer, regardless\nof the underlying representation.\n" "\n" "(fxlognot -1) --> 0\n(fxlognot 0) --> -1\n(fxlognot 1) --> -2\n(fxlognot -2) --> 1\n") ("numeric:s57" "\nprocedure: (fxlogbit? index fixnum)\nreturns: #t if the specified bit is set, otherwise #f\nlibraries: (chezscheme)\n" "index must be a nonnegative fixnum.\nfixnum is treated as a two's complement integer, regardless of\nthe underlying representation.\n" "\nfxlogbit? returns #t if the bit at index index\nof fixnum is set (one) and #f otherwise.\nThe index is zero-based, counting from the lowest-order toward\nhigher-order bits.\nThe index is limited only by the fixnum range; for nonnegative values of\nfixnum, the bits above the highest order set bit are all considered\nto be zero, and for negative values, the bits above the highest order\nreset bit are all considered to be one.\n" "\n" "(fxlogbit? 0 #b1110) --> #f\n(fxlogbit? 1 #b1110) --> #t\n(fxlogbit? 2 #b1110) --> #t\n(fxlogbit? 3 #b1110) --> #t\n(fxlogbit? 4 #b1110) --> #f\n(fxlogbit? 100 #b1110) --> #f\n\n(fxlogbit? 0 -6) --> #f  ; the two's complement of -6 is 1...1010\n(fxlogbit? 1 -6) --> #t\n(fxlogbit? 2 -6) --> #f\n(fxlogbit? 3 -6) --> #t\n(fxlogbit? 100 -6) --> #t\n\n(fxlogbit? (random 1000000) 0) --> #f\n(fxlogbit? (random 1000000) -1) --> #t\n") ("numeric:s58" "\nprocedure: (fxlogtest fixnum1 fixnum2)\nreturns: #t if any common bits are set, otherwise #f\nlibraries: (chezscheme)\n" "The arguments are treated as two's complement integers, regardless of\nthe underlying representation.\n" "\nfxlogtest returns #t if any bit set in one argument is\nalso set in the other.\nIt returns #f if the two arguments have no set bits in common.\n" "\n" "(fxlogtest #b10001 #b1110) --> #f\n(fxlogtest #b10101 #b1110) --> #t\n(fxlogtest #b111000 #b110111) --> #t\n\n(fxlogtest #b101 -6) --> #f  ; the two's complement of -6 is 1...1010\n(fxlogtest #b1000 -6) --> #t\n(fxlogtest 100 -6) --> #t\n\n(fxlogtest (+ (random 1000000) 1) 0) --> #f\n(fxlogtest (+ (random 1000000) 1) -1) --> #t\n") ("numeric:s59" "\nprocedure: (fxlogbit0 index fixnum)\nreturns: the result of clearing bit index of fixnum\nlibraries: (chezscheme)\n" "fixnum is treated\nas a two's complement integer, regardless of the underlying representation.\nindex must be nonnegative and less than the number of\nbits in a fixnum, excluding the sign bit, i.e., less than\n(integer-length (most-positive-fixnum)).\nThe index is zero-based, counting from the lowest-order toward\nhigher-order bits.\n" "\nfxlogbit0 is equivalent to\n" "\n" "(lambda (i n) (fxlogand (fxlognot (fxsll 1 i)) n))\n" "but more efficient.\n" "\n" "(fxlogbit0 3 #b10101010) --> #b10100010\n(fxlogbit0 4 #b10101010) --> #b10101010\n(fxlogbit0 0 -1) --> -2\n") ("numeric:s60" "\nprocedure: (fxlogbit1 index fixnum)\nreturns: the result of setting bit index of fixnum\nlibraries: (chezscheme)\n" "fixnum is treated\nas a two's complement integer, regardless of the underlying representation.\nindex must be nonnegative and less than the number of\nbits in a fixnum, excluding the sign bit, i.e., less than\n(integer-length (most-positive-fixnum)).\nThe index is zero-based, counting from the lowest-order toward\nhigher-order bits.\n" "\nfxlogbit1 is equivalent to\n" "\n" "(lambda (i n) (fxlogor (fxsll 1 i) n))\n" "but more efficient.\n" "\n" "(fxlogbit1 3 #b10101010) --> #b10101010\n(fxlogbit1 4 #b10101010) --> #b10111010\n(fxlogbit1 4 0) --> #b10000\n(fxlogbit1 0 -2) --> -1\n") ("numeric:s61" "\nprocedure: (fxsll fixnum count)\nreturns: fixnum shifted left by count\nlibraries: (chezscheme)\n" "fixnum is treated as a two's complement integer, regardless\nof the underlying representation.\ncount must be nonnegative and not more than the number of\nbits in a fixnum, i.e.,\n(+ (integer-length (most-positive-fixnum)) 1).\nAn exception is raised with condition-type\n&implementation-restriction if the result cannot be represented\nas a fixnum.\n" "\n" "(fxsll 1 2) --> 4\n(fxsll -1 2) --> -4\n") ("numeric:s62" "\nprocedure: (fxsrl fixnum count)\nreturns: fixnum logically shifted right by count\nlibraries: (chezscheme)\n" "fixnum is treated as a two's complement integer, regardless\nof the underlying representation.\ncount must be nonnegative and not more than the number of\nbits in a fixnum, i.e.,\n(+ (integer-length (most-positive-fixnum)) 1).\n" "\n" "(fxsrl 4 2) --> 1\n(= (fxsrl -1 1) (most-positive-fixnum)) --> #t\n") ("numeric:s63" "\nprocedure: (fxsra fixnum count)\nreturns: fixnum arithmetically shifted right by count\nlibraries: (chezscheme)\n" "fixnum is treated as a two's complement integer, regardless\nof the underlying representation.\ncount must be nonnegative and not more than the number of\nbits in a fixnum, i.e.,\n(+ (integer-length (most-positive-fixnum)) 1).\n" "\n" "(fxsra 64 3) --> 8\n(fxsra -1 1) --> -1\n(fxsra -64 3) --> -8\n") ("numeric:s64" "\nprocedure: (random real)\nreturns: a nonnegative pseudo-random number less than real\nlibraries: (chezscheme)\n" "real must be a positive integer or positive inexact real number.\n" "\n" "(random 1) --> 0\n(random 1029384535235) --> 1029384535001, every now and then\n(random 1.0) --> 0.5, every now and then\n") ("numeric:s65" "\nthread parameter: random-seed\nlibraries: (chezscheme)\n" "The random number generator allows the\ncurrent random seed to be obtained and modified via the parameter\nrandom-seed.\n" "\nWhen called without arguments, random-seed returns the current\nrandom seed.\nWhen called with one argument, which must be a nonnegative exact integer\nranging from 1 through 232 - 1, random-seed sets the current\nrandom seed to the argument.\n" "\n" "(let ([s (random-seed)])\n  (let ([r1 (random 1.0)])\n    (random-seed s)\n    (eqv? (random 1.0) r1))) --> #t\n") ("numeric:s67" "\nprocedure: (= num1 num2 num3 ...)\nprocedure: (< real1 real2 real3 ...)\nprocedure: (> real1 real2 real3 ...)\nprocedure: (<= real1 real2 real3 ...)\nprocedure: (>= real1 real2 real3 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (chezscheme)\n" "These predicates are identical to the Revised6 Report counterparts,\nexcept they are extended to accept one or more rather than two or more\narguments.\nWhen passed one argument, each of these predicates returns #t.\n" "\n" "(> 3/4) --> #t\n(< 3/4) --> #t\n(= 3/4) --> #t\n") ("numeric:s68" "\nprocedure: (1+ num)\nprocedure: (add1 num)\nprocedure: (1- num)\nprocedure: (-1+ num)\nprocedure: (sub1 num)\nreturns: num plus 1 or num minus 1\nlibraries: (chezscheme)\n" "1+ and add1 are equivalent to\n(lambda (x) (+ x 1));\n1-, -1+, and sub1 are equivalent to\n(lambda (x) (- x 1)).\n" "\n" "(define plus\n ; x should be a nonnegative integer\n  (lambda (x y)\n    (if (zero? x)\n        y\n        (plus (1- x) (1+ y)))))\n\n(plus 7 8) --> 15\n\n(define double\n ; x should be a nonnegative integer\n  (lambda (x)\n    (if (zero? x)\n        0\n        (add1 (add1 (double (sub1 x)))))))\n\n(double 7) --> 14\n") ("numeric:s69" "\nprocedure: (expt-mod int1 int2 int3)\nreturns: int1 raised to the int2 power, modulo int3\nlibraries: (chezscheme)\n" "int1, int2 and int3\nmust be nonnegative integers.\nexpt-mod performs its computation in such a way that the\nintermediate results are never much larger than int3.\nThis means that when int2 is large, expt-mod is more efficient\nthan the equivalent procedure (lambda (x y z) (modulo (expt x y) z)).\n" "\n" "(expt-mod 2 4 3) --> 1\n(expt-mod 2 76543 76543) --> 2\n") ("numeric:s70" "\nprocedure: (isqrt n)\nreturns: the integer square root of n\nlibraries: (chezscheme)\n" "n must be a nonnegative integer.\nThe integer square root of n is defined to be\nmath/csug/1.gif.\n\n" "\n" "(isqrt 0) --> 0\n(isqrt 16) --> 4\n(isqrt 16.0) --> 4.0\n(isqrt 20) --> 4\n(isqrt 20.0) --> 4.0\n(isqrt (* 2 (expt 10 20))) --> 14142135623\n") ("numeric:s71" "\nprocedure: (integer-length n)\nreturns: see below\nlibraries: (chezscheme)\n" "The procedure integer-length returns the length in bits of\nthe smallest two's complement representation for n, with an\nassumed leading 1 (sign) bit for negative numbers.\nFor zero, integer-length returns 0.\n" "\n" "(integer-length 0) --> 0\n(integer-length 1) --> 1\n(integer-length 2) --> 2\n(integer-length 3) --> 2\n(integer-length 4) --> 3\n(integer-length #b10000000) --> 8\n(integer-length #b11111111) --> 8\n(integer-length -1) --> 0\n(integer-length -2) --> 1\n(integer-length -3) --> 2\n(integer-length -4) --> 2\n") ("numeric:s72" "\nprocedure: (nonpositive? real)\nreturns: #t if real is not greater than zero, #f otherwise\nlibraries: (chezscheme)\n" "nonpositive? is equivalent to (lambda (x) (<= x 0)).\n" "\n" "(nonpositive? 128) --> #f\n(nonpositive? 0.0) --> #t\n(nonpositive? 1.8e-15) --> #f\n(nonpositive? -2/3) --> #t\n") ("numeric:s73" "\nprocedure: (nonnegative? real)\nreturns: #t if real is not less than zero, #f otherwise\nlibraries: (chezscheme)\n" "nonnegative? is equivalent to (lambda (x) (>= x 0)).\n" "\n" "(nonnegative? -65) --> #f\n(nonnegative? 0) --> #t\n(nonnegative? -0.0121) --> #f\n(nonnegative? 15/16) --> #t\n") ("numeric:s74" "\nprocedure: (conjugate num)\nreturns: complex conjugate of num\nlibraries: (chezscheme)\n" "The procedure conjugate, when passed a complex argument\na + bi, returns its complex conjugate a + (-b)i.\n" "\n" "(conjugate 3.0+4.0i) --> 3.0-4.0i\n(conjugate 1e-20-2e-30i) --> 1e-20+2e-30i\n(conjugate 3) --> 3\n") ("numeric:s75" "\nprocedure: (magnitude-squared num)\nreturns: magnitude of num squared\nlibraries: (chezscheme)\n" "The procedure magnitude-squared, when passed a complex\nargument a + bi returns its magnitude squared,\ni.e., a2 + b2.\n" "\n" "(magnitude-squared 3.0-4.0i) --> 25.0\n(magnitude-squared 3.0) --> 9.0\n") ("numeric:s76" "\nprocedure: (sinh num)\nprocedure: (cosh num)\nprocedure: (tanh num)\nreturns: the hyperbolic sine, cosine, or tangent of num\nlibraries: (chezscheme)\n" "\n" "(sinh 0.0) --> 0.0\n(cosh 0.0) --> 1.0\n(tanh -0.0) --> -0.0\n") ("numeric:s77" "\nprocedure: (asinh num)\nprocedure: (acosh num)\nprocedure: (atanh num)\nreturns: the hyperbolic arc sine, arc cosine, or arc tangent of num\nlibraries: (chezscheme)\n" "\n" "(acosh 0.0) --> 0.0+1.5707963267948966i\n(acosh 1.0) --> 0.0\n(atanh -1.0) --> -inf.0\n") ("numeric:s78" "\nprocedure: (string->number string)\nprocedure: (string->number string radix)\nreturns: the number represented by string, or #f\nlibraries: (chezscheme)\n" "This procedure is identical to the Revised6 Report version except\nthat radix may be any exact integer between 2 and 36, inclusive.\nThe Revised6 Report version requires radix to be in the set\n{2,8,10,16}.\n" "\n" "(string->number \"211012\" 3) --> 559\n(string->number \"tobeornottobe\" 36) --> 140613689159812836698\n") ("numeric:s79" "\nprocedure: (number->string num)\nprocedure: (number->string num radix)\nprocedure: (number->string num radix precision)\nreturns: an external representation of num as a string\nlibraries: (chezscheme)\n" "This procedure is identical to the Revised6 Report version except\nthat radix may be any exact integer between 2 and 36, inclusive.\nThe Revised6 Report version requires radix to be in the set\n{2,8,10,16}.\n" "\n" "(number->string 10000 4) --> \"2130100\"\n(number->string 10000 27) --> \"DJA\"\n") ("compat:s0" "\nprocedure: (make-hash-table)\nprocedure: (make-hash-table weak?)\nreturns: a new hash table\nlibraries: (chezscheme)\n" "If weak? is provided and is non-false, the hash\ntable is a weak hash table, which means that it does not protect\nkeys from the garbage collector.\nKeys reclaimed by the garbage collector are removed from the table,\nand their associated values are dropped the next time the table\nis modified, if not sooner.\n") ("compat:s1" "\nprocedure: (hash-table? obj)\nreturns: #t if obj is a hash table, otherwise #f\nlibraries: (chezscheme)\n") ("compat:s2" "\nprocedure: (put-hash-table! ht k v)\nreturns: unspecified\nlibraries: (chezscheme)\n" "ht must be a hash table.\nk and v may be any Scheme values.\n" "\nput-hash-table! associates the value\nv with the key k in ht.\n") ("compat:s3" "\nprocedure: (get-hash-table ht k d)\nreturns: see below\nlibraries: (chezscheme)\n" "get-hash-table returns the value\nassociated with k in ht.\nIf no value is associated with k in ht,\nget-hash-table returns d.\n" "\nKey comparisons are performed with eq?.\n" "\nBecause objects may be moved by the garbage collector, get-hash-table\nmay need to rehash some objects and therefore cause side effects in the\nhash table.\nThus, it is not safe to perform concurrent accesses of the same hash table\nfrom multiple threads using get-hash-table.\n") ("compat:s4" "\nprocedure: (remove-hash-table! ht k)\nreturns: unspecified\nlibraries: (chezscheme)\n" "remove-hash-table! drops any association\nfor k from ht.\n") ("compat:s5" "\nprocedure: (hash-table-map ht p)\nreturns: see below\nlibraries: (chezscheme)\n" "hash-table-map applies p to each key, value association\nin ht, in no particular order, and returns a list of the resulting\nvalues, again in no particular order.\np should accept two arguments, a key and a value.\n\n") ("compat:s6" "\nprocedure: (hash-table-for-each ht p)\nreturns: unspecified\nlibraries: (chezscheme)\n" "hash-table-for-each applies p to each key, value\nassociation in ht, in no particular order.\nUnlike hash-table-map, it does not create a list of the values;\ninstead, it's value is unspecified.\np should accept two arguments, a key and a value.\n\n") ("compat:s8" "\nsyntax: (extend-syntax (name key ...) (pat fender template) ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "The identifier name is the name, or syntax keyword, for the\nsyntactic extension to be defined.\nWhen the system expander processes any list expression whose car is\nname, the syntactic transformation procedure generated by\nextend-syntax is invoked on this expression.\nThe remaining identifiers key ... are additional keywords to\nbe recognized within input expressions during expansion (such as\nelse in cond or case).\n" "\nEach clause after the list of keys consists of a pattern pat, an\noptional fender,\nand a template.\nThe optional fender is omitted more often than not.\nThe pat specifies the syntax the input expression must have\nfor the clause to be chosen.\nIdentifiers within the pattern that are not keywords\n(pattern variables) are bound to corresponding pieces of the input expression.\nIf present, the fender is a Scheme expression that specifies\nadditional constraints on the input expression (accessed through the\npattern variables) that must be satisfied in order for the clause to\nbe chosen.\nThe template specifies what form the output takes, usually in\nterms of the pattern variables.\n" "\nDuring expansion, the transformation procedure extend-syntax\ngenerates attempts to match the input expression against each\npattern in the order the clauses are given.\nIf the input expression matches the pattern, the pattern variables are\nbound to the corresponding pieces of the input expression and the\nfender for the clause, if any, is evaluated.\nIf the fender returns a true value, the given expansion is performed.\nIf input does not match the pattern or if the fender returns a false\nvalue, the transformation procedure tries the next clause.\nAn exception is raised with condition type &assertion if no clause can be chosen.\n" "\nWithin the pattern,\nellipsis\n(...) may be\nused to specify zero or more occurrences\nof the preceding pattern fragment, or prototype.\nSimilarly, ellipses may be used in the output to specify the construction\nof zero or more expansion prototypes.\nIn this case, the expansion prototype must contain part of an input pattern\nprototype.\nThe use of patterns, templates, ellipses within patterns and templates,\nand fenders is illustrated in the following sequence of examples.\n" "\nThe first example, defining rec, uses a single keyword, a single\nclause with no fender, and no ellipses.\n" "\n" "(extend-syntax (rec)\n  [(rec id val)\n   (let ([id #f])\n     (set! id val)\n     id)])\n" "The second example, defining when, shows\nthe use of ellipses.\n" "\n" "(extend-syntax (when)\n  [(when test exp1 exp2 ...)\n   (if test (begin exp1 exp2 ...) #f)])\n" "The next example shows the definition of\nlet.\nThe definition of let shows the use of multiple ellipses, employing\none for the identifier/value pairs and one for the expressions in the body.\nIt also shows that the prototype need not be a single identifier, and that\npieces of the prototype may be separated from one another in the template.\n" "\n" "(extend-syntax (let)\n  [(let ([x e] ...) b1 b2 ...)\n   ((lambda (x ...) b1 b2 ...) e ...)])\n" "The next example shows let*, whose syntax is the same as for\nlet, but which is defined recursively in terms of let with\ntwo clauses (one for the base case, one for the recursion step) since\nit must produce a nested structure.\n" "\n" "(extend-syntax (let*)\n  [(let* () b1 b2 ...)\n   (let () b1 b2 ...)]\n  [(let* ([x e] more ...) b1 b2 ...)\n   (let ([x e]) (let* (more ...) b1 b2 ...))])\n" "The first pattern/template pair matches any let* expression with no\nidentifier/value pairs and maps it into the equivalent begin expression.\nThis is the base case.\nThe second pattern/template pair matches any let* expression with one\nor more identifier/value pairs and transforms it into a let expression\nbinding the first pair whose body is a let* expression binding the\nremaining pairs.\nThis is the recursion step, which will eventually lead us to the base case\nbecause we remove one identifier/value pair at each step.\nNotice that the second pattern uses the pattern variable more for the\nsecond and later identifier/value pairs; this makes the pattern and template\nless cluttered and makes it clear that only the first identifier/value pair\nis dealt with explicitly.\n" "\nThe definition for and requires three clauses.\nThe first clause is necessary to recognize (and), and the second\ntwo define all other and forms recursively.\n" "\n" "(extend-syntax (and)\n  [(and) #t]\n  [(and x) x]\n  [(and x y ...) (if x (and y ...) #f)])\n" "The definition for cond requires four clauses.\nAs with let*, cond must be described recursively, partly because\nit produces nested if expressions, and partly because one\nellipsis prototype would not be sufficient to describe all possible\ncond clauses.\nThe definition of cond also requires that we specify else as a\nkeyword, in addition to cond.\nHere is the definition:\n" "\n" "(extend-syntax (cond else)\n  [(cond) #f]\n  [(cond (else e1 e2 ...))\n   (begin e1 e2 ...)]\n  [(cond (test) more ...)\n   (or test (cond more ...))]\n  [(cond (test e1 e2 ...) more ...)\n   (if test\n       (begin e1 e2 ...)\n       (cond more ...))])\n" "Two of the clauses are base cases and two are recursion steps.\nThe first base case is an empty cond.\nThe value of cond in this case is unspecified, so the choice of\n#f is somewhat arbitrary.\nThe second base case is a cond containing only an else clause;\nthis is transformed to the equivalent begin expression.\nThe two recursion steps differ in the number of expressions in the cond\nclause.\nThe value of cond when the first true clause contains only the test\nexpression is the value of the test.\nThis is similar to what or does, so we expand the cond clause\ninto an or expression.\nOn the other hand, when there are expressions following the test expression,\nthe value of the last expression is returned, so we use if and\nbegin.\n" "\nTo be absolutely correct about the syntax of let, we actually\nmust require that the bound identifiers in the input are symbols.\nIf we typed something like (let ([3 x]) x) we would not get an\nerror from let because it does not check to verify that the\nobjects in the identifier positions are symbols.\nInstead, lambda may complain, or perhaps the system evaluator\nlong after expansion is complete. \nThis is where fenders\nare useful.\n" "\n" "(extend-syntax (let)\n  [(let ([x e] ...) b1 b2 ...)\n   (andmap symbol? '(x ...))\n   ((lambda (x ...) b1 b2 ...) e ...)])\n" "The andmap of symbol?\nover '(x ...) assures that each\nbound identifier is a symbol.\nA fender is simply a Scheme expression.\nWithin that expression, any quoted object is first expanded by the same\nrules as the template part of the clause.\nIn this case, '(x ...) is expanded to the list of identifiers from\nthe identifier/value pairs.\n" "\nextend-syntax typically handles everything you need it for, but\nsome syntactic extension definitions require the ability to include the\nresult of evaluating an arbitrary Scheme expression.\nThis ability is provided by with.\n\n") ("compat:s20" "\nsyntax: (with ((pat expr) ...) template)\nreturns: processed template\n" "\n" "with is valid only within an template inside of extend-syntax.\nwith patterns are the same as extend-syntax patterns, with\nexpressions are the same as extend-syntax fenders, and with\ntemplates are the same as extend-syntax templates.\n" "\nwith can be used to introduce new pattern identifiers bound to\nexpressions produced by arbitrary Scheme expressions within\nextend-syntax templates.\nThat is, with allows an escape from the declarative style of\nextend-syntax into the procedural style of full Scheme.\n" "\nOne common use of with is the introduction of a temporary\nidentifier or list of temporary identifiers into a template.\nwith is also used to perform complex transformations that might\nbe clumsy or inefficient if performed within the extend-syntax\nframework.\n" "\nFor example, or requires the use of a temporary identifier.\nWe could define or as follows.\n" "\n" "(extend-syntax (or)\n  [(or) #f]\n  [(or x) x]\n  [(or x y ...)\n   (let ([temp x])\n     (if temp temp (or y ...)))])\n" "This would work until we placed an or expression within the scope\nof an occurrence of temp, in which case strange things could happen,\nsince extend-syntax does not respect lexical scoping.\n(This is one of the reasons that define-syntax is preferable to\nextend-syntax.)\n" "\n" "(let ([temp #t])\n  (or #f temp)) --> #f\n" "One solution is to use\ngensym and with to\ncreate a temporary identifier, as follows.\n" "\n" "(extend-syntax (or)\n  [(or) #f]\n  [(or x) x]\n  [(or x y ...)\n   (with ([temp (gensym)])\n     (let ([temp x])\n       (if temp temp (or y ...))))])\n" "Also, with can be used to combine elements of the input pattern\nin ways not possible directly with extend-syntax, such as the\nfollowing folding-plus example.\n" "\n" "(extend-syntax (folding-plus)\n  [(folding-plus x y)\n   (and (number? 'x) (number? 'y))\n   (with ([val (+ 'x 'y)])\n      val)]\n  [(folding-plus x y) (+ x y)])\n" "folding-plus collapses into the value of (+ x y) if both\nx and y are numeric constants.\nOtherwise, folding-plus is transformed into (+ x y) for\nlater evaluation.\nThe fender checks that the operands are numbers at expansion time, and\nthe with performs the evaluation.\nAs with fenders, expansion is performed only within a quoted expressions,\nsince quote sets the data apart from the remainder of the Scheme\nexpression.\n" "\nThe example below binds a list of pattern variables to a list of\ntemporary symbols, taking advantage of the fact that with allows\nus to bind patterns to expressions.\nThis list of temporaries helps us to implement the sigma syntactic\nextension.\nsigma is similar to lambda, except it assigns the identifiers\nin the identifier list instead of creating new bindings.\nIt may be used to perform a series of assignments in parallel.\n" "\n" "(extend-syntax (sigma)\n  [(sigma (x ...) e1 e2 ...)\n   (with ([(t ...) (map (lambda (x) (gensym)) '(x ...))])\n     (lambda (t ...)\n       (set! x t) ...\n       e1 e2 ...))])\n\n(let ([x 'a] [y 'b])\n  ((sigma (x y) (list x y)) y x)) --> (b a)\n" "The final example below uses extend-syntax to implement\ndefine-structure, following a similar example using\nsyntax-case in Section http://scheme.com/tspl4/./syntax.html#g1378.4 of\nThe Scheme Programming Language, 4th Edition.\n" "\nThe definition of define-structure makes use of two pattern/template\nclauses.\nTwo clauses are needed to handle the optionality of the second subexpression.\nThe first clause matches the form without the second subexpression and\nmerely converts it into the equivalent form with the second subexpression\npresent, but empty.\n" "\nThe definition also makes heavy use of with to evaluate Scheme\nexpressions at expansion time.\nThe first four with clauses are used to manufacture the identifiers\nthat name the automatically defined procedures.\n(The procedure format is particularly useful here, but it could be\nreplaced with string-append!, using symbol->string as needed.)\nThe first two clauses yield single identifiers (for the constructor and\npredicate), while the next two yield lists of identifiers (for the field\naccess and assignment procedures).\nThe fifth with clause (the final clause in the outer with)\nis used to count the total length vector needed for each instance of\nthe structure, which must include room for the name and all of the fields.\nThe final with clause (the only clause in the inner with)\nis used to create a list of vector indexes, one for each field (starting at\n1, since the structure name occupies position 0).\n" "\n" "(extend-syntax (define-structure)\n  [(define-structure (name id1 ...))\n   (define-structure (name id1 ...) ())]\n  [(define-structure (name id1 ...) ([id2 val] ...))\n   (with ([constructor\n           (string->symbol (format \"make-~a\" 'name))]\n          [predicate\n           (string->symbol (format \"~a?\" 'name))]\n          [(access ...)\n           (map (lambda (x)\n                  (string->symbol\n                    (format \"~a-~a\" 'name x)))\n                '(id1 ... id2 ...))]\n          [(assign ...)\n           (map (lambda (x)\n                  (string->symbol\n                    (format \"set-~a-~a!\" 'name x)))\n                '(id1 ... id2 ...))]\n          [count (length '(name id1 ... id2 ...))])\n     (with ([(index ...)\n             (let f ([i 1])\n               (if (= i 'count)\n                   '()\n                   (cons i (f (+ i 1)))))])\n       (begin\n         (define constructor\n           (lambda (id1 ...)\n             (let* ([id2 val] ...)\n               (vector 'name id1 ... id2 ...))))\n         (define predicate\n           (lambda (obj)\n             (and (vector? obj)\n                  (= (vector-length obj) count)\n                  (eq? (vector-ref obj 0) 'name))))\n         (define access\n           (lambda (obj)\n             (vector-ref obj index)))\n         ...\n         (define assign\n           (lambda (obj newval)\n             (vector-set! obj index newval)))\n         ...)))])\n") ("compat:s25" "\nsyntax: (define-structure (name id1 ...) ((id2 expr) ...))\nreturns: unspecified\nlibraries: (chezscheme)\n" "A define-structure form is a definition and may appear anywhere\nand only where other definitions may appear.\n" "\ndefine-structure defines a new data structure, name, and\ncreates a set of procedures for creating and manipulating instances of\nthe structure.\nThe identifiers id1 ... and id2 ...\nname the fields of the data structure.\n" "\nThe following procedures are defined by define-structure:\n" "\na constructor procedure whose name is make-name,\n\na type predicate whose name is name?,\n\nan access procedure whose name is name-field\nfor each field name id1 ... and\nid2 ..., and\n\nan assignment procedure whose name is\nset-name-field!\nfor each field name id1 ... and id2 ....\n" "\n" "\nThe fields named by the identifiers id1 ... are\ninitialized by the arguments to the constructor procedure.\nThe fields named by the identifiers id2 ... are initialized\nexplicitly to the values of the expressions expr ....\nEach expression is evaluated within the scope of the identifiers\nid1 ... (bound to the corresponding field values) and any\nof the identifiers id2 ... (bound to the corresponding field\nvalues) appearing before it (as if within a let*).\n" "\nTo clarify, the constructor behaves as if defined as\n" "\n" "(define make-name\n  (lambda (id1 ...)\n    (let* ([id2 expr] ...)\n      body)))\n" "where body builds the structure from the values of the identifiers\nid1 ... and id2 ....\n" "\nIf no fields other than those initialized by the arguments to the\nconstructor procedure are needed, the second subexpression,\n((id2 expr) ...), may be omitted.\n" "\nThe following simple example\ndemonstrates how pairs might be defined in Scheme if they did not\nalready exist.\nBoth fields are initialized by the arguments to the constructor\nprocedure.\n" "\n" "(define-structure (pare car cdr))\n(define p (make-pare 'a 'b))\n\n(pare? p) --> #t\n(pair? p) --> #f\n(pare? '(a . b)) --> #f\n\n(pare-car p) --> a\n(pare-cdr p) --> b\n\n(set-pare-cdr! p (make-pare 'b 'c))\n\n(pare-car (pare-cdr p)) --> b\n(pare-cdr (pare-cdr p)) --> c\n" "The following example defines a handy string data structure, called a\nstretch-string, that grows as needed.\nThis example uses a field explicitly initialized to a value that\ndepends on the value of the constructor argument fields.\n" "\n" "(define-structure (stretch-string length fill)\n  ([string (make-string length fill)]))\n\n(define stretch-string-ref\n  (lambda (s i)\n    (let ([n (stretch-string-length s)])\n      (when (>= i n) (stretch-stretch-string! s (+ i 1) n))\n      (string-ref (stretch-string-string s) i))))\n\n(define stretch-string-set!\n  (lambda (s i c)\n    (let ([n (stretch-string-length s)])\n      (when (>= i n) (stretch-stretch-string! s (+ i 1) n))\n      (string-set! (stretch-string-string s) i c))))\n\n(define stretch-string-fill!\n  (lambda (s c)\n    (string-fill! (stretch-string-string s) c)\n    (set-stretch-string-fill! s c)))\n\n(define stretch-stretch-string!\n  (lambda (s i n)\n    (set-stretch-string-length! s i)\n    (let ([str (stretch-string-string s)]\n          [fill (stretch-string-fill s)])\n      (let ([xtra (make-string (- i n) fill)])\n        (set-stretch-string-string! s\n          (string-append str xtra))))))\n" "As often happens, most of the procedures defined automatically are\nused only to define more specialized procedures, in this case the procedures\nstretch-string-ref and stretch-string-set!.\nstretch-string-length and stretch-string-string are\nthe only automatically defined procedures that are likely to be\ncalled directly in code that uses stretch strings.\n" "\n" "(define ss (make-stretch-string 2 #\\X))\n\n(stretch-string-string ss) --> \"XX\"\n(stretch-string-ref ss 3) --> #\\X\n(stretch-string-length ss) --> 4\n(stretch-string-string ss) --> \"XXXX\"\n\n(stretch-string-fill! ss #\\@)\n(stretch-string-string ss) --> \"@@@@\"\n(stretch-string-ref ss 5) --> #\\@\n(stretch-string-string ss) --> \"@@@@@@\"\n\n(stretch-string-set! ss 7 #\\=)\n(stretch-string-length ss) --> 8\n(stretch-string-string ss) --> \"@@@@@@@=\"\n" "Section http://scheme.com/tspl4/./syntax.html#g1378.4 of The Scheme Programming Language, 4th Edition defines a simplified\nvariant of define-structure as an example of the use of\nsyntax-case.\nThe definition given below implements the complete version.\n" "\ndefine-structure expands into a series of definitions for names\ngenerated from the structure name and field names.\nThe generated identifiers are created with\ndatum->syntax to\nmake the identifiers visible where the define-structure\nform appears.\nSince a define-structure form expands into a begin\ncontaining definitions, it is itself a definition and can be used\nwherever definitions are valid.\n" "\n" "(define-syntax define-structure\n  (lambda (x)\n    (define gen-id\n      (lambda (template-id . args)\n        (datum->syntax template-id\n          (string->symbol\n            (apply string-append\n                   (map (lambda (x)\n                          (if (string? x)\n                              x\n                              (symbol->string\n                                (syntax->datum x))))\n                        args))))))\n    (syntax-case x ()\n      ((_ (name field1 ...))\n       (andmap identifier? #'(name field1 ...))\n       #'(define-structure (name field1 ...) ()))\n      ((_ (name field1 ...) ((field2 init) ...))\n       (andmap identifier? #'(name field1 ... field2 ...))\n       (with-syntax\n         ((constructor (gen-id #'name \"make-\" #'name))\n          (predicate (gen-id #'name #'name \"?\"))\n          ((access ...)\n           (map (lambda (x) (gen-id x #'name \"-\" x))\n                #'(field1 ... field2 ...)))\n          ((assign ...)\n           (map (lambda (x) (gen-id x \"set-\" #'name \"-\" x \"!\"))\n                #'(field1 ... field2 ...)))\n          (structure-length\n           (+ (length #'(field1 ... field2 ...)) 1))\n          ((index ...)\n           (let f ([i 1] [ids #'(field1 ... field2 ...)])\n             (if (null? ids)\n                 '()\n                 (cons i (f (+ i 1) (cdr ids)))))))\n         #'(begin\n             (define constructor\n               (lambda (field1 ...)\n                 (let* ([field2 init] ...)\n                   (vector 'name field1 ... field2 ...))))\n             (define predicate\n               (lambda (x)\n                 (and (vector? x)\n                      (#3%fx= (vector-length x) structure-length)\n                      (eq? (vector-ref x 0) 'name))))\n             (define access (lambda (x) (vector-ref x index)))\n             ...\n             (define assign\n               (lambda (x update) (vector-set! x index update)))\n             ...))))))\n") ("foreign:s4" "\nprocedure: (system command)\nreturns: see below\nlibraries: (chezscheme)\n" "command must be a string.\n" "\nThe system procedure creates a subprocess to perform the operation\nspecified by command.\nThe subprocess may communicate with the user through the same console\ninput and console output files used by the Scheme process.\nAfter creating the subprocess, system waits for the process to exit\nbefore returning.\n" "\nWhen the subprocess exits, system returns the exit code for the\nsubprocess, unless (on Unix-based systems) a signal caused the subprocess\nto terminate, in which case system returns the negation of the\nsignal that caused the termination, e.g., -1 for SIGHUP.\n\n") ("foreign:s5" "\nprocedure: (open-process-ports command)\nprocedure: (open-process-ports command b-mode)\nprocedure: (open-process-ports command b-mode ?transcoder)\nreturns: see below\nlibraries: (chezscheme)\n" "command must be a string.\nIf ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure creates textual ports, each of whose\ntranscoder is ?transcoder.\nOtherwise, this procedure returns binary ports.\nb-mode specifies the buffer mode used by each of the ports\nreturned by this procedure and defaults to block.\nBuffer modes are described in Section http://scheme.com/tspl4/./io.html#g1237.2 of\nThe Scheme Programming Language, 4th Edition.\n" "\nopen-process-ports creates a subprocess to perform the operation\nspecified by command.\nUnlike system, process returns immediately after creating the\nsubprocess, i.e., without waiting for the subprocess to terminate.\nIt returns four values:\n" "\ng24to-stdin is an output port to which Scheme can send output to the\nsubprocess through the subprocess's standard input file.\n\ng25from-stdout is an input port from which Scheme can read input from\nthe subprocess through the subprocess's standard output file.\n\ng26from-stderr is an input port from which Scheme can read input from\nthe subprocess through the subprocess's standard error file.\n\ng27process-id is an integer identifying the created subprocess\nprovided by the host operating system.\n" "\n" "\nIf the process exits or closes its standard output file descriptor, any\nprocedure that reads input from from-stdout will return an\nend-of-file object.\nSimilarly, if the process exits or closes its standard error file\ndescriptor, any procedure that reads input from from-stderr will\nreturn an end-of-file object.\n" "\nThe predicate input-port-ready?\nmay be used to detect whether input has been sent by the subprocess to\nScheme.\n" "\nIt is sometimes necessary to force output to be sent immediately\nto the subprocess by invoking flush-output-port on\nto-stdin, since Chez Scheme buffers the output for efficiency.\n" "\nOn UNIX systems, the process-id is the process identifier\nfor the shell created to execute command.\nIf command is used to invoke an executable file rather than\na shell command, it may be useful to prepend command with\nthe string \"exec \", which causes the shell to load and execute\nthe named executable directly, without forking a new\nprocess---the shell equivalent of a tail call.\nThis will reduce by one the number of subprocesses created and\ncause process-id to reflect the process identifier for the \nexecutable once the shell has transferred control.\n\n") ("foreign:s7" "\nprocedure: (process command)\nreturns: see explanation\nlibraries: (chezscheme)\n" "command must be a string.\n" "\nprocess is similar to open-process-ports, but less\ngeneral.\nIt does not return a port from which the subprocess's standard error output\ncan be read, and it always creates textual ports.\nIt returns a list of three values rather than the four separate values\nof open-process-ports.\nThe returned list contains, in order: from-stdout,\nto-stdin, and process-id, which correspond to the second,\nfirst, and fourth return values of open-process-ports.\n\n" "\n\n") ("foreign:s10" "\nsyntax: (foreign-procedure conv ... entry-exp (param-type ...) res-type)\nreturns: a procedure\nlibraries: (chezscheme)\n" "entry-exp must evaluate to a string representing a valid foreign\nprocedure entry point or an integer representing the address of the\nforeign procedure.\nThe param-types and res-type must be symbols or\nstructured forms as described below.\nWhen a foreign-procedure expression is evaluated, a Scheme procedure is\ncreated that will invoke the foreign procedure specified by entry-exp.\nWhen the procedure is called each argument is checked and converted according to\nthe specified param-type before it is passed to the foreign procedure.\nThe result of the foreign procedure call is converted as specified\nby the res-type.\nMultiple procedures may be created for the same foreign entry.\n" "\npage:conv-descriptionEach conv adjusts specifies the calling convention to be used.\nA #f is allowed as conv to indicate the default calling convention\non the target machine (so the #f has no effect).\nThree other conventions are currently supported under\nWindows: __stdcall, __cdecl, and __com (32-bit only).\nSince __cdecl is the default, specifying __cdecl is\nequivalent to specifying #f or no convention.\nFinally, conv can be __collect_safe to indicate that garbage\ncollection is allowed concurrent to a call of the foreign procedure.\n" "\nUse __stdcall to access most Windows API procedures.\nUse __cdecl for Windows API varargs procedures,\nfor C library procedures, and for most other procedures.\nUse __com to invoke COM interface methods; COM uses the\n__stdcall convention but additionally performs the indirections\nnecessary to obtain the correct method from a COM instance.\nThe address of the COM instance must be passed as the first argument,\nwhich should normally be declared as iptr.\nFor the __com interface only, entry-exp must evaluate\nto the byte offset of the method in the COM vtable.\nFor example,\n" "\n" "(foreign-procedure __com 12 (iptr double-float) integer-32)\n" "creates an interface to a COM method at offset 12 in the vtable\nencapsulated within the COM instance passed as the first argument,\nwith the second argument being a double float and the return\nvalue being an integer.\n" "\nUse __collect_safe to declare that garbage collection is\nallowed concurrent to the foreign procedure. The\n__collect_safe declaration allows concurrent collection by\ndeactivating the current thread (see fork-thread) when the\nforeign procedure is called, and the thread is activated again when\nthe foreign procedure returns. The __collect_safe declaration\nis useful, for example, when calling a blocking I/O call to allow\nother Scheme threads to run normally. Refrain from passing collectable memory to a\n__collect_safe foreign procedure, or use lock-object\nto lock the memory in place; see also Sdeactivate_thread. The\n__collect_safe declaration has no effect on a non-threaded\nversion of the system.\n" "\nFor example, calling the C sleep function with the default\nconvention will block other Scheme threads from performing a garbage\ncollection, but adding the __collect_safe declaration avoids that\nproblem:\n" "\n" "(define c-sleep\n  (foreign-procedure __collect_safe \"sleep\" (unsigned) unsigned))\n(c-sleep 10) ; sleeps for 10 seconds without blocking other threads\n" "If a foreign procedure that is called with __collect_safe can\ninvoke callables, then each callable should also be declared with\n__collect_safe so that the callable reactivates the thread.\n\n" "\nComplete type checking and conversion is performed on the parameters\nto a foreign procedure.\nThe types\nscheme-object,\nstring,\nwstring,\nu8*,\nu16*,\nu32*,\nutf-8,\nutf-16le,\nutf-16be,\nutf-32le,\nand\nutf-32be,\nmust be used with caution, however, since they allow allocated\nScheme objects to be used in places the Scheme memory management system\ncannot control. No problems will arise as long as such objects are not\nretained in foreign variables or data structures while Scheme code is running,\nand as long as they are not passed as arguments to a __collect_safe procedure,\nsince garbage collection can occur only while Scheme code is running\nor when concurrent garbage collection is enabled.\nOther parameter types are converted to equivalent foreign\nrepresentations and consequently they can be retained indefinitely in\nforeign variables and data structures.\n" "\nFor argument types string, wstring,\nutf-8,\nutf-16le,\nutf-16be,\nutf-32le, and\nutf-32be, an argument is converted\nto a fresh object that is passed to the foreign procedure. Since the\nfresh object is not accessible for locking before the call, it can\nnever be treated correctly for a __collect_safe foreign\nprocedure, so those types are disallowed as argument types for\na __collect_safe foreign procedure. For analogous reasons,\nthose types are disallowed as the result of a __collect_safe\nforeign callable.\n" "\nFollowing are the valid parameter types:\n" "\n" "integer-8: Exact integers from -27 through\n28 - 1 are valid.\nIntegers in the range 27 through 28 - 1 are treated as\ntwo's complement representations of negative numbers, e.g.,\n#xff is treated as -1.\nThe argument is passed to C as an integer of the appropriate size\n(usually signed char).\n" "\n" "unsigned-8: Exact integers from -27 to\n28 - 1 are valid.\nIntegers in the range -27 through -1 are treated as the\npositive equivalents of their two's complement representation,\ne.g., -1 is treated as #xff.\nThe argument is passed to C as an unsigned integer of the\nappropriate size (usually unsigned char).\n" "\n" "integer-16: Exact integers from -215 through\n216 - 1 are valid.\nIntegers in the range 215 through 216 - 1 are treated as\ntwo's complement representations of negative numbers, e.g.,\n#xffff is treated as -1.\nThe argument is passed to C as an integer of the appropriate size\n(usually short).\n" "\n" "unsigned-16: Exact integers from -215 to\n216 - 1 are valid.\nIntegers in the range -215 through -1 are treated as the\npositive equivalents of their two's complement representation,\ne.g., -1 is treated as #xffff.\nThe argument is passed to C as an unsigned integer of the\nappropriate size (usually unsigned short).\n" "\n" "integer-32: Exact integers from -231 through\n232 - 1 are valid.\nIntegers in the range 231 through 232 - 1 are treated as\ntwo's complement representations of negative numbers, e.g.,\n#xffffffff is treated as -1.\nThe argument is passed to C as an integer of the appropriate size\n(usually int).\n" "\n" "unsigned-32: Exact integers from -231 to\n232 - 1 are valid.\nIntegers in the range -231 through -1 are treated as the\npositive equivalents of their two's complement representation,\ne.g., -1 is treated as #xffffffff.\nThe argument is passed to C as an unsigned integer of the\nappropriate size (usually unsigned int).\n" "\n" "integer-64: Exact integers from -263 through\n264 - 1 are valid.\nIntegers in the range 263 through 264 - 1 are treated as\ntwo's complement representations of negative numbers.\nThe argument is passed to C as an integer of the appropriate\nsize (usually long long or, on many 64-bit platforms,\nlong).\n" "\n" "unsigned-64: Exact integers from -263 through\n264 - 1 are valid.\nIntegers in the range -263 through -1 are treated as the\npositive equivalents of their two's complement representation,\nThe argument is passed to C as an integer of the appropriate\nsize (usually unsigned long long or, on many 64-bit\nplatforms, long).\n" "\n" "double-float: Only Scheme flonums are valid---other\nScheme numeric types are not automatically converted.\nThe argument is passed to C as a double float.\n" "\n" "single-float: Only Scheme flonums are valid---other\nScheme numeric types are not automatically converted.\nThe argument is passed to C as a single float.\nSince Chez Scheme represents flonums in double-float format, the\nparameter is first converted into single-float format.\n" "\n" "short: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C short.\n" "\n" "unsigned-short: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C unsigned short.\n" "\n" "int: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C int.\n" "\n" "unsigned: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C unsigned.\n" "\n" "unsigned-int: This type is an alias unsigned.\nfixed-size type above, depending on the size of a C unsigned.\n" "\n" "long: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C long.\n" "\n" "unsigned-long: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C unsigned long.\n" "\n" "long-long: This type is an alias for the appropriate\nfixed-size type above, depending on the size of the nonstandard C type\nlong long.\n" "\n" "unsigned-long-long: This type is an alias for the appropriate\nfixed-size type above, depending on the size of the nonstandard C type\nunsigned long long.\n" "\n" "ptrdiff_t: This type is an alias for the appropriate\nfixed-size type above, depending on its definition in the host machine's\nstddef.h include file.\n" "\n" "size_t: This type is an alias for the appropriate unsigned\nfixed-size type above, depending on its definition in the host machine's\nstddef.h include file.\n" "\n" "ssize_t: This type is an alias for the appropriate signed\nfixed-size type above, depending on its definition in the host machine's\nstddef.h include file.\n" "\n" "iptr: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C pointer.\n" "\n" "uptr: This type is an alias for the appropriate\n(unsigned) fixed-size type above, depending on the size of a C pointer.\n" "\n" "void*: This type is an alias for uptr.\n" "\n" "fixnum: This type is equivalent to iptr,\nexcept only values in the fixnum range are valid.\nTransmission of fixnums is slightly faster than transmission of\niptr values, but the fixnum range is smaller, so some\niptr values do not have a fixnum representation.\n" "\n" "boolean: Any Scheme object may be passed as a boolean.\n#f is converted to 0; all other objects are converted to 1.\nThe argument is passed to C as an int.\n" "\n" "char: Only Scheme characters with Unicode scalar values\nin the range 0 through 255 are valid char parameters.\nThe character is converted to its Unicode scalar value, as with\nchar->integer, and passed to C as an unsigned char.\n" "\n" "wchar_t: Only Scheme characters are valid wchar_t parameters.\nUnder Windows and any other system where wchar_t holds only\n16-bit values rather than full Unicode scalar values, only characters with\n16-bit Unicode scalar values are valid.\nOn systems where wchar_t is a full 32-bit value, any Scheme\ncharacter is valid.\nThe character is converted to its Unicode scalar value, as with\nchar->integer, and passed to C as a wchar_t.\n" "\n" "wchar: This type is an alias for wchar_t.\n" "\n" "double: This type is an alias for double-float.\n" "\n" "float: This type is an alias for single-float.\n" "\n" "scheme-object: The argument is passed directly to the\nforeign procedure; no conversion or type checking is performed.\nThis form of parameter passing should be used with discretion.\nScheme objects should not be preserved in foreign variables or data structures\nsince the memory management system may relocate them between foreign procedure\ncalls.\n" "\n" "ptr: This type is an alias for scheme-object.\n" "\n" "u8*: The argument must be a Scheme bytevector or\n#f.\nFor #f, the null pointer (0) is passed to the foreign procedure.\nFor a bytevector, a pointer to the first byte of the bytevector's data\nis passed.\nIf the C routine to which the data is passed requires the input to be\nnull-terminated, a null (0) byte must be included explicitly in the\nbytevector.\nThe bytevector should not be retained in foreign variables or data\nstructures, since the memory management system may relocate or discard\nthem between foreign procedure calls, and use their storage for some\nother purpose.\n" "\n" "u16*: Arguments of this type are treated just like\narguments of type u8*.\nIf the C routine to which the data is passed requires the input to be\nnull-terminated, two null (0) bytes must be included explicitly in the\nbytevector, aligned on a 16-bit boundary.\n" "\n" "u32*: Arguments of this type are treated just like\narguments of type u8*.\nIf the C routine to which the data is passed requires the input to be\nnull-terminated, four null (0) bytes must be included explicitly in the\nbytevector, aligned on a 32-bit boundary.\n" "\n" "utf-8: The argument must be a Scheme string or\n#f.\nFor #f, the null pointer (0) is passed to the foreign procedure.\nA string is converted into a bytevector, as if via string->utf8,\nwith an added null byte, and the address of the first byte of the\nbytevector is passed to C.\nThe bytevector should not be retained in foreign variables or data\nstructures, since the memory management system may relocate or discard\nthem between foreign procedure calls and use their storage for some\nother purpose. The utf-8 argument type is not allowed for a\n__collect_safe foreign procedure.\n" "\n" "utf-16le: Arguments of this type are treated like arguments\nof type utf-8, except they are converted as if via\nstring->utf16 with endianness little, and they are\nextended by two null bytes rather than one.\n" "\n" "utf-16be: Arguments of this type are treated like arguments\nof type utf-8, except they are converted as if via\nstring->utf16 with endianness big, and they are\nextended by two null bytes rather than one.\n" "\n" "utf-32le: Arguments of this type are treated like arguments\nof type utf-8, except they are converted as if via\nstring->utf32 with endianness little, and they are\nextended by four null bytes rather than one.\n" "\n" "utf-32be: Arguments of this type are treated like arguments\nof type utf-8, except they are converted as if via\nstring->utf32 with endianness big, and they are\nextended by four null bytes rather than one.\n" "\n" "string: This type is an alias for utf-8.\n" "\n" "wstring: This type is an alias for utf-16le,\nutf-16be, utf-32le, or utf-32be as\nappropriate depending on the size of a C wchar_t and\nthe endianness of the target machine.\nFor example, wstring is equivalent to utf-16le\nunder Windows running on Intel hardware.\n" "\n" "(* ftype-name): This type allows a pointer to a foreign\ntype (ftype) to be passed.\nThe argument must be an ftype pointer of the type identified by\nftype-name,\nand the actual argument is the address encapsulated in the\nftype pointer.\nSee Section 4.5 for a description of\nforeign types.\n" "\n" "(& ftype-name): This type allows a foreign\ntype (ftype) to be passed as a value, but represented\non the Scheme side as a pointer to the foreign-type data.\nThat is, a (& ftype-name) argument is represented on\nthe Scheme side the same as a (* ftype-name) argument,\nbut a (& ftype-name) argument is passed to the foreign procedure as the\ncontent at the foreign pointer's address instead of as the\naddress. For example, if ftype-name identifies a struct type,\nthen (& ftype-name) passes a struct argument instead of\na struct-pointer argument. The ftype-name cannot refer to an array type.\n" "\n" "The result types are similar to the parameter types with the addition of a\nvoid type.\nIn general, the type conversions are the inverse of the parameter type\nconversions.\nNo error checking is performed on return, since the system cannot determine\nwhether a foreign result is actually of the indicated type.\nParticular caution should be exercised with the result types\nscheme-object,\ndouble-float,\ndouble,\nsingle-float,\nfloat,\nand the types that result in the construction of bytevectors or strings,\nsince invalid\nreturn values may lead to invalid memory references as well as incorrect\ncomputations.\nFollowing are the valid result types:\n" "\n" "void: The result of the foreign procedure call is\nignored and an unspecified Scheme object is returned.\nvoid should be used when foreign procedures are called for effect only.\n" "\n" "integer-8: The result is interpreted as a signed\n8-bit integer and is converted to a Scheme exact integer.\n" "\n" "unsigned-8: The result is interpreted as an unsigned\n8-bit integer and is converted to a Scheme nonnegative exact integer.\n" "\n" "integer-16: The result is interpreted as a signed\n16-bit integer and is converted to a Scheme exact integer.\n" "\n" "unsigned-16: The result is interpreted as an unsigned\n16-bit integer and is converted to a Scheme nonnegative exact integer.\n" "\n" "integer-32: The result is interpreted as a signed\n32-bit integer and is converted to a Scheme exact integer.\n" "\n" "unsigned-32: The result is interpreted as an unsigned\n32-bit integer and is converted to a Scheme nonnegative exact integer.\n" "\n" "integer-64: The result is interpreted as a signed\n64-bit integer and is converted to a Scheme exact integer.\n" "\n" "unsigned-64: The result is interpreted as an unsigned\n64-bit integer and is converted to a Scheme nonnegative exact integer.\n" "\n" "double-float: The result is interpreted as a double float\nand is translated into a Chez Scheme flonum.\n" "\n" "single-float: The result is interpreted as a single float\nand is translated into a Chez Scheme flonum.\nSince Chez Scheme represents flonums in double-float format, the\nresult is first converted into double-float format.\n" "\n" "short: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C short.\n" "\n" "unsigned-short: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C unsigned short.\n" "\n" "int: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C int.\n" "\n" "unsigned: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C unsigned.\n" "\n" "unsigned-int: This type is an alias unsigned.\nfixed-size type above, depending on the size of a C unsigned.\n" "\n" "long: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C long.\n" "\n" "unsigned-long: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C unsigned long.\n" "\n" "long-long: This type is an alias for the appropriate\nfixed-size type above, depending on the size of the nonstandard C type\nlong long.\n" "\n" "unsigned-long-long: This type is an alias for the appropriate\nfixed-size type above, depending on the size of the nonstandard C type\nunsigned long long.\n" "\n" "ptrdiff_t: This type is an alias for the appropriate\nfixed-size type above, depending on its definition in the host machine's\nstddef.h include file.\n" "\n" "size_t: This type is an alias for the appropriate unsigned\nfixed-size type above, depending on its definition in the host machine's\nstddef.h include file.\n" "\n" "ssize_t: This type is an alias for the appropriate signed\nfixed-size type above, depending on its definition in the host machine's\nstddef.h include file.\n" "\n" "iptr: This type is an alias for the appropriate\nfixed-size type above, depending on the size of a C pointer.\n" "\n" "uptr: This type is an alias for the appropriate\n(unsigned) fixed-size type above, depending on the size of a C pointer.\n" "\n" "void*: This type is an alias for uptr.\n" "\n" "boolean: This type converts a C int return value\ninto a Scheme boolean.\n0 is converted to #f; all other values are converted to #t.\n" "\n" "char: This type converts a C unsigned char return value\ninto a Scheme character, as if via integer->char.\n" "\n" "wchar_t: This type converts a C wchar_t return value\ninto a Scheme character, as if via integer->char.\nThe wchar_t value must be a valid Unicode scalar value.\n" "\n" "wchar: This type is an alias for wchar_t.\n" "\n" "double: This type is an alias for double-float.\n" "\n" "float: This type is an alias for single-float.\n" "\n" "scheme-object: The result is assumed to be a valid Scheme\nobject, and no conversion is performed.\nThis type is inherently dangerous, since an invalid Scheme object can corrupt\nthe memory management system with unpredictable (but always unpleasant) results.\nSince Scheme objects are actually typed pointers, even integers cannot\nsafely be returned as type scheme-object unless they were created by\nthe Scheme system.\n" "\n" "ptr: This type is an alias for scheme-object.\n" "\n" "u8*: The result is interpreted as a pointer to a\nnull-terminated sequence of 8-bit unsigned integers (bytes).\nIf the result is a null pointer, #f is returned.\nOtherwise, the sequence of bytes is stored in a freshly allocated\nbytevector of the appropriate length, and the bytevector is returned to\nScheme.\n" "\n" "u16*: The result is interpreted as a pointer to a\nnull-terminated sequence of 16-bit unsigned integers.\nIf the result is a null pointer, #f is returned.\nOtherwise, the sequence of 16-bit integers is stored in a freshly allocated\nbytevector of the appropriate length, and the bytevector is returned to\nScheme.\nThe null terminator must be a properly aligned 16-bit word,\ni.e., two bytes of zero aligned on a 16-bit boundary.\n" "\n" "u32*: The result is interpreted as a pointer to a\nnull-terminated sequence of 32-bit unsigned integers.\nIf the result is a null pointer, #f is returned.\nOtherwise, the sequence of 16-bit integers is stored in a freshly allocated\nbytevector of the appropriate length, and the bytevector is returned to\nScheme.\nThe null terminator must be a properly aligned 32-bit word,\ni.e., four bytes of zero aligned on a 32-bit boundary.\n" "\n" "utf-8: The result is interpreted as a pointer to a\nnull-terminated sequence of 8-bit unsigned character values.\nIf the result is a null pointer, #f is returned.\nOtherwise, the sequence of bytes is converted into a Scheme string, as if\nvia utf8->string, and the string is returned to Scheme.\n" "\n" "utf-16le: The result is interpreted as a pointer to a\nnull-terminated sequence of 16-bit unsigned integers.\nIf the result is a null pointer, #f is returned.\nOtherwise, the sequence of integers is converted into a Scheme string, as if\nvia utf16->string with endianness little,\nand the string is returned to Scheme.\nA byte-order mark in the sequence of integers as treated as an ordinary\ncharacter value and does not affect the byte ordering.\n" "\n" "utf-16be: The result is interpreted as a pointer to a\nnull-terminated sequence of 16-bit unsigned integers.\nIf the result is a null pointer, #f is returned.\nOtherwise, the sequence of integers is converted into a Scheme string, as if\nvia utf16->string with endianness big,\nand the string is returned to Scheme.\nA byte-order mark in the sequence of integers as treated as an ordinary\ncharacter value and does not affect the byte ordering.\n" "\n" "utf-32le: The result is interpreted as a pointer to a\nnull-terminated sequence of 32-bit unsigned integers.\nIf the result is a null pointer, #f is returned.\nOtherwise, the sequence of integers is converted into a Scheme string, as if\nvia utf32->string with endianness little,\nand the string is returned to Scheme.\nA byte-order mark in the sequence of integers as treated as an ordinary\ncharacter value and does not affect the byte ordering.\n" "\n" "utf-32be: The result is interpreted as a pointer to a\nnull-terminated sequence of 32-bit unsigned integers.\nIf the result is a null pointer, #f is returned.\nOtherwise, the sequence of integers is converted into a Scheme string, as if\nvia utf32->string with endianness big,\nand the string is returned to Scheme.\nA byte-order mark in the sequence of integers as treated as an ordinary\ncharacter value and does not affect the byte ordering.\n" "\n" "string: This type is an alias for utf-8.\n" "\n" "wstring: This type is an alias for utf-16le,\nutf-16be, utf-32le, or utf-32be as\nappropriate depending on the size of a C wchar_t and\nthe endianness of the target machine.\nFor example, wstring is equivalent to utf-16le\nunder Windows running on Intel hardware.\n" "\n" "(* ftype-name): The result is interpreted as the address of a foreign object\nwhose structure is described by the ftype identified by ftype-name, and a freshly allocated\nftype pointer encapsulating the address is returned.\nSee Section 4.5 for a description of\nforeign types.\n" "\n" "(& ftype-name): The result is interpreted as a foreign object\nwhose structure is described by the ftype identified by ftype-name, where the foreign\nprocedure returns a ftype-name result, but the caller\nmust provide an extra (* ftype-name) argument before\nall other arguments to receive the result. An unspecified Scheme object\nis returned when the foreign procedure is called, since the result\nis instead written into storage referenced by the extra argument.\n The ftype-name cannot refer to an array type.\n" "\n" "Consider a C identity procedure:\n" "int id(x) int x; { return x; }\n" "After a file containing this procedure has been compiled and loaded\n(see Section 4.6) it can be accessed as follows:\n" "\n" "(foreign-procedure \"id\"\n  (int) int) --> #<procedure>\n((foreign-procedure \"id\"\n   (int) int)\n 1) --> 1\n(define int-id\n  (foreign-procedure \"id\"\n    (int) int))\n(int-id 1) --> 1\n" "The \"id\" entry can also be interpreted as accepting and returning\na boolean:\n" "\n" "(define bool-id\n  (foreign-procedure \"id\"\n    (boolean) boolean))\n(bool-id #f) --> #f\n(bool-id #t) --> #t\n(bool-id 1) --> #t\n" "As the last example reveals, bool-id is actually a conversion procedure.\nWhen a Scheme object is passed as type boolean it is converted to\n0 or 1, and when it is returned it is converted to #f or #t.\nAs a result objects are converted to normalized boolean values.\nThe \"id\" entry can be used to create other conversion procedures by\nvarying the type specifications:\n" "\n" "(define int->bool\n  (foreign-procedure \"id\"\n    (int) boolean))\n(int->bool 0) --> #f\n(int->bool 5) --> #t\n(map (foreign-procedure \"id\"\n       (boolean) int)\n     '(#t #f)) --> (1 0)\n(define void\n  (foreign-procedure \"id\"\n    (int) void))\n(void 10) --> unspecified\n" "There are, of course, simpler and more efficient ways of accomplishing\nthese conversions directly in Scheme.\n" "\nA foreign entry is resolved when a\nforeign-procedure expression\nis evaluated, rather than either when the code is loaded or each time\nthe procedure is invoked.\nThus, the following definition is always valid since the\nforeign-procedure expression is not immediately evaluated:\n" "\n" "(define doit\n  (lambda ()\n    ((foreign-procedure \"doit\" () void))))\n" "doit should not be invoked, however, before an entry for\n\"doit\" has been provided.\nSimilarly, an entry for \"doit\" must exist before the following code\nis evaluated:\n" "\n" "(define doit\n  (foreign-procedure \"doit\" () void))\n" "Although the second definition is more constraining on the load order\nof foreign files, it is more efficient since the entry resolution need\nbe done only once.\n" "\nIt is often useful to define a template to be used\nin the creation of several foreign procedures with similar argument\ntypes and return values.\nFor example, the following code creates two foreign procedures from\na single foreign procedure expression, by abstracting out the foreign\nprocedure name:\n" "\n" "(define double->double\n  (lambda (proc-name)\n    (foreign-procedure proc-name\n      (double)\n      double)))\n\n(define log10 (double->double \"log10\"))\n(define gamma (double->double \"gamma\"))\n" "Both \"log10\" and \"gamma\" must be available as foreign\nentries (see Section 4.6)\nbefore the corresponding definitions.\nThe use of foreign procedure templates can simplify the coding process\nand reduce the amount of code generated when a large number of\nforeign procedures are involved, e.g., when an entire library of\nforeign procedures is imported into Scheme.\n\n") ("foreign:s127" "\nsyntax: (foreign-callable conv ... proc-exp (param-type ...) res-type)\nreturns: a code object\nlibraries: (chezscheme)\n" "proc-exp must evaluate to a procedure, the Scheme procedure that\nis to be invoked by foreign code.\nThe parameter and result types are as described for\nforeign-procedure in Section 4.2,\nexcept that the requirements and conversions are effectively reversed,\ne.g., the conversions described for foreign-procedure\narguments are performed for foreign-callable return\nvalues.\nA (& ftype) argument to the callable refers to an address\nthat is valid only during the dynamic extent of the callback invocation.\nA (& ftype) result type for a callable causes the Scheme\nprocedure to receive an extra (& ftype) argument before\nall others; the Scheme procedure should write a result into the extra\nargument, and the direct result of the Scheme procedure is ignored.\nType checking is performed for result values but not argument values,\nsince the parameter\nvalues are provided by the foreign code and must be assumed to be\ncorrect.\n" "\nEach conv adjusts the calling convention to be used.\nforeign-callable supports the same conventions as\nforeign-procedure with the exception of __com.\nThe __collect_safe convention for a callable activates a\ncalling thread if the thread is not already activated, and\nthe thread's activation state is reverted when the callable\nreturns. If a calling thread is not currently registered with\nthe Scheme system, then reverting the thread's activation state implies\ndestroying the thread's registration (see Sdestroy_thread).\n\n" "\nThe value produced by foreign-callable is a Scheme code object,\nwhich contains some header information as well as code that performs\nthe call to the encapsulated Scheme procedure.\nThe code object may be converted into a foreign-callable address via\nforeign-callable-entry-point, which returns an integer representing\nthe address of the entry point within the code object.\n(The C-callable library function Sforeign_callable_entry_point, described in\nSection 4.8, may be used to obtain the entry point\nas well.)  \nThis is an implicit pointer into a Scheme object, and\nin many cases, it is necessary to lock the code object\n(using lock-object)\nbefore converting it into an entry point\nto prevent Scheme's storage management system from\nrelocating or destroying the code object, e.g., when the entry point is\nregistered as a callback and retained in the \"C\" side indefinitely.\n" "\nThe following code creates a foreign-callable code object, locks\nthe code object, and returns the entry point.\n" "\n" "(let ([x (foreign-callable\n           (lambda (x y) (pretty-print (cons x (* y 2))))\n           (string integer-32)\n           void)])\n  (lock-object x)\n  (foreign-callable-entry-point x))\n" "Unless the entry point is intended to be permanent, a pointer to the\ncode object returned by foreign-callable should be retained\nso that it can be unlocked when no longer needed.\n" "\nMixed use of foreign-callable and foreign-procedure\nmay result in nesting of foreign and Scheme calls, and this\nresults in some interesting considerations when continuations are\ninvolved, directly or indirectly (as via the default exception handler).\nSee Section 4.4 for a discussion of the\ninteraction between foreign calls and continuations.\n" "\nThe following example demonstrates how the \"callback\" functions\nrequired by many windowing systems might be defined in Scheme with the\nuse of foreign-callable.\nAssume that the following C code has been compiled and loaded\n(see Section 4.6).\n" "\n" "#include <stdio.h>\n\ntypedef void (*CB)(char);\n\nCB callbacks[256];\n\nvoid cb_init(void) {\n   int i;\n\n   for (i = 0; i < 256; i += 1)\n       callbacks[i] = (CB)0;\n}\n\nvoid register_callback(char c, CB cb) {\n    callbacks[c] = cb;\n}\n\nvoid event_loop(void) {\n    CB f; char c;\n\n    for (;;) {\n        c = getchar();\n        if (c == EOF) break;\n        f = callbacks[c];\n        if (f != (CB)0) f(c);\n    }\n}\n" "Interfaces to these functions may be defined in Scheme as follows.\n" "\n" "(define cb-init\n  (foreign-procedure \"cb_init\" () void))\n(define register-callback\n  (foreign-procedure \"register_callback\" (char void*) void))\n(define event-loop\n  (foreign-procedure __collect_safe \"event_loop\" () void))\n" "A callback for selected characters can then be defined.\n" "\n" "(define callback\n  (lambda (p)\n    (let ([code (foreign-callable __collect_safe p (char) void)])\n      (lock-object code)\n      (foreign-callable-entry-point code))))\n(define ouch\n  (callback\n    (lambda (c)\n      (printf \"Ouch! Hit by '~c'~%\" c))))\n(define rats\n  (callback\n    (lambda (c)\n      (printf \"Rats! Received '~c'~%\" c))))\n\n(cb-init)\n(register-callback #\\a ouch)\n(register-callback #\\c rats)\n(register-callback #\\e ouch)\n" "This sets up the following interaction.\n" "\n" "> (event-loop)\na\nOuch! Hit by 'a'\nb\nc\nRats! Received 'c'\nd\ne\nOuch! Hit by 'e'\n" "The __collect_safe declarations in this example ensure that\nother threads can continue working while event-loop\nblocks waiting for input.\nA more well-behaved version of the example would save each code object\nreturned by foreign-callable and unlock it when it is no longer\nregistered as a callback.\n\n") ("foreign:s130" "\nprocedure: (foreign-callable-entry-point code)\nreturns: the address of the foreign-callable entry point in code\nlibraries: (chezscheme)\n" "code should be a code object produced by foreign-callable.\n\n") ("foreign:s131" "\nprocedure: (foreign-callable-code-object address)\nreturns: the code object corresponding to the foreign-callable entry point address\nlibraries: (chezscheme)\n" "address must be an exact integer and should be the address of the\nentry point of a code object produced by foreign-callable.\n\n") ("foreign:s132" "\nprocedure: (foreign-alloc n)\nreturns: the address of a freshly allocated block of foreign data n bytes long\nlibraries: (chezscheme)\n" "n must be a positive fixnum.\nThe returned value is an exact integer and is guaranteed to be properly\naligned for any type of value according to the requirements of the\nunderlying hardware.\nAn exception is raised with condition type &assertion\nif the block of foreign data cannot be allocated.\n\n") ("foreign:s133" "\nprocedure: (foreign-free address)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure frees the block of storage to which address points.\naddress must be an exact integer in the range -2w-1 through\n2w - 1, where w is the width in bits of a pointer, e.g., 64 for a\n64-bit machine.\nIt should be an address returned by an earlier call to\nforeign-alloc and not subsequently passed to\nforeign-free.\n") ("foreign:s134" "\nprocedure: (foreign-ref type address offset)\nreturns: see below\nlibraries: (chezscheme)\n" "foreign-ref extracts the value of type type\nfrom the memory location at offset bytes offset from\naddress.\n" "\ntype must be a symbol identifying the type of value\nto be extracted.\nThe following types have machine-dependent sizes and correspond to the\nlike-named C types:\n" "\nshort,\nunsigned-short,\nint,\nunsigned,\nunsigned-int,\nlong,\nunsigned-long,\nlong-long,\nunsigned-long-long,\nptrdiff_t,\nsize_t,\nssize_t,\nchar,\nwchar_t,\nfloat,\ndouble, and\nvoid*.\n" "\n" "\nThe types long-long and unsigned-long-long\ncorrespond to the C types long long \nand unsigned long long.\nA value of type char is referenced as a single\nbyte and converted (as if via integer->char)\ninto a Scheme character.\nA value of type wchar_t is converted (as if via\ninteger->char) into a Scheme character.\nThe value must be a valid Unicode scalar value.\n" "\nwchar is an alias for wchar_t.\n" "\nSeveral additional machine-dependent types are recognized:\n" "\niptr,\nuptr,\nfixnum, and\nboolean.\n" "\n" "\nuptr is equivalent to void*; both are treated as\nunsigned integers the size of a pointer.\niptr is treated as a signed integer the size of a pointer.\nfixnum is treated as an iptr, but with a range limited\nto the fixnum range.\nboolean is treated as an int, with zero\nconverted to the Scheme value #f and all\nother values converted to #t.\n" "\nFinally, several fixed-sized types are also supported:\n" "\ninteger-8,\nunsigned-8,\ninteger-16,\nunsigned-16,\ninteger-32,\nunsigned-32,\ninteger-64,\nunsigned-64,\nsingle-float, and\ndouble-float.\n" "\n" "\naddress must be an exact integer in the range -2w-1 through\n2w - 1, where w is the width in bits of a pointer, e.g., 64 for a\n64-bit machine.\noffset must be an exact fixnum.\nThe sum of address and offset should address a readable block\nof memory large enough to hold a value of type type, within a block\nof storage previously returned by foreign-alloc and not\nsubsequently freed by foreign-free or within a block of storage\nobtained via some other mechanism, e.g., a foreign call.\nFor multiple-byte values, the native endianness of the machine is assumed.\n") ("foreign:s135" "\nprocedure: (foreign-set! type address offset value)\nreturns: see below\nlibraries: (chezscheme)\n" "foreign-set! stores a representation of value as type\ntype offset bytes into the block of foreign data addressed by\naddress.\n" "\ntype must be a symbol identifying the type of value\nto be stored, one of those listed in the description of\nforeign-ref above.\nScheme characters are converted to type char or wchar_t\nas if via char->integer.\nFor type boolean, Scheme #f is converted to the\nint 0, and any other Scheme object is converted to 1.\n" "\naddress must be an exact integer in the range -2w-1 through\n2w - 1, where w is the width in bits of a pointer, e.g., 64 for a\n64-bit machine.\noffset must be an exact fixnum.\nThe sum of address and offset should address a writable block\nof memory large enough to hold a value of type type, within a block\nof storage previously returned by foreign-alloc and not\nsubsequently freed by foreign-free or within a block of storage\nobtained via some other mechanism, e.g., a foreign call.\nvalue must be an appropriate value for type, e.g.,\na floating-point number for the float types or an exact integer within\nthe appropriate range for the integer types.\nFor multiple-byte values, the native endianness of the machine is assumed.\n") ("foreign:s136" "\nprocedure: (foreign-sizeof type)\nreturns: the size in bytes of type\nlibraries: (chezscheme)\n" "type must be one of the symbols listed in the description\nof foreign-ref above.\n\n") ("foreign:s137" "\ndefn:define-ftype\nsyntax: (define-ftype ftype-name ftype)\nsyntax: (define-ftype (ftype-name ftype) ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "A define-ftype form is a definition and can appear anywhere\nother definitions can appear.\nIt establishes one or more foreign-type (ftype) bindings for the identifier\nftype-name or identifiers ftype-name ...\nto the foreign type represented ftype or the foreign types\nrepresented by ftype ....\nEach ftype-name can be used to access foreign objects with the\ndeclared shape, and each can be used in the formation of other ftypes.\n" "\nAn ftype must take one of the following forms:\n" "\n" "ftype-name\n(struct (field-name ftype) ...)\n(union (field-name ftype) ...)\n(array length ftype)\n(* ftype)\n(bits (field-name signedness bits) ...)\n(function conv ... (ftype ...) ftype)\n(packed ftype)\n(unpacked ftype)\n(endian endianness ftype)\n" "where length is an exact nonnegative integer,\nbits is an exact positive integer,\nfield-name is an identifier,\nconv is #f or a string naming a valid convention\nas described on page 4.2,\nsignedness is either signed or unsigned, and\nendianness is one of native, big, or little.\n" "\nA restriction not reflected above is that \nfunction ftypes cannot be used as the types of\nfield names or array elements.\nThat is, function ftypes are valid only at the\ntop level of an ftype, e.g,:\n" "\n" "(define-ftype bvcopy_t (function (u8* u8* size_t) void))\n" "or as the immediate sub-type of a pointer (*) ftype, as in the\nfollowing definitions, which are equivalent assuming the definition of\nbvcopy_t above.\n" "\n" "(define-ftype A\n  (struct\n    [x int]\n    [f (* (function (u8* u8* size_t) void))]))\n\n(define-ftype A\n  (struct\n    [x int]\n    [f (* bvcopy_t)]))\n" "That is, a function cannot be embedded within a struct, union,\nor array, but a pointer to a function can be so embedded.\n" "\nThe following definitions establish ftype bindings for F,\nA, and E.\n" "\n" "(define-ftype F (function (wchar_t int) int))\n\n(define-ftype A (array 10 wchar_t))\n\n(define-ftype E\n  (struct\n    [a int]\n    [b double]\n    [c (array 25\n         (struct\n           [a short]\n           [_ long]\n           [b A]))]\n    [d (endian big\n         (union\n           [v1 unsigned-32]\n           [v2 (bits\n                 [hi unsigned 12]\n                 [lo unsigned 20])]))]\n    [e (* A)]\n    [f (* F)]))\n" "The ftype F describes the type of a foreign function that\ntakes two arguments, a wide character and an integer, and returns an\ninteger.\nThe ftype A is simply an array of 10 wchar_t values,\nand its size will be 10 times the size of a single wchar_t.\nThe ftype E is a structure with six fields: an integer\na, a double-float b, an array c, a\nunion d, a pointer e, and a pointer f.\nThe array c is an array of 25 structs, each of which\ncontains a short integer, a long integer, and a A array.\nThe size of the c array will be 25 times the size of a\nsingle A array, plus 25 times the space needed to store\neach of the short and long integers.\nThe union d is either a 32-bit unsigned integer or\na 32-bit unsigned integer split into high (12 bits) and low (20 bits)\ncomponents.\nThe fields of a union overlap so that writing to one effectively\noverlaps the other.\nThus, one can use the d union type to split apart an\nunsigned integer by writing the integer into v1 and reading\nthe pieces from hi and lo.\nThe pointer e points to an A array; it is not\nitself an array, and its size is just the size of a single pointer.\nSimilarly, f points to a function, and its size is also\nthat of a single pointer.\n" "\nAn underscore ( _ ) can be used as the field name for one or\nmore fields of a struct, union, or bits ftype.\nSuch fields are included in the layout but are considered unnamed and\ncannot be accessed via the ftype operators described below.\nThus, in the example above, the long field within the\nc array is inaccessible.\n" "\nNon-underscore field names are handled symbolically, i.e.,\nthey are treated as symbols rather than identifiers.\nEach symbol must be unique (as a symbol) with respect to the other\nfield names within a single struct, union,\nor bits ftype but need not be\nunique with respect to field names in other struct,\nunion, or bits ftypes within the same\nftype.\n" "\nEach ftype-name in an ftype must either\n(a) have been defined previously by define-ftype,\n(b) be defined by the current define-ftype,\nor\n(c) be a base-type name, i.e., one of the type names supported by\nforeign-ref and foreign-set!.\nIn case (b), any reference within one ftype to the\nftype-name of one of the earlier bindings is permissible,\nbut a reference to the ftype-name of the current or a\nsubsequent binding can appear only within a pointer field.\n" "\nFor example, in:\n" "\n" "(define-ftype\n  [Qlist (struct\n           [head int]\n           [tail (* Qlist)])])\n" "the reference to Qlist is permissible since it appears\nwithin a pointer field.\nSimilarly, in:\n" "\n" "(define-ftype\n  [Qfrob (struct\n           [head int]\n           [tail (* Qsnark)])]\n  [Qsnark (struct\n            [head int]\n            [xtra Qfrob]\n            [tail (* Qfrob)])])\n" "the mutually recursive references to Qsnark and Qfrob\nare permissible.\nIn the following, however:\n" "\n" "(define-ftype\n  [Qfrob (struct\n           [head int]\n           [xtra Qfrob]\n           [tail (* Qsnark)])]\n  [Qsnark (struct\n            [head int]\n            [tail (* Qfrob)])])\n" "the reference to Qfrob within the ftype for Qfrob\nis invalid, and in:\n" "\n" "(define-ftype\n  [Qfrob (struct\n           [head int]\n           [xtra Qsnark]\n           [tail (* Qsnark)])]\n  [Qsnark (struct\n            [head int]\n            [tail (* Qfrob)])])\n" "the reference to Qsnark is similarly invalid.\n" "\nBy default, padding is inserted where appropriate to maintain\nproper alignment of multiple-byte scalar values in an attempt to\nmirror the target machine's C struct layout conventions, where\nsuch layouts are adequately documented.\nFor packed ftypes (ftypes wrapped in a packed form with\nno closer enclosing unpacked form), this padding is not\ninserted.\n" "\nMultiple-byte scalar values are stored in memory using the\ntarget machine's native \"endianness,\" e.g., little\non X86 and X86_64-based platforms and big on\nSparc-based platforms.\nBig-endian or little-endian representation can be forced via\nthe endian ftype with a big or little\nendianness specifier.\nThe native specifier can be used to force a return\nback to native representation.\nEach endian form affects only ftypes nested syntactically\nwithin it and not nested within a closer endian form.\nThe endianness of an ftype is fixed once it is defined.\n" "\nThe total size n of the fields within an ftype bits form must\nbe 8, 16, 24, 32, 40, 48, 56, or 64.  padding must be added manually if needed.\nIn little-endian representation, the first field occupies\nthe low-order bits of the containing 8, 16, 24, 32, 40, 48, 56, or 64-bit word,\nwith each subsequent field just above the preceding field.\nIn big-endian representation, the first field occupies the\nhigh-order bits, with each subsequent field just below the\npreceding field.\n" "\nTwo ftypes are considered equivalent only if defined by the\nsame ftype binding.\nIf two ftype definitions look identical but appear in two\nparts of the same program, the ftypes are not identical,\nand attempts to access one using the name of the other via\nthe operators described below will fail with a run-time\nexception.\n" "\nArray bounds must always be constant.\nIf an array's length cannot be known until run time, the array\ncan be placed at the end of the ftype (and any containing ftype)\nand declared to have size zero, as illustrated by the example below.\n" "\n" "(define-ftype Vec\n  (struct\n    [len int]\n    [data (array 0 double)]))\n(define make-Vec\n  (lambda (n)\n    (let ([fptr (make-ftype-pointer Vec\n                  (foreign-alloc\n                    (+ (ftype-sizeof Vec)\n                       (* (ftype-sizeof double) n))))])\n      (ftype-set! Vec (len) fptr n)\n      fptr)))\n(define x (make-Vec 100))\n(/ (- (ftype-pointer-address (ftype-&ref Vec (data 10) x))\n      (ftype-pointer-address x)                            --> 10\n      (ftype-sizeof int))\n   (ftype-sizeof double))\n(foreign-free (ftype-pointer-address x))\n" "No array bounds checks are performed for zero-length arrays.\nOnly one variable-sized array can appear\nin a single foreign object, but one can work around this by\ntreating the object as multiple individual objects.\n" "\nTo avoid specifying the constant length of an array in more than\none place, a macro that binds both a variable to the size as\nwell as an ftype name to the ftype can be used.\nFor example,\n" "\n" "(define-syntax define-array\n  (syntax-rules ()\n    [(_ array-name type size-name size)\n     (begin\n       (define size-name size)\n       (define-ftype array-name\n         (array size type)))]))\n(define-array A int A-size 100)\nA-size --> 100\n(ftype-pointer-ftype\n  (make-ftype-pointer A\n    (foreign-alloc (ftype-sizeof A)))) --> (array 100 int)\n" "This technique can be used to define arbitrary ftypes with\narbitrary numbers of array fields.\n" "\npage:ftype-subtypingA struct ftype is an implicit subtype of the type of the first field\nof the struct.\nSimilarly, an array ftype is an implicit subtype of the type of its\nelements.\nThus, the struct or array extends the type of first field or element\nwith additional fields or elements.\nThis allows an instance of the struct or array to be treated as an instance\nof the type of its first field or element, without the need to use\nftype-&ref to allocate a new pointer to the field or element.\n\n") ("foreign:s142" "\nsyntax: (ftype-sizeof ftype-name)\nreturns: the size in bytes of the ftype identified by ftype-name\nlibraries: (chezscheme)\n" "The size includes the sizes of any ftypes directly embedded within the\nidentified ftype but excludes those indirectly embedded via a pointer\nftype.\nIn the latter case, the size of the pointer is included.\n" "\nftype-name must not be defined as a function ftype, since the size\nof a function cannot generally be determined.\n" "\n" "(define-ftype B\n  (struct\n    [b1 integer-32]\n    [b2 (array 10 integer-32)]))\n(ftype-sizeof B) --> 44\n\n(define-ftype C (* B))\n(ftype-sizeof C) --> 4  ; on 32-bit machines\n(ftype-sizeof C) --> 8  ; on 64-bit machines\n\n(define-ftype BB\n  (struct\n    [bb1 B]\n    [bb2 (* B)]))\n(- (ftype-sizeof BB) (ftype-sizeof void*)) --> 44\n") ("foreign:s143" "desc:make-ftype-pointer\nsyntax: (make-ftype-pointer ftype-name expr)\nreturns: an ftype-pointer object\nlibraries: (chezscheme)\n" "If ftype-name does not describe a function ftype, expr\nmust evaluate to an address represented as an exact integer in\nthe appropriate range for the target machine.\n" "\nThe ftype-pointer object returned by this procedure encapsulates the\naddress and is tagged with a representation of the type identified by\nftype-name to enable various forms of checking to be done by the\naccess routines described below.\n" "\n" "(make-ftype-pointer E #x80000000) --> #<ftype-pointer #x80000000>\n" "The address will not typically be a constant, as shown.\nInstead, it might instead come from a call to foreign-alloc, e.g.:\n" "\n" "(make-ftype-pointer E (foreign-alloc (ftype-sizeof E)))\n" "It might also come from source outside of Scheme such as from a C\nroutine called from Scheme via the foreign-procedure interface.\n" "\nIf ftype-name describes a function ftype,\nexpr must evaluate to an address, procedure, or string.\nIf it evaluates to address, the call behaves like any other call to\nmake-ftype-pointer with an address argument.\n" "\nIf it evaluates to a procedure, a foreign-callable code object is\ncreated for the procedure, as if via\nforeign-callable\n(Section 4.3).\nThe address encapsulated in the resulting ftype-pointer object is the\naddress of the procedure's entry point.\n" "\n" "(define fact\n  (lambda (n)\n    (if (= n 0) 1 (fact (- n 1)))))\n(define-ftype fact_t (function (int) int))\n(define fact-fptr (make-ftype-pointer fact_t fact))\n" "The resulting ftype pointer can be passed to a C routine,\nif the argument is declared to be a pointer to the same ftype, and\nthe C routine can invoke the function pointer it receives as it\nwould any other function pointer.\nThus, make-ftype-pointer with a function ftype is an alternative\nto foreign-callable for creating C-callable wrappers for Scheme\nprocedures.\n" "\nSince all Scheme objects, including code objects, can be relocated or\neven reclaimed by the garbage collector the foreign-callable code object\nis automatically locked, as if via lock-object, before it is\nembedded in the ftype pointer.\nThe code object should be unlocked after its last use from C,\nsince locked objects take up space, cause fragmentation, and\nincrease the cost of collection.\nSince the system cannot determine automatically when the last use\nfrom C occurs, the program must explicitly unlock the code object,\nwhich it can do by extracting the address from the ftype-pointer\nconverting the address (back) into a code object, and passing it\nto unlock-object:\n" "\n" "(unlock-object\n  (foreign-callable-code-object\n    (ftype-pointer-address fact-fptr)))\n" "Once unlocked, the ftype pointer should not be used again, unless\nit is relocked, e.g., via:\n" "\n" "(lock-object\n  (foreign-callable-code-object\n    (ftype-pointer-address fact-fptr)))\n" "A program can determine whether an object is already locked via\nthe locked-object? predicate.\n" "\nA function ftype can be also used with\nmake-ftype-pointer to create an ftype-pointer to a C function,\neither by providing the address of the C function or its name, represented\nas a string.\nFor example, with the following definition of bvcopy_t,\n" "\n" "(define-ftype bvcopy_t (function (u8* u8* size_t) void))\n" "the two definitions of bvcopy-ftpr below are equivalent.\n" "\n" "(define bvcopy-fptr (make-ftype-pointer bvcopy_t \"memcpy\"))\n(define bvcopy-fptr (make-ftype-pointer bvcopy_t (foreign-entry \"memcpy\")))\n" "A library that defines memcpy must be loaded first via\nload-shared-object, or memcpy must be registered\nvia one of the methods described in Section  4.6.\n") ("foreign:s147" "\nsyntax: (ftype-pointer? obj)\nreturns: #t if obj is an ftype pointer, otherwise #f\nsyntax: (ftype-pointer? ftype-name obj)\nreturns: #t if obj is an ftype-name, otherwise #f\nlibraries: (chezscheme)\n" "\n" "(define-ftype Widget1 (struct [x int] [y int]))\n(define-ftype Widget2 (struct [w Widget1] [b boolean]))\n\n(define x1 (make-ftype-pointer Widget1 #x80000000))\n(define x2 (make-ftype-pointer Widget2 #x80000000))\n\n(ftype-pointer? x1) --> #t\n(ftype-pointer? x2) --> #t\n\n(ftype-pointer? Widget1 x1) --> #t\n(ftype-pointer? Widget1 x2) --> #t\n\n(ftype-pointer? Widget2 x1) --> #f\n(ftype-pointer? Widget2 x2) --> #t\n\n(ftype-pointer? #x80000000) --> #f\n(ftype-pointer? Widget1 #x80000000) --> #f\n") ("foreign:s148" "\nprocedure: (ftype-pointer-address fptr)\nreturns: the address encapsulated within fptr\nlibraries: (chezscheme)\n" "fptr must be an ftype-pointer object.\n" "\n" "(define x (make-ftype-pointer E #x80000000))\n(ftype-pointer-address x) --> #x80000000\n") ("foreign:s149" "\nsyntax: (ftype-pointer=? fptr1 fptr2)\nreturns: #t if fptr1 and fptr2 have the same address, otherwise #f\nlibraries: (chezscheme)\n" "fptr1 and fptr2 must be ftype-pointer objects.\n" "\nftype-pointer=? might be defined as follows:\n" "\n" "(define ftype-pointer=?\n  (lambda (fptr1 fptr2)\n    (= (ftype-pointer-address fptr1) (ftype-pointer-address fptr2))))\n" "It is, however, guaranteed not to allocate bignums for the addresses\neven if the addresses do not fit in fixnum range.\n") ("foreign:s150" "\nsyntax: (ftype-pointer-null? fptr)\nreturns: #t if the address of fptr is 0, otherwise #f\nlibraries: (chezscheme)\n" "fptr must be an ftype-pointer object.\n" "\nftype-pointer-null? might be defined as follows:\n" "\n" "(define ftype-pointer-null?\n  (lambda (fptr)\n    (= (ftype-pointer-address fptr) 0)))\n" "It is, however, guaranteed not to allocate a bignum for the address\neven if the address does not fit in fixnum range.\n") ("foreign:s151" "\nsyntax: (ftype-&ref ftype-name (a ...) fptr-expr)\nsyntax: (ftype-&ref ftype-name (a ...) fptr-expr index)\nreturns: an ftype-pointer object\nlibraries: (chezscheme)\n" "The ftype-pointer object returned by ftype-&ref\nencapsulates the address of some object embedded directly or\nindirectly within the foreign object pointed to by the value\nof fptr-expr, offset by index, if present.\nThe value of fptr-expr must be\nan ftype pointer (fptr) of the ftype identified by ftype-name,\nand index must either be the identifier * or evaluate\nto a fixnum, possibly negative.\nThe index is automatically scaled by the size of the ftype identified\nby ftype-name, which allows the fptr to be treated as an array\nof ftype-name objects and index as an index into that array.\nAn index of * or 0 is the same as no index.\n" "\nThe sequence of accessors a ... must specify a\nvalid path through the identified ftype.\nFor struct, union, and bits ftypes,\nan accessor must be a valid field name for the ftype, while for\npointer and array ftypes, an accessor must be the identifier\n* or evaluate to a fixnum index.\nFor array ftypes, an index must be nonnegative, and for array ftypes\nwith nonzero length, an index must also be less than the length.\n" "\nThe examples below assume the definitions of B and BB\nshown above in the description of ftype-sizeof.\nFixed addresses are shown for illustrative purposes and are assumed\nto be valid, although addresses are generally determined\nat run time via foreign-alloc or some other mechanism.\n" "\n" "(define x (make-ftype-pointer B #x80000000))\n(ftype-&ref B () x) --> #<ftype-pointer #x80000000>\n(let ([idx 1])             --> #<ftype-pointer #x8000002C>\n  (ftype-&ref B () x idx))\n(let ([idx -1])            --> #<ftype-pointer #x7FFFFFD4>\n  (ftype-&ref B () x idx))\n(ftype-&ref B (b1) x) --> #<ftype-pointer #x80000000>\n(ftype-&ref B (b2) x) --> #<ftype-pointer #x80000004>\n(ftype-&ref B (b2 5) x) --> #<ftype-pointer #x80000018>\n(let ([n 5]) (ftype-&ref B (b2 n) x)) --> #<ftype-pointer #x80000018>\n\n(ftype-&ref B (b1 b2) x) --> syntax error\n(ftype-&ref B (b2 15) x) --> run-time exception\n\n(define y (make-ftype-pointer BB #x90000000))\n(ftype-set! BB (bb2) y x)\n(ftype-&ref BB (bb1 b2) y) --> #<ftype-pointer #x90000004>\n(ftype-&ref BB (bb2 * b2) y) --> #<ftype-pointer #x80000004>\n(let ([idx 1])                    --> #<ftype-pointer #x80000030>\n  (ftype-&ref BB (bb2 idx b2) y))\n" "With no accessors and no index, as in the first use of ftype-&ref\nabove, the returned ftype-pointer might be eq? to\nthe input.\nOtherwise, the ftype-pointer is freshly allocated.\n") ("foreign:s152" "\ndefn:ftype-set!\nsyntax: (ftype-set! ftype-name (a ...) fptr-expr val-expr)\nsyntax: (ftype-set! ftype-name (a ...) fptr-expr index val-expr)\nreturns: unspecified\nsyntax: (ftype-ref ftype-name (a ...) fptr-expr)\nsyntax: (ftype-ref ftype-name (a ...) fptr-expr index)\nreturns: an ftype-pointer object\nlibraries: (chezscheme)\n" "These forms are used to store values into or retrieve values from the\nobject pointed to by the value of fptr-expr, offset by\nindex, if present.\nThe value of fptr-expr must be\nan ftype pointer (fptr) of the ftype identified by ftype-name,\nand index must either be the identifier * or evaluate\nto a fixnum, possibly negative.\nThe index is automatically scaled by the size of the ftype identified\nby ftype-name, which allows the fptr to be treated as an array\nof ftype-name objects and index as an index into that array.\nAn index of * or 0 is the same as no index.\n" "\nThe sequence of accessors a ... must specify a\nvalid path through the identified ftype.\nFor struct, union, and bits ftypes,\nan accessor must be a valid field name for the ftype, while for\npointer and array ftypes, an accessor must be the identifier\n* or evaluate to a fixnum index.\nFor array ftypes, an index must be nonnegative, and for array ftypes\nwith nonzero length, an index must also be less than the length.\nThe field or element specified by the sequence of accessors must be a scalar\nfield, e.g., a pointer field or a field containing a base type\nsuch as an int, char, or double.\n" "\nFor ftype-set!, val-expr must evaluate to a value\nof the appropriate type for the specified field, e.g., an ftype\npointer of the appropriate type or an appropriate base-type value.\n" "\nFor both signed and unsigned integer fields, values in the range\n-2w-1 through 2w - 1 are accepted, where w is the width in\nbits of the integer field.\nFor signed integer fields, values in the range 2w-1 through 2w - 1\nare treated as two's complement representations of the corresponding\nnegative numbers.\nFor unsigned integer fields, values in the range -2w-1 through\n-1 are similarly treated as two's complement representations of the\ncorresponding positive numbers.\n" "\nchar and wchar_t (wchar) field values\nare converted from (ftype-set!) or to (ftype-ref)\nScheme characters, as if with char->integer and\ninteger->char.\nCharacters stored by ftype-set! into a char\nfield must have Unicode scalar values in the range 0 through 255.\nUnder Windows and any other system where wchar_t\n(wchar) is a 16-bit value, characters stored by\nftype-set! into a whar_t (wchar)\nfield must have Unicode scalar values in the range 0 through 216 - 1.\nOn systems where wchar_t is a 32-bit value, any\ncharacter can be stored in a wchar_t (wchar)\nfield.\n" "\nThe examples below assume that B and C have been\ndefined as shown in the description of ftype-sizeof above.\n" "\n" "(define b\n  (make-ftype-pointer B\n    (foreign-alloc\n      (* (ftype-sizeof B) 3))))\n(define c\n  (make-ftype-pointer C\n    (foreign-alloc (ftype-sizeof C))))\n\n(ftype-set! B (b1) b 5)\n(ftype-set! B (b1) b 1 6)\n(ftype-set! B (b1) c 5) --> exception: ftype mismatch\n(ftype-set! B (b2) b 0) --> exception: not a scalar\n(ftype-set! B (b2 -1) b 0) --> exception: invalid index\n(ftype-set! B (b2 0) b 50)\n(ftype-set! B (b2 4) b 55)\n(ftype-set! B (b2 10) b 55) --> exception: invalid index\n\n(ftype-set! C () c (ftype-&ref B () b 1))\n\n(= (ftype-pointer-address (ftype-ref C () c))      --> #t\n   (+ (ftype-pointer-address b) (ftype-sizeof B)))\n(= (ftype-pointer-address (ftype-&ref C (*) c)) --> #t\n   (+ (ftype-pointer-address b) (ftype-sizeof B)))\n(= (ftype-pointer-address (ftype-&ref C (-1) c)) --> #t\n   (ftype-pointer-address b))\n\n(ftype-ref C (-1 b1) c) --> 5\n(ftype-ref C (* b1) c) --> 6\n(ftype-ref C (-1 b2 0) c) --> 50\n(let ([i 4]) (ftype-ref C (-1 b2 i) c)) --> 55\n\n(ftype-set! C (-1 b2 0) c 75)\n(ftype-ref B (b2 0) b) --> 75\n(foreign-free (ftype-pointer-address c))\n(foreign-free (ftype-pointer-address b))\n" "A function ftype pointer can be converted into\na Scheme-callable procedure via ftype-ref.\nAssuming that a library defining memcpy has been loaded via\nload-shared-object or memcpy has been registered\nvia one of the methods described in Section  4.6,\nA Scheme-callable memcpy can be defined as follows.\n" "\n" "(define-ftype bvcopy_t (function (u8* u8* size_t) void))\n(define bvcopy-fptr (make-ftype-pointer bvcopy_t \"memcpy\"))\n(define bvcopy (ftype-ref bvcopy_t () bvcopy-fptr))\n\n(define bv1 (make-bytevector 8 0))\n(define bv2 (make-bytevector 8 57))\nbv1 --> #vu8(0 0 0 0 0 0 0 0)\nbv2 --> #vu8(57 57 57 57 57 57 57 57)\n(bvcopy bv1 bv2 5)\nbv1 --> #vu8(57 57 57 57 57 0 0 0)\n" "An ftype pointer can also be obtained as a return value from a\nC function declared to return a pointer to a function ftype.\n" "\nThus, ftype-ref with a function ftype is an alternative to\nforeign-procedure\n(Section 4.2)\nfor creating Scheme-callable wrappers for\nC functions.\n") ("foreign:s155" "\nprocedure: (ftype-pointer-ftype fptr)\nreturns: fptr's ftype, represented as an s-expression\nlibraries: (chezscheme)\n" "fptr must be an ftype-pointer object.\n" "\n" "(define-ftype Q0\n  (struct\n    [x int]\n    [y int]))\n(define-ftype Q1\n  (struct\n    [x double]\n    [y char]\n    [z (endian big\n         (bits\n           [_ unsigned 3]\n           [a unsigned 9]\n           [b unsigned 4]))]\n    [w (* Q0)]))\n(define q1 (make-ftype-pointer Q1 0))\n(ftype-pointer-ftype q1) --> (struct \n                         gifs/ghostRightarrow.gif   [x double]\n                         gifs/ghostRightarrow.gif   [y char]\n                         gifs/ghostRightarrow.gif   [z (endian big\n                         gifs/ghostRightarrow.gif        (bits\n                         gifs/ghostRightarrow.gif          [_ unsigned 3]\n                         gifs/ghostRightarrow.gif          [a unsigned 9]\n                         gifs/ghostRightarrow.gif          [b unsigned 4]))]\n                         gifs/ghostRightarrow.gif   [w (* Q0)])\n") ("foreign:s156" "\nprocedure: (ftype-pointer->sexpr fptr)\nreturns: an s-expression representation of the object to which fptr points\nlibraries: (chezscheme)\n" "fptr must be an ftype-pointer object.\n" "\nFor each unnamed field, i.e., each whose field name is an underscore, the\ncorresponding field value in the resulting s-expression is also an underscore.\nSimilarly, if a field is inaccessible, i.e., if its address is invalid, the\nvalue is the symbol invalid.\n" "\n" "(define-ftype Frob\n  (struct\n    [p boolean]\n    [q char]))\n(define-ftype Snurk\n  (struct\n    [a Frob]\n    [b (* Frob)]\n    [c (* Frob)]\n    [d (bits\n         [_ unsigned 15]\n         [dx signed 17])]\n    [e (array 5 double)]))\n(define x\n  (make-ftype-pointer Snurk\n    (foreign-alloc (ftype-sizeof Snurk))))\n(ftype-set! Snurk (b) x\n  (make-ftype-pointer Frob\n    (foreign-alloc (ftype-sizeof Frob))))\n(ftype-set! Snurk (c) x\n  (make-ftype-pointer Frob 0))\n(ftype-set! Snurk (a p) x #t)\n(ftype-set! Snurk (a q) x #\\A)\n(ftype-set! Snurk (b * p) x #f)\n(ftype-set! Snurk (b * q) x #\\B)\n(ftype-set! Snurk (d dx) x -2500)\n(do ([i 0 (fx+ i 1)])\n    ((fx= i 5))\n  (ftype-set! Snurk (e i) x (+ (* i 5.0) 3.0)))\n(ftype-pointer->sexpr x) --> (struct\n                         gifs/ghostRightarrow.gif   [a (struct [p #t] [q #\\A])]\n                         gifs/ghostRightarrow.gif   [b (* (struct [p #f] [q #\\B]))]\n                         gifs/ghostRightarrow.gif   [c (* (struct [p invalid] [q invalid]))]\n                         gifs/ghostRightarrow.gif   [d (bits [_ _] [dx -2500])]\n                         gifs/ghostRightarrow.gif   [e (array 5 3.0 8.0 13.0 18.0 23.0)])\n") ("foreign:s157" "\nprocedure: (foreign-entry? entry-name)\nreturns: #t if entry-name is an existing foreign procedure entry\npoint, #f otherwise\nlibraries: (chezscheme)\n" "entry-name must be a string.\nforeign-entry? may be used to determine if an entry exists for a foreign\nprocedure.\n" "\nThe following examples assume that \na library that defines strlen has been loaded via\nload-shared-object or that strlen has been registered\nvia one of the other methods described in this section.\n" "\n" "(foreign-entry? \"strlen\") --> #t\n((foreign-procedure \"strlen\"\n    (string) size_t)\n \"hey!\") --> 4\n") ("foreign:s158" "\nprocedure: (foreign-entry entry-name)\nreturns: the address of entry-name as an exact integer\nlibraries: (chezscheme)\n" "entry-name must be a string naming an existing foreign entry point.\n" "\nThe following examples assume that \na library that defines strlen has been loaded via\nload-shared-object or that strlen has been registered\nvia one of the other methods described in this section.\n" "\n" "(let ([addr (foreign-entry \"strlen\")])\n  (and (integer? addr) (exact? addr))) --> #t\n\n(define-ftype strlen-type (function (string) size_t))\n(define strlen\n  (ftype-ref strlen-type ()\n    (make-ftype-pointer strlen-type \"strlen\")))\n(strlen \"hey!\") --> 4\n") ("foreign:s159" "\nprocedure: (foreign-address-name address)\nreturns: the entry name corresponding to address, if known, otherwise #f\nlibraries: (chezscheme)\n" "The following examples assume that \na library that defines strlen has been loaded via\nload-shared-object or that strlen has been registered\nvia one of the other methods described in this section.\n" "\n" "(foreign-address-name (foreign-entry \"strlen\")) --> \"strlen\"\n") ("foreign:s160" "\nprocedure: (load-shared-object path)\nreturns: unspecified\nlibraries: (chezscheme)\n" "path must be a string.\nload-shared-object loads the shared object named by path.\nShared objects may be system libraries or files created from ordinary\nC programs.\nAll external symbols in the shared object, along with external symbols\navailable in other shared objects linked with the shared object,\nare made available as foreign entries. \n" "\nThis procedure is supported for most platforms upon which Chez Scheme\nruns.\n" "\nIf path does not begin with a \".\" or \"/\", the shared\nobject is searched for in a default set of directories determined\nby the system.\n" "\nOn most Unix systems, load-shared-object is based on the\nsystem routine dlopen.\nUnder Windows, load-shared-object is based on LoadLibrary.\nRefer to the documentation for these routines and for the C compiler\nand loader for precise rules for locating and building shared objects.\n" "\nload-shared-object can be used to access built-in C library\nfunctions, such as getenv.\nThe name of the shared object varies from one system to another.\nOn Linux systems:\n" "\n" "(load-shared-object \"libc.so.6\")\n" "On Solaris, OpenSolaris, FreeBSD, NetBSD, and OpenBSD systems:\n" "\n" "(load-shared-object \"libc.so\")\n" "On MacOS X systems:\n" "\n" "(load-shared-object \"libc.dylib\")\n" "On Windows:\n" "\n" "(load-shared-object \"msvcrt.dll\")\n" "Once the C library has been loaded, getenv should be available\nas a foreign entry.\n" "\n" "(foreign-entry? \"getenv\") --> #t\n" "An equivalent Scheme procedure may be defined and\ninvoked as follows.\n" "\n" "(define getenv\n  (foreign-procedure \"getenv\"\n    (string)\n    string))\n(getenv \"HOME\") --> \"/home/elmer/fudd\"\n(getenv \"home\") --> #f\n" "load-shared-object can be used to access user-created\nlibraries as well.\nSuppose the C file \"even.c\"\ncontains\n" "\n" "int even(n) int n; { return n == 0 || odd(n - 1); }\n" "and the C file \"odd.c\" contains\n" "\n" "int odd(n) int n; { return n != 0 && even(n - 1); }\n" "The files must be compiled and linked into a shared object before\nthey can be loaded.\nHow this is done depends upon the host system.\nOn Linux, FreeBSD, OpenBSD, and OpenSolaris systems:\n" "\n" "(system \"cc -fPIC -shared -o evenodd.so even.c odd.c\")\n" "Depending on the host configuration, the -m32 or\n-m64 option might be needed to specify 32-bit\nor 64-bit compilation as appropriate.\n" "\nOn MacOS X (Intel or PowerPC) systems:\n" "\n" "(system \"cc -dynamiclib -o evenodd.so even.c odd.c\")\n" "Depending on the host configuration, the -m32 or\n-m64 option might be needed to specify 32-bit\nor 64-bit compilation as appropriate.\n" "\nOn 32-bit Sparc Solaris:\n" "\n" "(system \"cc -KPIC -G -o evenodd.so even.c odd.c\")\n" "On 64-bit Sparc Solaris:\n" "\n" "(system \"cc -xarch=v9 -KPIC -G -o evenodd.so even.c odd.c\")\n" "On Windows, we build a DLL (dynamic link library) file.\nIn order to make the compiler generate the appropriate entry\npoints, we alter even.c to read\n" "\n" "#ifdef WIN32\n#define EXPORT extern __declspec (dllexport)\n#else\n#define EXPORT extern\n#endif\n\nEXPORT int even(n) int n; { return n == 0 || odd(n - 1); }\n" "and odd.c to read\n" "\n" "#ifdef WIN32\n#define EXPORT extern __declspec (dllexport)\n#else\n#define EXPORT extern\n#endif\n\nEXPORT int odd(n) int n; { return n != 0 && even(n - 1); }\n" "We can then build the DLL as follows, giving\nit the extension \".so\" rather than \".dll\"\nfor consistency with the other systems.\n" "\n" "(system \"cl -c -DWIN32 even.c\")\n(system \"cl -c -DWIN32 odd.c\")\n(system \"link -dll -out:evenodd.so even.obj odd.obj\")\n" "" "The resulting \".so\" file can be loaded into Scheme and even and\nodd made available as foreign procedures:\n" "\n" "(load-shared-object \"./evenodd.so\")\n(let ([odd (foreign-procedure \"odd\"\n             (integer-32) boolean)]\n      [even (foreign-procedure \"even\"\n              (integer-32) boolean)])\n  (list (even 100) (odd 100))) --> (#t #f)\n" "The filename is given as \"./evenodd.so\" rather than simply\n\"evenodd.so\", because some systems look for shared libraries\nin a standard set of system directories that does not include the\ncurrent directory.\n\n") ("foreign:s162" "\nprocedure: (remove-foreign-entry entry-name)\nreturns: unspecified\nlibraries: (chezscheme)\n" "remove-foreign-entry blocks further access to the entry\nspecified by the string entry-name.\nAn exception is raised with condition type &assertion\nif the entry does not exist.\nSince access previously established by foreign-procedure is not affected,\nremove-foreign-entry may be used to clean up after the desired interface\nto a group of foreign procedures has been established.\n" "\nremove-foreign-entry can be used to remove entries registered using\nSforeign_symbol and Sregister_symbol but not\nentries created as\na result of a call to load-shared-object.\n\n") ("objects:s0" "\nprocedure: (enum-set? obj)\nreturns: #t if obj is an enum set, #f otherwise\nlibraries: (chezscheme)\n" "This predicate is not defined by the Revised6 Report, but should be.\n") ("objects:s1" "\nprocedure: (record-constructor-descriptor? obj)\nreturns: #t if obj is a record constructor descriptor, #f otherwise\nlibraries: (chezscheme)\n" "This predicate is not defined by the Revised6 Report, but should be.\n\n") ("objects:s2" "\nprocedure: (atom? obj)\nreturns: #t if obj is not a pair, #f otherwise\nlibraries: (chezscheme)\n" "atom? is equivalent to (lambda (x) (not (pair? x))).\n" "\n" "(atom? '(a b c)) --> #f\n(atom? '(3 . 4)) --> #f\n(atom? '()) --> #t\n(atom? 3) --> #t\n") ("objects:s3" "\nprocedure: (list-head list n)\nreturns: a list of the first n elements of list\nlibraries: (chezscheme)\n" "n must be an exact nonnegative integer less than or equal to\nthe length of list.\n" "\nlist-head and the standard Scheme procedure list-tail \nmay be used together to split a list into two separate lists.\nWhile list-tail performs no allocation but instead returns a\nsublist of the original list, list-head always returns a copy\nof the first portion of the list.\n" "\nlist-head may be defined as follows.\n" "\n" "(define list-head\n  (lambda (ls n)\n    (if (= n 0)\n        '()\n        (cons (car ls) (list-head (cdr ls) (- n 1))))))\n\n(list-head '(a b c) 0) --> ()\n(list-head '(a b c) 2) --> (a b)\n(list-head '(a b c) 3) --> (a b c)\n(list-head '(a b c . d) 2) --> (a b)\n(list-head '(a b c . d) 3) --> (a b c)\n(list-head '#1=(a . #1#) 5) --> (a a a a a)\n") ("objects:s4" "\nprocedure: (last-pair list)\nreturns: the last pair of a list\nlibraries: (chezscheme)\n" "list must not be empty.\nlast-pair returns the last pair (not the last element) of list.\nlist may be an improper list, in which case the last pair is the\npair containing the last element and the terminating object.\n" "\n" "(last-pair '(a b c d)) --> (d)\n(last-pair '(a b c . d)) --> (c . d)\n") ("objects:s5" "\nprocedure: (list-copy list)\nreturns: a copy of list\nlibraries: (chezscheme)\n" "list-copy returns a list equal? to list, using new pairs\nto reform the top-level list structure.\n" "\n" "(list-copy '(a b c)) --> (a b c)\n\n(let ([ls '(a b c)])\n  (equal? ls (list-copy ls))) --> #t\n\n(let ([ls '(a b c)])\n  (let ([ls-copy (list-copy ls)])\n    (or (eq? ls-copy ls)\n        (eq? (cdr ls-copy) (cdr ls))\n        (eq? (cddr ls-copy) (cddr ls))))) --> #f\n") ("objects:s6" "\nprocedure: (list* obj ... final-obj)\nreturns: a list of obj ... terminated by final-obj\nlibraries: (chezscheme)\n" "list* is identical to the Revised6 Report cons*.\n\n") ("objects:s7" "\nprocedure: (make-list n)\nprocedure: (make-list n obj)\nreturns: a list of n objs\nlibraries: (chezscheme)\n" "n must be a nonnegative integer.\nIf obj is omitted, the elements of the list are unspecified.\n" "\n" "(make-list 0 '()) --> ()\n(make-list 3 0) --> (0 0 0)\n(make-list 2 \"hi\") --> (\"hi\" \"hi\")\n") ("objects:s8" "\nprocedure: (iota n)\nreturns: a list of integers from 0 (inclusive) to n (exclusive)\nlibraries: (chezscheme)\n" "n must be an exact nonnegative integer.\n" "\n" "(iota 0) --> ()\n(iota 5) --> (0 1 2 3 4)\n") ("objects:s9" "\nprocedure: (enumerate ls)\nreturns: a list of integers from 0 (inclusive) to the length of ls (exclusive)\nlibraries: (chezscheme)\n" "\n" "(enumerate '()) --> ()\n(enumerate '(a b c)) --> (0 1 2)\n(let ([ls '(a b c)])\n  (map cons ls (enumerate ls))) --> ((a . 0) (b . 1) (c . 2))\n") ("objects:s10" "\nprocedure: (remq! obj list)\nprocedure: (remv! obj list)\nprocedure: (remove! obj list)\nreturns: a list containing the elements of list with all occurrences of obj removed\nlibraries: (chezscheme)\n" "These procedures are similar to the Revised6 Report\nremq, remv, and remove procedures, except\nremq!, remv! and remove! use pairs from the\ninput list to build the output list.\nThey perform less allocation but are not\nnecessarily faster than their nondestructive counterparts.\nTheir use can easily lead to confusing or incorrect results if used\nindiscriminately.\n" "\n" "(remq! 'a '(a b a c a d)) --> (b c d)\n\n(remv! #\\a '(#\\a #\\b #\\c)) --> (#\\b #\\c)\n\n(remove! '(c) '((a) (b) (c))) --> ((a) (b))\n") ("objects:s11" "\nprocedure: (substq new old tree)\nprocedure: (substv new old tree)\nprocedure: (subst new old tree)\nprocedure: (substq! new old tree)\nprocedure: (substv! new old tree)\nprocedure: (subst! new old tree)\nreturns: a tree with new substituted for occurrences of old in tree\nlibraries: (chezscheme)\n" "These procedures traverse tree, replacing all objects equivalent to\nthe object old with the object new.\n" "\nThe equivalence test for substq and substq! is eq?,\nfor substv and substv! is eqv?,\nand for subst and subst! is equal?.\n" "\nsubstq!, substv!, and subst! perform the\nsubstitutions destructively.\nThey perform less allocation but are not\nnecessarily faster than their nondestructive counterparts.\nTheir use can easily lead to confusing or incorrect results if used\nindiscriminately.\n\n" "\n" "(substq 'a 'b '((b c) b a)) --> ((a c) a a)\n\n(substv 2 1 '((1 . 2) (1 . 4) . 1)) --> ((2 . 2) (2 . 4) . 2)\n\n(subst 'a\n       '(a . b)\n       '((a . b) (c a . b) . c)) --> (a (c . a) . c)\n\n(let ([tr '((b c) b a)])\n  (substq! 'a 'b tr)\n  tr) --> ((a c) a a)\n") ("objects:s12" "\nprocedure: (reverse! list)\nreturns: a list containing the elements of list in reverse order\nlibraries: (chezscheme)\n" "reverse! destructively reverses list\nby reversing its links.\nUsing reverse! in place of reverse reduces allocation but is not\nnecessarily faster than reverse.\nIts use can easily lead to confusing or incorrect results if used\nindiscriminately.\n" "\n" "(reverse! '()) --> ()\n(reverse! '(a b c)) --> (c b a)\n\n(let ([x '(a b c)])\n    (reverse! x)\n    x) --> (a)\n\n(let ([x '(a b c)])\n    (set! x (reverse! x))\n    x) --> (c b a)\n") ("objects:s13" "\nprocedure: (append! list ...)\nreturns: the concatenation of the input lists\nlibraries: (chezscheme)\n" "Like append,\nappend! returns a new list consisting of the elements of the first\nlist followed by the elements of the second list, the elements of the\nthird list, and so on.\nUnlike append,\nappend! reuses the pairs in all of the\narguments in forming the new list.\nThat is, the last cdr of each list argument but the last is changed to\npoint to the next list argument.\nIf any argument but the last is the empty list, it is essentially ignored.\nThe final argument (which need not be a list) is not altered.\n" "\nappend! performs less allocation than append but is not\nnecessarily faster.\nIts use can easily lead to confusing or incorrect results if used\nindiscriminately.\n" "\n" "(append! '(a b) '(c d)) --> (a b c d)\n\n(let ([x '(a b)])\n    (append! x '(c d))\n    x) --> (a b c d)\n") ("objects:s15" "\nprocedure: (char=? char1 char2 ...)\nprocedure: (char<? char1 char2 ...)\nprocedure: (char>? char1 char2 ...)\nprocedure: (char<=? char1 char2 ...)\nprocedure: (char>=? char1 char2 ...)\nprocedure: (char-ci=? char1 char2 ...)\nprocedure: (char-ci<? char1 char2 ...)\nprocedure: (char-ci>? char1 char2 ...)\nprocedure: (char-ci<=? char1 char2 ...)\nprocedure: (char-ci>=? char1 char2 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (chezscheme)\n" "These predicates are identical to the Revised6 Report counterparts,\nexcept they are extended to accept one or more rather than two or more\narguments.\nWhen passed one argument, each of these predicates returns #t.\n" "\n" "(char>? #\\a) --> #t\n(char<? #\\a) --> #t\n(char-ci=? #\\a) --> #t\n") ("objects:s16" "\nprocedure: (char- char1 char2)\nreturns: the integer difference between char1 and char2\nlibraries: (chezscheme)\n" "char- subtracts the integer value of char2 from the\ninteger value of char1 and returns the difference.\nThe following examples assume that the integer representation is the\nASCII code for the character.\n" "\n" "(char- #\\f #\\e) --> 1\n\n(define digit-value\n ; returns the digit value of the base-r digit c, or #f if c\n ; is not a valid digit\n  (lambda (c r)\n    (let ([v (cond\n               [(char<=? #\\0 c #\\9) (char- c #\\0)]\n               [(char<=? #\\A c #\\Z) (char- c #\\7)]\n               [(char<=? #\\a c #\\z) (char- c #\\W)]\n               [else 36])])\n      (and (fx< v r) v))))\n(digit-value #\\8 10) --> 8\n(digit-value #\\z 10) --> #f\n(digit-value #\\z 36) --> 35\n" "char- might be defined as follows.\n" "\n" "(define char-\n  (lambda (c1 c2)\n    (- (char->integer c1) (char->integer c2))))\n") ("objects:s20" "\nprocedure: (string=? string1 string2 string3 ...)\nprocedure: (string<? string1 string2 string3 ...)\nprocedure: (string>? string1 string2 string3 ...)\nprocedure: (string<=? string1 string2 string3 ...)\nprocedure: (string>=? string1 string2 string3 ...)\nprocedure: (string-ci=? string1 string2 string3 ...)\nprocedure: (string-ci<? string1 string2 string3 ...)\nprocedure: (string-ci>? string1 string2 string3 ...)\nprocedure: (string-ci<=? string1 string2 string3 ...)\nprocedure: (string-ci>=? string1 string2 string3 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (chezscheme)\n" "These predicates are identical to the Revised6 Report counterparts,\nexcept they are extended to accept one or more rather than two or more\narguments.\nWhen passed one argument, each of these predicates returns #t.\n" "\n" "(string>? \"a\") --> #t\n(string<? \"a\") --> #t\n(string-ci=? \"a\") --> #t\n") ("objects:s21" "\nprocedure: (string-copy! src src-start dst dst-start n)\nreturns: unspecified\nlibraries: (chezscheme)\n" "src and dst must be strings, and dst must be mutable.\nsrc-start, dst-start, and n must be exact nonnegative\nintegers.\nThe sum of src-start and n must not exceed the length of src,\nand the sum of dst-start and n must not exceed the length of dst.\n" "\nstring-copy! overwrites the n bytes of dst\nstarting at dst-start with the n bytes of dst\nstarting at src-start.\nThis works even if dst is the same string as src and the\nsource and destination locations overlap.\nThat is, the destination is filled with the characters that appeared at the\nsource before the operation began.\n" "\n" "(define s1 \"to boldly go\")\n(define s2 (make-string 10 #\\-))\n\n(string-copy! s1 3 s2 1 3)\ns2 --> \"-bol------\"\n \n(string-copy! s1 7 s2 4 2)\ns2 --> \"-bolly----\"\n \n(string-copy! s2 2 s2 5 4)\ns2 --> \"-bollolly-\"\n") ("objects:s22" "\nprocedure: (substring-fill! string start end char)\nreturns: unspecified\nlibraries: (chezscheme)\n" "string must be mutable.\nThe characters of string from start (inclusive) to end\n(exclusive) are set to char.\nstart and end must be nonnegative integers; start\nmust be strictly less than the length of string, while end may\nbe less than or equal to the length of string.\nIf end  start, the string is left unchanged.\n" "\n" "(let ([str (string-copy \"a tpyo typo\")])\n  (substring-fill! str 2 6 #\\X)\n  str) --> \"a XXXX typo\"\n") ("objects:s23" "\nprocedure: (string-truncate! string n)\nreturns: string or the empty string\nlibraries: (chezscheme)\n" "string must be mutable.\nn must be an exact nonnegative fixnum not greater than the length of\nstring.\nIf n is zero, string-truncate! returns the empty string.\nOtherwise, string-truncate! destructively truncates string to\nits first n characters and returns string.\n" "\n" "(define s (make-string 7 #\\$))\n(string-truncate! s 0) --> \"\"\ns --> \"$$$$$$$\"\n(string-truncate! s 3) --> \"$$$\"\ns --> \"$$$\"\n") ("objects:s24" "\nprocedure: (mutable-string? obj)\nreturns: #t if obj is a mutable string, #f otherwise\nprocedure: (immutable-string? obj)\nreturns: #t if obj is an immutable string, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(mutable-string? (string #\\a #\\b #\\c)) --> #t\n(mutable-string? (string->immutable-string \"abc\")) --> #f\n(immutable-string? (string #\\a #\\b #\\c)) --> #f\n(immutable-string? (string->immutable-string \"abc\")) --> #t\n(immutable-string? (cons 3 4)) --> #f\n") ("objects:s25" "\nprocedure: (string->immutable-string string)\nreturns: an immutable string equal to string\nlibraries: (chezscheme)\n" "The result is string itself if string\nis immutable; otherwise, the result is an immutable string with the same content as string.\n" "\n" "(define s (string->immutable-string (string #\\x #\\y #\\z)))\n(string-set! s 0 #\\a) --> exception: not mutable\n") ("objects:s31" "\nprocedure: (vector-copy vector)\nreturns: a copy of vector\nlibraries: (chezscheme)\n" "vector-copy creates a new vector of the same length and contents\nas vector.\nThe elements themselves are not copied.\n" "\n" "(vector-copy '#(a b c)) --> #(a b c)\n\n(let ([v '#(a b c)])\n  (eq? v (vector-copy v))) --> #f\n") ("objects:s32" "\nprocedure: (vector-set-fixnum! vector n fixnum)\nreturns: unspecified\nlibraries: (chezscheme)\n" "vector must be mutable.\nvector-set-fixnum! changes the nth element of vector to fixnum.\nn must be an exact nonnegative integer strictly less than\nthe length of vector.\n" "\nIt is faster to store a fixnum than an arbitrary value,\nsince for arbitrary values, the system has to record potential assignments from older to\nyounger objects to support generational garbage collection.\nCare must be taken to ensure that the argument is indeed a fixnum, however;\notherwise, the collector may not properly track the assignment.\nThe primitive performs a fixnum check on the argument except at\noptimization level 3.\n" "\nSee also the description of fixnum-only vectors (fxvectors) below.\n" "\n" "(let ([v (vector 1 2 3 4 5)])\n  (vector-set-fixnum! v 2 73)\n  v) --> #(1 2 73 4 5)\n") ("objects:s33" "\nprocedure: (vector-cas! vector n old-obj new-obj)\nreturns: #t if vector is changed, #f otherwise\nlibraries: (chezscheme)\n" "vector must be mutable.\nvector-cas! atomically changes the nth element of vector to new-obj\nif the replaced nth element is eq? to old-obj.\nIf the nth element of vector that would be replaced\nis not eq? to old-obj, then\nvector is unchanged.\n" "\n" "(define v (vector 'old0 'old1 'old2))\n(vector-cas! v 1 'old1 'new1) --> #t\n(vector-ref v 1) --> 'new1\n(vector-cas! v 2 'old1 'new2) --> #f\n(vector-ref v 2) --> 'old2\n") ("objects:s34" "\nprocedure: (mutable-vector? obj)\nreturns: #t if obj is a mutable vector, #f otherwise\nprocedure: (immutable-vector? obj)\nreturns: #t if obj is an immutable vector, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(mutable-vector? (vector 1 2 3)) --> #t\n(mutable-vector? (vector->immutable-vector (vector 1 2 3))) --> #f\n(immutable-vector? (vector 1 2 3)) --> #f\n(immutable-vector? (vector->immutable-vector (vector 1 2 3))) --> #t\n(immutable-vector? (cons 3 4)) --> #f\n") ("objects:s35" "\nprocedure: (vector->immutable-vector vector)\nreturns: an immutable vector equal to vector\nlibraries: (chezscheme)\n" "The result is vector itself if vector\nis immutable; otherwise, the result is an immutable vector with the same content as vector.\n" "\n" "(define v (vector->immutable-vector (vector 1 2 3)))\n(vector-set! v 0 0) --> exception: not mutable\n") ("objects:s38" "\nthread parameter: self-evaluating-vectors\nlibraries: (chezscheme)\n" "The default value of this parameter is #f, meaning that vector literals must be quoted, as\nrequired by the Revised6 Report.\nSetting self-evaluating-vectors to a true value may be useful to provide compatibility with\nR7RS, as the latter states that vectors are self-evaluating.\n" "\n" "#(a b c) --> exception: invalid syntax\n\n(self-evaluating-vectors #t)\n#(a b c) --> #(a b c)\n") ("objects:s43" "\nprocedure: (fxvector? obj)\nreturns: #t if obj is an fxvector, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(fxvector? #vfx()) --> #t\n(fxvector? #vfx(1 2 3)) --> #t\n(fxvector? (fxvector 1 2 3)) --> #t\n(fxvector? '#(a b c)) --> #f\n(fxvector? '(a b c)) --> #f\n(fxvector? \"abc\") --> #f\n") ("objects:s44" "\nprocedure: (fxvector fixnum ...)\nreturns: an fxvector of the fixnums fixnum ...\nlibraries: (chezscheme)\n" "\n" "\n(fxvector) --> #vfx()\n(fxvector 1 3 5) --> #vfx(1 3 5)\n") ("objects:s45" "\nprocedure: (make-fxvector n)\nprocedure: (make-fxvector n fixnum)\nreturns: an fxvector of length n\nlibraries: (chezscheme)\n" "n must be a fixnum.\nIf fixnum is supplied, each element of the fxvector is initialized\nto fixnum; otherwise, the elements are unspecified.\n" "\n" "(make-fxvector 0) --> #vfx()\n(make-fxvector 0 7) --> #vfx()\n(make-fxvector 5 7) --> #vfx(7 7 7 7 7)\n") ("objects:s46" "\nprocedure: (fxvector-length fxvector)\nreturns: the number of elements in fxvector\nlibraries: (chezscheme)\n" "\n" "(fxvector-length #vfx()) --> 0\n(fxvector-length #vfx(1 2 3)) --> 3\n(fxvector-length #10vfx(1 2 3)) --> 10\n(fxvector-length (fxvector 1 2 3 4)) --> 4\n(fxvector-length (make-fxvector 300)) --> 300\n") ("objects:s47" "\nprocedure: (fxvector-ref fxvector n)\nreturns: the nth element (zero-based) of fxvector\nlibraries: (chezscheme)\n" "n must be a nonnegative fixnum strictly less than\nthe length of fxvector.\n" "\n" "(fxvector-ref #vfx(-1 2 4 7) 0) --> -1\n(fxvector-ref #vfx(-1 2 4 7) 1) --> 2\n(fxvector-ref #vfx(-1 2 4 7) 3) --> 7\n") ("objects:s48" "\nprocedure: (fxvector-set! fxvector n fixnum)\nreturns: unspecified\nlibraries: (chezscheme)\n" "fxvector must be mutable.\nn must be a nonnegative fixnum strictly less than\nthe length of fxvector.\nfxvector-set! changes the nth element of fxvector to fixnum.\n" "\n" "(let ([v (fxvector 1 2 3 4 5)])\n  (fxvector-set! v 2 (fx- (fxvector-ref v 2)))\n  v) --> #vfx(1 2 -3 4 5)\n") ("objects:s49" "\nprocedure: (fxvector-fill! fxvector fixnum)\nreturns: unspecified\nlibraries: (chezscheme)\n" "fxvector must be mutable.\nfxvector-fill! replaces each element of fxvector with fixnum.\n" "\n" "(let ([v (fxvector 1 2 3)])\n  (fxvector-fill! v 0)\n  v) --> #vfx(0 0 0)\n") ("objects:s50" "\nprocedure: (fxvector->list fxvector)\nreturns: a list of the elements of fxvector\nlibraries: (chezscheme)\n" "\n" "(fxvector->list (fxvector)) --> ()\n(fxvector->list #vfx(7 5 2)) --> (7 5 2)\n\n(let ([v #vfx(1 2 3 4 5)])\n  (apply fx* (fxvector->list v))) --> 120\n") ("objects:s51" "\nprocedure: (list->fxvector list)\nreturns: an fxvector of the elements of list\nlibraries: (chezscheme)\n" "list must consist entirely of fixnums.\n" "\n" "(list->fxvector '()) --> #vfx()\n(list->fxvector '(3 5 7)) --> #vfx(3 5 7)\n\n(let ([v #vfx(1 2 3 4 5)])\n  (let ([ls (fxvector->list v)])\n    (list->fxvector (map fx* ls ls)))) --> #vfx(1 4 9 16 25)\n") ("objects:s52" "\nprocedure: (fxvector-copy fxvector)\nreturns: a copy of fxvector\nlibraries: (chezscheme)\n" "fxvector-copy creates a new fxvector with the same length and contents\nas fxvector.\n" "\n" "(fxvector-copy #vfx(3 4 5)) --> #vfx(3 4 5)\n\n(let ([v #vfx(3 4 5)])\n  (eq? v (fxvector-copy v))) --> #f\n") ("objects:s53" "\nprocedure: (mutable-fxvector? obj)\nreturns: #t if obj is a mutable fxvector, #f otherwise\nprocedure: (immutable-fxvector? obj)\nreturns: #t if obj is an immutable fxvector, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(mutable-fxvector? (fxvector 1 2 3)) --> #t\n(mutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) --> #f\n(immutable-fxvector? (fxvector 1 2 3)) --> #f\n(immutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) --> #t\n(immutable-fxvector? (cons 3 4)) --> #f\n") ("objects:s54" "\nprocedure: (fxvector->immutable-fxvector fxvector)\nreturns: either an immutable copy of fxvector or fxvector itself\nlibraries: (chezscheme)\n" "The result is fxvector itself if fxvector\nis immutable; otherwise, the result is an immutable fxvector with the same content as fxvector.\n" "\n" "(define v (fxvector->immutable-fxvector (fxvector 1 2 3)))\n(fxvector-set! v 0 0) --> exception: not mutable\n") ("objects:s60" "\nprocedure: (bytevector fill ...)\nreturns: a new bytevector containing fill ...\nlibraries: (chezscheme)\n" "Each fill value must be an exact integer representing a signed or\nunsigned 8-bit value, i.e.,\na value in the range -128 to 255 inclusive.\nA negative fill value is treated as its two's complement equivalent.\n" "\n" "(bytevector) --> #vu8()\n(bytevector 1 3 5) --> #vu8(1 3 5)\n(bytevector -1 -3 -5) --> #vu8(255 253 251)\n") ("objects:s61" "\nprocedure: (bytevector->s8-list bytevector)\nreturns: a new list of the 8-bit signed elements of bytevector\nlibraries: (chezscheme)\n" "The values in the returned list are exact eight-bit signed integers,\ni.e., values in the range -128 to 127 inclusive.\nbytevector->s8-list is similar to the Revised6 Report \nbytevector->u8-list except the values in the returned list\nare signed rather than unsigned.\n" "\n" "(bytevector->s8-list (make-bytevector 0)) --> ()\n(bytevector->s8-list #vu8(1 127 128 255)) --> (1 127 -128 -1)\n\n(let ([v #vu8(1 2 3 255)])\n  (apply * (bytevector->s8-list v))) --> -6\n") ("objects:s62" "\nprocedure: (s8-list->bytevector list)\nreturns: a new bytevector of the elements of list\nlibraries: (chezscheme)\n" "list must consist entirely of exact eight-bit signed integers, i.e.,\nvalues in the range -128 to 127 inclusive.\ns8-list->bytevector is similar to the Revised6 Report \nprocedure\nu8-list->bytevector, except the elements of the input list\nare signed rather than unsigned.\n" "\n" "(s8-list->bytevector '()) --> #vu8()\n(s8-list->bytevector '(1 127 -128 -1)) --> #vu8(1 127 128 255)\n\n(let ([v #vu8(1 2 3 4 5)])\n  (let ([ls (bytevector->s8-list v)])\n    (s8-list->bytevector (map - ls)))) --> #vu8(255 254 253 252 251)\n") ("objects:s63" "\nprocedure: (bytevector-truncate! bytevector n)\nreturns: bytevector or the empty bytevector\nlibraries: (chezscheme)\n" "bytevector must be mutable.\nn must be an exact nonnegative fixnum not greater than the length of\nbytevector.\nIf n is zero, bytevector-truncate! returns the empty bytevector.\nOtherwise, bytevector-truncate! destructively truncates bytevector to\nits first n bytes and returns bytevector.\n" "\n" "(define bv (make-bytevector 7 19))\n(bytevector-truncate! bv 0) --> #vu8()\nbv --> #vu8(19 19 19 19 19 19 19)\n(bytevector-truncate! bv 3) --> #vu8(19 19 19)\nbv --> #vu8(19 19 19)\n") ("objects:s64" "\nprocedure: (bytevector-u24-ref bytevector n eness)\nreturns: the 24-bit unsigned integer at index n (zero-based) of bytevector \nprocedure: (bytevector-s24-ref bytevector n eness)\nreturns: the 24-bit signed integer at index n (zero-based) of bytevector \nprocedure: (bytevector-u40-ref bytevector n eness)\nreturns: the 40-bit unsigned integer at index n (zero-based) of bytevector \nprocedure: (bytevector-s40-ref bytevector n eness)\nreturns: the 40-bit signed integer at index n (zero-based) of bytevector \nprocedure: (bytevector-u48-ref bytevector n eness)\nreturns: the 48-bit unsigned integer at index n (zero-based) of bytevector \nprocedure: (bytevector-s48-ref bytevector n eness)\nreturns: the 48-bit signed integer at index n (zero-based) of bytevector \nprocedure: (bytevector-u56-ref bytevector n eness)\nreturns: the 56-bit unsigned integer at index n (zero-based) of bytevector \nprocedure: (bytevector-s56-ref bytevector n eness)\nreturns: the 56-bit signed integer at index n (zero-based) of bytevector \nlibraries: (chezscheme)\n" "n must be an exact nonnegative integer and\nindexes the starting byte of the value.\nThe sum of n and the number of bytes occupied by the value\n(3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values,\nand 7 for 56-bit values) must not exceed the length of bytevector.\neness must be a valid endianness symbol naming the endianness.\n" "\nThe return value is an exact integer in the appropriate range for\nthe number of bytes occupied by the value.\nSigned values are the equivalent of the stored value treated as a two's\ncomplement value.\n") ("objects:s65" "\nprocedure: (bytevector-u24-set! bytevector n u24 eness)\nprocedure: (bytevector-s24-set! bytevector n s24 eness)\nprocedure: (bytevector-u40-set! bytevector n u40 eness)\nprocedure: (bytevector-s40-set! bytevector n s40 eness)\nprocedure: (bytevector-u48-set! bytevector n u48 eness)\nprocedure: (bytevector-s48-set! bytevector n s48 eness)\nprocedure: (bytevector-u56-set! bytevector n u56 eness)\nprocedure: (bytevector-s56-set! bytevector n s56 eness)\nreturns: unspecified\nlibraries: (chezscheme)\n" "bytevector must be mutable.\nn must be an exact nonnegative integer and\nindexes the starting byte of the value.\nThe sum of n and the number of bytes occupied by the value must\nnot exceed the length of bytevector.\nu24 must be a 24-bit unsigned value, i.e., a value in the range\n0 to 224 - 1 inclusive;\ns24 must be a 24-bit signed value, i.e., a value in the range\n-223 to 223 - 1 inclusive;\nu40 must be a 40-bit unsigned value, i.e., a value in the range\n0 to 240 - 1 inclusive;\ns40 must be a 40-bit signed value, i.e., a value in the range\n-239 to 239 - 1 inclusive;\nu48 must be a 48-bit unsigned value, i.e., a value in the range\n0 to 248 - 1 inclusive;\ns48 must be a 48-bit signed value, i.e., a value in the range\n-247 to 247 - 1 inclusive;\nu56 must be a 56-bit unsigned value, i.e., a value in the range\n0 to 256 - 1 inclusive; and\ns56 must be a 56-bit signed value, i.e., a value in the range\n-255 to 255 - 1 inclusive.\neness must be a valid endianness symbol naming the endianness.\n" "\nThese procedures store the given value in the 3, 5, 6, or 7 bytes starting\nat index n (zero-based) of bytevector.\nNegative values are stored as their two's complement equivalent.\n") ("objects:s66" "\nprocedure: (mutable-bytevector? obj)\nreturns: #t if obj is a mutable bytevector, #f otherwise\nprocedure: (immutable-bytevector? obj)\nreturns: #t if obj is an immutable bytevector, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(mutable-bytevector? (bytevector 1 2 3)) --> #t\n(mutable-bytevector?\n  (bytevector->immutable-bytevector (bytevector 1 2 3))) --> #f\n(immutable-bytevector? (bytevector 1 2 3)) --> #f\n(immutable-bytevector?\n  (bytevector->immutable-bytevector (bytevector 1 2 3))) --> #t\n(immutable-bytevector? (cons 3 4)) --> #f\n") ("objects:s67" "\nprocedure: (bytevector->immutable-bytevector bytevector)\nreturns: an immutable bytevector equal to bytevector\nlibraries: (chezscheme)\n" "The result is bytevector itself if bytevector\nis immutable; otherwise, the result is an immutable bytevector with the same content as bytevector.\n" "\n" "(define bv (bytevector->immutable-bytevector (bytevector 1 2 3)))\n(bytevector-u8-set! bv 0 0) --> exception: not mutable\n") ("objects:s70" "\nprocedure: (bytevector-compress bytevector)\nreturns: a new bytevector containing compressed content of bytevector\nlibraries: (chezscheme)\n" "The result is the raw compressed data with a minimal header to record\nthe uncompressed size and the compression mode. The result does not include\nthe header that is written by port-based compression using the\ncompressed option. The compression format is determined by the\ncompress-format\nparameter, and the compression level is determined by the\ncompress-level\nparameter.\n\n") ("objects:s73" "\nprocedure: (bytevector-uncompress bytevector)\nreturns: a bytevector containing uncompressed content of bytevector\nlibraries: (chezscheme)\n" "Uncompresses a bytevector produced by\nbytevector-compress to a new bytevector with the same content\nas the original given to bytevector-compress.\n\n") ("objects:s82" "\nprocedure: (box? obj)\nreturns: #t if obj is a box, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(box? '#&a) --> #t\n(box? 'a) --> #f\n(box? (box 3)) --> #t\n") ("objects:s83" "\nprocedure: (box obj)\nreturns: a new box containing obj\nlibraries: (chezscheme)\n" "\n" "\n(box 'a) --> #&a\n(box (box '(a b c))) --> #&#&(a b c)\n") ("objects:s84" "\nprocedure: (unbox box)\nreturns: contents of box\nlibraries: (chezscheme)\n" "\n" "\n(unbox #&a) --> a\n(unbox #&#&(a b c)) --> #&(a b c)\n\n(let ([b (box \"hi\")])\n  (unbox b)) --> \"hi\"\n") ("objects:s85" "\nprocedure: (set-box! box obj)\nreturns: unspecified\nlibraries: (chezscheme)\n" "box must be mutable.\nset-box! sets the contents of box to obj.\n" "\n" "(let ([b (box 'x)])\n  (set-box! b 'y)\n  b) --> #&y\n\n(let ([incr!\n       (lambda (x)\n         (set-box! x (+ (unbox x) 1)))])\n  (let ([b (box 3)])\n    (incr! b)\n    (unbox b))) --> 4\n") ("objects:s86" "\nprocedure: (box-cas! box old-obj new-obj)\nreturns: #t if box is changed, #f otherwise\nlibraries: (chezscheme)\n" "box must be mutable.\nbox-cas! atomically changes the content of box to new-obj\nif the replaced content is eq? to old-obj.\nIf the content of box that would be replaced is not eq? to old-obj, then\nbox is unchanged.\n" "\n" "(define b (box 'old))\n(box-cas! b 'old 'new) --> #t\n(unbox b) --> 'new\n(box-cas! b 'other 'wrong) --> #f\n(unbox b) --> 'new\n") ("objects:s87" "\nprocedure: (mutable-box? obj)\nreturns: #t if obj is a mutable box, #f otherwise\nprocedure: (immutable-box? obj)\nreturns: #t if obj is an immutable box, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(mutable-box? (box 1)) --> #t\n(mutable-box? (box-immutable 1)) --> #f\n(immutable-box? (box 1)) --> #f\n(immutable-box? (box-immutable 1)) --> #t\n(mutable-box? (cons 3 4)) --> #f\n") ("objects:s88" "\nprocedure: (box-immutable obj)\nreturns: a new immutable box containing obj\nlibraries: (chezscheme)\n" "Boxes are typically intended to support shared, mutable structure, so immutable boxes\nare not often useful.\n" "\n" "(define b (box-immutable 1))\n(set-box! b 0) --> exception: not mutable\n") ("objects:s93" "\ndesc:gensym\nprocedure: (gensym)\nprocedure: (gensym pretty-name)\nprocedure: (gensym pretty-name unique-name)\nreturns: a unique generated symbol\nlibraries: (chezscheme)\n" "Each\ncall to gensym returns a unique generated symbol, or gensym.\nEach generated symbol has two names: a \"pretty\" name and a\n\"unique\" name.\n" "\nIn the first form above, the pretty name is formed (lazily---see\nbelow) by combining an\ninternal prefix with the value of an internal counter.\nAfter each name is formed, the internal counter is incremented.\nThe parameters gensym-prefix and\ngensym-count, described below, may be used to access and set\nthe internal prefix and counter.\nBy default, the prefix is the single-character string \"g\".\nIn the second and third forms, the pretty name of the new gensym\nis pretty-name, which must be a string.\nThe pretty name of a gensym is returned by the procedure\nsymbol->string.\n" "\nIn both the first and second forms, the unique name is an\nautomatically generated globally unique name.\nGlobally unique names are constructed (lazily---see below) from the\ncombination of a universally unique identifier and an internal\ncounter.\nIn the third form of gensym, the unique name of the new gensym is\nunique-name, which must be a string.\nThe unique name of a gensym may be obtained via the procedure\ngensym->unique-string.\n" "\nThe unique name allows gensyms to be written in such a way that they\ncan be read back and reliably commonized on input.\nThe syntax for gensyms\nincludes both the pretty name and the unique name, as shown in the\nexample below:\n" "\n" "(gensym) --> #{g0 bcsfg5eq4e9b3h9o-a}\n" "When the parameter print-gensym is set to pretty,\nthe printer prints the pretty name only, with a\n#: syntax, so\n" "\n" "(parameterize ([print-gensym 'pretty])\n  (write (gensym)))\n" "prints #:g0.\n" "\nWhen the reader sees the #: syntax, it produces a gensym with\nthe given pretty name, but the original unique name is lost.\n" "\nWhen the parameter is set to #f, the printer prints just the\npretty name, so\n" "\n" "(parameterize ([print-gensym #f])\n  (write (gensym)))\n" "prints g0.\nThis is useful only when gensyms do not need to be read back in\nas gensyms.\n" "\nIn order to reduce construction and (when threaded) synchronization\noverhead when gensyms are frequently created but rarely printed or\nstored in an object file, generated pretty and unique names are created\nlazily, i.e., not until first requested, either by the printer, fasl\nwriter, or explicitly by one of the procedures symbol->string\nor gensym->unique-string.\nIn addition, a gensym is not placed into the system's internal symbol\ntable (the oblist; see page 156) until the unique name\nis requested.\nThis allows a gensym to be reclaimed by the storage manager\nif no references to the gensym exist and no unique name exists by which to\naccess it, even if it has a top-level binding or a nonempty property\nlist.\n" "\n" "(define x (gensym))\nx                         --> #{g2 bcsfg5eq4e9b3h9o-c}\n(symbol->string x)        --> \"g2\"\n(gensym->unique-string x) --> \"bcsfg5eq4e9b3h9o-c\"\n" "Gensyms subsume the notion of uninterned\nsymbols supported by earlier versions of Chez Scheme.\nSimilarly, the predicate\nuninterned-symbol? has been replaced\nby gensym?.\n") ("objects:s101" "\nthread parameter: gensym-prefix\nthread parameter: gensym-count\nlibraries: (chezscheme)\n" "The parameters gensym-prefix and\ngensym-count are used to access and set the internal prefix\nand counter from which the pretty name of a gensym\nis generated when gensym is not given an explicit string\nargument.\ngensym-prefix defaults to the string \"g\" and may be\nset to any object.\ngensym-count starts at 0 and may be set to any nonnegative\ninteger.\n" "\nAs described above, Chez Scheme delays the creation\nof the pretty name until the name is first requested by the printer or by\nan explicit call to symbol->string.\nThese parameters are not consulted until that time; setting them when\ngensym is called thus has no effect on the generated name.\n" "\n" "(let ([x (parameterize ([gensym-prefix \"genny\"]\n                        [gensym-count 17]\n                        [print-gensym 'pretty])\n           (gensym))])\n  (format \"~s\" x))                       --> \"#{g4 bcsfg5eq4e9b3h9o-e}\"\n(let ([x (gensym)])\n  (parameterize ([gensym-prefix \"genny\"]\n                 [gensym-count 17]\n                 [print-gensym #f])\n    (format \"~s\" (gensym))))             --> \"genny17\"\n") ("objects:s103" "\nprocedure: (gensym->unique-string gensym)\nreturns: the unique name of gensym\nlibraries: (chezscheme)\n" "\n" "\n(gensym->unique-string (gensym)) --> \"bd3kufa7ypjcuvut-g\"\n") ("objects:s104" "\nprocedure: (gensym? obj)\nreturns: #t if obj is gensym, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(gensym? (string->symbol \"z\")) --> #f\n(gensym? (gensym \"z\")) --> #t\n(gensym? 'a) --> #f\n(gensym? 3) --> #f\n(gensym? (gensym)) --> #t\n(gensym? '#{g2 bcsfg5eq4e9b3h9o-c}) --> #t\n") ("objects:s105" "property-lists\nprocedure: (putprop symbol key value)\nreturns: unspecified\nlibraries: (chezscheme)\n" "Chez Scheme associates a property list with\neach symbol, allowing multiple key-value pairs to be stored\ndirectly with the symbol.\nNew key-value pairs may be placed in the property list or retrieved in\na manner analogous to the use of association lists, using the procedures\nputprop and getprop.\nProperty lists are often used to store information related to the symbol\nitself.\nFor example, a natural language program might use symbols to represent\nwords, using their property lists to store information about use and\nmeaning.\n" "\nputprop associates value with key on the\nproperty list of symbol.\nkey and value may be any types of object, although key is\ntypically a symbol.\n" "\nputprop may be used to establish a new property or to change\nan existing property.\n" "\nSee the examples under getprop below.\n\n") ("objects:s107" "\nprocedure: (getprop symbol key)\nprocedure: (getprop symbol key default)\nreturns: the value associated with key on the property list of symbol\nlibraries: (chezscheme)\n" "getprop searches the property list of\nsymbol for a key identical to key (in the sense of\neq?), and returns the value associated with this key, if any.\nIf no value is associated with key on the property list of\nsymbol, getprop returns default, or #f if\nthe default argument is not supplied.\n\n" "\n" "(putprop 'fred 'species 'snurd)\n(putprop 'fred 'age 4)  \n(putprop 'fred 'colors '(black white))\n\n(getprop 'fred 'species) --> snurd\n(getprop 'fred 'colors) --> (black white)\n(getprop 'fred 'nonkey) --> #f\n(getprop 'fred 'nonkey 'unknown) --> unknown\n \n(putprop 'fred 'species #f)\n(getprop 'fred 'species 'unknown) --> #f\n") ("objects:s109" "\nprocedure: (remprop symbol key)\nreturns: unspecified\nlibraries: (chezscheme)\n" "remprop removes the property with key key from the property\nlist of symbol, if such a property exists.\n" "\n" "(putprop 'fred 'species 'snurd)\n(getprop 'fred 'species) --> snurd\n\n(remprop 'fred 'species)\n(getprop 'fred 'species 'unknown) --> unknown\n") ("objects:s111" "\nprocedure: (property-list symbol)\nreturns: a copy of the internal property list for symbol\nlibraries: (chezscheme)\n" "A property list is a list of alternating keys and values,\ni.e., (key value ...).\n" "\n" "(putprop 'fred 'species 'snurd)\n(putprop 'fred 'colors '(black white))\n(property-list 'fred) --> (colors (black white) species snurd)\n") ("objects:s112" "desc:oblist\nprocedure: (oblist)\nreturns: a list of interned symbols\nlibraries: (chezscheme)\n" "The system maintains an internal symbol table used\nto insure that any two occurrences of the same\nsymbol name resolve to the same symbol object.\nThe oblist procedure returns a list of the symbols currently in\nthis symbol table.\n" "\nThe list of interned symbols grows when a new symbol\nis introduced into the system or when the unique name of a\ngensym (see page 153) is requested.\nIt shrinks when the garbage collector determines that it is\nsafe to discard a symbol.\nIt is safe to discard a symbol only if the symbol is not accessible except\nthrough the oblist,\nhas no top-level binding, and has no properties on its property\nlist.\n" "\n" "(if (memq 'tiger (oblist)) 'yes 'no) --> yes\n(equal? (oblist) (oblist)) --> #t\n(= (length (oblist)) (length (oblist))) --> #t or #f\n" "The first example above follows from the property that all interned\nsymbols are in the oblist from the time they are read, which happens\nprior to evaluation.\nThe second example follows from the fact that no symbols can be\nremoved from the oblist while references to those symbols exist, in\nthis case, within the list returned by the first call to\noblist (whichever call is performed first).\nThe expression in the third example can return #f only if a garbage\ncollection occurs sometime between the two calls to oblist, and only\nif one or more symbols are removed from the oblist by that collection.\n") ("objects:s113" "\nprocedure: (void)\nreturns: the void object\nlibraries: (chezscheme)\n" "void is a procedure of no arguments that returns the void object.\nIt can be used to force expressions that are used for effect or whose\nvalues are otherwise unspecified to evaluate to a consistent, trivial\nvalue.\nSince most Chez Scheme operations that are used for effect\nreturn the void object, however, it is rarely necessary to explicitly\ninvoke the void procedure.\n" "\nSince the void object is used explicitly as an \"unspecified\" value,\nit is a bad idea to use it for any other purpose or to count on any\ngiven expression evaluating to the void object.\n" "\nThe default waiter printer suppresses the void object; that is, nothing\nis printed for expressions that evaluate to the void object.\n" "\n" "(eq? (void) #f) --> #f\n(eq? (void) #t) --> #f\n(eq? (void) '()) --> #f\n") ("objects:s114" "\nprocedure: (sort predicate list)\nprocedure: (sort! predicate list)\nreturns: a list containing the elements of list sorted according to predicate\nlibraries: (chezscheme)\n" "sort is identical to the Revised6 Report list-sort,\nand sort! is a destructive version of sort, i.e., it\nreuses pairs from the input list to form the output list.\n" "\n" "(sort < '(3 4 2 1 2 5)) --> (1 2 2 3 4 5)\n(sort! < '(3 4 2 1 2 5)) --> (1 2 2 3 4 5)\n") ("objects:s115" "\nprocedure: (merge predicate list1 list2)\nprocedure: (merge! predicate list1 list2)\nreturns: list1 merged with list2 in the order specified by predicate\nlibraries: (chezscheme)\n" "predicate should be a procedure that expects two arguments and\nreturns #t if its first argument must precede its second in\nthe merged list.\nIt should not have any side effects.\nThat is, if predicate is applied to two objects x and\ny, where x is taken from the second list and y\nis taken from the first list,\nit should return true only if x should appear before y\nin the output list.\nIf this constraint is met,\nmerge and merge! are stable, in that items from list1 are\nplaced in front of equivalent items from list2 in the output list.\nDuplicate elements are included in the merged list.\n" "\nmerge! combines the lists destructively, using pairs from the input\nlists to form the output list.\n" "\n" "(merge char<?\n       '(#\\a #\\c)\n       '(#\\b #\\c #\\d)) --> (#\\a #\\b #\\c #\\c #\\d)\n(merge <\n       '(1/2 2/3 3/4)\n       '(0.5 0.6 0.7)) --> (1/2 0.5 0.6 2/3 0.7 3/4)\n") ("objects:s116" "\nprocedure: (hashtable-cell hashtable key default)\nreturns: a pair (see below)\nlibraries: (chezscheme)\n" "hashtable must be a hashtable.\nkey and default may be any Scheme values.\n" "\nIf no value is associated with key in hashtable,\nhashtable-cell modifies hashtable to associate key with\ndefault.\nIt returns a pair whose car is key and whose cdr is\nthe associated value.\nChanging the cdr of this pair effectively updates the table to\nassociate key with a new value.\nThe key in the car field should not be changed.\nThe advantage of this procedure over the Revised6 Report procedures\nfor manipulating hashtable entries is that the value associated with\na key may be read or written many times with only a single hashtable\nlookup.\n" "\n" "(define ht (make-eq-hashtable))\n(define v (vector 'a 'b 'c))\n(define cell (hashtable-cell ht v 3))\ncell --> (#(a b c) . 3)\n(hashtable-ref ht v 0) --> 3\n(set-cdr! cell 4)\n(hashtable-ref ht v 0) --> 4\n") ("objects:s117" "\nprocedure: (hashtable-keys hashtable)\nprocedure: (hashtable-keys hashtable size)\nreturns: a vector containing the keys in hashtable\nlibraries: (chezscheme)\n" "Identical to the Revised6 Report counterpart, but allowing an optional\nsize argument.\nIf size is specified, then it must be an exact, nonnegative integer, and the\nresult vector contains no more than size elements.\nDifferent calls to hashtable-keys\nwith a size less than (hashtable-size hashtable)\nmay return different subsets of hashtable's keys.\n" "\n" "(define ht (make-eq-hashtable))\n(hashtable-set! ht 'a \"one\")\n(hashtable-set! ht 'b \"two\")\n(hashtable-set! ht 'c \"three\")\n(hashtable-keys ht) --> #(a b c) or any permutation\n(hashtable-keys ht 1) --> #(a) or #(b) or #(c)\n") ("objects:s118" "\nprocedure: (hashtable-values hashtable)\nprocedure: (hashtable-values hashtable size)\nreturns: a vector containing the values in hashtable\nlibraries: (chezscheme)\n" "Each value is the value of one of the keys in hashtable.\nDuplicate values are not removed.\nThe values may appear in any order in the returned vector.\nIf size is specified, then it must be an exact, nonnegative integer, and the\nresult vector contains no more than size elements.\nDifferent calls to hashtable-values\nwith a size less than (hashtable-size hashtable)\nmay return different subsets of hashtable's values.\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 \"one\")\n(hashtable-set! ht p2 \"two\")\n(hashtable-set! ht 'q \"two\")\n(hashtable-values ht) --> #(\"one\" \"two\" \"two\") or any permutation\n(hashtable-values ht 1) --> #(\"one\") or #(\"two\")\n" "This procedure is equivalent to calling hashtable-entries and returning only\nthe second result, but it is more efficient since the separate vector of keys need\nnot be created.\n") ("objects:s119" "\nprocedure: (hashtable-entries hashtable)\nprocedure: (hashtable-entries hashtable size)\nreturns: two vectors containing the keys and values in hashtable\nlibraries: (chezscheme)\n" "Identical to the Revised6 Report counterpart, but allowing an optional\nsize argument.\nIf size is specified, then it must be an exact, nonnegative integer, and the\nresult vectors contain no more than size elements.\nDifferent calls to hashtable-entries\nwith a size less than (hashtable-size hashtable)\nmay return different subsets of hashtable's entries.\n" "\n" "(define ht (make-eq-hashtable))\n(hashtable-set! ht 'a \"one\")\n(hashtable-set! ht 'b \"two\")\n(hashtable-entries ht) --> #(a b) #(\"one\" \"two\") or the other permutation\n(hashtable-entries ht 1) --> #(a) #(\"one\") or #(b) #(\"two\") \n") ("objects:s120" "\nprocedure: (hashtable-cells hashtable)\nprocedure: (hashtable-cells hashtable size)\nreturns: a vector of up to size elements containing the cells of hashtable\nlibraries: (chezscheme)\n" "Each element of the result vector is the value of one of the cells in hashtable.\nThe cells may appear in any order in the returned vector.\nIf size is specified, then it must be an exact, nonnegative integer, and the\nresult vector contains no more than size cells.\nIf size is not specified, then the result vector has (hashtable-size hashtable) elements.\nDifferent calls to hashtable-cells\nwith a size less than (hashtable-size hashtable)\nmay return different subsets of hashtable's cells.\n" "\n" "(define ht (make-eqv-hashtable))\n(hashtable-set! ht 1 'one)\n(hashtable-set! ht 2 'two)\n(hashtable-cells ht) --> #((1 . one) (2 . two)) or #((2 . two) (1 . one))\n(hashtable-cells ht 1) --> #((1 . one)) or #((2 . two))\n(hashtable-cells ht 0) --> #()\n") ("objects:s121" "\nprocedure: (make-weak-eq-hashtable)\nprocedure: (make-weak-eq-hashtable size)\nprocedure: (make-weak-eqv-hashtable)\nprocedure: (make-weak-eqv-hashtable size)\nreturns: a new weak eq hashtable\nlibraries: (chezscheme)\n" "These procedures are like the Revised6 Report procedures make-eq-hashtable\nand make-eqv-hashtable\nexcept the keys of the hashtable are held weakly, i.e., they are not\nprotected from the garbage collector.\nKeys reclaimed by the garbage collector are removed from the table,\nand their associated values are dropped the next time the table\nis modified, if not sooner.\n" "\nValues in the hashtable are referenced normally as long as the key is\nnot reclaimed, since keys are paired values using weak pairs. Consequently,\nif a value in the hashtable refers to its own key, then\ngarbage collection is prevented from reclaiming the key. See\nmake-ephemeron-eq-hashtable and make-ephemeron-eqv-hashtable.\n" "\nA copy of a weak eq or eqv hashtable created by hashtable-copy is\nalso weak.\nIf the copy is immutable, inaccessible keys may still be dropped from the\nhashtable, even though the contents of the table is otherwise unchanging.\nThe effect of this can be observed via hashtable-keys and\nhashtable-entries.\n" "\n" "(define ht1 (make-weak-eq-hashtable))\n(define ht2 (make-weak-eq-hashtable 32))\n") ("objects:s122" "\nprocedure: (make-ephemeron-eq-hashtable)\nprocedure: (make-ephemeron-eq-hashtable size)\nprocedure: (make-ephemeron-eqv-hashtable)\nprocedure: (make-ephemeron-eqv-hashtable size)\nreturns: a new ephemeron eq hashtable\nlibraries: (chezscheme)\n" "These procedures are like make-weak-eq-hashtable and\nmake-weak-eqv-hashtable, but a value in the hashtable can refer to a\nkey in the hashtable (directly or indirectly) without preventing garbage collection from\nreclaiming the key, because keys are paired with values using ephemeron pairs.\n" "\nA copy of an ephemeron eq or eqv hashtable created by\nhashtable-copy is also an ephemeron table, and an inaccessible\nkey can be dropped from an immutable ephemeron hashtable in the same\nway as for an immutable weak hashtable.\n" "\n" "(define ht1 (make-ephemeron-eq-hashtable))\n(define ht2 (make-ephemeron-eq-hashtable 32))\n") ("objects:s123" "\nprocedure: (hashtable-weak? obj)\nreturns: #t if obj is a weak eq or eqv hashtable, #f otherwise\nlibraries: (chezscheme)\n" "\n" "(define ht1 (make-weak-eq-hashtable))\n(define ht2 (hashtable-copy ht1))\n(hashtable-weak? ht2) --> #t\n") ("objects:s124" "\nprocedure: (hashtable-ephemeron? obj)\nreturns: #t if obj is an ephemeron eq or eqv hashtable, #f otherwise\nlibraries: (chezscheme)\n" "\n" "(define ht1 (make-ephemeron-eq-hashtable))\n(define ht2 (hashtable-copy ht1))\n(hashtable-ephemeron? ht2) --> #t\n") ("objects:s125" "\nprocedure: (eq-hashtable? obj)\nreturns: #t if obj is an eq hashtable, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(eq-hashtable? (make-eq-hashtable)) --> #t\n(eq-hashtable? '(not a hash table)) --> #f\n") ("objects:s126" "\nprocedure: (eq-hashtable-weak? hashtable)\nreturns: #t if hashtable is weak, #f otherwise\nlibraries: (chezscheme)\n" "hashtable must be an eq hashtable.\n" "\n" "(eq-hashtable-weak? (make-eq-hashtable)) --> #f\n(eq-hashtable-weak? (make-weak-eq-hashtable)) --> #t\n") ("objects:s127" "\nprocedure: (eq-hashtable-ephemeron? hashtable)\nreturns: #t if hashtable uses ephemeron pairs, #f otherwise\nlibraries: (chezscheme)\n" "hashtable must be an eq hashtable.\n" "\n" "(eq-hashtable-ephemeron? (make-eq-hashtable)) --> #f\n(eq-hashtable-ephemeron? (make-ephemeron-eq-hashtable)) --> #t\n") ("objects:s128" "\nprocedure: (eq-hashtable-set! hashtable key value)\nreturns: unspecified\nlibraries: (chezscheme)\n" "hashtable must be a mutable eq hashtable.\nkey and value may be any Scheme values.\n" "\neq-hashtable-set! associates the value\nvalue with the key key in hashtable.\n" "\n" "(define ht (make-eq-hashtable))\n(eq-hashtable-set! ht 'a 73)\n") ("objects:s129" "\nprocedure: (eq-hashtable-ref hashtable key default)\nreturns: see below\nlibraries: (chezscheme)\n" "hashtable must be an eq hashtable.\nkey and default may be any Scheme values.\n" "\neq-hashtable-ref returns the value\nassociated with key in hashtable.\nIf no value is associated with key in hashtable,\neq-hashtable-ref returns default.\n\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(eq-hashtable-set! ht p1 73)\n(eq-hashtable-ref ht p1 55) --> 73\n(eq-hashtable-ref ht p2 55) --> 55\n") ("objects:s130" "\nprocedure: (eq-hashtable-contains? hashtable key)\nreturns: #t if an association for key exists in hashtable, #f otherwise\nlibraries: (chezscheme)\n" "hashtable must be an eq hashtable.\nkey may be any Scheme value.\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(eq-hashtable-set! ht p1 73)\n(eq-hashtable-contains? ht p1) --> #t\n(eq-hashtable-contains? ht p2) --> #f\n") ("objects:s131" "\nprocedure: (eq-hashtable-update! hashtable key procedure default)\nreturns: unspecified\nlibraries: (chezscheme)\n" "hashtable must be a mutable eq hashtable.\nkey and default may be any Scheme values.\nprocedure should accept one argument, should return one value, and\nshould not modify hashtable.\n" "\neq-hashtable-update! applies procedure to the value associated with\nkey in hashtable, or to default if no value is associated with\nkey in hashtable.\nIf procedure returns, eq-hashtable-update! associates key\nwith the value returned by procedure, replacing the old association,\nif any.\n" "\nA version of eq-hashtable-update! that does not verify that it receives\narguments of the proper type might be defined as follows.\n" "\n" "(define eq-hashtable-update!\n  (lambda (ht key proc value)\n    (eq-hashtable-set! ht key\n      (proc (eq-hashtable-ref ht key value)))))\n" "An implementation may, however, be able to implement\neq-hashtable-update! more efficiently by avoiding multiple\nhash computations and hashtable lookups.\n" "\n" "(define ht (make-eq-hashtable))\n(eq-hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  55)\n(eq-hashtable-ref ht 'a 0) --> 110\n(eq-hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  0)\n(eq-hashtable-ref ht 'a 0) --> 220\n") ("objects:s132" "\nprocedure: (eq-hashtable-cell hashtable key default)\nreturns: a pair (see below)\nlibraries: (chezscheme)\n" "hashtable must be an eq hashtable.\nkey and default may be any Scheme values.\n" "\nIf no value is associated with key in hashtable,\neq-hashtable-cell modifies hashtable to associate key with\ndefault.\nIt returns a pair whose car is key and whose cdr is\nthe associated value.\nChanging the cdr of this pair effectively updates the table to\nassociate key with a new value.\nThe key should not be changed.\n" "\n" "(define ht (make-eq-hashtable))\n(define v (vector 'a 'b 'c))\n(define cell (eq-hashtable-cell ht v 3))\ncell --> (#(a b c) . 3)\n(eq-hashtable-ref ht v 0) --> 3\n(set-cdr! cell 4)\n(eq-hashtable-ref ht v 0) --> 4\n") ("objects:s133" "\nprocedure: (eq-hashtable-delete! hashtable key)\nreturns: unspecified\nlibraries: (chezscheme)\n" "hashtable must be a mutable eq hashtable.\nkey may be any Scheme value.\n" "\neq-hashtable-delete! drops any association\nfor key from hashtable.\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(eq-hashtable-set! ht p1 73)\n(eq-hashtable-contains? ht p1) --> #t\n(eq-hashtable-delete! ht p1)\n(eq-hashtable-contains? ht p1) --> #f\n(eq-hashtable-contains? ht p2) --> #f\n(eq-hashtable-delete! ht p2)\n") ("objects:s134" "\nprocedure: (symbol-hashtable? obj)\nreturns: #t if obj is an eq hashtable, #f otherwise\nlibraries: (chezscheme)\n" "\n" "\n(symbol-hashtable? (make-hashtable symbol-hash eq?)) --> #t\n(symbol-hashtable? (make-eq-hashtable)) --> #f\n") ("objects:s135" "\nprocedure: (symbol-hashtable-set! hashtable key value)\nreturns: unspecified\nlibraries: (chezscheme)\n" "hashtable must be a mutable symbol hashtable.\n(A symbol hashtable is a hashtable created with hash function symbol-hash\nand equivalence function eq?, eqv?, equal?, or symbol=?.)\nkey must be a symbol, and value may be any Scheme value.\n" "\nsymbol-hashtable-set! associates the value\nvalue with the key key in hashtable.\n" "\n" "(define ht (make-hashtable symbol-hash eq?))\n(symbol-hashtable-ref ht 'a #f) --> #f\n(symbol-hashtable-set! ht 'a 73)\n(symbol-hashtable-ref ht 'a #f) --> 73\n") ("objects:s136" "\nprocedure: (symbol-hashtable-ref hashtable key default)\nreturns: see below\nlibraries: (chezscheme)\n" "hashtable must be a symbol hashtable.\n(A symbol hashtable is a hashtable created with hash function symbol-hash\nand equivalence function eq?, eqv?, equal?, or symbol=?.)\nkey must be a symbol, and default may be any Scheme value.\n" "\nsymbol-hashtable-ref returns the value\nassociated with key in hashtable.\nIf no value is associated with key in hashtable,\nsymbol-hashtable-ref returns default.\n\n" "\n" "(define ht (make-hashtable symbol-hash eq?))\n(define k1 'abcd)\n(define k2 'not-abcd)\n(symbol-hashtable-set! ht k1 \"hi\")\n(symbol-hashtable-ref ht k1 \"bye\") --> \"hi\"\n(symbol-hashtable-ref ht k2 \"bye\") --> \"bye\"\n") ("objects:s137" "\nprocedure: (symbol-hashtable-contains? hashtable key)\nreturns: #t if an association for key exists in hashtable, #f otherwise\nlibraries: (chezscheme)\n" "hashtable must be a symbol hashtable.\n(A symbol hashtable is a hashtable created with hash function symbol-hash\nand equivalence function eq?, eqv?, equal?, or symbol=?.)\nkey must be a symbol.\n" "\n" "(define ht (make-hashtable symbol-hash eq?))\n(define k1 'abcd)\n(define k2 'not-abcd)\n(symbol-hashtable-set! ht k1 \"hi\")\n(symbol-hashtable-contains? ht k1) --> #t\n(symbol-hashtable-contains? ht k2 ) --> #f\n") ("objects:s138" "\nprocedure: (symbol-hashtable-update! hashtable key procedure default)\nreturns: unspecified\nlibraries: (chezscheme)\n" "hashtable must be a mutable symbol hashtable.\n(A symbol hashtable is a hashtable created with hash function symbol-hash\nand equivalence function eq?, eqv?, equal?, or symbol=?.)\nkey must be a symbol, and default may be any Scheme value.\nprocedure should accept one argument, should return one value, and\nshould not modify hashtable.\n" "\nsymbol-hashtable-update! applies procedure to the value associated with\nkey in hashtable, or to default if no value is associated with\nkey in hashtable.\nIf procedure returns, symbol-hashtable-update! associates key\nwith the value returned by procedure, replacing the old association,\nif any.\n" "\nA version of symbol-hashtable-update! that does not verify that it receives\narguments of the proper type might be defined as follows.\n" "\n" "(define symbol-hashtable-update!\n  (lambda (ht key proc value)\n    (symbol-hashtable-set! ht key\n      (proc (symbol-hashtable-ref ht key value)))))\n" "An implementation may, however, be able to implement\nsymbol-hashtable-update! more efficiently by avoiding multiple\nhash computations and hashtable lookups.\n" "\n" "(define ht (make-hashtable symbol-hash eq?))\n(symbol-hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  55)\n(symbol-hashtable-ref ht 'a 0) --> 110\n(symbol-hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  0)\n(symbol-hashtable-ref ht 'a 0) --> 220\n") ("objects:s139" "\nprocedure: (symbol-hashtable-cell hashtable key default)\nreturns: a pair (see below)\nlibraries: (chezscheme)\n" "hashtable must be a mutable symbol hashtable.\n(A symbol hashtable is a hashtable created with hash function symbol-hash\nand equivalence function eq?, eqv?, equal?, or symbol=?.)\nkey must be a symbol, and default may be any Scheme value.\n" "\nIf no value is associated with key in hashtable,\nsymbol-hashtable-cell modifies hashtable to associate key with\ndefault.\nIt returns a pair whose car is key and whose cdr is\nthe associated value.\nChanging the cdr of this pair effectively updates the table to\nassociate key with a new value.\nThe key should not be changed.\n" "\n" "(define ht (make-hashtable symbol-hash eq?))\n(define k 'a-key)\n(define cell (symbol-hashtable-cell ht k 3))\ncell --> (a-key . 3)\n(symbol-hashtable-ref ht k 0) --> 3\n(set-cdr! cell 4)\n(symbol-hashtable-ref ht k 0) --> 4\n") ("objects:s140" "\nprocedure: (symbol-hashtable-delete! hashtable key)\nreturns: unspecified\nlibraries: (chezscheme)\n" "hashtable must be a mutable symbol hashtable.\n(A symbol hashtable is a hashtable created with hash function symbol-hash\nand equivalence function eq?, eqv?, equal?, or symbol=?.)\nkey must be a symbol.\n" "\nsymbol-hashtable-delete! drops any association\nfor key from hashtable.\n" "\n" "(define ht (make-hashtable symbol-hash eq?))\n(define k1 (gensym))\n(define k2 (gensym))\n(symbol-hashtable-set! ht k1 73)\n(symbol-hashtable-contains? ht k1) --> #t\n(symbol-hashtable-delete! ht k1)\n(symbol-hashtable-contains? ht k1) --> #f\n(symbol-hashtable-contains? ht k2) --> #f\n(symbol-hashtable-delete! ht k2)\n") ("objects:s143" "\nthread parameter: require-nongenerative-clause\nlibraries: (chezscheme)\n" "This parameter holds a boolean value that determines whether\ndefine-record-type\nrequires a nongenerative clause.\nThe default value is #f.\nThe lead-in above describes why one might want to set this to #t.\n") ("objects:s157" "\nprocedure: (record-type-equal-procedure rtd equal-proc)\nreturns: unspecified\nprocedure: (record-type-equal-procedure rtd)\nreturns: equality procedure associated with rtd, if any, otherwise #f\nlibraries: (chezscheme)\n" "In the first form, equal-proc must be a procedure or #f.\nIf equal-proc is a procedure, a new association between\nrtd and equal-proc is established, replacing any existing\nsuch association.\nIf equal-proc is #f, any existing association between\nrtd and an equality procedure is dropped.\n" "\nIn the second form, record-type-equal-procedure returns\nthe equality procedure associated with rtd, if any, otherwise #f.\n" "\nWhen changing a record type's equality procedure, the record type's\nhash procedure, if any, should be updated if necessary to maintain\nthe property that it produces the same hash value for any two\ninstances the equality procedure considers equal.\n") ("objects:s158" "\nprocedure: (record-equal-procedure record1 record2)\nreturns: the shared equality procedure for record1 and record2, if there is one, otherwise #f\nlibraries: (chezscheme)\n" "record-equal-procedure traverses the inheritance chains\nfor both record instances in an attempt to find the most specific\ntype for each that is associated with an equality procedure, if any.\nIf such type is found and is the same for both instances, the\nequality procedure associated with the type is returned.\nOtherwise, #f is returned.\n") ("objects:s159" "\nprocedure: (record-type-hash-procedure rtd hash-proc)\nreturns: unspecified\nprocedure: (record-type-hash-procedure rtd)\nreturns: hash procedure associated with rtd, if any, otherwise #f\nlibraries: (chezscheme)\n" "In the first form, hash-proc must be a procedure or #f.\nIf hash-proc is a procedure, a new association between\nrtd and hash-proc is established, replacing any existing\nsuch association.\nIf hash-proc is #f, any existing association between\nrtd and a hash procedure is dropped.\n" "\nIn the second form, record-type-hash-procedure returns\nthe hash procedure associated with rtd, if any, otherwise #f.\n" "\nThe procedure hash-proc should accept two arguments, the\ninstance for which it should compute a hash value and a hash procedure\nto use to compute hash values for arbitrary fields of the instance,\nand it returns a nonnegative exact integer.\nA record type's hash procedure should produce the same hash value\nfor any two instances the record type's equality procedure considers\nequal.\n") ("objects:s160" "\nprocedure: (record-hash-procedure record)\nreturns: the hash procedure for record, if there is one, otherwise #f\nlibraries: (chezscheme)\n" "record-hash-procedure traverses the inheritance chain\nfor the record instance in an attempt to find the most specific\ntype that is associated with a hash procedure, if any.\nIf such type is found, the hash procedure associated with the type\nis returned.\nOtherwise, #f is returned.\n") ("objects:s161" "\nthread parameter: default-record-equal-procedure\nlibraries: (chezscheme)\n" "This parameter determines how two record instances are compared by\nequal? if neither has a type-specific equality procedure.\nWhen the parameter has the value #f (the default), equal?\ncompares the instances with eq?, i.e., there is no attempt at\ndetermining structural equivalence.\nOtherwise, the parameter's value must be a procedure, and equal?\ninvokes that procedure to compare the instances, passing it three arguments:\nthe two instances and a procedure that should be used to recursively\ncompare arbitrary values within the instances.\n") ("objects:s162" "\nthread parameter: default-record-hash-procedure\nlibraries: (chezscheme)\n" "This parameter determines the hash procedure used when equal-hash\nis called on a record instance and the instance does not have a type-specific\nhash procedure.\nWhen the parameter has the value #f (the default), equal-hash\nreturns a value that is independent of the record type and contents\nof the instance.\nOtherwise, the parameter's value must be a procedure, and equal-hash\ninvokes the procedure to compute the instance's hash value, passing it\nthe record instance and a procedure to invoke to recursively compute\nhash values for arbitrary values contained within the record.\nThe procedure should return a nonnegative exact integer, and the\nreturn value should be the same for any two instances the default\nequal procedure considers equivalent.\n") ("objects:s173" "\nsyntax: (define-record name (fld1 ...) ((fld2 init) ...) (opt ...))\nsyntax: (define-record name parent (fld1 ...) ((fld2 init) ...) (opt ...))\nreturns: unspecified\nlibraries: (chezscheme)\n" "A define-record form is a definition and may appear anywhere\nand only where other definitions may appear.\n" "\ndefine-record creates a new record type containing a specified\nset of named fields and defines a set of procedures for creating and\nmanipulating instances of the record type.\n" "\nname must be an identifier.\nIf name is a generated symbol (gensym), the record definition is\nnongenerative, otherwise it is expand-time generative.\n(See the discussion of generativity earlier in this section.)\n" "\nEach fld must be an identifier field-name, or it must take\nthe form\n" "\n" "(class type field-name)\n" "where class and type are optional and\nfield-name is an identifier.\nclass, if present, must be the keyword immutable\nor the keyword mutable.\nIf the immutable class specifier is present, the field is\nimmutable; otherwise, the field is mutable.\ntype, if present, specifies how the field is represented,\nas described below.\n \n" "\nleftrecord-field-types\nptr left            any Scheme objectleft\nscheme-object left  same as ptrleft\nint left            a C intleft\nunsigned left       a C unsigned intleft\nshort left          a C shortleft\nunsigned-short left a C unsigned shortleft\nlong left           a C longleft\nunsigned-long left  a C unsigned longleft\niptr left           a signed integer the size of a ptrleft\nuptr left           an unsigned integer the size of a ptrleft\nfloat left          a C floatleft\ndouble left         a C doubleleft\ninteger-8 left      an eight-bit signed integerleft\nunsigned-8 left     an eight-bit unsigned integerleft\ninteger-16 left     a 16-bit signed integerleft\nunsigned-16 left    a 16-bit unsigned integerleft\ninteger-32 left     a 32-bit signed integerleft\nunsigned-32 left    a 32-bit unsigned integerleft\ninteger-64 left     a 64-bit signed integerleft\nunsigned-64 left    a 64-bit unsigned integerleft\nsingle-float left   a 32-bit single floating point numberleft\ndouble-float left   a 64-bit double floating point number\n\n" "\nIf a type is specified, the field can contain objects only of the\nspecified type.\nIf no type is specified, the field is of type ptr,\nmeaning that it can contain any Scheme object.\n" "\nThe field identifiers name the fields of the record.\nThe values of the n fields described by fld1 ... are\nspecified by the n arguments to the generated constructor procedure.\nThe values of the remaining fields, fld2 ..., are\ngiven by the corresponding expressions, init ....\nEach init is evaluated within the scope of the set of field names\ngiven by fld1 ... and each field in\nfld2 ... that precedes it, as if within a\nlet* expression.\nEach of these field names is bound to the value of the corresponding field\nduring initialization.\n" "\nIf\nparent is present, the record type named by parent\nis the parent of the record.\nThe new record type inherits each of the parent record's fields,\nand records of the new type are considered records of the\nparent type.\nIf parent is not present, the parent record type is\na base record type with no fields.\n" "\nThe following procedures are defined by define-record:\n" "\na constructor procedure whose name is make-name,\n\na type predicate whose name is name?,\n\nan access procedure whose name is name-fieldname\nfor each noninherited field, and\n\nan assignment procedure whose name is\nset-name-fieldname!\nfor each noninherited mutable field.\n" "\n" "\nIf no parent record type is specified,\nthe constructor behaves as if defined as\n" "\n" "(define make-name\n  (lambda (id1 ...)\n    (let* ([id2 init] ...)\n      body)))\n" "where id1 ... are the names of the fields defined by\nfld1 ...,\nid2 ... are the names of the fields defined by\nfld2 ...,\nand body builds the record from the values of the identifiers\nid1 ... and id2 ....\n" "\nIf a parent record type is specified, the parent arguments appear first,\nand the parent fields are inserted into the record before the child\nfields.\n" "\nThe options opt ... control the selection of names\nof the generated constructor, predicate, accessors, and mutators.\n" "\n" "(constructor id)\n(predicate id)\n(prefix string)\n" "The option\n(constructor id) causes the generated constructor's name\nto be id rather than make-name.\nThe option (predicate id) likewise causes the generated\npredicate's name to be id rather than name?.\nThe option (prefix string) determines the prefix\nto be used in the generated accessor and mutator names in place of\nname-.\n" "\nIf no options are needed, the third subexpression,\n(opt ...), may be omitted.\nIf no options and no fields other than those initialized by the arguments\nto the\nconstructor procedure are needed, both the second and third subexpressions\nmay be omitted.\nIf options are specified, the second subexpression must be present,\neven if it contains no field specifiers.\n" "\nHere is a simple example with no inheritance and no options.\n" "\n" "(define-record marble (color quality))\n(define x (make-marble 'blue 'medium))\n(marble? x) --> #t\n(pair? x) --> #f\n(vector? x) --> #f\n(marble-color x) --> blue\n(marble-quality x) --> medium\n(set-marble-quality! x 'low)\n(marble-quality x) --> low\n\n(define-record marble ((immutable color) (mutable quality))\n  (((mutable shape) (if (eq? quality 'high) 'round 'unknown))))\n(marble-shape (make-marble 'blue 'high)) --> round\n(marble-shape (make-marble 'blue 'low)) --> unknown\n(define x (make-marble 'blue 'high))\n(set-marble-quality! x 'low)\n(marble-shape x) --> round\n(set-marble-shape! x 'half-round)\n(marble-shape x) --> half-round\n" "The following example illustrates inheritance.\n" "\n" "(define-record shape (x y))\n(define-record point shape ())\n(define-record circle shape (radius))\n\n(define a (make-point 7 -3))\n(shape? a) --> #t\n(point? a) --> #t\n(circle? a) --> #f\n\n(shape-x a) --> 7\n(set-shape-y! a (- (shape-y a) 1))\n(shape-y a) --> -4\n\n(define b (make-circle 7 -3 1))\n(shape? b) --> #t\n(point? b) --> #f\n(circle? b) --> #t\n\n(circle-radius b) --> 1\n(circle-radius a) --> exception: not of type circle\n\n(define c (make-shape 0 0))\n(shape? c) --> #t\n(point? c) --> #f\n(circle? c) --> #f\n" "This example demonstrates the use of options:\n" "\n" "(define-record pair (car cdr)\n  ()\n  ((constructor cons)\n   (prefix \"\")))\n\n(define x (cons 'a 'b))\n(car x) --> a\n(cdr x) --> b\n(pair? x) --> #t\n\n(pair? '(a b c)) --> #f\nx --> #[#{pair bdhavk1bwafxyss1-a} a b]\n" "This example illustrates the use a specified reader name, immutable\nfields, and the graph mark and reference syntax.\n" "\n" "(define-record triple ((immutable x1) (mutable x2) (immutable x3)))\n(record-reader 'triple (type-descriptor triple))\n\n(let ([t '#[triple #1=(1 2) (3 4) #1#]])\n  (eq? (triple-x1 t) (triple-x3 t))) --> #t\n(let ([x '(#1=(1 2) . #[triple #1# b c])])\n  (eq? (car x) (triple-x1 (cdr x)))) --> #t\n(let ([t #[triple #1# (3 4) #1=(1 2)]])\n  (eq? (triple-x1 t) (triple-x3 t))) --> #t\n(let ([t '#1=#[triple a #1# c]])\n  (eq? t (triple-x2 t))) --> #t\n(let ([t '#1=(#[triple #1# b #1#])])\n  (and (eq? t (triple-x1 (car t)))\n       (eq? t (triple-x1 (car t))))) --> #t\n" "Cycles established with the mark and reference syntax can be\nresolved only if a mutable record field or mutable location\nof some other object is involved the cycle, as in the last\ntwo examples above.\nAn exception is raised with condition type &lexical if only\nimmutable fields are involved.\n" "\n" "'#1=#[triple #1# (3 4) #1#] --> exception\n" "The following example demonstrates\nthe use of nongenerative record definitions.\n" "\n" "(module A (point-disp)\n  (define-record #{point bdhavk1bwafxyss1-b} (x y))\n  (define square (lambda (x) (* x x)))\n  (define point-disp\n    (lambda (p1 p2)\n      (sqrt (+ (square (- (point-x p1) (point-x p2)))\n               (square (- (point-y p1) (point-y p2))))))))\n\n(module B (base-disp)\n  (define-record #{point bdhavk1bwafxyss1-b} (x y))\n  (import A)\n  (define base-disp\n    (lambda (p)\n      (point-disp (make-point 0 0) p))))\n\n(let ()\n  (import B)\n  (define-record #{point bdhavk1bwafxyss1-b} (x y))\n  (base-disp (make-point 3 4))) --> 5\n" "This works even if the different program components are loaded from\ndifferent source files or are compiled separately and loaded from\ndifferent object files.\n") ("objects:s177" "\nsyntax: predicate\nsyntax: prefix\nsyntax: constructor\nlibraries: (chezscheme)\n" "These identifiers are auxiliary keywords for define-record.\nIt is a syntax violation to reference these identifiers except in\ncontexts where they are recognized as auxiliary keywords.\nmutable and immutable are also auxiliary keywords for\ndefine-record, shared with the Revised6 Report\ndefine-record-type.\n\n") ("objects:s180" "\nsyntax: (type-descriptor name)\nreturns: the record-type descriptor associated with name\nlibraries: (chezscheme)\n" "name must name a record type defined by define-record\nor define-record-type.\n" "\nThis form is equivalent to the Revised6 Report\nrecord-type-descriptor form.\n" "\nThe record-type descriptor is useful for overriding the default\nread and write syntax using record-reader and\nrecord-writer and may also be used with the procedural\ninterface routines described later in this section.\n" "\n" "(define-record frob ())\n(type-descriptor frob) --> #<record type frob>\n") ("objects:s181" "\nprocedure: (record-reader name)\nreturns: the record-type descriptor associated with name\nprocedure: (record-reader rtd)\nreturns: the first name associated with rtd\nprocedure: (record-reader name rtd)\nreturns: unspecified\nprocedure: (record-reader name #f)\nreturns: unspecified\nprocedure: (record-reader rtd #f)\nreturns: unspecified\nlibraries: (chezscheme)\n" "name must be a symbol, and rtd must be a\nrecord-type descriptor.\n" "\nWith one argument, record-reader is used to retrieve the record\ntype associated with a name or name associated with a record type.\nIf no association has been created, record-reader returns\n#f\n" "\nWith arguments name and rtd, record-reader registers\nrtd as the record-type descriptor to be used whenever the\nread procedure encounters a record named by name and\nprinted in the default record syntax.\n" "\nWith arguments name and #f, record-reader removes\nany association for name to a record-type descriptor.\nSimilarly, with arguments rtd and #f, record-reader\nremoves any association for rtd to a name.\n" "\n" "(define-record marble (color quality))\n(define m (make-marble 'blue 'perfect))\nm --> #[#{marble bdhavk1bwafxyss1-c} blue perfect]\n\n(record-reader (type-descriptor marble)) --> #f\n(record-reader 'marble) --> #f\n\n(record-reader 'marble (type-descriptor marble))\n(marble-color '#[marble red miserable]) --> red\n\n(record-reader (type-descriptor marble)) --> marble\n(record-reader 'marble) --> #<record type marble>\n\n(record-reader (type-descriptor marble) #f)\n(record-reader (type-descriptor marble)) --> #f\n(record-reader 'marble) --> #f\n\n(record-reader 'marble (type-descriptor marble))\n(record-reader 'marble #f)\n(record-reader (type-descriptor marble)) --> #f\n(record-reader 'marble) --> #f\n" "The introduction of a record reader also changes the default\nprinting of records.\nThe printer always chooses the reader name first assigned\nto the record, if any, in place of the unique record name, as this\ncontinuation of the example above demonstrates.\n" "\n" "(record-reader 'marble (type-descriptor marble))\n(make-marble 'pink 'splendid) --> #[marble pink splendid]\n") ("objects:s182" "\nprocedure: (record-writer rtd)\nreturns: the record writer associated with rtd\nprocedure: (record-writer rtd procedure)\nreturns: unspecified\nlibraries: (chezscheme)\n" "rtd must be a record-type descriptor, and procedure should\naccept three arguments, as described below.\n" "\nWhen passed only one argument, record-writer returns the\nrecord writer associated with rtd, which is initially the\ndefault record writer for all records.\nThe default print method prints all records in a uniform syntax that\nincludes the generated name for the record \nand the values of each of the fields, as described in the introduction\nto this section.\n" "\nWhen passed two arguments, record-writer establishes a\nnew association between rtd and procedure so that\nprocedure will be used by the printer in place of the default\nprinter for records of the given type.\nThe printer passes procedure three arguments:\nthe record r, a port p, and a procedure wr that\nshould be used to write out the values of arbitrary Scheme objects that\nthe print method chooses to include in the printed representation of the\nrecord, e.g., values of the record's fields.\n" "\n" "(define-record marble (color quality))\n(define m (make-marble 'blue 'medium))\n\nm --> #[#{marble bdhavk1bwafxyss1-d} blue medium]\n\n(record-writer (type-descriptor marble)\n  (lambda (r p wr)\n    (display \"#<\" p)\n    (wr (marble-quality r) p)\n    (display \" quality \" p)\n    (wr (marble-color r) p)\n    (display \" marble>\" p)))\n\nm --> #<medium quality blue marble>\n" "The record writer is used only when print-record is true\n(the default).\nWhen the parameter print-record is set to #f, records\nare printed using a compressed syntax that identifies only the type\nof record.\n" "\n" "(parameterize ([print-record #f])\n  (format \"~s\" m)) --> \"#<record of type marble>\"\n" "A print method may be called more than once during the printing of a\nsingle record to support cycle detection and graph printing\n(see print-graph),\nso print\nmethods that perform side effects other than printing to the given\nport are discouraged.\nWhenever a print method is called more than once during the printing\nof a single record, in all but one call, a generic \"bit sink\" port\nis used to suppress output automatically so that only one copy of\nthe object appears on the actual port.\nIn order to avoid confusing the cycle detection and graph printing\nalgorithms, a print method should always produce the same printed\nrepresentation for each object.\nFurthermore, a print method should normally use the supplied procedure\nwr to print subobjects, though atomic values, such as strings\nor numbers, may be printed by direct calls to display or\nwrite or by other means.\n" "\n" "(let ()\n  (define-record ref () ((contents 'nothing)))\n  (record-writer (type-descriptor ref)\n    (lambda (r p wr)\n      (display \"<\" p)\n      (wr (ref-contents r) p)\n      (display \">\" p)))\n  (let ([ref-lexive (make-ref)])\n    (set-ref-contents! ref-lexive ref-lexive)\n    ref-lexive)) --> #0=<#0#>\n" "Print methods need not be concerned with handling nonfalse values of\nthe parameters\nprint-level.\nThe printer handles print-level automatically even when\nuser-defined print procedures are used.\nSince records typically contain a small, fixed number of fields, it\nis usually possible to ignore nonfalse values of\nprint-length as well.\n" "\n" "(print-level 3)\n(let ()\n  (define-record ref () ((contents 'nothing)))\n  (record-writer (type-descriptor ref)\n    (lambda (r p wr)\n      (display \"<\" p)\n      (wr (ref-contents r) p)\n      (display \">\" p)))\n  (let ([ref-lexive (make-ref)])\n    (set-ref-contents! ref-lexive ref-lexive)\n    ref-lexive)) --> <<<<#[...]>>>>\n") ("objects:s186" "\nthread parameter: print-record\nlibraries: (chezscheme)\n" "This parameter controls the printing of records.\nIf set to true (the default) the record writer associated with a\nrecord type is used to print records of that type.\nIf set to false, all records are printed with the syntax\n#<record of type name>, where name is the\nname of the record type as returned by record-type-name.\n\n") ("objects:s187" "\nprocedure: (make-record-type type-name fields)\nprocedure: (make-record-type parent-rtd type-name fields)\nreturns: a record-type descriptor for a new record type\nlibraries: (chezscheme)\n" "make-record-type creates a new data type and returns a\nrecord-type descriptor, a value representing the new data type.\nThe new type is disjoint from all others.\n" "\nIf present, parent-rtd must be a record-type descriptor.\n" "\ntype-name must be a string or gensym.\nIf type-name is a string, a new record type is generated.\nIf type-name is a gensym, a new record type is generated only\nif one with the same gensym has not already been defined.\nIf one has already been defined, the parent and fields must be identical\nto those of the existing record type, and the\nexisting record type is used.\nIf the parent and fields are not identical, an exception is raised with\ncondition-type &assertion.\n" "\nfields must be a list of field descriptors, each of which\ndescribes one field of instances of the new record type.\nA field descriptor is either a symbol or a list in the following form:\n" "\n" "(class type field-name)\n" "where class and type are optional.\nfield-name must be a symbol.\nclass, if present, must be the symbol immutable or\nthe symbol mutable.\nIf the immutable class-specifier is present, the field is\nimmutable; otherwise, the field is mutable.\ntype, if present, specifies how the field is represented.\nThe types are the same as those given in the description\nof define-record on page 175.\n" "\nIf a type is specified, the field can contain objects only of the\nspecified type.\nIf no type is specified, the field is of type ptr,\nmeaning that it can contain any Scheme object.\n" "\nThe behavior of a program that modifies the string type-name\nor the list fields or any of its sublists is unspecified.\n" "\nThe record-type descriptor may be passed as an argument to any of the\nRevised6 Report procedures\n" "\nrecord-constructor,\nrecord-predicate,\nrecord-accessor, and\nrecord-mutator,\n" "\n" "\nor to the Chez Scheme variants\n" "\nrecord-constructor,\nrecord-field-accessor, and\nrecord-field-mutator\n" "\n" "\nto obtain procedures for creating and manipulating records of the\nnew type.\n" "\n" "(define marble\n  (make-record-type \"marble\"\n    '(color quality)\n    (lambda (r p wr)\n      (display \"#<\" p)\n      (wr (marble-quality r) p)\n      (display \" quality \" p)\n      (wr (marble-color r) p)\n      (display \" marble>\" p))))\n(define make-marble\n  (record-constructor marble))\n(define marble?\n  (record-predicate marble))\n(define marble-color\n  (record-field-accessor marble 'color))\n(define marble-quality\n  (record-field-accessor marble 'quality))\n(define set-marble-quality!\n  (record-field-mutator marble 'quality))\n(define x (make-marble 'blue 'high))\n(marble? x) --> #t\n(marble-quality x) --> high\n(set-marble-quality! x 'low)\n(marble-quality x) --> low\nx --> #<low quality blue marble>\n" "The order in which the fields appear in fields is important.\nWhile field names are generally distinct, it is permissible for one field\nname to be the same as another in the list of fields or the same as\nan inherited name.\nIn this case, field ordinals\nmust be used to select fields in calls to record-field-accessor\nand record-field-mutator.\nOrdinals range from zero through one less than the number of fields.\nParent fields come first, if any, followed by the fields in\nfields, in the order given.\n" "\n" "(define r1 (make-record-type \"r1\" '(t t)))\n(define r2 (make-record-type r1 \"r2\" '(t)))\n(define r3 (make-record-type r2 \"r3\" '(t t t)))\n\n(define x ((record-constructor r3) 'a 'b 'c 'd 'e 'f))\n((record-field-accessor r3 0) x) --> a\n((record-field-accessor r3 2) x) --> c\n((record-field-accessor r3 4) x) --> e\n((record-field-accessor r3 't) x) --> unspecified\n") ("objects:s190" "\nprocedure: (record-constructor rcd)\nprocedure: (record-constructor rtd)\nreturns: a constructor for records of the type represented by rtd\nlibraries: (chezscheme)\n" "Like the Revised6 Report version of this procedure, this procedure\nmay be passed a record-constructor descriptor, rcd, which determines\nthe behavior of the constructor.\nIt may also be passed a record-type descriptor, rtd, in which\ncase the constructor accepts as many arguments as there are fields in the\nrecord; these arguments are the initial values of the fields in the\norder given when the record-type descriptor was created.\n\n") ("objects:s191" "\nprocedure: (record-field-accessor rtd field-id)\nreturns: an accessor for the identified field\nlibraries: (chezscheme csv7)\n" "rtd must be a record-type descriptor, field-id must be\na symbol or field ordinal, i.e., a nonnegative exact integer less than\nthe number of fields of the given record type.\nThe specified field must be accessible.\n" "\nThe generated accessor expects one argument, which must be a record of\nthe type represented by rtd.\nIt returns the contents of the specified field of the record.\n\n") ("objects:s192" "\nprocedure: (record-field-accessible? rtd field-id)\nreturns: #t if the specified field is accessible, otherwise #f\nlibraries: (chezscheme csv7)\n" "rtd must be a record-type descriptor, field-id must be\na symbol or field ordinal, i.e., a nonnegative exact integer less than\nthe number of fields of the given record type.\n" "\nThe compiler is free to eliminate a record field if it can prove that\nthe field is not accessed.\nIn making this determination, the compiler is free to ignore the\npossibility that an accessor might be created from a record-type\ndescriptor obtained by calling record-type-descriptor on an\ninstance of the record type.\n\n") ("objects:s193" "\nprocedure: (record-field-mutator rtd field-id)\nreturns: a mutator for the identified field\nlibraries: (chezscheme csv7)\n" "rtd must be a record-type descriptor, field-id must be\na symbol or field ordinal, i.e., a nonnegative exact integer less than\nthe number of fields of the given record type.\nThe specified field must be mutable.\n" "\nThe mutator expects two arguments, r and obj.\nr must be a record of the type represented by rtd.\nobj must be a value that is compatible with the type declared for\nthe specified field when the record-type descriptor was created.\nobj is stored in the specified field of the record.\n\n") ("objects:s194" "\nprocedure: (record-field-mutable? rtd field-id)\nreturns: #t if the specified field is mutable, otherwise #f\nlibraries: (chezscheme csv7)\n" "rtd must be a record-type descriptor, field-id must be\na symbol or field ordinal, i.e., a nonnegative exact integer less than\nthe number of fields of the given record type.\n" "\nAny field declared immutable is immutable.\nIn addition,\nthe compiler is free to treat a field as immutable if it can prove that\nthe field is never assigned.\nIn making this determination, the compiler is free to ignore the\npossibility that a mutator might be created from a record-type\ndescriptor obtained by calling record-type-descriptor on an\ninstance of the record type.\n\n") ("objects:s195" "\nprocedure: (record-type-name rtd)\nreturns: the name of the record-type represented by rtd\nlibraries: (chezscheme csv7)\n" "rtd must be a record-type descriptor.\n" "\nThe name is a always a string.\nIf a gensym is provided as the record-type name in a\ndefine-record form or make-record-type call, the result\nis the \"pretty\" name of the gensym (see 7.9).\n" "\n" "(record-type-name (make-record-type \"empty\" '())) --> \"empty\"\n\n(define-record #{point bdhavk1bwafxyss1-b} (x y))\n(define p (type-descriptor #{point bdhavk1bwafxyss1-b}))\n(record-type-name p) --> \"point\"\n") ("objects:s196" "\nprocedure: (record-type-symbol rtd)\nreturns: the generated symbol associated with rtd\nlibraries: (chezscheme csv7)\n" "rtd must be a record-type descriptor.\n" "\n" "(define e (make-record-type \"empty\" '()))\n(record-type-symbol e) --> #{empty bdhavk1bwafxyss1-e}\n\n(define-record #{point bdhavk1bwafxyss1-b} (x y))\n(define p (type-descriptor #{point bdhavk1bwafxyss1-b}))\n(record-type-symbol p) --> #{point bdhavk1bwafxyss1-b}\n") ("objects:s197" "\nprocedure: (record-type-field-names rtd)\nreturns: a list of field names of the type represented by rtd\nlibraries: (chezscheme csv7)\n" "rtd must be a record-type descriptor.\nThe field names are symbols.\n" "\n" "(define-record triple ((immutable x1) (mutable x2) (immutable x3)))\n(record-type-field-names (type-descriptor triple)) --> (x1 x2 x3)\n") ("objects:s198" "\nprocedure: (record-type-field-decls rtd)\nreturns: a list of field declarations of the type represented by rtd\nlibraries: (chezscheme csv7)\n" "rtd must be a record-type descriptor.\nEach field declaration has the following form:\n" "\n" "(class type field-name)\n" "where class, type, and field-name are as described\nunder make-record-type.\n" "\n" "(define-record shape (x y))\n(define-record circle shape (radius))\n\n(record-type-field-decls\n  (type-descriptor circle)) --> ((mutable ptr x)\n                            gifs/ghostRightarrow.gif  (mutable ptr y)\n                            gifs/ghostRightarrow.gif  (mutable ptr radius))\n") ("objects:s199" "\nprocedure: (record? obj)\nreturns: #t if obj is a record, otherwise #f\nprocedure: (record? obj rtd)\nreturns: #t if obj is a record of the given type, otherwise #f\nlibraries: (chezscheme)\n" "If present, rtd must be a record-type descriptor.\n" "\nA record is \"of the given type\" if it is an instance of the record\ntype or one of its ancestors.\nThe predicate generated by record-predicate for a\nrecord-type descriptor rtd is equivalent to the following.\n" "\n" "(lambda (x) (record? x rtd))\n") ("objects:s200" "\nprocedure: (record-type-descriptor rec)\nreturns: the record-type descriptor of rec\nlibraries: (chezscheme csv7)\n" "rec must be a record.\nThis procedure is intended for use in the definition of portable printers\nand debuggers.\nFor records created with make-record-type,\nit may not be the same as the descriptor returned by\nmake-record-type.\nSee the comments about field accessibility and mutability under\nrecord-field-accessible? and\nrecord-field-mutable? above.\n" "\nThis procedure is equivalent to the Revised6 Report record-rtd\nprocedure.\n" "\n" "(define rtd (make-record-type \"frob\" '(blit blat)))\nrtd --> #<record type frob>\n(define x ((record-constructor rtd) 1 2))\n(record-type-descriptor x) --> #<record type frob>\n(eq? (record-type-descriptor x) rtd) --> unspecified\n") ("objects:s201" "\nprocedure: (procedure-arity-mask proc)\nreturns: an exact integer bitmask identifying the accepted argument counts of proc\nlibraries: (chezscheme)\n" "The bitmask is represented as two's complement number with the bit\nat each index n set if and only if proc accepts n\narguments.\n" "\nThe two's complement encoding implies that if proc accepts\nn or more arguments, the encoding is a negative number,\nsince all the bits from n and up are set. For example, if\nproc accepts any number of arguments, the two's complement\nencoding of all bits set is -1.\n" "\n" "(procedure-arity-mask (lambda () 'none)) --> 1\n(procedure-arity-mask car) --> 2\n(procedure-arity-mask (case-lambda [() 'none] [(x) x])) --> 3\n(procedure-arity-mask (lambda x x)) --> -1\n(procedure-arity-mask (case-lambda [() 'none] [(x y . z) x])) --> -3\n(procedure-arity-mask (case-lambda)) --> 0\n(logbit? 1 (procedure-arity-mask pair?)) --> #t\n(logbit? 2 (procedure-arity-mask pair?)) --> #f\n(logbit? 2 (procedure-arity-mask cons)) --> #t\n") ("io:s9" "\nprocedure: (utf-16-codec)\nprocedure: (utf-16-codec endianness)\nprocedure: (utf-16le-codec)\nprocedure: (utf-16be-codec)\nreturns: a codec\nlibraries: (chezscheme)\n" "endianness must be the symbol big or the symbol\nlittle.\n" "\nThe codec returned by utf-16-codec can be used to create and\nprocess data written UTF-16 format.\nWhen called without the endianness argument or with endianness\nbig, utf-16-codec returns a codec for standard UTF-16\ndata, i.e., one that defaults to big-endian format if no byte-order mark\n(BOM) is found.\n" "\nWhen output is transcoded with a transcoder based on this codec, a BOM is\nemitted just before the first character written, and each character is\nwritten as a UTF-16 character in big-endian format.\nFor input, a BOM is looked for at the start of the\ninput and, if present, controls the byte order of the remaining\nUTF-16 characters.\nIf no BOM is present, big-endian order is assumed.\nFor input-output ports, the BOM is not emitted if the file is\nread before written, and a BOM is not looked for if the file is written\nbefore read.\n" "\nFor textual ports created via transcoded-port, a BOM written or\nread via the transcoder appears at the beginning of the underlying data\nstream or file only if the binary port passed to transcoded-port\nis positioned at the start of the data stream or file.\nWhen the transcoder can determine this is the case, it sets a flag that\ncauses set-port-position! to position the port beyond the BOM if\nan attempt is made to reposition the port to the start of the data stream\nor file, so that the BOM is preserved.\n" "\nWhen called with endianness little, utf-16-codec\nreturns a codec that defaults to the little-endian format both for reading\nand for writing.\nFor output-only streams or input/output streams that are written before read,\nthe result is standard UTF-16, with a BOM that specifies little-endian\nformat followed by characters in little-endian byte order.\nFor input-only streams or input/output streams that are read before written,\nthis codec allows programs to read from input streams that either\nbegin with a BOM or are encoded in UTF-16LE format.\nThis is particularly useful for handling files that might have been\nproduced by older Windows applications that claim to produce UTF-16 files\nbut actually produce UTF-16LE files.\n" "\nThe Revised6 Report version of utf-16-codec lacks the\noptional endianness argument.\n" "\nThe codecs returned by utf-16le-codec and utf-16be-codec\nare used to read and write data in the UTF-16LE and UTF-16BE formats,\ni.e., UTF-16 with little-endian or big-endian byte order and no BOM.\nFor output, these codecs are useful for controlling whether and where\nthe BOM is emitted, since no BOM is emitted implicitly and a BOM\ncan be emitted explicitly as an ordinary character.\nFor input, these codecs are useful for processing files known to be\nin little-endian or big-endian format with no BOM.\n\n") ("io:s10" "\nprocedure: (iconv-codec code-page)\nreturns: a codec\nlibraries: (chezscheme)\n" "code-page must be a string and should identify a codec accepted by\nthe iconv library installed on the target machine.\nThe codec returned by this procedure can be used to convert from the\nnon-Unicode single- and multiple-byte character sets supported by\niconv.\nWhen used in the input direction, the codec converts byte sequences\ninto Scheme strings, and when used in the output direction, it converts\nScheme strings to byte sequences.\n" "\nThe set of supported code pages depends on the version of\niconv available; consult the iconv documentation\nor use the shell command iconv --list to obtain a list\nof supported code pages.\n" "\nWhile the Windows operating system does not supply an iconv\nlibrary, it is possible to use iconv-codec on Windows systems by\nsupplying an iconv dynamic-link library (named iconv.dll,\nlibiconv.dll, or libiconv-2.dll) that provides\nPosix-conformant iconv_open, iconv, and\niconv_close entry points either under those names or under the\nalternative names libiconv_open, libiconv, and\nlibiconv_close.\nThe dll must be located in a standard location for dlls or in the\ncurrent directory of the process the first time iconv-codec\nis called.\n") ("io:s11" "\nthread parameter: current-transcoder\nlibraries: (chezscheme)\n" "The transcoder value of the current-transcoder parameter is used\nwhenever a textual file is opened with an implicit transcoder, e.g., by\nopen-input-file and other convenience I/O procedures,\ncompile-file include, load, and\npretty-file.\nIts initial value is the value of the native-transcoder procedure.\n\n") ("io:s12" "\nprocedure: (transcoder? obj)\nreturns: #t if obj is a transcoder, #f otherwise\nlibraries: (chezscheme)\n") ("io:s13" "\nprocedure: (make-input-port handler input-buffer)\nprocedure: (make-output-port handler output-buffer)\nprocedure: (make-input/output-port handler input-buffer output-buffer)\nreturns: a new textual port\nlibraries: (chezscheme)\n" "handler must be a procedure, and\ninput-buffer and output-buffer must be strings.\nEach procedure creates a generic port.\nThe handler associated with the port is handler, the\ninput buffer is input-buffer, and the\noutput buffer is output-buffer.\nFor make-input-port, the output buffer is undefined, and for\nmake-output-port, the input buffer is undefined.\n" "\nThe input size of an input or input/output port is initialized to the\nstring length of the input buffer, and the input index is set to 0.\nThe output size and index of an output or input/output port are\ninitialized similarly.\n" "\nThe length of an input or output buffer may be zero, in which case\nbuffering is effectively disabled.\n") ("io:s15" "\nprocedure: (port-handler port)\nreturns: a procedure\nlibraries: (chezscheme)\n" "For generic ports, port-handler returns the handler passed to one\nof the generic port creation procedures described above.\nFor ports created by open-input-file and similar procedures,\nport-handler returns an internal handler that may be invoked in\nthe same manner as any other handler.\n") ("io:s16" "\nprocedure: (port-input-buffer input-port)\nprocedure: (port-input-size input-port)\nprocedure: (port-input-index input-port)\nprocedure: (textual-port-input-buffer textual-input-port)\nprocedure: (textual-port-input-size textual-input-port)\nprocedure: (textual-port-input-index textual-input-port)\nprocedure: (binary-port-input-buffer binary-input-port)\nprocedure: (binary-port-input-size binary-input-port)\nprocedure: (binary-port-input-index binary-input-port)\nreturns: see below\nlibraries: (chezscheme)\n" "These procedures return the input buffer, size, or index\nof the input port.\nThe variants specialized to textual or binary ports are slightly\nmore efficient than their generic counterparts.\n\n") ("io:s17" "\nprocedure: (set-port-input-index! input-port n)\nprocedure: (set-port-input-size! input-port n)\nprocedure: (set-port-input-buffer! input-port x)\nprocedure: (set-textual-port-input-index! textual-input-port n)\nprocedure: (set-textual-port-input-size! textual-input-port n)\nprocedure: (set-textual-port-input-buffer! textual-input-port string)\nprocedure: (set-binary-port-input-index! binary-input-port n)\nprocedure: (set-binary-port-input-size! binary-input-port n)\nprocedure: (set-binary-port-input-buffer! binary-input-port bytevector)\nreturns: unspecified\nlibraries: (chezscheme)\n" "The procedure set-port-input-index! sets the input index field of\ninput-port to n, which must be a nonnegative integer less than\nor equal to the port's input size.\n" "\nThe procedure set-port-input-size! sets the input size field of\ninput-port to n, which must be a nonnegative integer less than\nor equal to the string length of the port's input buffer.\nIt also sets the input index to 0.\n" "\nThe procedure set-port-input-buffer! sets the input buffer field of\ninput-port to x, which must be a string for textual ports and a\nbytevector for binary ports.\nIt also sets the input size to the length of the string or bytevector\nand the input index to 0.\n" "\nThe variants specialized to textual or binary ports are slightly\nmore efficient than their generic counterparts.\n") ("io:s18" "\nprocedure: (port-input-count input-port)\nprocedure: (textual-port-input-count textual-input-port)\nprocedure: (binary-port-input-count binary-input-port)\nreturns: see below\nlibraries: (chezscheme)\n" "These procedures return an exact integer representing the number of\ncharacters or bytes left to be read from the port's input buffer, i.e.,\nthe difference between the buffer size and index.\n" "\nThe variants specialized to textual or binary ports are slightly\nmore efficient than their generic counterpart.\n") ("io:s19" "\nprocedure: (port-input-empty? input-port)\nreturns: #t if the port's input buffer contains no more data, otherwise #f\nlibraries: (chezscheme)\n" "This procedure determines whether the port's input count is zero without\ncomputing or returning the actual count.\n") ("io:s20" "\nprocedure: (port-output-buffer output-port)\nprocedure: (port-output-size output-port)\nprocedure: (port-output-index output-port)\nprocedure: (textual-port-output-buffer output-port)\nprocedure: (textual-port-output-size output-port)\nprocedure: (textual-port-output-index output-port)\nprocedure: (binary-port-output-buffer output-port)\nprocedure: (binary-port-output-size output-port)\nprocedure: (binary-port-output-index output-port)\nreturns: see below\nlibraries: (chezscheme)\n" "These procedures return the output buffer, size, or index\nof the output port.\nThe variants specialized to textual or binary ports are slightly\nmore efficient than their generic counterparts.\n\n") ("io:s21" "\nprocedure: (set-port-output-index! output-port n)\nprocedure: (set-port-output-size! output-port n)\nprocedure: (set-port-output-buffer! output-port x)\nprocedure: (set-textual-port-output-index! textual-output-port n)\nprocedure: (set-textual-port-output-size! textual-output-port n)\nprocedure: (set-textual-port-output-buffer! textual-output-port string)\nprocedure: (set-binary-port-output-index! output-port n)\nprocedure: (set-binary-port-output-size! output-port n)\nprocedure: (set-binary-port-output-buffer! binary-output-port bytevector)\nreturns: unspecified\nlibraries: (chezscheme)\n" "The procedure set-port-output-index! sets the output index field of\nthe output port to n, which must be a nonnegative integer less than\nor equal to the port's output size.\n" "\nThe procedure set-port-output-size! sets the output size field of\nthe output port to n, which must be a nonnegative integer less than\nor equal to the string length of the port's output buffer.\nIt also sets the output index to 0.\n" "\nThe procedure set-port-output-buffer! sets the output buffer field of\noutput-port to x, which must be a string for textual ports and a\nbytevector for binary ports.\nIt also sets the output size to the length of the string or bytevector\nand the output index to 0.\n" "\nThe variants specialized to textual or binary ports are slightly\nmore efficient than their generic counterparts.\n") ("io:s22" "\nprocedure: (port-output-count output-port)\nprocedure: (textual-port-output-count textual-output-port)\nprocedure: (binary-port-output-count binary-output-port)\nreturns: see below\nlibraries: (chezscheme)\n" "These procedures return an exact integer representing the amount of\nspace in characters or bytes available to be written in the\nport's output buffer, i.e., the difference between the buffer size\nand index.\n" "\nThe variants specialized to textual or binary ports are slightly\nmore efficient than their generic counterpart.\n") ("io:s23" "\nprocedure: (port-output-full? output-port)\nreturns: #t if the port's input buffer has no more room, otherwise #f\nlibraries: (chezscheme)\n" "This procedure determines whether the port's output count is zero without\ncomputing or returning the actual count.\n") ("io:s24" "\nprocedure: (mark-port-closed! port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure directly marks the port closed so that no further\ninput or output operations are allowed on it.\nIt is typically used by handlers upon receipt of a close-port\nmessage.\n") ("io:s25" "\nprocedure: (port-closed? port)\nreturns: #t if port is closed, #f otherwise\nlibraries: (chezscheme)\n" "\n" "(let ([p (open-output-string)])\n  (port-closed? p)) --> #f\n\n(let ([p (open-output-string)])\n  (close-port p)\n  (port-closed? p)) --> #t\n") ("io:s26" "desc:set-port-bol\nprocedure: (set-port-bol! output-port obj)\nreturns: unspecified\nlibraries: (chezscheme)\n" "When obj is #f, the port's beginning-of-line (BOL)\nflag is cleared; otherwise, the port's BOL flag is set.\n" "\nThe BOL flag is consulted by fresh-line\n(page 243) to determine if it needs to emit a\nnewline.\nThis flag is maintained automatically for file output ports, string output\nports, and transcript ports.\nThe flag is set for newly created file and string output ports, except\nfor file output ports created with the append option, for which\nthe flag is reset.\nThe BOL flag is clear for newly created generic ports and never set\nautomatically, but may be set explicitly using set-port-bol!.\nThe port is always flushed immediately before the flag is consulted, so it\nneed not be maintained on a per-character basis for buffered ports.\n") ("io:s27" "\nprocedure: (port-bol? port)\nreturns: #t if port's BOL flag is set, #f otherwise\nlibraries: (chezscheme)\n") ("io:s28" "\nprocedure: (set-port-eof! input-port obj)\nreturns: unspecified\nlibraries: (chezscheme)\n" "When obj is not #f, set-port-eof! marks input-port\nso that, once its buffer is empty, the port is treated as if it were at\neof even if more data is available in the underlying byte or character\nstream.\nOnce this artificial eof has been read, the eof mark is cleared, making\nany additional data in the stream available beyond the eof.\nThis feature can be used by a generic port to simulate a stream consisting\nof multiple input files.\n" "\nWhen obj is #f, the eof mark is cleared.\n" "\nThe following example assumes /dev/zero provides an infinite stream of\nzero bytes.\n" "\n" "(define p\n  (parameterize ([file-buffer-size 3])\n    (open-file-input-port \"/dev/zero\")))\n(set-port-eof! p #t)\n(get-u8 p) --> #!eof\n(get-u8 p) --> 0\n(set-port-eof! p #t)\n(get-u8 p) --> 0\n(get-u8 p) --> 0\n(get-u8 p) --> #!eof\n(get-u8 p) --> 0\n") ("io:s29" "\nprocedure: (port-name port)\nreturns: the name associated with port\nlibraries: (chezscheme)\n" "The name may be any object but is usually a string or #f\n(denoting no name).\nFor file ports, the name is typically a string naming the file.\n" "\n" "(let ([p (open-input-file \"myfile.ss\")])\n  (port-name p)) --> \"myfile.ss\"\n\n(let ([p (open-output-string)])\n  (port-name p)) --> \"string\"\n") ("io:s30" "\nprocedure: (set-port-name! port obj)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedure sets port's name to obj, which should be\na string or #f (denoting no name).\n\n") ("io:s31" "\nprocedure: (port-length port)\nprocedure: (file-length port)\nreturns: the length of the file or other object to which port refers\nprocedure: (port-has-port-length? port)\nreturns: #t if the port supports port-length, #f otherwise\nlibraries: (chezscheme)\n" "A port may allow the length of the underlying stream of characters or bytes\nto be determined.\nIf so, the procedure port-has-port-length? returns\n#t and port-length returns the current length.\nFor binary ports, the length is always an exact nonnegative integer byte\ncount.\nFor textual ports, the representation of a length is unspecified; it\nmay not be an exact nonnegative integer and, even if it is, it may not\nrepresent either a byte or character count.\nThe length may be used at some later time to reset the length if the\nport supports set-port-length!.\nIf port-length is called on a port that does not support it,\nan exception with condition type &assertion is raised.\n" "\nFile lengths beyond 232 might not be reported property\nfor compressed files on 32-bit versions of the system.\n" "\nfile-length is identical to port-length.\n") ("io:s32" "\nprocedure: (set-port-length! port len)\nreturns: unspecified\nprocedure: (port-has-set-port-length!? port)\nreturns: #t if the port supports set-port-length!, #f otherwise\nlibraries: (chezscheme)\n" "A port may allow the length of the underlying stream of characters or bytes\nto be set, i.e., extended or truncated.\nIf so, the procedure port-has-set-port-length!? returns\n#t and set-port-length! changes the length.\nFor binary ports, the length len must be an exact nonnegative integer byte\ncount.\nFor textual ports, the representation of a length is unspecified, as\ndescribed in the entry for port-length above, but len must be\nan appropriate length for the textual port, which is usually guaranteed\nto be the case only if it was obtained from a call to port-length\non the same port.\nIf set-port-length! is called on a port that does not support it,\nan exception with condition type &assertion is raised.\n" "\nIt is not possible to set the length of a port opened with compression\nto an arbitrary position, and the result of an attempt to set the length\nof a compressed file beyond 232 on 32-bit versions of the system is\nundefined.\n\n") ("io:s33" "\nprocedure: (port-nonblocking? port)\nreturns: #t if the port is in nonblocking mode, #f otherwise\nprocedure: (port-has-port-nonblocking?? port)\nreturns: #t if the port supports port-nonblocking?, #f otherwise\nlibraries: (chezscheme)\n" "A port may allow the nonblocking status of the port to be determined.\nIf so, the procedure port-has-port-nonblocking?? returns\n#t and port-nonblocking? returns a boolean value\nreflecting whether the port is in nonblocking mode.\n\n") ("io:s34" "\nprocedure: (set-port-nonblocking! port obj)\nreturns: unspecified\nprocedure: (port-has-set-port-nonblocking!? port)\nreturns: #t if the port supports set-port-nonblocking!, #f otherwise\nlibraries: (chezscheme)\n" "A port may allow reads or writes to be performed in a \"nonblocking\" fashion.\nIf so, the procedure port-has-set-port-nonblocking!? returns\n#t and set-port-nonblocking! sets the port to nonblocking\nmode (if obj is a true value) or blocking mode (if obj is #f).\nIf set-port-nonblocking! is called on a port that does not support it,\nan exception with condition type &assertion is raised.\n" "\nPorts created by the standard Revised6 port opening procedures are\ninitially set in blocking mode by default.\nThe same is true for most of the procedures described in this document.\nA generic port based on a nonblocking source may be nonblocking\ninitially.\nA port returned by open-fd-input-port,\nopen-fd-output-port, or open-fd-input/output-port\nis initially in nonblocking mode if the file-descriptor passed in is in\nnonblocking mode.\nSimilarly, a port returned by standard-input-port,\nstandard-output-port, or standard-error-port is\ninitially in nonblocking mode if the underlying stdin, stdout,\nor stderr file descriptor is in nonblocking mode.\n" "\nAlthough get-bytevector-some and get-string-some normally\ncannot return an empty bytevector or empty string, they can if the port\nis in nonblocking mode and no input is available.\nAlso, get-bytevector-some! and get-string-some!\nmay not read any data if the port is in nonblocking mode and\nno data is available.\nSimilarly, put-bytevector-some and put-string-some\nmay not write any data if the port is in nonblocking mode and\nno room is available.\n" "\nNonblocking mode is not supported under Windows.\n") ("io:s35" "\nprocedure: (file-position port)\nprocedure: (file-position port pos)\nreturns: see below\nlibraries: (chezscheme)\n" "When the second argument is omitted, this procedure behaves like the R6RS\nport-position procedure, and when present, like the R6RS\nset-port-position! procedure.\n" "\nFor compressed files opened with the compressed flag,\nfile-position returns the position in the\nuncompressed stream of data.\nChanging the position of a compressed input file opened with the\ncompressed flag generally requires rewinding and rereading the\nfile and might thus be slow.\nThe position of a compressed output file opened with the\ncompressed flag can be moved forward only; this is\naccomplished by writing a (compressed) sequence of zeros.\nFile positions beyond 232 might not be reported property\nfor compressed files on 32-bit versions of the system.\n\n") ("io:s36" "\nprocedure: (clear-input-port)\nprocedure: (clear-input-port input-port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "If input-port is not supplied, it defaults to the current input port.\nThis procedure discards any data in the buffer associated\nwith input-port.\nThis may be necessary, for example, to clear any type-ahead from the keyboard\nin preparation for an urgent query.\n") ("io:s37" "\nprocedure: (clear-output-port)\nprocedure: (clear-output-port output-port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "If output-port is not supplied, it defaults to the current output port.\nThis procedure discards any data in the buffer associated\nwith output-port.\nThis may be necessary, for example, to clear any pending output on an\ninteractive port in preparation for an urgent message.\n\n") ("io:s38" "\nprocedure: (flush-output-port)\nprocedure: (flush-output-port output-port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "If output-port is not supplied, it defaults to the current output port.\nThis procedure  forces any data in the buffer associated\nwith output-port to be printed immediately.\nThe console output port is automatically flushed after a newline and before\ninput from the console input port; all ports are automatically flushed when\nthey are closed.\nflush-output-port may be necessary, however, to force a message\nwithout a newline to be sent to the console output port or to force output\nto appear on a file without delay.\n") ("io:s39" "\nprocedure: (port-file-compressed! port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "port must be an input or an output port, but not an input/output port.\nIt must be a file port pointing to a regular file, i.e., a file on disk rather\nthan, e.g., a socket.\nThe port can be a binary or textual port.\nIf the port is an output port, subsequent output sent to the port\nwill be compressed.\nIf the port is an input port, subsequent input will be decompressed\nif and only if the port is currently pointing at compressed data.\nThe compression format for output\nis determined by the compress-format\nparameter, while the compression format on input is inferred.\nThe compression level, which is relevant only for output, is determined\nby the compress-level parameter.\nThis procedure has no effect if the port is already set for compression.\n") ("io:s42" "\nthread parameter: compress-format\nlibraries: (chezscheme)\n" "compress-format determines the\ncompression algorithm and format used for output. Currently,\nthe possible values of the parameter are the symbols lz4 (the default)\nand gzip.\n" "\nThe lz4 format uses the LZ4 compression library developed by\nYann Collet.\nIt is therefore compatible with the lz4 program, which\nmeans that lz4 may be used to uncompress files produced\nby Chez Scheme and visa versa.\n" "\nThe gzip format uses the zlib compression library developed by\nJean-loup Gailly and Mark Adler.\nIt is therefore compatible with the gzip program, which\nmeans that gzip may be used to uncompress files produced\nby Chez Scheme and visa versa.\n" "\nReading lz4-compressed data tends to be much faster than reading\ngzip-compressed data, while gzip-compressed data tends to \nbe significantly smaller.\n") ("io:s43" "\nthread parameter: compress-level\nlibraries: (chezscheme)\n" "compress-level determines the amount of effort spent on\ncompression and is thus relevant only for output.\nIt can be set to one of the symbols minimum, low,\nmedium, high, or maximum, which are\nlisted in order from shortest to longest expected compression time\nand least to greatest expected effectiveness.\nIts default value is medium.\n") ("io:s44" "\nprocedure: (open-input-string string)\nreturns: a new string input port\nlibraries: (chezscheme)\n" "A string input port is similar to a file input port, except that\ncharacters and objects drawn from the port come from string\nrather than from a file.\n" "\nA string port is at \"end of file\" when the port reaches the end of the\nstring.\nIt is not necessary to close a string port, although it is okay to do so.\n" "\n" "(let ([p (open-input-string \"hi mom!\")])\n  (let ([x (read p)])\n    (list x (read p)))) --> (hi mom!)\n") ("io:s46" "\nprocedure: (with-input-from-string string thunk)\nreturns: the values returned by thunk\nlibraries: (chezscheme)\n" "thunk must be a procedure and should accept zero arguments.\nwith-input-from-string parameterizes the current input port to be the\nresult of opening string for input during the\napplication of thunk.\n" "\n" "(with-input-from-string \"(cons 3 4)\"\n  (lambda ()\n    (eval (read)))) --> (3 . 4)\n") ("io:s47" "\nprocedure: (open-output-string)\nreturns: a new string output port\nlibraries: (chezscheme)\n" "A string output port is similar to a file output port, except that\ncharacters and objects written to the port are placed in a string\n(which grows as needed) rather than to a file.\nThe string built by writing to a string output port may be obtained\nwith get-output-string.\nSee the example given for get-output-string below.\nIt is not necessary to close a string port, although it is okay to do so.\n\n") ("io:s49" "\nprocedure: (get-output-string string-output-port)\nreturns: the string associated with string-output-port\nlibraries: (chezscheme)\n" "string-output-port must be an port returned by open-output-string.\n" "\nAs a side effect, get-output-string resets string-output-port\nso that subsequent output to string-output-port is placed\ninto a fresh string.\n" "\n" "(let ([p (open-output-string)])\n  (write 'hi p)\n  (write-char #\\space p)\n  (write 'mom! p)\n  (get-output-string p)) --> \"hi mom!\"\n" "An implementation of format (Section 9.13) might be\nwritten using string-output ports to produce string output.\n\n") ("io:s50" "\nprocedure: (with-output-to-string thunk)\nreturns: a string containing the output\nlibraries: (chezscheme)\n" "thunk must be a procedure and should accept zero arguments.\nwith-output-to-string parameterizes the current output port to\na new string output port during the\napplication of thunk.\nIf thunk returns, the string associated with the new string output\nport is returned, as with get-output-string.\n" "\n" "(with-output-to-string\n  (lambda ()\n    (display \"Once upon a time ...\")\n    (newline))) --> \"Once upon a time ...\\n\"\n") ("io:s51" "\nthread parameter: file-buffer-size\nlibraries: (chezscheme)\n" "file-buffer-size is a parameter that determines the size of each\nbuffer created when the buffer mode is not none for a port\ncreated by one of the file open operations, e.g., open-input-file\nor open-file-output-port.\nWhen called with no arguments, the parameter returns the\ncurrent buffer size.\nWhen called with a positive fixnum k,\nit sets the current buffer size to k.\n") ("io:s52" "\nprocedure: (file-port? port)\nreturns: #t if port is a file port, #f otherwise\nlibraries: (chezscheme)\n" "A file port is any port based directly\non an O/S file descriptor, e.g., one created by open-file-input-port,\nopen-output-port, open-fd-input-port, etc., but not\na string, bytevector, or custom  port.\n\n") ("io:s53" "\nprocedure: (port-file-descriptor port)\nreturns: the file descriptor associated with port\nlibraries: (chezscheme)\n" "port must be a file port, i.e., a port for which file-port?\nreturns #t.\n\n") ("io:s54" "\nthread parameter: custom-port-buffer-size\nlibraries: (chezscheme)\n" "custom-port-buffer-size is a parameter that determines the sizes\nof the buffers associated with newly created custom ports.\nWhen called with no arguments, the parameter returns the\ncurrent buffer size.\nWhen called with a positive fixnum k,\nit sets the current buffer size to k.\n") ("io:s55" "\nglobal parameter: console-input-port\nlibraries: (chezscheme)\n" "console-input-port is a parameter that determines the\ninput port used by the waiter and interactive debugger.\nWhen called with no arguments, it returns the\nconsole input port.\nWhen called with one argument, which must be a textual input port,\nit changes the value of the console\ninput port.\nThe initial value of this parameter is a port tied to the standard\ninput (stdin) stream of the Scheme process.\n") ("io:s56" "\nthread parameter: current-input-port\nlibraries: (chezscheme)\n" "current-input-port is a parameter that determines the\ndefault port argument for most input procedures, including\nread-char, peek-char, and read,\nWhen called with no arguments, current-input-port returns the\ncurrent input port.\nWhen called with one argument, which must be a textual input port,\nit changes the value of the current\ninput port.\nThe Revised6 Report version of current-input-port accepts\nonly zero arguments, i.e., it cannot be used to change the current input\nport.\nThe initial value of this parameter is the same port as the initial\nvalue of console-input-port.\n\n") ("io:s57" "\nprocedure: (open-input-file path)\nprocedure: (open-input-file path options)\nreturns: a new input port\nlibraries: (chezscheme)\n" "path must be a string.\nopen-input-file opens a textual input port for the file named by\npath.\nAn exception is raised with condition type\n&i/o-filename if the file does not exist or cannot be\nopened for input.\n" "\noptions, if present, is a symbolic option name or option list.\nPossible symbolic option names are \ncompressed, uncompressed, buffered,\nand unbuffered.\nAn option list is a list containing zero or more symbolic option names.\n" "\nThe mutually exclusive compressed and\nuncompressed options determine whether the input file\nshould be decompressed if it is compressed (where the compression\nformat is inferred).\n(See open-output-file.)\nThe default is uncompressed, so the uncompressed\noption is useful only as documentation.\n" "\nThe mutually exclusive buffered and unbuffered\noptions determine whether input is buffered.\nWhen input is buffered, it is read in large blocks and buffered internally\nfor efficiency to reduce the number of operating system requests.\nWhen the unbuffered option is specified, input is unbuffered,\nbut not fully, since one character of buffering is required to support\npeek-char and unread-char.\nInput is buffered by default, so the buffered option is useful\nonly as documentation.\n\n" "\nFor example, the call\n" "\n" "(open-input-file \"frob\" '(compressed))\n" "opens the file frob with decompression enabled.\n" "\nThe Revised6 Report version of open-input-file does not\nsupport the optional options argument.\n") ("io:s58" "\nprocedure: (call-with-input-file path procedure)\nprocedure: (call-with-input-file path procedure options)\nreturns: the values returned by procedure\nlibraries: (chezscheme)\n" "path must be a string.\nprocedure should accept one argument.\n" "\ncall-with-input-file creates a new input port for the file named\nby path, as if with open-input-file, and passes this port to procedure.\nIf procedure returns normally, call-with-input-file closes the input port\nand returns the values returned by procedure.\n" "\ncall-with-input-file does not automatically close the input\nport if a continuation created outside of procedure is invoked, since it\nis possible that another continuation created inside of procedure will be\ninvoked at a later time, returning control to procedure.\nIf procedure does not return, an implementation is free to close the\ninput port only if it can prove that the input port is no longer accessible.\nAs shown in Section http://scheme.com/tspl4/./control.html#g1025.6 of The Scheme Programming Language, 4th Edition, dynamic-wind may be used to\nensure that the port is closed if a continuation created outside of\nprocedure is invoked.\n" "\nSee open-input-file above for a description of the optional\noptions argument.\n" "\nThe Revised6 Report version of call-with-input-file does not\nsupport the optional input argument.\n") ("io:s59" "\nprocedure: (with-input-from-file path thunk)\nprocedure: (with-input-from-file path thunk options)\nreturns: the values returned by thunk\nlibraries: (chezscheme)\n" "path must be a string.\nthunk must be a procedure and should accept zero arguments.\n" "\nwith-input-from-file temporarily changes the current input port to be the\nresult of opening the file named by path, as if with open-input-file, during the\napplication of thunk.\nIf thunk returns, the port is closed and the current input port\nis restored to its old value.\n" "\nThe behavior of with-input-from-file is unspecified\nif a continuation created outside\nof thunk is invoked before thunk returns.\nAn implementation may close the port and restore the current input\nport to its old value---but it may not.\n" "\nSee open-input-file above for a description of the optional\noptions argument.\n" "\nThe Revised6 Report version of with-input-from-file does not\nsupport the optional options argument.\n") ("io:s60" "\nprocedure: (open-fd-input-port fd)\nprocedure: (open-fd-input-port fd b-mode)\nprocedure: (open-fd-input-port fd b-mode ?transcoder)\nreturns: a new input port for the file descriptor fd\nlibraries: (chezscheme)\n" "fd must be a nonnegative exact integer and should be a valid\nopen file descriptor.\nIf ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure returns a textual input port\nwhose transcoder is ?transcoder.\nOtherwise, this procedure returns a binary input port.\nSee the lead-in to Section http://scheme.com/tspl4/./io.html#g1237.2 of The Scheme Programming Language, 4th Edition\nfor a description of the constraints on and effects of the other\narguments.\n" "\nThe file descriptor is closed when the port is closed.\n") ("io:s61" "\nprocedure: (standard-input-port)\nprocedure: (standard-input-port b-mode)\nprocedure: (standard-input-port b-mode ?transcoder)\nreturns: a new input port connected to the process's standard input\nlibraries: (chezscheme)\n" "If ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure returns a textual input port\nwhose transcoder is ?transcoder.\nOtherwise, this procedure returns a binary input port.\nThe buffer mode b-mode defaults to block.\n" "\nThe Revised6 Report version of this procedure does not accept the\noptional b-mode and ?transcoder arguments, which limits\nit to an implementation-dependent buffering mode (block in\nChez Scheme) and binary output.\n") ("io:s62" "\nprocedure: (get-string-some textual-input-port)\nreturns: a nonempty string or the eof object\nlibraries: (chezscheme)\n" "If textual-input-port is at end of file, the eof object is returned.\nOtherwise, get-string-some reads (as if with get-u8)\nat least one character and possibly more, and returns a string containing\nthese characters.\nThe port's position is advanced past the characters read.\nThe maximum number of characters read by this operation is implementation-dependent.\n" "\nAn exception to the \"at least one character\" guarantee occurs\nif the port is in nonblocking mode (see set-port-nonblocking!)\nand no input is ready.\nIn this case, an empty string is returned.\n\n") ("io:s63" "\nprocedure: (get-string-some! textual-input-port string start n)\nreturns: the count of characters read, as an exact nonnegative integer, or the eof object\nlibraries: (chezscheme)\n" "start and n must be exact nonnegative integers, and the sum of\nstart and n must not exceed the length of string.\n" "\nIf n is 0, this procedure returns zero without attempting to\nread from textual-input-port and without modifying string.\n" "\nOtherwise, if textual-input-port is at end of file, this procedure\nreturns the eof object, except it returns zero when the port is in nonblocking mode\n(see set-port-nonblocking!) and the port cannot be determined\nto be at end of file without blocking.\nIn either case, string is not modified.\n" "\nOtherwise, this procedure reads (as if with get-char)\nup to n characters from the port, stores the characters in consecutive locations of string\nstarting at start, advances the port's position just past the characters read, and\nreturns the count of characters read.\n" "\nIf the port is in nonblocking mode, this procedure reads no more\nthan it can without blocking and thus might read zero characters;\notherwise, it reads at least one character but no more than are available\nwhen the first character becomes available.\n") ("io:s64" "\nprocedure: (get-bytevector-some! binary-input-port bytevector start n)\nreturns: the count of bytes read, as an exact nonnegative integer, or the eof object\nlibraries: (chezscheme)\n" "start and n must be exact nonnegative integers, and the sum of\nstart and n must not exceed the length of bytevector.\n" "\nIf n is 0, this procedure returns zero without attempting to\nread from binary-input-port and without modifying bytevector.\n" "\nOtherwise, if binary-input-port is at end of file, this procedure\nreturns the eof object, except it returns zero when the port is in nonblocking mode\n(see set-port-nonblocking!) and the port cannot be determined\nto be at end of file without blocking.\nIn either case, bytevector is not modified.\n" "\nOtherwise, this procedure reads (as if with get-u8)\nup to n bytes from the port, stores the bytes in consecutive locations of bytevector\nstarting at start, advances the port's position just past the bytes read, and\nreturns the count of bytes read.\n" "\nIf the port is in nonblocking mode, this procedure reads no more\nthan it can without blocking and thus might read zero bytes;\notherwise, it reads at least one byte but no more than are available\nwhen the first byte becomes available.\n") ("io:s65" "\nprocedure: (unread-char char)\nprocedure: (unread-char char textual-input-port)\nprocedure: (unget-char textual-input-port char)\nreturns: unspecified\nlibraries: (chezscheme)\n" "For unread-char, if textual-input-port is not supplied, it\ndefaults to the current input port.\nThese procedures \"unread\" the last character read from\ntextual-input-port.\nchar may or may not be ignored, depending upon the implementation.\nIn any case, char should be last character read from the port.\nA character should not be unread twice on the same port\nwithout an intervening call to read-char or get-char.\n" "\nunread-char and unget-char are provided for applications\nrequiring one character of lookahead and may be used in place of, or even\nin combination with, peek-char or lookahead-char.\nOne character of lookahead is required in the procedure\nread-word, which is defined below in terms of unread-char.\nread-word returns the next word from a textual input port as a string, where\na word is defined to be a sequence of alphabetic characters.\nSince it does not know until it reads one character too many that it has\nread the entire word, read-word uses unread-char to\nreturn the character to the input port.\n" "\n" "(define read-word\n  (lambda (p)\n    (list->string\n      (let f ([c (read-char p)])\n        (cond\n          [(eof-object? c) '()]\n          [(char-alphabetic? c)\n           (cons c (f (read-char p)))]\n          [else\n           (unread-char c p)\n           '()])))))\n" "In the alternate version below, peek-char is used instead of\nunread-char.\n" "\n" "(define read-word\n  (lambda (p)\n    (list->string\n      (let f ([c (peek-char p)])\n        (cond\n          [(eof-object? c) '()]\n          [(char-alphabetic? c)\n           (read-char p)\n           (cons c (f (peek-char p)))]\n          [else '()])))))\n" "The advantage of unread-char in this situation is that only\none call to unread-char per word is required, whereas one\ncall to peek-char is required for each character in the word\nplus the first character beyond.\nIn many cases, unread-char and unget-char do not enjoy\nthis advantage, and peek-char or lookahead-char\nshould be used instead.\n\n") ("io:s66" "\nprocedure: (unget-u8 binary-input-port octet)\nreturns: unspecified\nlibraries: (chezscheme)\n" "This procedures \"unreads\" the last byte read from\nbinary-input-port.\noctet may or may not be ignored, depending upon the implementation.\nIn any case, octet should be last byte read from the port.\nA byte should not be unread twice on the same port\nwithout an intervening call to get-u8.\n\n") ("io:s67" "\nprocedure: (input-port-ready? input-port)\nreturns: #t if data is available on input-port, #f otherwise\nlibraries: (chezscheme)\n" "input-port-ready? allows a program to check to see if input is\navailable on a textual or binary input port without hanging.\nIf input is available or the port is at end of file,\ninput-port-ready? returns #t.\nIf it cannot determine from the port whether input is ready, \ninput-port-ready? raises an exception with condition type\n&i/o-read-error.\nOtherwise, it returns #f.\n") ("io:s68" "\nprocedure: (char-ready?)\nprocedure: (char-ready? textual-input-port)\nreturns: #t if a character is available on textual-input-port, #f otherwise\nlibraries: (chezscheme)\n" "If textual-input-port is not supplied, it defaults to the current input port.\nchar-ready? is like input-port-ready? except it is\nrestricted to textual input ports.\n\n") ("io:s69" "\nprocedure: (block-read textual-input-port string)\nprocedure: (block-read textual-input-port string count)\nreturns: see below\nlibraries: (chezscheme)\n" "count must be a nonnegative fixnum less than or equal to the\nlength of string.\nIf not provided, it defaults to the length of string.\n" "\nIf textual-input-port is at end-of-file, an eof object is returned.\nOtherwise, string is filled with as many characters as are\navailable for reading from textual-input-port up to count,\nand the number of characters placed in the string is returned.\n" "\nIf textual-input-port is buffered and the buffer is nonempty,\nthe buffered input or a portion thereof is returned; otherwise\nblock-read bypasses the buffer entirely.\n") ("io:s70" "\nprocedure: (read-token)\nprocedure: (read-token textual-input-port)\nprocedure: (read-token textual-input-port sfd bfp)\nreturns: see below\nlibraries: (chezscheme)\n" "sfd must be a source-file descriptor.\nbfp must be an exact nonnegative integer and should be the\ncharacter position of the next character to be read from\ntextual-input-port.\n" "\nParsing of a Scheme datum is conceptually performed in two steps.\nFirst, the sequence of characters that form the datum are grouped into\ntokens, such as symbols, numbers, left parentheses, and\ndouble quotes.\nDuring this first step, whitespace and comments are discarded.\nSecond, these tokens are grouped into data.\n" "\nread performs both of these steps and creates an internal\nrepresentation of each datum it parses.\nread-token may be used to perform the first step only, one\ntoken at a time.\nread-token is intended to be used by editors and program\nformatters that must be able to parse a program or datum without\nactually reading it.\n" "\nIf textual-input-port is not supplied, it defaults to the current input port.\nOne token is read from the input port and returned as four values:\n" "\ntype: a symbol describing the type of token read,\n" "\nvalue: the token value,\n" "\nstart: the position of the first character of the token,\nrelative to the starting position of the input port (or #f,\nif the position cannot be determined), and\n" "\nend: the first position beyond the token,\nrelative to the starting position of the input port (or #f,\nif the position cannot be determined).\n\n" "\nThe input port is left pointing to the first character position beyond\nthe token.\n" "\nWhen the token type fully specifies the token,\nread-token returns #f for the value.\nThe token types are listed below with the corresponding value\nin parentheses.\n" "\natomic (atom) an atomic value, i.e., \n    a symbol, boolean, number, character, #!eof,\n    or #!bwp\nbox (#f) box prefix, i.e.,  #&\ndot (#f) dotted pair separator, i.e., .\neof (#!eof) end of file\nfasl (#f) fasl prefix, i.e., #@\ninsert (n) graph reference, i.e., #n#\nlbrack (#f) open square bracket\nlparen (#f) open parenthesis\nmark (n) graph mark, i.e., #n=\nquote (quote, quasiquote,\n    syntax, unquote, unquote-splicing,\n    or datum-comment)\n    an abbreviation mark, e.g., ' or ,@ or\n    datum-comment prefix\nrbrack (#f) close square bracket\nrecord-brack (#f) record open bracket, i.e., #[\nrparen (#f) close parenthesis\nvfxnparen (n) fxvector prefix, i.e., #nvfx(\nvfxparen (#f) fxvector prefix, i.e., #vfx(\nvnparen (n) vector prefix, i.e., #n(\nvparen (#f) vector prefix, i.e., #(\nvu8nparen (n) bytevector prefix, i.e., #nvu8(\nvu8paren (#f) bytevector prefix, i.e., #vu8(\n\n" "\nThe set of token types is likely to change in future releases of the\nsystem; check the release notes for details on such changes.\n" "\nSpecifying sfd and bfp improves the quality of error messages,\nguarantees start and end can be determined,\nand eliminates the overhead of asking for a file position on each call\nto read-token.\nIn most cases, bfp should be 0 for the first call\nto read-token at the start of a file,\nand it should be the fourth return value (end) of the preceding\ncall to read-token for each subsequent\ncall.\nThis protocol is necessary to handle files containing multiple-byte\ncharacters, since file positions do not necessarily correspond\nto character positions.\n" "\n" "(define s (open-input-string \"(a b c)\"))\n(read-token s) --> lparen\n                   #f\n                   0\n                   1\n(define s (open-input-string \"abc 123\"))\n(read-token s) --> atomic\n                   abc\n                   0\n                   3\n(define s (open-input-string \"\"))\n(read-token s) --> eof\n                   #!eof\n                   0\n                   0\n(define s (open-input-string \"#7=#7#\"))\n(read-token s) --> mark\n                   7\n                   0\n                   3\n(read-token s) --> insert\n                   7\n                   3\n                   6\n" "The information read-token returns is not always\nsufficient for reconstituting the exact sequence of characters that\nmake up a token.\nFor example, 1.0 and 1e0 both return\ntype atomic with value 1.0.\nThe exact sequence of characters may be obtained only by repositioning\nthe port and reading a block of characters of the appropriate length,\nusing the relative positions given by start and end.\n\n") ("io:s71" "\nglobal parameter: console-output-port\nlibraries: (chezscheme)\n" "console-output-port is a parameter that determines the\noutput port used by the waiter and interactive debugger.\nWhen called with no arguments, it returns the\nconsole output port.\nWhen called with one argument, which must be a textual output port,\nit changes the value of the console\noutput port.\nThe initial value of this parameter is a port tied to the standard\noutput (stdout) stream of the Scheme process.\n\n") ("io:s72" "\nthread parameter: current-output-port\nlibraries: (chezscheme)\n" "current-output-port is a parameter that determines the\ndefault port argument for most output procedures,\nincluding write-char, newline, write,\ndisplay, and pretty-print.\nWhen called with no arguments, current-output-port returns the\ncurrent output port.\nWhen called with one argument, which must be a textual output port,\nit changes the value of the current\noutput port.\nThe Revised6 Report version of current-output-port accepts\nonly zero arguments, i.e., it cannot be used to change the current output\nport.\nThe initial value of this parameter is the same port as the initial\nvalue of console-output-port.\n\n") ("io:s73" "\nthread parameter: console-error-port\nlibraries: (chezscheme)\n" "console-error-port is a parameter that can be used to set\nor obtain the console error port, which determines the port to which\nconditions and other messages are printed by the default exception\nhandler.\nWhen called with no arguments, console-error-port returns the\nconsole error port.\nWhen called with one argument, which must be a textual output port,\nit changes the value of the console\nerror port.\n" "\nIf the system determines that the standard output (stdout) and standard\nerror (stderr) streams refer to the same file, socket, pipe, virtual\nterminal, device, etc., this parameter is initially set to the same value\nas the parameter console-output-port.\nOtherwise, this parameter is initially set to a different port tied to the\nstandard error (stderr) stream of the Scheme process.\n") ("io:s74" "\nthread parameter: current-error-port\nlibraries: (chezscheme)\n" "current-error-port is a parameter that can be used to set\nor obtain the current error port.\nWhen called with no arguments, current-error-port returns the\ncurrent error port.\nWhen called with one argument, which must be a textual output port,\nit changes the value of the current error port.\nThe Revised6 Report version of current-error-port accepts\nonly zero arguments, i.e., it cannot be used to change the current error\nport.\nThe initial value of this parameter is the same port as the initial\nvalue of console-error-port.\n") ("io:s75" "\nprocedure: (open-output-file path)\nprocedure: (open-output-file path options)\nreturns: a new output port\nlibraries: (chezscheme)\n" "path must be a string.\nopen-output-file opens a textual output port for the file named by\npath.\n" "\noptions, if present, is a symbolic option name or option list.\nPossible symbolic option names are \nerror, truncate, replace, append,\ncompressed, uncompressed, buffered,\nunbuffered, exclusive, and nonexclusive.\nAn option list is a list containing zero or more symbolic option names\nand possibly the two-element\noption mode mode.\n" "\nThe mutually exclusive error, truncate,\nreplace, and append options are used to direct what happens when\nthe file to be opened already exists.\nerror: An exception is raised with condition-type &i/o-filename.\nreplace: The existing file is deleted before the new file\nis opened.\ntruncate: The existing file is opened\nand truncated to zero length.\nappend: \nThe existing file is opened\nand the output port is positioned at the end of the file before each write\nso that output to the port is always appended to the file.\nThe default behavior is to raise an exception.\n" "\nThe mutually exclusive compressed and\nuncompressed options determine whether the output file is to\nbe compressed.\nThe compression format and level are determined by the\ncompress-format\nand\ncompress-level\nparameters.\nFiles are uncompressed by default, so the uncompressed\noption is useful only as documentation.\n" "\nThe mutually exclusive buffered and unbuffered\noptions determine whether output is buffered.\nUnbuffered output is sent immediately to the file, whereas buffered\noutput not written until the port's output buffer is filled or the\nport is flushed (via flush-output-port) or closed (via\nflush-output-port or by the storage management system when\nthe port becomes inaccessible).\nOutput is buffered by default for efficiency, so the\nbuffered option is useful only as documentation.\n" "\nThe mutually exclusive exclusive and nonexclusive\noptions determine whether access to the file is \"exclusive.\"\nWhen the exclusive option is specified, the file is locked until\nthe port is closed to prevent access by other processes.\nOn some systems the lock is advisory, i.e., it inhibits access by \nother processes only if they also attempt to open exclusively.\nNonexclusive access is the default, so the nonexclusive option\nis useful only as documentation.\n" "\nThe mode option determines the permission bits\non Unix systems when the file is created by the operation, subject\nto the process umask.\nThe subsequent element in the options list must be an exact integer\nspecifying the permissions in the manner of the Unix open\nfunction.\nThe mode option is ignored under Windows.\n" "\nFor example, the call\n" "\n" "(open-output-file \"frob\" '(compressed truncate mode #o644))\n" "opens the file frob with compression enabled.\nIf frob already exists it is truncated.\nOn Unix-based systems, if frob does not already exist, the permission\nbits on the newly created file are set to logical and of #o644 and the\nprocess's umask.\n" "\nThe Revised6 Report version of open-output-file does not\nsupport the optional options argument.\n") ("io:s78" "\nprocedure: (call-with-output-file path procedure)\nprocedure: (call-with-output-file path procedure options)\nreturns: the values returned by procedure\nlibraries: (chezscheme)\n" "path must be a string.\nprocedure should accept one argument.\n" "\ncall-with-output-file creates a new output port for the file named\nby path, as if with open-output-file, and passes this port to procedure.\nIf procedure returns, call-with-output-file closes the output port\nand returns the values returned by procedure.\n" "\ncall-with-output-file does not automatically close the output\nport if a continuation created outside of procedure is invoked, since it\nis possible that another continuation created inside of procedure will be\ninvoked at a later time, returning control to procedure.\nIf procedure does not return, an implementation is free to close the\noutput port only if it can prove that the output port is no longer accessible.\nAs shown in Section http://scheme.com/tspl4/./control.html#g1025.6 of The Scheme Programming Language, 4th Edition, dynamic-wind may be used to\nensure that the port is closed if a continuation created outside of\nprocedure is invoked.\n" "\nSee open-output-file above for a description of the optional\noptions argument.\n" "\nThe Revised6 Report version of call-with-output-file does not\nsupport the optional options argument.\n\n") ("io:s79" "\nprocedure: (with-output-to-file path thunk)\nprocedure: (with-output-to-file path thunk options)\nreturns: the value returned by thunk\nlibraries: (chezscheme)\n" "path must be a string.\nthunk must be a procedure and should accept zero arguments.\n" "\nwith-output-to-file temporarily rebinds the current output port to be the\nresult of opening the file named by path, as if with open-output-file,\nduring the application of thunk.\nIf thunk returns, the port is closed and the current output port\nis restored to its old value.\n" "\nThe behavior of with-output-to-file is unspecified if a\ncontinuation created outside of thunk is invoked before\nthunk returns.\nAn implementation may close the port and restore the current output\nport to its old value---but it may not.\n" "\nSee open-output-file above for a description of the optional\noptions argument.\n" "\nThe Revised6 Report version of with-output-to-file does not\nsupport the optional options argument.\n") ("io:s80" "\nprocedure: (open-fd-output-port fd)\nprocedure: (open-fd-output-port fd b-mode)\nprocedure: (open-fd-output-port fd b-mode ?transcoder)\nreturns: a new output port for the file descriptor fd\nlibraries: (chezscheme)\n" "fd must be a nonnegative exact integer and should be a valid\nopen file descriptor.\nIf ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure returns a textual output port\nwhose transcoder is ?transcoder.\nOtherwise, this procedure returns a binary output port.\nSee the lead-in to Section http://scheme.com/tspl4/./io.html#g1237.2 of The Scheme Programming Language, 4th Edition\nfor a description of the constraints on and effects of the other\narguments.\n" "\nThe file descriptor is closed when the port is closed.\n") ("io:s81" "\nprocedure: (standard-output-port)\nprocedure: (standard-output-port b-mode)\nprocedure: (standard-output-port b-mode ?transcoder)\nreturns: a new output port connected to the process's standard output\nlibraries: (chezscheme)\n" "If ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure returns a textual output port\nwhose transcoder is ?transcoder.\nOtherwise, this procedure returns a binary output port.\nThe buffer mode b-mode defaults to line, which differs from\nblock in Chez Scheme only for textual output ports.\n" "\nThe Revised6 Report version of this procedure does not accept the\noptional b-mode and ?transcoder arguments, which limits\nit to an implementation-dependent buffering mode (line in\nChez Scheme) and binary output.\n\n") ("io:s82" "\nprocedure: (standard-error-port)\nprocedure: (standard-error-port b-mode)\nprocedure: (standard-error-port b-mode ?transcoder)\nreturns: a new output port connected to the process's standard error\nlibraries: (chezscheme)\n" "If ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure returns a textual output port\nwhose transcoder is ?transcoder.\nOtherwise, this procedure returns a binary output port.\nThe buffer mode b-mode defaults to none.\nSee the lead-in to Section http://scheme.com/tspl4/./io.html#g1237.2 of The Scheme Programming Language, 4th Edition\nfor a description of the constraints on and effects of the other\narguments.\n" "\nThe Revised6 Report version of this procedure does not accept the\noptional b-mode and ?transcoder arguments, which limits\nit to an implementation-dependent buffering mode (none in\nChez Scheme) and binary output.\n\n") ("io:s83" "\nprocedure: (put-bytevector-some binary-output-port bytevector)\nprocedure: (put-bytevector-some binary-output-port bytevector start)\nprocedure: (put-bytevector-some binary-output-port bytevector start n)\nreturns: the number of bytes written\nlibraries: (chezscheme)\n" "start and n must be nonnegative exact integers, and the sum of\nstart and n must not exceed the length of bytevector.\nIf not supplied, start defaults to zero and n defaults to\nthe difference between the length of bytevector and start.\n" "\nThis procedure normally writes the n bytes of bytevector\nstarting at start to the port and advances the its position past the\nend of the bytes written.\nIf the port is in nonblocking mode (see set-port-nonblocking!),\nhowever, the number of bytes written may be less than n, if\nthe system would have to block to write more bytes.\n\n") ("io:s84" "\nprocedure: (put-string-some textual-output-port string)\nprocedure: (put-string-some textual-output-port string start)\nprocedure: (put-string-some textual-output-port string start n)\nreturns: the number of characters written\nlibraries: (chezscheme)\n" "start and n must be nonnegative exact integers, and the sum of\nstart and n must not exceed the length of string.\nIf not supplied, start defaults to zero and n defaults to\nthe difference between the length of string and start.\n" "\nThis procedure normally writes the n characters of string\nstarting at start to the port and advances the its position past the\nend of the characters written.\nIf the port is in nonblocking mode (see set-port-nonblocking!),\nhowever, the number of characters written may be less than n, if\nthe system would have to block to write more characters.\n\n") ("io:s85" "\nprocedure: (display-string string)\nprocedure: (display-string string textual-output-port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "display-string writes the characters contained within\nstring to textual-output-port or to the current-output port \nif textual-output-port is not specified.\nThe enclosing string quotes are not printed, and special characters\nwithin the string are not escaped.\ndisplay-string is a more efficient alternative to\ndisplay for displaying strings.\n") ("io:s86" "\nprocedure: (block-write textual-output-port string)\nprocedure: (block-write textual-output-port string count)\nreturns: unspecified\nlibraries: (chezscheme)\n" "count must be a nonnegative fixnum less than or equal to the\nlength of string.\nIf not provided, it defaults to the length of string.\n" "\nblock-write writes the first count characters of string\nto textual-output-port.\nIf the port is buffered and the buffer is nonempty, the\nbuffer is flushed before the contents of string are written.\nIn any case, the contents of string are written immediately,\nwithout passing through the buffer.\n") ("io:s87" "\nprocedure: (truncate-port output-port)\nprocedure: (truncate-port output-port pos)\nprocedure: (truncate-file output-port)\nprocedure: (truncate-file output-port pos)\nreturns: unspecified\nlibraries: (chezscheme)\n" "truncate-port and truncate-file are identical.\n" "\npos must be an exact nonnegative integer.  It defaults to 0.\n" "\nThese procedures truncate the file or other object associated with\noutput-port to pos and repositions the port\nto that position, i.e., it combines the functionality of\nset-port-length! and set-port-position! and\ncan be called on a port only if port-has-set-port-length!? and\nport-has-set-port-position!? are both true of the port.\n\n") ("io:s88" "\ndesc:fresh-line\nprocedure: (fresh-line)\nprocedure: (fresh-line textual-output-port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "If textual-output-port is not supplied, it defaults to the current output port.\n" "\nThis procedure behaves like newline, i.e., sends a newline\ncharacter to textual-output-port, unless it can determine that the port\nis already positioned at the start of a line.\nIt does this by flushing the port and consulting the\n\"beginning-of-line\" (BOL) flag associated with the port.\n(See page 222.)\n\n") ("io:s89" "\nprocedure: (open-input-output-file path)\nprocedure: (open-input-output-file path options)\nreturns: a new input-output port\nlibraries: (chezscheme)\n" "path must be a string.\nopen-input-output-file opens a textual input-output port for the file named by\npath.\n" "\nThe port may be used to read from or write to the named file.\nThe file is created if it does not already exist.\n" "\noptions, if present, is a symbolic option name or option list.\nPossible symbolic option names are \nbuffered,\nunbuffered, exclusive, and nonexclusive.\nAn option list is a list containing zero or more symbolic option names\nand possibly the two-element\noption mode mode.\nSee the description of open-output-file for an explanation\nof these options.\n" "\nInput/output files are usually closed using close-port\nbut may also be closed with either\nclose-input-port or\nclose-output-port.\n") ("io:s90" "\nprocedure: (open-fd-input/output-port fd)\nprocedure: (open-fd-input/output-port fd b-mode)\nprocedure: (open-fd-input/output-port fd b-mode ?transcoder)\nreturns: a new input/output port for the file descriptor fd\nlibraries: (chezscheme)\n" "fd must be a nonnegative exact integer and should be a valid\nopen file descriptor.\nIf ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure returns a textual input/output port\nwhose transcoder is ?transcoder.\nOtherwise, this procedure returns a binary input/output port.\nSee the lead-in to Section http://scheme.com/tspl4/./io.html#g1237.2 of The Scheme Programming Language, 4th Edition\nfor a description of the constraints on and effects of the other\narguments.\n" "\nThe file descriptor is closed when the port is closed.\n\n") ("io:s92" "\nprocedure: (multibyte->string code-page bytevector)\nreturns: a string containing the characters encoded in bytevector\nprocedure: (string->multibyte code-page string)\nreturns: a bytevector containing the encodings of the characters in string\nlibraries: (chezscheme)\n" "These procedures are available only under Windows.\nThe procedure multibyte->string is a wrapper for the Windows API\nMultiByteToWideChar function,\nand string->multibyte is a wrapper for the Windows API\nWideCharToMultiByte function.\n" "\ncode-page declares the encoding of the byte sequences in the input\nor output bytevectors.\nIt must be an exact nonnegative integer identifying a code page or one of\nthe symbols cp-acp, cp-maccp, cp-oemcp,\ncp-symbol, cp-thread-acp, cp-utf7, or\ncp-utf8, which have the same meanings as the API function\nmeanings for the like-named constants.\n") ("io:s93" "\nprocedure: (pretty-print obj)\nprocedure: (pretty-print obj textual-output-port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "If textual-output-port is not supplied, it defaults to the current output port.\n" "\npretty-print is similar to write except that it uses\nany number of spaces and newlines in order to print obj in a\nstyle that is pleasing to look at and which shows the nesting level via\nindentation.\nFor example,\n" "\n" "(pretty-print '(define factorial (lambda (n) (let fact ((i n) (a 1))\n  (if (= i 0) a (fact (- i 1) (* a i)))))))\n" "might produce\n" "\n" "(define factorial\n  (lambda (n)\n    (let fact ([i n] [a 1])\n      (if (= i 0) a (fact (- i 1) (* a i))))))\n") ("io:s94" "\nprocedure: (pretty-file ifn ofn)\nreturns: unspecified\nlibraries: (chezscheme)\n" "ifn and ofn must be strings.\npretty-file reads each object in turn from the file named by\nifn and pretty prints the object to the file named by ofn.\nComments present in the input are discarded by the reader and so do\nnot appear in the output file.\nIf the file named by ofn already exists, it is replaced.\n") ("io:s95" "\nprocedure: (pretty-format sym)\nreturns: see below\nprocedure: (pretty-format sym fmt)\nreturns: unspecified\nlibraries: (chezscheme)\n" "By default, the pretty printer uses a generic algorithm for printing\neach form.\nThis procedure is used to override this default and guide the\npretty-printers treatment of specific forms.\nThe symbol sym names a syntactic form or procedure.\nWith just one argument, pretty-format returns the current\nformat associated with sym, or #f if no format is\nassociated with sym.\n" "\nIn the two-argument case, the format fmt is associated with\nsym for future invocations of the pretty printer.\nfmt must be in the formatting language described below.\n" "\n  \n  \n  \n<fmt>centermath/csug/2.gif(quote symbol)\n  center|var\n  center|symbol\n  center|(read-macro string symbol)\n  center|(meta)\n  center|(bracket . fmt-tail)\n  center|(alt fmt fmt*)\n  center|fmt-tail\nfmt-tailcentermath/csug/2.gif()\n  center|(tab fmt ...)\n  center|(fmt tab ...)\n  center|(tab fmt . fmt-tail)\n  center|(fmt ...)\n  center|(fmt . fmt-tail)\n  center|(fill tab fmt ...)\ntabcentermath/csug/2.gifint\n  center|#f\n\n" "\nSome of the format forms are used for matching when there are multiple\nalternatives, while others are used for matching and control indentation\nor printing.\nA description of each fmt is given below.\n" "\n(quote symbol):\nThis matches only the symbol symbol.\n" "\nvar:\nThis matches any symbol.\n" "\nsymbol:\nThis matches any input.\n" "\n(read-macro string symbol):\nThis is used for read macros like quote and syntax.\nIt matches any input of the form (symbol subform).\nFor forms that match, the pretty printer prints\nstring immediately followed by subform.\n" "\n(meta):\nThis is a special case used for the meta keyword\n(Section 11.8) which is used as a keyword prefix of\nanother form.\n" "\n(alt fmt fmt*):\nThis compares the input against the specified formats and uses the\none that is the closest match.\nMost often, one of the formats will match exactly, but in other\ncases, as when input is malformed or appears in abstract form in the\ntemplate of a syntactic abstraction, none of the formats will match\nexactly.\n" "\n(bracket . fmt-tail):\nThis matches any list-structured input and prints the input enclosed\nin square brackets, i.e.,\n[ and ],\nrather than parentheses.\n" "\nfmt-tail:\nThis matches any list-structured input.\n\n" "\nIndentation of list-structured forms is determined via the\nfmt-tail specifier used to the last two cases above.\nA description of each fmt-tail is given below.\n" "\n():\nThis matches an empty list tail.\n" "\n(tab fmt ...):\nThis matches the tail of any proper list; if the tail is nonempty\nand the list does not fit entirely on the current line, a line break is\ninserted before the first subform of the tail and tab (see\nbelow) determines the amount by which this and all subsequent subforms\nare indented.\n" "\n(fmt tab ...):\nThis matches the tail of any proper list; if the tail is nonempty\nand the list does not fit entirely on the current line, a line break is\ninserted after the first subform of the tail and tab (see\nbelow) determines the amount by which all subsequent subforms are\nindented.\n" "\n(tab fmt . fmt-tail):\nThis matches a nonempty tail if the tail of the tail matches fmt-tail.\nIf the list does not fit entirely on the current line, a line break is\ninserted before the first subform of the tail and tab (see\nbelow) determines the amount by which the subform is indented.\n" "\n(fmt ...):\nThis matches the tail of any proper list and specified that no\nline breaks are to be inserted before or after the current or\nsubsequent subforms.\n" "\n(fmt . fmt-tail):\nThis matches a nonempty tail if the tail of the tail matches fmt-tail\nand specifies that no line break is to be inserted before or after\nthe current subform.\n" "\n(fill tab fmt ...):\nThis matches the tail of any proper list and invokes a fill mode in\nwhich the forms are packed with as many as will fit on each line.\n\n" "\nA tab determines the amount by which a list subform is indented.\nIf tab is a nonnegative exact integer int, the subform\nis indented int spaces in from the character position just after\nthe opening parenthesis or bracket of the parent form.\nIf tab is #f, the standard indentation is used.\nThe standard indentation can be determined or changed via the parameter\npretty-standard-indent, which is described later in this\nsection.\n" "\nIn cases where a format is given that doesn't quite match, the pretty\nprinter tries to use the given format as far as it can.\nFor example, if a format matches a list-structured form with a specific\nnumber of subforms, but more or fewer subform are given, the pretty\nprinter will discard or replicate subform formats as necessary.\n" "\nHere is an example showing the formatting of let might be specified.\n" "\n" "(pretty-format 'let\n  '(alt (let ([bracket var x] 0 ...) #f e #f e ...)\n        (let var ([bracket var x] 0 ...) #f e #f e ...)))\n" "Since let comes in two forms, named and unnamed, two alternatives\nare specified.\nIn either case, the bracket fmt is used to enclose the\nbindings in square brackets, with all bindings after the first appearing\njust below the first (and just after the enclosing opening parenthesis),\nif they don't all fit on one line.\nEach body form is indented by the standard indentation.\n") ("io:s98" "\nthread parameter: pretty-line-length\nthread parameter: pretty-one-line-limit\nlibraries: (chezscheme)\n" "The value of each of these parameters must be a positive fixnum.\n" "\nThe parameters pretty-line-length and\npretty-one-line-limit control the output produced by\npretty-print.\npretty-line-length determines after which character position (starting\nfrom the first) on a line the pretty printer attempts to cut off output.\nThis is a soft limit only; if necessary, the pretty-printer will go beyond\npretty-line-length.\n" "\npretty-one-line-limit is similar to\npretty-line-length, except that it is relative to the first\nnonblank position on each line of output.\nIt is also a soft limit.\n\n") ("io:s100" "\nthread parameter: pretty-initial-indent\nlibraries: (chezscheme)\n" "The value of this parameter must be a nonnegative fixnum.\n" "\nThe parameter pretty-initial-indent is used to tell\npretty-print where on an output\nline it has been called.\nIf pretty-initial-indent is zero (the default), pretty-print\nassumes that the first line of output it produces will start at the\nbeginning of the line.\nIf set to a nonzero value n, pretty-print assumes that the first\nline will appear at character position n and will adjust its\nprinting of subsequent lines.\n\n") ("io:s102" "\nthread parameter: pretty-standard-indent\nlibraries: (chezscheme)\n" "The value of this parameter must be a nonnegative fixnum.\n" "\nThis determines the amount by which\npretty-print indents subexpressions of most forms, such as let\nexpressions, from the form's keyword or first subexpression.\n\n") ("io:s103" "\nthread parameter: pretty-maximum-lines\nlibraries: (chezscheme)\n" "The parameter pretty-maximum-lines controls how many lines\npretty-print prints when it is called.\nIf set to #f (the default), no limit is imposed; if set to a\nnonnegative fixnum n, at most n lines are printed.\n\n") ("io:s104" "\nprocedure: (format format-string obj ...)\nprocedure: (format #f format-string obj ...)\nprocedure: (format #t format-string obj ...)\nprocedure: (format textual-output-port format-string obj ...)\nreturns: see below\nlibraries: (chezscheme)\n" "When the first argument to format is a string or #f (first and\nsecond forms above),\nformat constructs an output string from format-string and the\nobjects obj ....\nCharacters are copied from format-string to the output string from\nleft to right, until format-string is exhausted.\nThe format string may contain one or more format directives, which are\nmulti-character sequences prefixed by a tilde ( ~ ).\nEach directive is replaced by some other text, often involving one or more\nof the obj ... arguments, as determined by the semantics\nof the directive.\n" "\nWhen the first argument is #t, output is sent to the current output\nport instead, as with printf.\nWhen the first argument is a port, output is sent to that port, as with\nfprintf.\nprintf and fprintf are described later in this section.\n" "\nChez Scheme's implementation of format supports all of the\nCommon Lisp [citation30] format directives except for those specific\nto the Common Lisp pretty printer.\nPlease consult a Common Lisp reference or the\nhttp://www.lispworks.com/documentation/HyperSpec/Front/index.htmCommon Lisp Hyperspec,\nfor complete documentation.\nA few of the most useful directives are described below.\n\n" "\nAbsent any format directives, format simply displays its string\nargument.\n" "\n" "(format \"hi there\") --> \"hi there\"\n" "The ~s directive is replaced by the printed representation of\nthe next obj, which may be any object, in machine-readable format,\nas with write.\n" "\n" "(format \"hi ~s\" 'mom) --> \"hi mom\"\n(format \"hi ~s\" \"mom\") --> \"hi \\\"mom\\\"\"\n(format \"hi ~s~s\" 'mom #\\!) --> \"hi mom#\\\\!\"\n" "The general form of a ~s directive is actually\n~mincol,colinc,minpad,padchars,\nand the s can be preceded by an at sign ( @ )\nmodifier.\nThese additional parameters are used to control padding in the\noutput, with at least minpad copies of padchar\nplus an integer multiple of colinc copies of padchar\nto make the total width, including the written object,\nmincol characters wide.\nThe padding is placed on the left if the @ modifier is\npresent, otherwise on the right.\nmincol and minpad default to 0, colinc defaults\nto 1, and padchar defaults to space.\nIf specified, padchar is prefixed by a single quote mark.\n" "\n" "(format \"~10s\" 'hello) --> \"hello     \"\n(format \"~10@s\" 'hello) --> \"     hello\"\n(format \"~10,,,'*@s\" 'hello) --> \"*****hello\"\n" "The ~a directive is similar, but prints the object as with\ndisplay.\n" "\n" "(format \"hi ~s~s\" \"mom\" #\\!) --> \"hi \\\"mom\\\"#\\\\!\"\n(format \"hi ~a~a\" \"mom\" #\\!) --> \"hi mom!\"\n" "A tilde may be inserted into the output with ~~, and a newline\nmay be inserted with ~% (or embedded in the string with\n\\n).\n" "\n" "(format \"~~line one,~%line two.~~\") --> \"~line one,\\nline two.~\"\n(format \"~~line one,\\nline two.~~\") --> \"~line one,\\nline two.~\"\n" "Real numbers may be printed in floating-point notation with ~f.\n" "\n" "(format \"~f\" 3.14159) --> 3.14159\n" "Exact numbers may printed as well as inexact numbers in this manner; they\nare simply converted to inexact first as if with exact->inexact.\n" "\n" "(format \"~f\" 1/3) --> \"0.3333333333333333\"\n" "The general form is actually ~w,d,k,overflowchar,padcharf.\nIf specified, w determines the overall width of the output,\nand d the number of digits to the right of the decimal point.\npadchar, which defaults to space, is the pad character used\nif padding is needed.\nPadding is always inserted on the left.\nThe number is scaled by 10k when printed; k defaults to zero.\nThe entire w-character field is filled with copies of\noverflowchar if overflowchar is specified and the number\ncannot be printed in w characters.\nk defaults to 1\nIf an @ modifier is present, a plus sign is printed before the\nnumber for nonnegative inputs; otherwise, a sign is printed only if the\nnumber is negative.\n" "\n" "(format \"~,3f\" 3.14159) --> \"3.142\"\n(format \"~10f\" 3.14159) --> \"   3.14159\"\n(format \"~10,,,'#f\" 1e20) --> \"##########\"\n" "Real numbers may also be printed with ~e for scientific\nnotation or with ~g, which uses either floating-point or\nscientific notation based on the size of the input.\n" "\n" "(format \"~e\" 1e23) --> \"1.0e+23\"\n(format \"~g\" 1e23) --> \"1.0e+23\"\n" "A real number may also be printed with ~$, which uses\nmonetary notation defaulting to two digits to the right of the\ndecimal point.\n" "\n" "(format \"$~$\" (* 39.95 1.06)) --> \"$42.35\"\n(format \"~$USD\" 1/3) --> \"0.33USD\"\n" "Words can be pluralized automatically using p.\n" "(format \"~s bear~:p in ~s den~:p\" 10 1) --> \"10 bears in 1 den\"\n" "Numbers may be printed out in words or roman numerals using variations\non ~r.\n" "\n" "(format \"~r\" 2599) -->  \"two thousand five hundred ninety-nine\"\n(format \"~:r\" 99) -->  \"ninety-ninth\"\n(format \"~@r\" 2599) --> \"MMDXCIX\"\n" "Case conversions can be performed by bracketing a portion of the\nformat string with the ~@( and ~) directives.\n" "\n" "(format \"~@(~r~)\" 2599) -->  \"Two thousand five hundred ninety-nine\"\n(format \"~@:(~a~)\" \"Ouch!\") -->  \"OUCH!\"\n" "Some of the directives shown above have more options and parameters, and \nthere are other directives as well, including directives for conditionals,\niteration, indirection, and justification.\nAgain, please consult a Common Lisp reference for complete documentation.\n" "\nAn implementation of a greatly simplified version of format\nappears in Section http://scheme.com/tspl4/./examples.html#g18012.6 of The Scheme Programming Language, 4th Edition.\n\n") ("io:s106" "\nprocedure: (printf format-string obj ...)\nprocedure: (fprintf textual-output-port format-string obj ...)\nreturns: unspecified\nlibraries: (chezscheme)\n" "These procedures are simple wrappers for format.\nprintf prints the formatted output to the current output,\nas with a first-argument of #t to format, and\nfprintf prints the formatted output to the textual-output-port,\nas when the first argument to format is a port.\n") ("io:s107" "\ndesc:char-name\nprocedure: (char-name obj)\nreturns: see below\nprocedure: (char-name name char)\nreturns: unspecified\nlibraries: (chezscheme)\n" "char-name is used to associate names (symbols) with characters\nor to retrieve the most recently associated name or character for a \ngiven character or name.\nA name can map to only one character, but more than one name\ncan map to the same character.\nThe name most recently associated with a character determines\nhow that character prints, and each name associated with a character\nmay be used after the #\\ character prefix to name that\ncharacter on input.\n" "\nCharacter associations created by char-name are ignored by the\nprinter unless the parameter print-char-name is set to a true\nvalue.\nThe reader recognizes character names established by char-name\nexcept after #!r6rs, which is implied within a library or\nR6RS top-level program.\n" "\nIn the one-argument form, obj must be a symbol or character.\nIf it is a symbol and a character is associated with the\nsymbol, char-name returns that character.\nIf it is a symbol and no character is associated with the symbol,\nchar-name returns #f.\nSimilarly, if obj is a character, char-name returns the\nmost recently associated symbol for the character or #f if\nno name is associated with the character.\nFor example, with the default set of character names:\n" "\n" "(char-name #\\space) --> space\n(char-name 'space) --> #\\space\n(char-name 'nochar) --> #f\n(char-name #\\a) --> #f\n" "When passed two arguments, name is added to the set of names\nassociated with char, and any other association for name\nis dropped.\nchar may be #f, in which case any other association\nfor name is dropped and no new association is formed.\nIn either case, any other names associated with char remain\nassociated with char.\n" "\nThe following interactive session demonstrates the use of\nchar-name to establish and remove associations between\ncharacters and names, including the association of more than\none name with a character.\n" "\n" "(print-char-name #t)\n(char-name 'etx) --> #f\n(char-name 'etx #\\x3)\n(char-name 'etx) --> #\\etx\n(char-name #\\x3) --> etx\n#\\etx --> #\\etx\n(eq? #\\etx #\\x3) --> #t\n#!r6rs #\\etx --> exception: invalid character name etx\n#!chezscheme #\\etx --> #\\etx\n(char-name 'etx #\\space)\n(char-name #\\x3) --> #f\n(char-name 'etx) --> #\\etx\n#\\space --> #\\etx\n(char-name 'etx #f)\n#\\etx --> exception: invalid character name etx\n#\\space --> #\\space\n" "(When using the expression editor, it is necessary to type Control-J to\nforce the editor to read the erroneous #\\etx input on the two\ninputs above that result in read errors, since typing Enter\ncauses the expression editor to read the input only if the input is\nwell-formed.)\n" "\nThe reader does not recognize hex scalar value escapes in character names,\nas it does in symbols, so #\\new\\x6c;ine is not equivalent\nto #\\newline.\nIn general, programmers should avoid the use of character name symbols\nthat cannot be entered without the use of hex scalar value escapes or\nother symbol-name escape mechanisms, since such character names will\nnot be readable.\n\n") ("io:s108" "\nthread parameter: print-char-name\nlibraries: (chezscheme)\n" "When print-char-name is set to #f (the default), associations\ncreated by char-name are ignored by write,\nput-datum, pretty-print, and the format\n\"~s\" directive.\nOtherwise, these procedures use the names established by\nchar-name when printing character objects.\n" "\n" "(char-name 'etx #\\x3)\n(format \"~s\" #\\x3) --> \"#\\\\x3\"\n(parameterize ([print-char-name #t])\n  (format \"~s\" #\\x3)) --> \"#\\\\etx\"\n") ("io:s109" "\nthread parameter: case-sensitive\nlibraries: (chezscheme)\n" "The case-sensitive parameter determines whether the\nreader is case-sensitive with respect to symbol and character names.\nWhen set to true (the default, as required by the Revised6 Report)\nthe case of alphabetic characters\nwithin symbol names is significant.\nWhen set to #f, case is insignificant.\nMore precisely, when set to #f, symbol and character names are\nfolded (as if by string-foldcase); otherwise, they are left\nas they appear in the input.\n" "\nThe value of the case-sensitive matters only\nif neither #!fold-case nor #!no-fold-case has appeared\npreviously in the same input stream.\nThat is, symbol and character name are folded if #!fold-case has\nbeen seen.\nThey are not folded if #!no-fold-case has been seen.\nIf neither has been seen, they are folded if and only if\n(case-sensitive) is #f.\n" "\n" "(case-sensitive) --> #t\n(eq? 'abc 'ABC) --> #f\n'ABC --> ABC\n(case-sensitive #f)\n'ABC --> abc\n(eq? 'abc 'ABC) --> #t\n") ("io:s110" "\nthread parameter: print-graph\nlibraries: (chezscheme)\n" "When print-graph is set to a true value,\nwrite and pretty-print\nlocate and print objects with shared structure, including\ncycles, in a notation that may be read subsequently with read.\nThis notation employs the syntax\n\"#n=obj,\"\nwhere n\nis a nonnegative integer and obj is the printed representation\nof an object, to label the first occurrence of obj in the output.\nThe syntax\n\"#n#\"\nis used to refer to the object labeled by\nn thereafter in the output.\nprint-graph is set to #f by default.\n" "\nIf graph printing is not enabled,\nthe settings of print-length and print-level\nare insufficient to force finite output,\nand write or pretty-print detects a cycle in an\nobject it is given to print,\na warning is issued (an exception with condition type &warning is\nraised) and the object is printed as if\nprint-graph were enabled.\n" "\nSince objects printed through the ~s option in the format control\nstrings of format, printf, and fprintf are printed as with\nwrite, the printing of such objects is also affected by print-graph.\n" "\n" "(parameterize ([print-graph #t])\n  (let ([x (list 'a 'b)])\n    (format \"~s\" (list x x)))) --> \"(#0=(a b) #0#)\"\n\n(parameterize ([print-graph #t])\n  (let ([x (list 'a 'b)])\n    (set-car! x x)\n    (set-cdr! x x)\n    (format \"~s\" x))) --> \"#0=(#0# . #0#)\"\n" "The graph syntax is understood by the procedure\nread, allowing graph structures\nto be printed and read consistently.\n\n") ("io:s114" "\nthread parameter: print-level\nthread parameter: print-length\nlibraries: (chezscheme)\n" "These parameters can be used to limit the extent to which nested\nor multiple-element structures are printed.\nWhen called without arguments, print-level returns the current\nprint level and print-length returns the current print length.\nWhen called with one argument, which must be a nonnegative fixnum or\n#f, print-level sets the current print level and\nprint-length sets the current print length to the argument.\n" "\nWhen print-level is set to a nonnegative integer n,\nwrite and pretty-print\ntraverse only n levels deep into nested structures.\nIf a structure being printed exceeds n levels of nesting,\nthe substructure beyond that point is replaced in the output by an\nellipsis\n( ... ).\nprint-level is set to #f by default, which places\nno limit on the number of levels printed.\n" "\nWhen print-length is set to a nonnegative integer n, the\nprocedures write and pretty-print\nprint only n elements of a list or vector,\nreplacing the remainder of the list or vector with an\nellipsis\n( ... ).\nprint-length is set to #f by default, which places\nno limit on the number of elements printed.\n" "\nSince objects printed through the ~s option in\nthe format control strings of format, printf, and fprintf are\nprinted as with write,\nthe printing of such objects is also affected by print-level\nand print-length.\n" "\nThe parameters print-level and print-length are useful for\ncontrolling the volume of output in contexts where only a small portion\nof the output is needed to identify the object being printed.\nThey are also useful in situations where circular structures may be\nprinted (see also print-graph).\n" "\n" "(format \"~s\" '((((a) b) c) d e f g)) --> \"((((a) b) c) d e f g)\"\n\n(parameterize ([print-level 2])\n  (format \"~s\" '((((a) b) c) d e f g))) --> \"(((...) c) d e f g)\"\n\n(parameterize ([print-length 3])\n  (format \"~s\" '((((a) b) c) d e f g))) --> \"((((a) b) c) d e ...)\"\n\n(parameterize ([print-level 2]\n               [print-length 3])\n  (format \"~s\" '((((a) b) c) d e f g))) --> \"(((...) c) d e ...)\"\n") ("io:s119" "\nthread parameter: print-radix\nlibraries: (chezscheme)\n" "The print-radix parameter determines the radix in which\nnumbers are printed by write, pretty-print, and\ndisplay.\nIts value should be an integer between 2 and 36, inclusive.\nIts default value is 10.\n" "\nWhen the value of print-radix is not 10, write and\npretty-print print a radix prefix before the number\n(#b for radix 2, #o for radix 8, #x for\nradix 16, and #nr for any other radix n).\n" "\nSince objects printed through the ~s and\n~a options in the format control strings of\nformat, printf, and fprintf are printed as\nwith write and display, the printing of such objects\nis also affected by print-radix.\n" "\n" "(format \"~s\" 11242957) --> \"11242957\"\n\n(parameterize ([print-radix 16])\n  (format \"~s\" 11242957)) --> \"#xAB8DCD\"\n\n(parameterize ([print-radix 16])\n  (format \"~a\" 11242957)) --> \"AB8DCD\"\n") ("io:s120" "\nthread parameter: print-gensym\nlibraries: (chezscheme)\n" "When\nprint-gensym is set to #t (the default)\ngensyms are printed with an\nextended symbol syntax that includes both the pretty name and the unique\nname of the gensym: \n#{pretty-name unique-name}.\nWhen set to pretty, the pretty name only is shown, with the\nprefix #:.\nWhen set to pretty/suffix,\nthe printer prints the gensym's \"pretty\" name along with a\nsuffix based on the gensym's \"unique\" name, separated by a dot ( \".\" ).\nIf the gensym's unique name is generated automatically during the current\nsession, the suffix is that portion of the unique name that is not common\nto all gensyms created during the current session.\nOtherwise, the suffix is the entire unique name.\nWhen set to #f, the pretty name only is shown, with no\nprefix.\n" "\nSince objects printed through the ~s option in the\nformat control strings of format, printf,\nerrorf, etc., are printed as with write, the printing of\nsuch objects is also affected by print-gensym.\n" "\nWhen printing an object that may contain more than one occurrence of a\ngensym and print-graph is set to pretty or #f,\nit is useful to set print-graph to #t so that\nmultiple occurrences of the same gensym are marked as identical in\nthe output.\n" "\n" "(let ([g (gensym)])\n  (format \"~s\" g)) --> \"#{g0 bdids2xl6v49vgwe-a}\"\n\n(let ([g (gensym)])\n  (parameterize ([print-gensym 'pretty])\n    (format \"~s\" g))) --> \"#:g1\n\n(let ([g (gensym)])\n  (parameterize ([print-gensym #f])\n    (format \"~s\" g))) --> \"g2\"\n\n(let ([g (gensym)])\n  (parameterize ([print-graph #t] [print-gensym 'pretty])\n    (format \"~s\" (list g g)))) --> \"(#0=#:g3 #0#)\"\n\n(let ([g1 (gensym \"x\")]\n      [g2 (gensym \"x\")]\n      [g3 (gensym \"y\")])\n  (parameterize ([print-gensym 'pretty/suffix])\n    (format \"~s ~s ~s\" g1 g2 g3))) --> \"x.1 x.2 y.3\"\n") ("io:s125" "\nthread parameter: print-brackets\nlibraries: (chezscheme)\n" "When print-brackets is set to a true value, the pretty printer\n(see pretty-print) uses square\nbrackets rather than parentheses around certain subexpressions of\ncommon control structures, e.g., around let bindings and\ncond clauses.\nprint-brackets is set to #t by default.\n" "\n" "(let ([p (open-output-string)])\n  (pretty-print '(let ([x 3]) x) p) --> \"(let ([x 3]) x)\n  (get-output-string p))            gifs/ghostRightarrow.gif \"\n\n(parameterize ([print-brackets #f])\n  (let ([p (open-output-string)])\n    (pretty-print '(let ([x 3]) x) p) --> \"(let ((x 3)) x)\n    (get-output-string p)))           gifs/ghostRightarrow.gif \"\n") ("io:s127" "\nthread parameter: print-extended-identifiers\nlibraries: (chezscheme)\n" "Chez Scheme extends the syntax of identifiers as described in\nSection 1.1, except within a set of forms prefixed by\n#!r6rs (which is implied in a library or top-level program).\n" "\nWhen this parameter is set to false (the default), identifiers in the\nextended set are printed with hex scalar value escapes as necessary to\nconform to the R6RS syntax for identifiers.\nWhen this parameter is set to a true value, identifiers in the\nextended set are printed without the escapes.\nIdentifiers whose names fall outside of both syntaxes are printed with\nthe escapes regardless of the setting of this parameter.\n" "\nFor example:\n" "\n" "(parameterize ([print-extended-identifiers #f])\n  (printf \"~s\\n~s\\n\"\n    '(1+ --- { } .xyz)\n    (string->symbol \"123\")))\n" "prints\n" "\n" "(\\x31;+ \\x2D;-- \\x7B; \\x7D; \\x2E;xyz)\n\\x31;23\n" "while\n" "\n" "(parameterize ([print-extended-identifiers #t])\n  (printf \"~s\\n~s\\n\"\n    '(1+ --- { } .xyz)\n    (string->symbol \"123\")))\n" "prints\n" "\n" "(1+ --- { } .xyz)\n\\x31;23\n") ("io:s128" "\nthread parameter: print-vector-length\nlibraries: (chezscheme)\n" "When print-vector-length is set to a true value,\nwrite, put-datum, and pretty-print includes the length\nfor all vectors between the \"#\" and open parenthesis,\nall bytevectors between the \"#vu8\" and open parenthesis,\nand all fxvectors between the \"#vfx\" and open parenthesis.\nThis parameter is set to #f by default.\n" "\nWhen print-vector-length is set to a\ntrue value, write, put-datum, and pretty-print\nalso suppress duplicated trailing elements in the vector to\nreduce the amount of output.\nThis form is also recognized by the reader.\n" "\nSince objects printed through the ~s option in the\nformat control strings of format, printf, and\nfprintf are printed as with write, the printing of\nsuch objects is also affected by the setting of\nprint-vector-length.\n" "\n" "(format \"~s\" (vector 'a 'b 'c 'c 'c)) --> \"#(a b c c c)\"\n\n(parameterize ([print-vector-length #t])\n  (format \"~s\" (vector 'a 'b 'c 'c 'c))) --> \"#5(a b c)\"\n\n(parameterize ([print-vector-length #t])\n  (format \"~s\" (bytevector 1 2 3 4 4 4))) --> \"#6vu8(1 2 3 4)\"\n\n(parameterize ([print-vector-length #t])\n  (format \"~s\" (fxvector 1 2 3 4 4 4))) --> \"#6vfx(1 2 3 4)\"\n") ("io:s130" "\nthread parameter: print-precision\nlibraries: (chezscheme)\n" "When print-precision is set to #f (the default),\nwrite, put-datum, pretty-print, and the\nformat \"~s\" directive do not include the\nvertical-bar \"mantissa-width\" syntax after each floating-point\nnumber.\nWhen set to a nonnegative exact integer, the mantissa width is\nincluded, as per the precision argument to\nnumber->string.\n") ("io:s131" "\nthread parameter: print-unicode\nlibraries: (chezscheme)\n" "When print-unicode is set to #f,\nwrite, put-datum, pretty-print, and the\nformat \"~s\" directive display Unicode characters\nwith encodings 8016 (128) and above that appear \nwithin character objects, symbols, and strings\nusing hexadecimal character escapes.\nWhen set to a true value (the default), they are displayed like\nother printing characters, as if by put-char.\n" "\n" "(format \"~s\" #\\x3bb) --> \"#\\\\math/csug/3.gif\"\n(parameterize ([print-unicode #f])\n  (format \"~s\" #\\x3bb)) --> \"#\\\\x3BB\"\n") ("io:s133" "\nprocedure: (fasl-write obj binary-output-port)\nreturns: unspecified\nlibraries: (chezscheme)\n" "fasl-write writes the fasl representation of obj to\nbinary-output-port.\nAn exception is raised with condition-type &assertion if\nobj or any portion of obj has no external fasl representation,\ne.g., if obj is or contains a procedure.\n" "\nThe fasl representation of obj is compressed if the parameter\nfasl-compressed, described below, is set to #t,\nits default value.\nFor this reason, binary-output-port generally should not be opened\nwith the compressed option.\nA warning is issued (an exception with condition type &warning\nis raised) on the first attempt to write fasl objects to or read\nfasl objects from a compressed file.\n" "\n" "(define bop (open-file-output-port \"tmp.fsl\"))\n(fasl-write '(a b c) bop)\n(close-port bop)\n\n(define bip (open-file-input-port \"tmp.fsl\"))\n(fasl-read bip) --> (a b c)\n(fasl-read bip) --> #!eof\n(close-port bip)\n") ("io:s134" "\nprocedure: (fasl-read binary-input-port)\nprocedure: (fasl-read binary-input-port situation)\nreturns: unspecified\nlibraries: (chezscheme)\n" "If present, situation must be one of the symbols load,\nvisit, or revisit.\nIt defaults to load.\n" "\nfasl-read reads one object from\nbinary-input-port, which must be positioned at the\nfront of an object written in fasl format.\nfasl-read returns the eof object if the file is positioned\nat the end of file.\nIf the situation is visit, fasl-read skips over \nany revisit (run-time-only) objects, and\nif the situation is revisit, fasl-read skips over \nany visit (compile-time-only) objects.\nIt doesn't skip any if the situation is load.\nSimilarly, objects marked as both visit and revisit (e.g., object code\ncorresponding to source code within an eval-when form with\nsituation load or situations visit and revisit)\nare never skipped.\n" "\nfasl-read automatically decompresses the representation\nof each fasl object written in compressed format by fasl-write.\nThus, binary-input-port generally should not be opened with\nthe compressed option.\nA warning is issued (an exception with condition type &warning\nis raised) on the first attempt to write fasl objects to or read\nfasl objects from a compressed file.\n" "\n" "(define bop (open-file-output-port \"tmp.fsl\"))\n(fasl-write '(a b c) bop)\n(close-port bop)\n\n(define bip (open-file-input-port \"tmp.fsl\"))\n(fasl-read bip) --> (a b c)\n(fasl-read bip) --> #!eof\n(close-port bip)\n") ("io:s135" "\nthread parameter: fasl-compressed\nlibraries: (chezscheme)\n" "When this parameter is set to its default value, #t,\nfasl-write compresses the representation of each object\nas it writes it, often resulting in substantially smaller output\nbut possibly taking more time to write and read.\nThe compression format and level are determined by the\ncompress-format\nand\ncompress-level\nparameters.\n\n") ("io:s138" "\nprocedure: (fasl-file ifn ofn)\nreturns: unspecified\nlibraries: (chezscheme)\n" "ifn and ofn must be strings.\nfasl-file may be used to convert a file in human-readable\nformat into an equivalent\nfile written in fasl format.\nfasl-file reads each object in turn from the file named by\nifn and writes the fasl format for the object onto the file\nnamed by ofn.\nIf the file named by ofn already exists, it is replaced.\n\n") ("io:s139" "\nglobal parameter: current-directory\nglobal parameter: cd\nlibraries: (chezscheme)\n" "When invoked without arguments, current-directory returns a string\nrepresenting the current working directory.\nOtherwise, the current working directory is changed to the directory\nspecified by the argument, which must be a string representing a valid\ndirectory pathname.\n" "\ncd is bound to the same parameter.\n") ("io:s140" "\nprocedure: (directory-list path)\nreturns: a list of file names\nlibraries: (chezscheme)\n" "path must be a string.\nThe return value is a list of strings representing the names of\nfiles found in the directory named by path.\ndirectory-list raises an exception with condition\ntype &i/o-filename if path does not name a directory\nor if the process cannot list the directory.\n") ("io:s141" "\nprocedure: (file-exists? path)\nprocedure: (file-exists? path follow?)\nreturns: #t if the file named by path exists, #f otherwise\nlibraries: (chezscheme)\n" "path must be a string.\nIf the optional follow? argument is true (the default),\nfile-exists? follows symbolic links; otherwise it does not.\nThus, file-exists? will return #f when handed the\npathname of a broken symbolic link unless follow? is provided\nand is #f.\n" "\nThe Revised6 Report file-exists? does not accept the\noptional follow? argument.\nWhether it follows symbolic links is unspecified.\n") ("io:s142" "\nprocedure: (file-regular? path)\nprocedure: (file-regular? path follow?)\nreturns: #t if the file named by path is a regular file, #f otherwise\nlibraries: (chezscheme)\n" "path must be a string.\nIf the optional follow? argument is true (the default),\nfile-regular? follows symbolic links; otherwise it does not.\n") ("io:s143" "\nprocedure: (file-directory? path)\nprocedure: (file-directory? path follow?)\nreturns: #t if the file named by path is a directory, #f otherwise\nlibraries: (chezscheme)\n" "path must be a string.\nIf the optional follow? argument is true (the default),\nthis procedure follows symbolic links; otherwise it does not.\n") ("io:s144" "\nprocedure: (file-symbolic-link? path)\nreturns: #t if the file named by path is a symbolic link, #f otherwise\nlibraries: (chezscheme)\n" "path must be a string.\nfile-symbolic-link? never follows symbolic links in making its\ndetermination.\n") ("io:s145" "\nprocedure: (file-access-time path/port)\nprocedure: (file-access-time path/port follow?)\nreturns: the access time of the specified file\nprocedure: (file-change-time path/port)\nprocedure: (file-change-time path/port follow?)\nreturns: the change time of the specified file\nprocedure: (file-modification-time path/port)\nprocedure: (file-modification-time path/port follow?)\nreturns: the modification time of the specified file\nlibraries: (chezscheme)\n" "path/port must be a string or port.\nIf path/port is a string, the time returned is for the file named\nby the string, and the optional follow? argument determines whether\nsymbolic links are followed.\nIf follow? is true (the default),\nthis procedure follows symbolic links; otherwise it does not.\nIf path/port is a port, it must be a file port, and the time returned\nis for the associated file.\nIn this case, follow? is ignored.\n" "\nThe returned times are represented as time objects\n(Section 12.10).\n\n") ("io:s146" "\nprocedure: (mkdir path)\nprocedure: (mkdir path mode)\nreturns: unspecified\nlibraries: (chezscheme)\n" "path must be a string.\nmode must be a fixnum.\n" "\nmkdir creates a directory with the name given by path.\nAll path path components leading up to the last must already\nexist.\nIf the optional mode argument is present, it overrides the default\npermissions for the new directory.\nUnder Windows, the mode argument is ignored.\n" "\nmkdir raises an exception with condition\ntype &i/o-filename if the directory cannot be created.\n\n") ("io:s147" "\nprocedure: (delete-file path)\nprocedure: (delete-file path error?)\nreturns: see below\nlibraries: (chezscheme)\n" "path must be a string.\ndelete-file removes the file named by path.\nIf the optional error? argument is #f (the default),\ndelete-file returns a boolean value: #t if the\noperation is successful and #f if it is not.\nOtherwise, delete-file returns an unspecified value if the\noperation is successful and raises an exception with condition\ntype &i/o-filename if it is not.\n" "\nThe Revised6 Report delete-file does not accept the\noptional error? argument but behaves as if error?\nis true.\n") ("io:s148" "\nprocedure: (delete-directory path)\nprocedure: (delete-directory path error?)\nreturns: see below\nlibraries: (chezscheme)\n" "path must be a string.\ndelete-directory removes the directory named by path.\nIf the optional error? argument is #f (the default),\ndelete-directory returns a boolean value: #t if the\noperation is successful and #f if it is not.\nOtherwise, delete-directory returns an unspecified value if the\noperation is successful and raises an exception with condition\ntype &i/o-filename if it is not.\nThe behavior is unspecified if the directory is not empty, but on\nmost systems the operations will not succeed.\n") ("io:s149" "\nprocedure: (rename-file old-pathname new-pathname)\nreturns: unspecified\nlibraries: (chezscheme)\n" "old-pathname and new-pathname must be strings.\nrename-file changes the name of the file named by old-pathname\nto new-pathname.\nIf the file does not exist or cannot be renamed,\nan exception is raised with condition type &i/o-filename.\n") ("io:s150" "\nprocedure: (chmod path mode)\nreturns: unspecified\nlibraries: (chezscheme)\n" "path must be a string.\nmode must be a fixnum.\n" "\nchmod sets the permissions on the file named by\npath to mode.\nBits 0, 1, and 2 of mode are the execute, write, and read permission bits\nfor users other than the file's owner who are not in the file's group.\nBits 3-5 are the execute, write, and read permission bits for users other\nthan the file's owner but in the file's group.\nBits 6-8 are the execute, write, and read permission bits\nfor the file's owner.\nBits 7-9 are the Unix sticky, set-group-id, and set-user-id bits.\nUnder Windows, all but the user \"write\" bit are ignored.\nIf the file does not exist or the permissions cannot be changed,\nan exception is raised with condition type &i/o-filename.\n") ("io:s151" "\nprocedure: (get-mode path)\nprocedure: (get-mode path follow?)\nreturns: the current permissions mode for path\nlibraries: (chezscheme)\n" "path must be a string.\nget-mode retrieves the permissions on the file named by\npath and returns them as a fixnum in the same form as the mode\nargument to chmod.\nIf the optional follow? argument is true (the default),\nthis procedure follows symbolic links; otherwise it does not.\n\n") ("io:s152" "\nprocedure: (directory-separator? char)\nreturns: #t if char is a directory separator, #f otherwise\nlibraries: (chezscheme)\n" "The character #\\/ is a directory separator on all\ncurrent machine types, and #\\\\ is a directory separator\nunder Windows.\n") ("io:s153" "\nprocedure: (directory-separator)\nreturns: the preferred directory separator\nlibraries: (chezscheme)\n" "The preferred directory separator is #\\\\ for Windows and\n#\\/ for other systems.\n") ("io:s154" "\nprocedure: (path-first path)\nprocedure: (path-rest path)\nprocedure: (path-last path)\nprocedure: (path-parent path)\nprocedure: (path-extension path)\nprocedure: (path-root path)\nreturns: the specified component of path\nprocedure: (path-absolute? path)\nreturns: #t if path is absolute, otherwise #f\nlibraries: (chezscheme)\n" "path must be a string.\nThe return value is also a (possibly empty) string.\n" "\nThe path first component is the first directory in the path, or the\nempty string if the path consists only of a single filename.\nThe path rest component is the portion of the path that does not\ninclude the path first component or the directory separator (if\nany) that separates it from the rest of the path.\nThe path last component is the last (filename) portion of path.\nThe path parent component is the portion of path that does not\ninclude the path last component, if any, or the directory separator that\nseparates it from the rest of the path.\n" "\nIf the first component of the path names a root directory (including drives\nand shares under Windows), home directory\n(e.g., ~/abc or ~user/abc), \nthe current directory (.), or the parent directory\n(..), path-first returns that component.\nFor paths that consist only of such a directory,\nboth path-first and path-parent act as\nidentity procedures, while path-rest and path-last\nreturn the empty string.\n" "\nThe path extension component is the portion of path that follows\nthe last dot (period) in the last component of a path name.\nThe path root component is the portion of path that does not\ninclude the extension, if any, or the dot that precedes it.\n" "\nIf the first component names a root directory (including drives\nand shares under Windows) or home directory,\npath-absolute? returns #t.\nOtherwise, path-absolute? returns #f. \n" "\nThe tables below identify the components for several example paths,\nwith underscores representing empty strings.\n" "\nleft\npath               left abs         left first              left rest               left parent             left last               left root               left ext        left\na         left #f left _         left a         left _         left a         left a         left _ left\na/        left #f left a         left _         left a         left _         left a/        left _ left\na/b       left #f left a         left b         left a         left b         left a/b       left _ left\na/b.c     left #f left a         left b.c       left a         left b.c       left a/b       left c left\n/         left #t left /         left _         left /         left _         left /         left _ left\n/a/b.c    left #t left /         left a/b.c     left /a        left b.c       left /a/b      left c left\n~/a/b.c   left #t left ~         left a/b.c     left ~/a       left b.c       left ~/a/b     left c left\n~u/a/b.c  left #t left ~u        left a/b.c     left ~u/a      left b.c       left ~u/a/b    left c left\n../..     left #f left ..        left ..        left ..        left ..        left ../..     left _ left\n\n" "\nThe second table shows the components when Windows drives and shares\nare involved.\n" "\nleft\npath               left abs         left first              left rest               left parent             left last               left root               left ext       left\nc:        left #f left c:        left _         left c:        left _         left c:        left _ left\nc:/       left #t left c:/       left _         left c:/       left _         left c:/       left _ left\nc:a/b     left #f left c:        left a/b       left c:a       left b         left c:a/b     left _ left\n//s/a/b.c left #t left //s       left a/b.c     left //s/a     left b.c       left //s/a/b   left c left\n//s.com   left #t left //s.com   left _         left //s.com   left _         left //s.com   left _ left\n\n" "\nThe following procedure can be used to reproduce the tables above.\n" "\n" "(define print-table\n  (lambda path*\n    (define print-row\n      (lambda (abs? path first rest parent last root extension)\n        (printf \"~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\\n\"\n          abs? path first rest parent last root extension)))\n    (print-row \"path\" \"abs\" \"first\" \"rest\" \"parent\" \"last\" \"root\" \"ext\")\n    (for-each\n      (lambda (path)\n        (define uscore (lambda (s) (if (eqv? s \"\") \"_\" s)))\n        (apply print-row path\n          (map (lambda (s) (if (eqv? s \"\") \"_\" s))\n               (list (path-absolute? path) (path-first path)\n                 (path-rest path) (path-parent path) (path-last path)\n                 (path-root path) (path-extension path)))))\n      path*)))\n" "For example, the first table can be produced with:\n" "\n" "(print-table \"a\" \"a/\" \"a/b\" \"a/b.c\" \"/\" \"/a/b.c\" \"~/a/b.c\"\n  \"~u/a/b.c\" \"../..\")\n" "while the second can be produced (under Windows) with:\n" "\n" "(print-table \"c:\" \"c:/\" \"c:a/b\" \"//s/a/b.c\" \"//s.com\")\n") ("threads:s2" "\nprocedure: (fork-thread thunk)\nreturns: a thread object\nlibraries: (chezscheme)\n" "thunk must be a procedure that accepts zero arguments.\n" "\nfork-thread invokes thunk in a new thread and returns\na thread object.\n" "\nNothing can be done with the thread object returned by\nfork-thread, other than to print it.\n" "\nThreads created by foreign code using some means other than\nfork-thread must call Sactivate_thread\n(Section 4.8) before touching any Scheme data\nor calling any Scheme procedures.\n") ("threads:s3" "\nprocedure: (thread? obj)\nreturns: #t if obj is a thread object, #f otherwise\nlibraries: (chezscheme)\n") ("threads:s4" "\nprocedure: (get-thread-id)\nreturns: the thread id of the current thread\nlibraries: (chezscheme)\n" "The thread id is a thread number assigned by thread id, and has no\nrelationship to the process id returned by\nget-process-id, which is the same\nin all threads.\n\n") ("threads:s6" "\nprocedure: (make-mutex)\nprocedure: (make-mutex name)\nreturns: a new mutex object\nlibraries: (chezscheme)\n" "name, if supplied, must be a symbol which identifies the mutex, or\n#f for no name. The name is printed every time the mutex is\nprinted, which is useful for debugging.\n") ("threads:s7" "\nprocedure: (mutex? obj)\nreturns: #t if obj is a mutex, #f otherwise\nlibraries: (chezscheme)\n") ("threads:s8" "\nprocedure: (mutex-acquire mutex)\nprocedure: (mutex-acquire mutex block?)\nreturns: see below\nlibraries: (chezscheme)\n" "mutex must be a mutex.\n" "\nmutex-acquire acquires the mutex identified by mutex.\nThe optional boolean argument block? defaults to\n#t and specifies whether the thread should block\nwaiting for the mutex.\nIf block? is omitted or is true, the thread\nblocks until the mutex has been acquired, and an unspecified\nvalue is returned.\n" "\nIf block? is false and the mutex currently belongs\nto a different thread, the current thread does not block.\nInstead, mutex-acquire returns\nimmediately with the value #f to\nindicate that the mutex is not available.\nIf block? is false and the mutex is successfully\nacquired, mutex-acquire returns #t.\n" "\nMutexes are recursive in Posix threads terminology, which\nmeans that the calling thread can use mutex-acquire to\n(re)acquire a mutex it already has.\nIn this case, an equal number of mutex-release calls\nis necessary to release the mutex.\n") ("threads:s9" "\nprocedure: (mutex-release mutex)\nreturns: unspecified\nlibraries: (chezscheme)\n" "mutex must be a mutex.\n" "\nmutex-release releases the mutex identified by mutex.\nUnpredictable behavior results if the mutex is not owned by the\ncalling thread.\n") ("threads:s10" "\nsyntax: (with-mutex mutex body1 body2 ...)\nreturns: the values of the body body1 body2 ...\nlibraries: (chezscheme)\n" "with-mutex evaluates the expression mutex, which must\nevaluate to a mutex, acquires the mutex, evaluates the body\nbody1 body2 ..., and releases the mutex.\nThe mutex is released whether the body returns normally or\nvia a control operation (that is, throw to a continuation, perhaps because\nof an error) that results in\na nonlocal exit from the with-mutex form.\nIf control subsequently returns to the body via a\ncontinuation invocation, the mutex is reacquired.\n" "\nUsing with-mutex is generally more convenient and safer than using\nmutex-acquire and mutex-release directly.\n") ("threads:s11" "\nprocedure: (mutex-name mutex)\nreturns: the name associated with mutex, if any; otherwise #f\nlibraries: (chezscheme)\n" "mutex must be a mutex.\n") ("threads:s12" "\nprocedure: (make-condition)\nprocedure: (make-condition name)\nreturns: a new condition object\nlibraries: (chezscheme)\n" "name, if supplied, must be a symbol which identifies the condition\nobject, or #f for no name. The name is printed every time the\ncondition is printed, which is useful for debugging.\n") ("threads:s13" "\nprocedure: (thread-condition? obj)\nreturns: #t if obj is a condition object, #f otherwise\nlibraries: (chezscheme)\n") ("threads:s14" "\nprocedure: (condition-wait cond mutex)\nprocedure: (condition-wait cond mutex timeout)\nreturns: #t if the calling thread was awakened by the condition, #f if the calling thread timed out waiting\nlibraries: (chezscheme)\n" "cond must be a condition object, and\nmutex must be a mutex.\nThe optional argument timeout is a time record of type\ntime-duration or time-utc, or #f for no\ntimeout. It defaults to #f.\n" "\ncondition-wait waits up to the specified timeout for\nthe condition identified by the condition object cond.\nThe calling thread must have acquired the mutex identified by the mutex\nmutex at the time condition-wait is\ncalled.\nmutex is released as a side effect of the call to\ncondition-wait.\nWhen a thread is later released from the condition variable by one of\nthe procedures described below or the timeout expires, mutex is\nreacquired and condition-wait returns.\n\n") ("threads:s15" "\nprocedure: (condition-signal cond)\nreturns: unspecified\nlibraries: (chezscheme)\n" "cond must be a condition object.\n" "\ncondition-signal releases one of the threads waiting for the\ncondition identified by cond.\n\n") ("threads:s16" "\nprocedure: (condition-broadcast cond)\nreturns: unspecified\nlibraries: (chezscheme)\n" "cond must be a condition object.\n" "\ncondition-broadcast releases all of the threads waiting for the\ncondition identified by cond.\n") ("threads:s17" "\nprocedure: (condition-name condition)\nreturns: the name associated with condition, if any; otherwise #f\nlibraries: (chezscheme)\n" "condition must be a condition.\n") ("threads:s19" "\nsyntax: (ftype-init-lock! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-init-lock! ftype-name (a ...) fptr-expr index)\nreturns: unspecified\nsyntax: (ftype-lock! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-lock! ftype-name (a ...) fptr-expr index)\nreturns: #t if the lock is not already locked, #f otherwise\nsyntax: (ftype-spin-lock! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-spin-lock! ftype-name (a ...) fptr-expr index)\nreturns: unspecified\nsyntax: (ftype-unlock! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-unlock! ftype-name (a ...) fptr-expr index)\nreturns: unspecified\nlibraries: (chezscheme)\n" "Each of these has a syntax like and behaves similarly to\nftype-set! (page 86), though with an implicit\nval-expr.\nIn particular, the restrictions on and handling of fptr-expr\nand the accessors a ... is similar, with one important\nrestriction: the field specified by the last accessor, upon which\nthe form operates,  must be a word-size integer, i.e., an\niptr, uptr, or the equivalent, with the native\nendianness.\n" "\nftype-init-lock! should be used to initialize the lock prior\nto the use of any of the other operators; if this is not done, the\nbehavior of the other operators is undefined.\n" "\nftype-lock! can be used to lock the lock.\nIf it finds the lock unlocked at the time of the operation, it locks\nthe lock and returns #t; if it finds the lock already locked,\nit returns #f without changing the lock.\n" "\nftype-spin-lock! can also be used to lock the lock.\nIf it finds the lock unlocked at the time of the operation, it locks the\nlock and returns; if it finds the lock already locked, it waits until\nthe lock is unlocked, then locks the lock and returns.\nIf no other thread or process unlocks the lock, the operation does\nnot return and cannot be interrupted by normal means, including by the\nstorage manager for the purpose of initiating a garbage collection.\nThere are also no guarantees of fairness, so a process might hang\nindefinitely even if other processes are actively locking and unlocking\nthe lock.\n" "\nftype-unlock! is used to unlock a lock.\nIf it finds the lock locked, it unlocks the lock and returns.\nOtherwise, it returns without changing the lock.\n") ("threads:s20" "\nsyntax: (ftype-locked-incr! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-locked-incr! ftype-name (a ...) fptr-expr index)\nreturns: #t if the updated value is 0, #f otherwise\nsyntax: (ftype-locked-decr! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-locked-decr! ftype-name (a ...) fptr-expr index)\nreturns: #t if the updated value is 0, #f otherwise\nlibraries: (chezscheme)\n" "Each of these has a syntax like and behaves similarly to\nftype-set! (page 86), though with an implicit\nval-expr.\nIn particular, the restrictions on and handling of fptr-expr\nand the accessors a ... is similar, with one important\nrestriction: the field specified by the last accessor, upon which\nthe form operates,  must be a word-size integer, i.e., an\niptr, uptr, or the equivalent, with the native\nendianness.\n" "\nftype-locked-incr! atomically reads the value of the specified\nfield, adds 1 to the value, and writes the new value back into the\nfield.\nSimilarly, ftype-locked-decr! atomically reads the value of\nthe specified field, subtracts 1 from the value, and writes the new\nvalue back into the field.\nBoth return #t if the new value is 0, otherwise #f.\n") ("threads:s25" "\nsyntax: (ftype-guardian ftype-name)\nreturns: a new ftype guardian\nlibraries: (chezscheme)\n" "ftype-name must name an ftype.\nThe first base field of the ftype (or one of the first base fields\nin the case of unions) must be a word-sized integer (iptr or uptr)\nwith native endianness.\nThis field is assumed to hold a reference count.\n" "\nThe return value is a new ftype guardian g, with which\nftype-pointers of type ftype-name (or some subtype of\nftype-name) can be registered.\nAn ftype pointer is registered with g by invoking g\nwith the ftype pointer as an argument.\n" "\nAn ftype guardian does not automatically protect from collection\nthe ftype pointers registered with it,  as a normal guardian would\ndo.\nInstead, for each registered ftype pointer that becomes inaccessible\nvia normal (non-weak, non-guardian pointers), the guardian decrements\nthe reference count of the object to which the ftype pointer points.\nIf the resulting reference-count value is zero, the ftype pointer\nis preserved and can be retrieved from the guardian.\nIf the resulting reference-count value is non-zero, however, the\nftype pointer is not preserved.\nObjects retrieved from an ftype guardian (by calling it without\narguments) are guaranteed to have zero reference counts, assuming\nreference counts are maintained properly by code outside the\ncollector.\n" "\nThe collector decrements the reference count using the equivalent\nof ftype-locked-decr!\nto support systems in which non-Scheme objects are stored in memory\nshared by multiple processes.\nIn such systems, programs should themselves use\nftype-locked-incr! and\nftype-locked-decr! or non-Scheme equivalents (e.g., the C\nLOCKED_INCR and\nLOCKED_DECR macros in scheme.h,\nwhich are described in Section 4.8) to maintain\nreference counts.\n" "\nThe following example defines a simple ftype and an allocator for\nobjects of that ftype that frees any objects of that ftype that were\npreviously allocated and no longer accessible.\n" "\n" "(module (A make-A free-dropped-As)\n  (define-ftype A\n    (struct\n      [refcount uptr]\n      [data int]))\n  (define g (ftype-guardian A))\n  (define free-dropped-As\n    (lambda ()\n      (let ([a (g)])\n        (when a\n          (printf \"freeing ~s\\n\" (ftype-ref A (data) a))\n          (foreign-free (ftype-pointer-address a))\n          (free-dropped-As)))))\n  (define make-A\n    (lambda (n)\n      (free-dropped-As)\n      (let ([a (make-ftype-pointer A (foreign-alloc (ftype-sizeof A)))])\n        (ftype-set! A (refcount) a 1)\n        (ftype-set! A (data) a n)\n        (g a)\n        a))))\n" "We can test this by allocating, dropping, and immediately collecting\nftype pointers to A.\n" "\n" "> (do ([i 10 (fx- i 1)])\n      ((fx= i 0))\n    (make-A i)\n    (collect))\nfreeing 10\nfreeing 9\nfreeing 8\nfreeing 7\nfreeing 6\nfreeing 5\nfreeing 4\nfreeing 3\nfreeing 2\n> (free-dropped-As)\nfreeing 1\n" "Objects guarded by an ftype guardian might contain pointers to other\nobjects whose reference counts should also be incremented upon\nallocation of the containing object and decremented upon freeing\nof the containing object.\n\n") ("threads:s30" "\nprocedure: (make-thread-parameter object)\nprocedure: (make-thread-parameter object procedure)\nreturns: a new thread parameter\nlibraries: (chezscheme)\n" "See Section 12.13 for a general\ndiscussion of parameters and the use of the optional second argument.\n" "\nWhen a thread parameter is created, a separate location is set aside\nin each current and future thread to hold the value of the parameter's\ninternal state variable.\n(This location may be eliminated by the storage manager when the\nparameter becomes inaccessible.)\nChanges to the thread parameter in one thread are not seen by any\nother thread.\n" "\nWhen a new thread is created (see fork-thread),\nthe current value (not location) of each\nthread parameter is inherited from the forking thread by the new thread.\nSimilarly, when a thread created by some other means is activated for the\nfirst time (see Sactivate_thread in\nSection 4.8), the current value (not location) of each\nthread parameter is inherited from the main (original) thread by the new\nthread.\n" "\nMost built-in parameters are thread parameters, but some are global.\nAll are marked as global or thread where they are defined.\nThere is no distinction between built-in global and thread parameters\nin the nonthreaded versions of the system.\n\n")) (tspl ("control:s1" "\nsyntax: (expr0 expr1 ...)\nreturns: values of applying the value of expr0 to the values of expr1 ...\n" "Procedure application is the most basic Scheme control structure.\nAny structured form without a syntax keyword in the first position is a\nprocedure application.\nThe expressions expr0 and expr1 ... are evaluated; each\nshould evaluate to a single value.\nAfter each of these expressions has been evaluated, the value of\nexpr0 is applied to the values of expr1 ....\nIf expr0 does not evaluate to a procedure, or if the procedure does not\naccept the number of arguments provided, an exception with condition type\n&assertion is raised.\n" "\nThe order in which the procedure and argument\nexpressions are evaluated is unspecified.\nIt may be left to right, right to left, or any other order.\nThe evaluation is guaranteed to be sequential, however: whatever order\nis chosen, each expression is fully evaluated before evaluation of\nthe next is started.\n" "\n" "(+ 3 4) --> 7\n\n((if (odd? 3) + -) 6 2) --> 8\n\n((lambda (x) x) 5) --> 5\n\n(let ([f (lambda (x) (+ x x))])\n  (f 8)) --> 16\n") ("control:s3" "desc:apply\nprocedure: (apply procedure obj ... list)\nreturns: the values of applying procedure to obj ... and\nthe elements of list\nlibraries: (rnrs base), (rnrs)\n" "apply invokes procedure, passing\nthe first obj as the first argument,\nthe second obj as the second argument, and\nso on for each object in obj ..., and passing the elements of\nlist in order as the remaining arguments.\nThus, procedure is called with as many arguments as there are\nobjs plus elements of list.\n" "\napply is useful when some or all of the arguments to be passed to\na procedure are in a list, since it frees the programmer from\nexplicitly destructuring the list.\n" "\n" "(apply + '(4 5)) --> 9\n\n(apply min '(6 8 3 2 5)) --> 2\n\n(apply min  5 1 3 '(6 8 3 2 5)) --> 1\n\n(apply vector 'a 'b '(c d e)) --> #(a b c d e)\n\n(define first\n  (lambda (ls)\n    (apply (lambda (x . y) x) ls)))\n(define rest\n  (lambda (ls)\n    (apply (lambda (x . y) y) ls)))\n(first '(a b c d)) --> a\n(rest '(a b c d)) --> (b c d)\n\n(apply append\n  '(1 2 3)\n  '((a b) (c d e) (f))) --> (1 2 3 a b c d e f)\n") ("control:s4" "\nsyntax: (begin expr1 expr2 ...)\nreturns: the values of the last subexpression\nlibraries: (rnrs base), (rnrs)\n" "The expressions expr1 expr2 ... are evaluated in sequence\nfrom left to right.\nbegin is used to sequence assignments,\ninput/output, or other operations that cause side effects.\n" "\n" "(define x 3)\n(begin\n  (set! x (+ x 1))\n  (+ x x)) --> 8\n" "A begin form may contain zero or more definitions in place of\nthe expressions expr1 expr2 ..., in which case\nit is considered to be a definition and may appear only where definitions\nare valid.\n" "\n" "(let ()\n  (begin (define x 3) (define y 4))\n  (+ x y)) --> 7\n" "This form of begin is primarily used by syntactic extensions\nthat must expand into multiple definitions.\n(See page 101.)\n" "\nThe bodies of many syntactic forms, including lambda, case-lambda, let,\nlet*, letrec, and letrec*, as well as the result clauses of cond,\ncase, and do, are treated as if they\nwere inside an implicit begin; i.e., the expressions\nmaking up the body or result clause are executed in sequence, with the values of the\nlast expression being returned.\n" "\n" "(define swap-pair!\n  (lambda (x)\n    (let ([temp (car x)])\n      (set-car! x (cdr x))\n      (set-cdr! x temp)\n      x)))\n(swap-pair! (cons 'a 'b)) --> (b . a)\n") ("control:s8" "\nsyntax: (if test consequent alternative)\n\nsyntax: (if test consequent)\nreturns: the values of consequent or alternative depending on the\nvalue of test\nlibraries: (rnrs base), (rnrs)\n" "The test, consequent, and alternative subforms must be\nexpressions.\nIf test evaluates to a true value (anything other than #f),\nconsequent is evaluated and its values are returned.\nOtherwise, alternative is evaluated and its values are returned.\nWith the second, \"one-armed,\" form, which has no alternative,\nthe result is unspecified if test evaluates to false.\n" "\n" "(let ([ls '(a b c)])\n  (if (null? ls)\n      '()\n      (cdr ls))) --> (b c)\n\n(let ([ls '()])\n  (if (null? ls)\n      '()\n      (cdr ls))) --> ()\n\n(let ([abs\n       (lambda (x)\n         (if (< x 0)\n             (- 0 x)\n             x))])\n  (abs -4)) --> 4\n\n(let ([x -4])\n  (if (< x 0)\n      (list 'minus (- 0 x))\n      (list 'plus 4))) --> (minus 4)\n") ("control:s10" "\nprocedure: (not obj)\nreturns: #t if obj is false, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "not is equivalent to (lambda (x) (if x #f #t)).\n" "\n" "(not #f) --> #t\n(not #t) --> #f\n(not '()) --> #f\n(not (< 4 5)) --> #f\n") ("control:s11" "\nsyntax: (and expr ...)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "If no subexpressions are present, the and form evaluates to #t.\nOtherwise, and evaluates each subexpression in sequence from left to right\nuntil only one subexpression remains or a subexpression returns #f.\nIf one subexpression remains, it is evaluated and its values are returned.\nIf a subexpression returns #f, and returns #f without\nevaluating the remaining subexpressions.\nA syntax definition of and appears on page 62.\n" "\n" "(let ([x 3])\n  (and (> x 2) (< x 4))) --> #t\n\n(let ([x 5])\n  (and (> x 2) (< x 4))) --> #f\n\n(and #f '(a b) '(c d)) --> #f\n(and '(a b) '(c d) '(e f)) --> (e f)\n") ("control:s12" "\nsyntax: (or expr ...)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "If no subexpressions are present, the or form evaluates to #f.\nOtherwise, or evaluates each subexpression in sequence from left to right\nuntil only one subexpression remains or a subexpression returns a value other\nthan #f.\nIf one subexpression remains, it is evaluated and its values are returned.\nIf a subexpression returns a value other than #f, or returns\nthat value without evaluating the remaining subexpressions.\nA syntax definition of or appears on page 63.\n" "\n" "(let ([x 3])\n  (or (< x 2) (> x 4))) --> #f\n\n(let ([x 5])\n  (or (< x 2) (> x 4))) --> #t\n\n(or #f '(a b) '(c d)) --> (a b)\n") ("control:s13" "\nsyntax: (cond clause1 clause2 ...)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "Each clause but the last must take one of the forms\nbelow.\n" "\n" "(test)\n(test expr1 expr2 ...)\n(test => expr)\n" "The last clause may be in any of the above forms, or it may be\nan \"else clause\" of the form\n" "\n" "(else expr1 expr2 ...)\n" "Each test is evaluated in order until one evaluates to a true\nvalue or until all of the tests have been evaluated.\nIf the first clause whose test evaluates to a true value is\nin the first form given above, the\nvalue of test is returned.\n" "\nIf the first clause whose test evaluates to a true value is\nin the second form given above, the\nexpressions expr1 expr2... are evaluated in\nsequence and the values of the last expression are returned.\n" "\nIf the first clause whose test evaluates to a true value is\nin the third form given above, the expression expr is\nevaluated.\nThe value should be a procedure of one argument, which is applied\nto the value of test.\nThe values of this application are returned.\n" "\nIf none of the tests evaluates to a true value and an else clause\nis present, the expressions expr1 expr2 ... of the else\nclause are evaluated in sequence and the values of the last expression\nare returned.\n" "\nIf none of the tests evaluates to a true value and no else clause\nis present, the value or values are unspecified.\n" "\nSee page 305 for a syntax definition of cond.\n" "\n" "(let ([x 0])\n  (cond\n    [(< x 0) (list 'minus (abs x))]\n    [(> x 0) (list 'plus x)]\n    [else (list 'zero x)])) --> (zero 0)\n\n(define select\n  (lambda (x)\n    (cond\n      [(not (symbol? x))]\n      [(assq x '((a . 1) (b . 2) (c . 3))) => cdr]\n      [else 0])))\n\n(select 3) --> #t\n(select 'b) --> 2\n(select 'e) --> 0\n") ("control:s16" "\nsyntax: else\n\nsyntax: =>\nlibraries: (rnrs base), (rnrs exceptions), (rnrs)\n" "These identifiers are auxiliary keywords for cond.\nBoth also serve as auxiliary keywords for guard, and\nelse also serves as an auxiliary keyword for case.\nIt is a syntax violation to reference these identifiers except in\ncontexts where they are recognized as auxiliary keywords.\n\n") ("control:s17" "\nsyntax: (when test-expr expr1 expr2 ...)\n\nsyntax: (unless test-expr expr1 expr2 ...)\nreturns: see below\nlibraries: (rnrs control), (rnrs)\n" "For when,\nif test-expr evaluates to a true value, the expressions\nexpr1 expr2 ... are evaluated in sequence,\nand the values of the last expression are returned.\nIf test-expr evaluates to false, none of the other expressions\nare evaluated, and the value or values of when are unspecified.\n" "\nFor unless,\nif test-expr evaluates to false, the expressions\nexpr1 expr2 ... are evaluated in sequence,\nand the values of the last expression are returned.\nIf test-expr evaluates to a true value, none of the other\nexpressions are evaluated, and the value or values of unless are unspecified.\n" "\nA when or unless expression is usually clearer than\nthe corresponding \"one-armed\" if expression.\n" "\n" "(let ([x -4] [sign 'plus])\n  (when (< x 0)\n    (set! x (- 0 x))\n    (set! sign 'minus))\n  (list sign x)) --> (minus 4)\n\n(define check-pair\n  (lambda (x)\n    (unless (pair? x)\n      (syntax-violation 'check-pair \"invalid argument\" x))\n    x))\n\n(check-pair '(a b c)) --> (a b c)\n" "when may be defined as follows:\n" "\n" "(define-syntax when\n  (syntax-rules ()\n    [(_ e0 e1 e2 ...)\n     (if e0 (begin e1 e2 ...))]))\n" "unless may be defined as follows:\n" "\n" "(define-syntax unless\n  (syntax-rules ()\n    [(_ e0 e1 e2 ...)\n     (if (not e0) (begin e1 e2 ...))]))\n" "or in terms of when as follows:\n" "\n" "(define-syntax unless\n  (syntax-rules ()\n    [(_ e0 e1 e2 ...)\n     (when (not e0) e1 e2 ...)]))\n") ("control:s18" "\nsyntax: (case expr0 clause1 clause2 ...)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "Each clause but the last must take the form\n" "\n" "((key ...) expr1 expr2 ...)\n" "where each key is a datum distinct from the other keys.\nThe last clause may be in the above form or it may be an\nelse clause of the form\n" "\n" "(else expr1 expr2 ...)\n" "expr0 is evaluated and the result is compared\n(using eqv?) against the keys of each clause in order.\nIf a clause containing a matching key is found, the\nexpressions expr1 expr2 ... are evaluated in sequence\nand the values of the last expression are returned.\n" "\nIf none of the clauses contains a matching key and an else clause\nis present, the expressions expr1 expr2 ... of the\nelse clause are evaluated in sequence and the values of the last\nexpression are returned.\n" "\nIf none of the clauses contains a matching key and no else clause\nis present, the value or values are unspecified.\n" "\nSee page 306 for a syntax definition of case.\n" "\n" "(let ([x 4] [y 5])\n  (case (+ x y)\n    [(1 3 5 7 9) 'odd]\n    [(0 2 4 6 8) 'even]\n    [else 'out-of-range])) --> odd\n") ("control:s20" "\nsyntax: (let name ((var expr) ...) body1 body2 ...)\nreturns: values of the final body expression\nlibraries: (rnrs base), (rnrs)\n" "This form of let, called named\nlet, is a general-purpose iteration and\nrecursion construct.\nIt is similar to the more common form of let\n(see Section 4.4) in the\nbinding of the variables var ... to the values of expr ... within\nthe body body1 body2 ..., which is processed and evaluated like\na lambda body.\nIn addition, the variable name is bound within the body to\na procedure that may be called to recur or iterate; the arguments to\nthe procedure become the new values of the variables var ....\n" "\nA named let expression of the form\n" "\n" "(let name ((var expr) ...)\n  body1 body2 ...)\n" "can be rewritten with letrec as follows.\n" "\n" "((letrec ((name (lambda (var ...) body1 body2 ...)))\n   name)\n expr ...)\n" "A syntax definition of let that implements this transformation\nand handles unnamed let as well\ncan be found on page 312.\n\n" "\nThe procedure divisors defined below uses named let to compute the\nnontrivial divisors of a nonnegative integer.\n" "\n" "(define divisors\n  (lambda (n)\n    (let f ([i 2])\n      (cond\n        [(>= i n) '()]\n        [(integer? (/ n i)) (cons i (f (+ i 1)))]\n        [else (f (+ i 1))]))))\n\n(divisors 5) --> ()\n(divisors 32) --> (2 4 8 16)\n" "The version above is non-tail-recursive when a divisor is found and\ntail-recursive when a divisor is not found.\nThe version below is fully tail-recursive.\nIt builds up the list in reverse order, but this is easy to remedy,\nif desired, by reversing the list on exit.\n" "\n" "(define divisors\n  (lambda (n)\n    (let f ([i 2] [ls '()])\n      (cond\n        [(>= i n) ls]\n        [(integer? (/ n i)) (f (+ i 1) (cons i ls))]\n        [else (f (+ i 1) ls)]))))\n") ("control:s25" "\nsyntax: (do ((var init update) ...) (test result ...) expr ...)\nreturns: the values of the last result expression\nlibraries: (rnrs control), (rnrs)\n" "do allows a common restricted form of iteration\nto be expressed succinctly.\nThe variables var ... are bound initially to the\nvalues of init ... and are rebound on each subsequent\niteration to the values of update ....\nThe expressions test, \nupdate ...,\nexpr ..., and\nresult ...\nare all within the scope of the bindings\nestablished for var ....\n" "\nOn each step, the test expression test is evaluated.\nIf the value of test is true, iteration ceases,\nthe expressions result ... are evaluated in\nsequence, and the values of the last expression are returned.\nIf no result expressions are present, the value or values of the do\nexpression are unspecified.\n" "\nIf the value of test is false, the expressions expr ...\nare evaluated in sequence, the expressions update ... are\nevaluated, new bindings for var ... to the values of\nupdate ... are created, and iteration continues.\n" "\nThe expressions expr ... are evaluated only for effect\nand are often omitted entirely.\nAny update expression may be omitted, in which case the effect is\nthe same as if the update were simply the corresponding\nvar.\n" "\nAlthough looping constructs in most languages require that the loop\niterands be updated via assignment, do requires the loop\niterands var ... to be updated via rebinding.\nIn fact, no side effects are involved in the evaluation of a\ndo expression unless they are performed explicitly by its\nsubexpressions.\n" "\nSee page 313 for a syntax definition of do.\n" "\nThe definitions of factorial and fibonacci below are\nstraightforward translations of the tail-recursive named-let versions\ngiven in Section 3.2.\n" "\n" "(define factorial\n  (lambda (n)\n    (do ([i n (- i 1)] [a 1 (* a i)])\n        ((zero? i) a))))\n\n(factorial 10) --> 3628800\n\n(define fibonacci\n  (lambda (n)\n    (if (= n 0)\n        0\n        (do ([i n (- i 1)] [a1 1 (+ a1 a2)] [a2 0 a1])\n            ((= i 1) a1)))))\n\n(fibonacci 6) --> 8\n" "The definition of divisors below is\nsimilar to the tail-recursive definition of divisors given\nwith the description of named let above.\n" "\n" "(define divisors\n  (lambda (n)\n    (do ([i 2 (+ i 1)]\n         [ls '()\n             (if (integer? (/ n i))\n                 (cons i ls)\n                 ls)])\n        ((>= i n) ls))))\n" "The definition of scale-vector! below, which scales each\nelement of a vector v by a constant k, demonstrates a nonempty\ndo body.\n" "\n" "(define scale-vector!\n  (lambda (v k)\n    (let ([n (vector-length v)])\n      (do ([i 0 (+ i 1)])\n          ((= i n))\n        (vector-set! v i (* (vector-ref v i) k))))))\n\n(define vec (vector 1 2 3 4 5))\n(scale-vector! vec 2)\nvec --> #(2 4 6 8 10)\n") ("control:s30" "\nprocedure: (map procedure list1 list2 ...)\nreturns: list of results\nlibraries: (rnrs base), (rnrs)\n" "map applies procedure to corresponding\nelements of the lists list1 list2 ... and returns a\nlist of the resulting values.\nThe lists list1 list2 ... must be of the same length.\nprocedure should accept as many arguments as there are lists, should\nreturn a single value, and should not mutate the list arguments.\n" "\n" "(map abs '(1 -2 3 -4 5 -6)) --> (1 2 3 4 5 6)\n\n(map (lambda (x y) (* x y))\n     '(1 2 3 4)\n     '(8 7 6 5)) --> (8 14 18 20)\n" "While the order in which the applications themselves occur is not\nspecified, the order of the values in the output list is the same\nas that of the corresponding values in the input lists.\n" "\nmap might be defined as follows.\n" "\n" "(define map\n  (lambda (f ls . more)\n    (if (null? more)\n        (let map1 ([ls ls])\n          (if (null? ls)\n              '()\n              (cons (f (car ls))\n                    (map1 (cdr ls)))))\n        (let map-more ([ls ls] [more more])\n          (if (null? ls)\n              '()\n              (cons\n                (apply f (car ls) (map car more))\n                (map-more (cdr ls) (map cdr more))))))))\n" "No error checking is done by this version of map; f is assumed to\nbe a procedure and the other arguments are assumed to be proper lists\nof the same length.\nAn interesting feature of this definition is that map uses itself\nto pull out the cars and cdrs of the list of input lists; this works\nbecause of the special treatment of the single-list case.\n\n") ("control:s33" "\ndesc:for-each\nprocedure: (for-each procedure list1 list2 ...)\nreturns: unspecified\nlibraries: (rnrs base), (rnrs)\n" "for-each is similar to map except that\nfor-each does\nnot create and return a list of the resulting values, and for-each\nguarantees to perform the applications in sequence over the elements from\nleft to right.\nprocedure should accept as many arguments as there are lists\nand should not mutate the list arguments.\nfor-each may be defined without error checks as follows.\n" "\n" "(define for-each\n  (lambda (f ls . more)\n    (do ([ls ls (cdr ls)] [more more (map cdr more)])\n        ((null? ls))\n      (apply f (car ls) (map car more)))))\n\n(let ([same-count 0])\n  (for-each\n    (lambda (x y)\n      (when (= x y)\n        (set! same-count (+ same-count 1))))\n    '(1 2 3 4 5 6)\n    '(2 3 3 4 7 6))\n  same-count) --> 3\n") ("control:s36" "\nprocedure: (exists procedure list1 list2 ...)\nreturns: see below\nlibraries: (rnrs lists), (rnrs)\n" "The lists list1 list2 ... must be of the same length.\nprocedure should accept as many arguments as there are lists and should\nnot mutate the list arguments.\nIf the lists are empty, exists returns #f.\nOtherwise, exists applies procedure to corresponding elements\nof the lists list1 list2 ... in sequence until either the\nlists each have only one element or procedure returns a true value t.\nIn the former case, exists tail-calls procedure, applying it to the\nremaining element of each list.\nIn the latter case, exists returns t.\n" "\n" "(exists symbol? '(1.0 #\\a \"hi\" '())) --> #f\n\n(exists member\n        '(a b c)\n        '((c b) (b a) (a c))) --> (b a)\n\n(exists (lambda (x y z) (= (+ x y) z))\n        '(1 2 3 4)\n        '(1.2 2.3 3.4 4.5)\n        '(2.3 4.4 6.4 8.6)) --> #t\n" "exists may be defined (somewhat inefficiently and without error\nchecks) as follows:\n" "\n" "(define exists\n  (lambda (f ls . more)\n    (and (not (null? ls))\n      (let exists ([x (car ls)] [ls (cdr ls)] [more more])\n        (if (null? ls)\n            (apply f x (map car more))\n            (or (apply f x (map car more))\n                (exists (car ls) (cdr ls) (map cdr more))))))))\n") ("control:s37" "\nprocedure: (for-all procedure list1 list2 ...)\nreturns: see below\nlibraries: (rnrs lists), (rnrs)\n" "The lists list1 list2 ... must be of the same length.\nprocedure should accept as many arguments as there are lists and should\nnot mutate the list arguments.\nIf the lists are empty, for-all returns #t.\nOtherwise, for-all applies procedure to corresponding elements\nof the lists list1 list2 ... in sequence until either the\nlists each have only one element left or procedure returns #f.\nIn the former case, for-all tail-calls procedure, applying it to the\nremaining element of each list.\nIn the latter case, for-all returns #f.\n" "\n" "(for-all symbol? '(a b c d)) --> #t\n\n(for-all =\n         '(1 2 3 4)\n         '(1.0 2.0 3.0 4.0)) --> #t\n\n(for-all (lambda (x y z) (= (+ x y) z))\n         '(1 2 3 4)\n         '(1.2 2.3 3.4 4.5)\n         '(2.2 4.3 6.5 8.5)) --> #f\n" "for-all may be defined (somewhat inefficiently and without error\nchecks) as follows:\n" "\n" "(define for-all\n  (lambda (f ls . more)\n    (or (null? ls)\n      (let for-all ([x (car ls)] [ls (cdr ls)] [more more])\n        (if (null? ls)\n            (apply f x (map car more))\n            (and (apply f x (map car more))\n                 (for-all (car ls) (cdr ls) (map cdr more))))))))\n") ("control:s38" "\nprocedure: (fold-left procedure obj list1 list2 ...)\nreturns: see below\nlibraries: (rnrs lists), (rnrs)\n" "The list arguments should all have the same length.\nprocedure should accept one more argument than the number of list\narguments and return a single value.\nIt should not mutate the list arguments.\n" "\nfold-left returns obj if the list arguments are empty.\nIf they are not empty, fold-left applies procedure to\nobj and the cars of list1 list2 ...,\nthen recurs with\nthe value returned by procedure in place of obj and the cdr of\neach list in place of the list.\n" "\n" "(fold-left cons '() '(1 2 3 4)) --> ((((() . 1) . 2) . 3) . 4)\n\n(fold-left\n  (lambda (a x) (+ a (* x x)))\n  0 '(1 2 3 4 5)) --> 55\n\n(fold-left\n  (lambda (a . args) (append args a))\n  '(question)\n  '(that not to)\n  '(is to be)\n  '(the be: or)) --> (to be or not to be: that is the question)\n") ("control:s41" "\nprocedure: (fold-right procedure obj list1 list2 ...)\nreturns: see below\nlibraries: (rnrs lists), (rnrs)\n" "The list arguments should all have the same length.\nprocedure should accept one more argument than the number of list\narguments and return a single value.\nIt should not mutate the list arguments.\n" "\nfold-right returns obj if the list arguments are empty.\nIf they are not empty, fold-right recurs with the cdr of each\nlist replacing the list, then applies\nprocedure to the cars of list1 list2 ... and\nthe result returned by the recursion.\n" "\n" "(fold-right cons '() '(1 2 3 4)) --> (1 2 3 4)\n\n(fold-right\n  (lambda (x a) (+ a (* x x)))\n  0 '(1 2 3 4 5)) --> 55\n\n(fold-right\n  (lambda (x y a) (cons* x y a))   --> (parting is such sweet sorrow\n  '((with apologies))              gifs/ghostRightarrow.gif  gotta go see ya tomorrow\n  '(parting such sorrow go ya)     gifs/ghostRightarrow.gif  (with apologies))\n  '(is sweet gotta see tomorrow))\n") ("control:s44" "\nprocedure: (vector-map procedure vector1 vector1 ...)\nreturns: vector of results\nlibraries: (rnrs base), (rnrs)\n" "vector-map applies procedure to corresponding\nelements of vector1 vector2 ... and returns a\nvector of the resulting values.\nThe vectors vector1 vector2 ... must be of the same length, and\nprocedure should accept as many arguments as there are vectors and\nreturn a single value.\n" "\n" "(vector-map abs '#(1 -2 3 -4 5 -6)) --> #(1 2 3 4 5 6)\n(vector-map (lambda (x y) (* x y))\n  '#(1 2 3 4)\n  '#(8 7 6 5)) --> #(8 14 18 20)\n" "While the order in which the applications themselves occur is not\nspecified, the order of the values in the output vector is the same\nas that of the corresponding values in the input vectors.\n") ("control:s47" "\nprocedure: (vector-for-each procedure vector1 vector2 ...)\nreturns: unspecified\nlibraries: (rnrs base), (rnrs)\n" "vector-for-each is similar to vector-map except that\nvector-for-each does\nnot create and return a vector of the resulting values, and vector-for-each\nguarantees to perform the applications in sequence over the elements from\nleft to right.\n" "\n" "(let ([same-count 0])\n  (vector-for-each\n    (lambda (x y)\n      (when (= x y)\n        (set! same-count (+ same-count 1))))\n    '#(1 2 3 4 5 6)\n    '#(2 3 3 4 7 6))\n  same-count) --> 3\n") ("control:s50" "\nprocedure: (string-for-each procedure string1 string2 ...)\nreturns: unspecified\nlibraries: (rnrs base), (rnrs)\n" "string-for-each is similar to\nfor-each and vector-for-each\nexcept that the inputs are strings rather than lists or vectors.\n" "\n" "(let ([ls '()])\n  (string-for-each\n    (lambda r (set! ls (cons r ls)))\n    \"abcd\"\n    \"====\"\n    \"1234\")\n  (map list->string (reverse ls))) --> (\"a=1\" \"b=2\" \"c=3\" \"d=4\")\n") ("control:s54" "\nprocedure: (call/cc procedure)\n\nprocedure: (call-with-current-continuation procedure)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "These procedures are the same.\nThe shorter name is often used for the obvious reason that it requires\nfewer keystrokes to type.\n" "\ncall/cc obtains its continuation and passes it to procedure,\nwhich should accept one argument.\nThe continuation itself is represented by a procedure.\nEach time this procedure is applied to zero or more values, it returns the values to the\ncontinuation of the call/cc application.\nThat is, when the continuation procedure is called, it returns its arguments\nas the values of the application of call/cc.\n" "\nIf procedure returns normally when passed the continuation procedure,\nthe values returned by call/cc are the values returned by procedure.\n" "\nContinuations allow the implementation of nonlocal exits,\nbacktracking [citation14,citation29],\ncoroutines [citation16], and\nmultitasking [citation10,citation32].\n" "\nThe example below illustrates the use of a continuation to perform\na nonlocal exit from a loop.\n" "\n" "(define member\n  (lambda (x ls)\n    (call/cc\n      (lambda (break)\n        (do ([ls ls (cdr ls)])\n            ((null? ls) #f)\n          (when (equal? x (car ls))\n            (break ls)))))))\n\n(member 'd '(a b c)) --> #f\n(member 'b '(a b c)) --> (b c)\n" "Additional examples are given in Sections 3.3\nand 12.11.\n" "\nThe current continuation is typically represented internally as a stack\nof procedure activation records, and obtaining the continuation\ninvolves encapsulating the stack within a procedural object.\nSince an encapsulated stack has indefinite extent, some mechanism must\nbe used to preserve the stack contents indefinitely.\nThis can be done with surprising ease and efficiency and with no impact\non programs that do not use continuations [citation17].\n") ("control:s56" "\ndesc:dynamic-wind\nprocedure: (dynamic-wind in body out)\nreturns: values resulting from the application of body\nlibraries: (rnrs base), (rnrs)\n" "dynamic-wind offers \"protection\" from continuation\ninvocation.\nIt is useful for performing tasks that must be performed whenever control\nenters or leaves body, either normally or by continuation application.\n" "\nThe three arguments in, body, and out must be procedures\nand should accept zero arguments, i.e., they should be thunks.\nBefore applying body, and each time body is entered subsequently\nby the application of a continuation created within body, the in\nthunk is applied.\nUpon normal exit from body and each time body is exited by\nthe application of a continuation created outside body, the out\nthunk is applied.\n" "\nThus, it is guaranteed that in is invoked at least once.\nIn addition, if body ever returns, out is invoked at least\nonce.\n" "\nThe following example demonstrates the use of dynamic-wind to be sure\nthat an input port is closed after processing, regardless of whether the\nprocessing completes normally.\n" "\n" "(let ([p (open-input-file \"input-file\")])\n  (dynamic-wind\n    (lambda () #f)\n    (lambda () (process p))\n    (lambda () (close-port p))))\n" "Common Lisp provides a similar\nfacility (unwind-protect) for protection from nonlocal exits.\nThis is often sufficient.\nunwind-protect provides only the equivalent to out, however,\nsince Common Lisp does not support fully general continuations.\nHere is how unwind-protect might be specified with dynamic-wind.\n" "\n" "(define-syntax unwind-protect\n  (syntax-rules ()\n    [(_ body cleanup ...)\n     (dynamic-wind\n       (lambda () #f)\n       (lambda () body)\n       (lambda () cleanup ...))]))\n\n((call/cc\n   (let ([x 'a])\n     (lambda (k)\n       (unwind-protect\n         (k (lambda () x))\n         (set! x 'b)))))) --> b\n" "Some Scheme implementations support a controlled form of assignment\nknown as fluid\nbinding, in which a variable takes on a\ntemporary value during a given computation and reverts to the old value\nafter the computation has completed.\nThe syntactic form fluid-let defined below in terms of dynamic-wind\npermits the fluid binding of a single variable x to the value of\nan expression e within a the body b1 b2 ....\n" "\n" "(define-syntax fluid-let\n  (syntax-rules ()\n    [(_ ((x e)) b1 b2 ...)\n     (let ([y e])\n       (let ([swap (lambda () (let ([t x]) (set! x y) (set! y t)))])\n         (dynamic-wind swap (lambda () b1 b2 ...) swap)))]))\n" "Implementations that support fluid-let typically extend it to\nallow an indefinite number of (x e) pairs, as with let.\n" "\nIf no continuations are invoked within the body of a fluid-let,\nthe behavior is the same as if the variable were simply assigned\nthe new value on entry and assigned the old value on return.\n" "\n" "(let ([x 3])\n  (+ (fluid-let ([x 5])\n       x)\n     x)) --> 8\n" "A fluid-bound variable also reverts to the old value if a continuation\ncreated outside of the fluid-let is invoked.\n" "\n" "(let ([x 'a])\n  (let ([f (lambda () x)])\n    (cons (call/cc\n            (lambda (k)\n              (fluid-let ([x 'b])\n                (k (f)))))\n          (f)))) --> (b . a)\n" "If control has left a fluid-let body, either normally\nor by the invocation of a continuation, and control reenters the\nbody by the invocation of a continuation, the temporary value of\nthe fluid-bound variable is reinstated.\nFurthermore, any changes to the temporary value are maintained\nand reflected upon reentry.\n" "\n" "(define reenter #f)\n(define x 0)\n(fluid-let ([x 1])\n  (call/cc (lambda (k) (set! reenter k)))\n  (set! x (+ x 1))\n  x) --> 2\nx --> 0\n(reenter '*) --> 3\n(reenter '*) --> 4\nx --> 0\n" "A library showing how dynamic-wind might be implemented\nwere it not already built in is given below.\nIn addition to defining dynamic-wind, the code defines\na version of\ncall/cc\nthat does its part to support dynamic-wind.\n" "\n" "(library (dynamic-wind)\n  (export dynamic-wind call/cc\n    (rename (call/cc call-with-current-continuation)))\n  (import (rename (except (rnrs) dynamic-wind) (call/cc rnrs:call/cc)))\n\n  (define winders '())\n\n  (define common-tail\n    (lambda (x y)\n      (let ([lx (length x)] [ly (length y)])\n        (do ([x (if (> lx ly) (list-tail x (- lx ly)) x) (cdr x)]\n             [y (if (> ly lx) (list-tail y (- ly lx)) y) (cdr y)])\n            ((eq? x y) x)))))\n\n  (define do-wind\n    (lambda (new)\n      (let ([tail (common-tail new winders)])\n        (let f ([ls winders])\n          (if (not (eq? ls tail))\n              (begin\n                (set! winders (cdr ls))\n                ((cdar ls))\n                (f (cdr ls)))))\n        (let f ([ls new])\n          (if (not (eq? ls tail))\n              (begin\n                (f (cdr ls))\n                ((caar ls))\n                (set! winders ls)))))))\n" "\n" "  (define call/cc\n    (lambda (f)\n      (rnrs:call/cc\n        (lambda (k)\n          (f (let ([save winders])\n               (lambda (x)\n                 (unless (eq? save winders) (do-wind save))\n                 (k x))))))))\n\n  (define dynamic-wind\n    (lambda (in body out)\n      (in)\n      (set! winders (cons (cons in out) winders))\n      (let-values ([ans* (body)])\n        (set! winders (cdr winders))\n        (out)\n        (apply values ans*)))))\n" "Together, dynamic-wind and call/cc manage a list\nof winders.\nA winder is a pair of in and out thunks established\nby a call to dynamic-wind.\nWhenever dynamic-wind is invoked, the in thunk is\ninvoked, a new winder containing the in and out thunks\nis placed on the winders list, the body thunk is invoked,\nthe winder is removed from the winders list, and the out\nthunk is invoked.\nThis ordering ensures that the winder is on the winders list only\nwhen control has passed through in and not yet entered\nout.\nWhenever a continuation is obtained, the winders list is saved, and\nwhenever the continuation is invoked, the saved winders list is\nreinstated.\nDuring reinstatement, the out thunk of each winder on the\ncurrent winders list that is not also on the saved winders list is\ninvoked, followed by the in thunk of each winder on the saved\nwinders list that is not also on the current winders list.\nThe winders list is updated incrementally, again to ensure that\na winder is on the current winders list only if control has passed\nthrough its in thunk and not entered its out thunk.\n" "\nThe test (not (eq? save winders)) performed in call/cc\nis not strictly necessary but makes invoking a continuation\nless costly whenever the saved winders list is the same as the\ncurrent winders list.\n") ("control:s65" "\nsyntax: (delay expr)\nreturns: a promise\n\nprocedure: (force promise)\nreturns: result of forcing promise\nlibraries: (rnrs r5rs)\n" "The first time a promise created by delay is forced (with\nforce), it evaluates expr, \"remembering\" the resulting\nvalue.\nThereafter, each time the promise is forced, it returns the remembered\nvalue instead of reevaluating expr.\n" "\ndelay and force are typically used only in the absence of side\neffects, e.g., assignments, so that the order of evaluation is unimportant.\n" "\nThe benefit of using delay and force is that some\namount of computation might be avoided altogether if it is delayed until\nabsolutely required.\nDelayed evaluation may be used to construct conceptually infinite\nlists, or streams.\nThe example below shows how a stream abstraction may be built with\ndelay and force.\nA stream is a promise that, when forced, returns a pair whose cdr\nis a stream.\n" "\n" "(define stream-car\n  (lambda (s)\n    (car (force s))))\n\n(define stream-cdr\n  (lambda (s)\n    (cdr (force s))))\n\n(define counters\n  (let next ([n 1])\n    (delay (cons n (next (+ n 1))))))\n\n(stream-car counters) --> 1\n\n(stream-car (stream-cdr counters)) --> 2\n\n(define stream-add\n  (lambda (s1 s2)\n    (delay (cons\n             (+ (stream-car s1) (stream-car s2))\n             (stream-add (stream-cdr s1) (stream-cdr s2))))))\n\n(define even-counters\n  (stream-add counters counters))\n\n(stream-car even-counters) --> 2\n\n(stream-car (stream-cdr even-counters)) --> 4\n" "delay may be defined by\n" "\n" "(define-syntax delay\n  (syntax-rules ()\n    [(_ expr) (make-promise (lambda () expr))]))\n" "where make-promise might be defined\nas follows.\n" "\n" "(define make-promise\n  (lambda (p)\n    (let ([val #f] [set? #f])\n      (lambda ()\n        (unless set?\n          (let ([x (p)])\n            (unless set?\n              (set! val x)\n              (set! set? #t))))\n        val))))\n" "With this definition of delay, force simply invokes the promise\nto force evaluation or to retrieve the saved value.\n" "\n" "(define force\n  (lambda (promise)\n    (promise)))\n" "The second test of the variable set? in make-promise is necessary\nin the event that, as a result of applying p, the\npromise is recursively forced.\nSince a promise must always return the same value, the\nresult of the first application of p to complete is\nreturned.\n" "\nWhether delay and force handle multiple return values\nis unspecified; the implementation given above does not, but the following\nversion does, with the help of call-with-values and apply.\n" "\n" "(define make-promise\n  (lambda (p)\n    (let ([vals #f] [set? #f])\n      (lambda ()\n        (unless set?\n          (call-with-values p\n            (lambda x\n              (unless set?\n                (set! vals x)\n                (set! set? #t)))))\n        (apply values vals)))))\n\n(define p (delay (values 1 2 3)))\n(force p) --> 1\n          gifs/ghostRightarrow.gif 2\n          gifs/ghostRightarrow.gif 3\n(call-with-values (lambda () (force p)) +) --> 6\n" "Neither implementation is quite right, since force must raise\nan exception with condition type &assertion if its argument is\nnot a promise.\nSince distinguishing procedures created by make-promise from\nother procedures is impossible, force cannot do so reliably.\nThe following reimplementation of make-promise and force\nrepresents promises as records of the type promise to allow\nforce to make the required check.\n" "\n" "(define-record-type promise\n  (fields (immutable p) (mutable vals) (mutable set?))\n  (protocol (lambda (new) (lambda (p) (new p #f #f)))))\n\n(define force\n  (lambda (promise)\n    (unless (promise? promise)\n      (assertion-violation 'promise \"invalid argument\" promise))\n    (unless (promise-set? promise)\n      (call-with-values (promise-p promise)\n        (lambda x\n          (unless (promise-set? promise)\n            (promise-vals-set! promise x)\n            (promise-set?-set! promise #t)))))\n    (apply values (promise-vals promise))))\n") ("control:s70" "\nprocedure: (values obj ...)\nreturns: obj ...\nlibraries: (rnrs base), (rnrs)\n" "The procedure values accepts any number of arguments and\nsimply passes (returns) the arguments to its continuation.\n" "\n" "(values) -->\n(values 1) --> 1\n\n(values 1 2 3) --> 1\n               gifs/ghostRightarrow.gif 2\n               gifs/ghostRightarrow.gif 3\n\n(define head&tail\n  (lambda (ls)\n    (values (car ls) (cdr ls))))\n\n(head&tail '(a b c)) --> a\n                     gifs/ghostRightarrow.gif (b c)\n") ("control:s71" "\nprocedure: (call-with-values producer consumer)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "producer and consumer must be procedures.\ncall-with-values applies consumer to the values\nreturned by invoking producer without arguments.\n" "\n" "(call-with-values\n  (lambda () (values 'bond 'james))\n  (lambda (x y) (cons y x))) --> (james . bond)\n\n(call-with-values values list) --> '()\n" "In the second example, values itself serves as the producer.\nIt receives no arguments and thus returns no values.\nlist is thus applied to no arguments and so returns the\nempty list.\n" "\nThe procedure dxdy defined below computes\nthe change in x and y coordinates for a pair of points whose\ncoordinates are represented by (x . y) pairs.\n" "\n" "(define dxdy\n  (lambda (p1 p2)\n    (values (- (car p2) (car p1))\n            (- (cdr p2) (cdr p1)))))\n\n(dxdy '(0 . 0) '(0 . 5)) --> 0\n                         gifs/ghostRightarrow.gif 5\n" "dxdy can be used to compute the length and slope of\na segment represented by two\nendpoints.\n" "\n" "(define segment-length\n  (lambda (p1 p2)\n    (call-with-values\n      (lambda () (dxdy p1 p2))\n      (lambda (dx dy) (sqrt (+ (* dx dx) (* dy dy)))))))\n\n(define segment-slope\n  (lambda (p1 p2)\n    (call-with-values\n      (lambda () (dxdy p1 p2))\n      (lambda (dx dy) (/ dy dx)))))\n\n(segment-length '(1 . 4) '(4 . 8)) --> 5\n(segment-slope '(1 . 4) '(4 . 8)) --> 4/3\n" "We can of course combine these to form one procedure that returns\ntwo values.\n" "\n" "(define describe-segment\n  (lambda (p1 p2)\n    (call-with-values\n      (lambda () (dxdy p1 p2))\n      (lambda (dx dy)\n        (values\n          (sqrt (+ (* dx dx) (* dy dy)))\n          (/ dy dx))))))\n\n(describe-segment '(1 . 4) '(4 . 8)) --> 5\n                                     --> 4/3\n" "The example below employs multiple values to divide a\nlist nondestructively into two sublists of alternating\nelements.\n" "\n" "(define split\n  (lambda (ls)\n    (if (or (null? ls) (null? (cdr ls)))\n        (values ls '())\n        (call-with-values\n          (lambda () (split (cddr ls)))\n          (lambda (odds evens)\n            (values (cons (car ls) odds)\n                    (cons (cadr ls) evens)))))))\n\n(split '(a b c d e f)) --> (a c e)\n                       gifs/ghostRightarrow.gif (b d f)\n" "At each level of recursion, the procedure split returns two\nvalues:  a list of the odd-numbered elements from the argument list and\na list of the even-numbered elements.\n\n" "\nThe continuation of a call to values need not be one established\nby a call to call-with-values, nor must only values be used to return\nto a continuation established by call-with-values.\nIn particular, (values e) and e are equivalent expressions.\nFor example:\n" "\n" "(+ (values 2) 4) --> 6\n\n(if (values #t) 1 2) --> 1\n\n(call-with-values\n  (lambda () 4)\n  (lambda (x) x)) --> 4\n" "Similarly, values may be used to pass any number of values to\na continuation that ignores the values, as in the following.\n" "\n" "(begin (values 1 2 3) 4) --> 4\n" "Because a continuation may accept zero or more than one value,\ncontinuations obtained via\ncall/cc may\naccept zero or more than one argument.\n" "\n" "(call-with-values\n  (lambda ()\n    (call/cc (lambda (k) (k 2 3))))\n  (lambda (x y) (list x y))) --> (2 3)\n" "The behavior is unspecified when a\ncontinuation expecting exactly one value receives zero values or more\nthan one value.\nFor example, the behavior of each of the following expressions is\nunspecified.\nSome implementations raise an exception, while others silently\nsuppress additional values or supply defaults for missing values.\n" "\n" "(if (values 1 2) 'x 'y)\n\n(+ (values) 5)\n" "Programs that wish to force extra values to be ignored in particular\ncontexts can do so easily by calling call-with-values explicitly.\nA syntactic form, which we might call first, can be defined to\nabstract the discarding of more than one value when only one is\ndesired.\n" "\n" "(define-syntax first\n  (syntax-rules ()\n    [(_ expr)\n     (call-with-values\n       (lambda () expr)\n       (lambda (x . y) x))]))\n\n(if (first (values #t #f)) 'a 'b) --> a\n" "Since implementations are required to raise an exception with condition\ntype &assertion if a procedure does not accept the number of\narguments passed to it, each of the following raises an exception.\n" "\n" "(call-with-values\n  (lambda () (values 2 3 4))\n  (lambda (x y) x))\n\n(call-with-values\n  (lambda () (call/cc (lambda (k) (k 0))))\n  (lambda (x y) x))\n" "Since producer is most often a lambda expression, it\nis often convenient to use a syntactic extension that suppresses\nthe lambda expression in the interest of readability.\n" "\n" "(define-syntax with-values\n  (syntax-rules ()\n    [(_ expr consumer)\n     (call-with-values (lambda () expr) consumer)]))\n\n(with-values (values 1 2) list) --> (1 2)\n(with-values (split '(1 2 3 4))\n  (lambda (odds evens)\n    evens)) --> (2 4)\n" "If the consumer is also a lambda expression, the\nmultiple-value variants of let and let* described\nin Section 4.5 are usually even more\nconvenient.\n" "\n" "(let-values ([(odds evens) (split '(1 2 3 4))])\n  evens) --> (2 4)\n\n(let-values ([ls (values 'a 'b 'c)])\n  ls) --> (a b c)\n" "Many standard syntactic forms and procedures  pass along multiple values.\nMost of these are \"automatic,\" in the sense that nothing special\nmust be done by the implementation to make this happen.\nThe usual expansion of let into a direct\nlambda call automatically propagates multiple\nvalues produced by the body of the let.\nOther operators must be coded specially to pass along multiple\nvalues.\nThe call-with-port procedure (page 7.6),\nfor example, calls its procedure argument, then closes the port argument\nbefore returning the procedure's values, so it must save the values\ntemporarily.\nThis is easily accomplished via let-values,\napply, and values:\n" "\n" "(define call-with-portdefn:call-with-port\n  (lambda (port proc)\n    (let-values ([val* (proc port)])\n      (close-port port)\n      (apply values val*))))\n" "If this seems like too much overhead when a single value is returned,\nthe code can use call-with-values and case-lambda to\nhandle the single-value case more efficiently:\n" "\n" "(define call-with-port\n  (lambda (port proc)\n    (call-with-values (lambda () (proc port))\n      (case-lambda\n        [(val) (close-port port) val]\n        [val* (close-port port) (apply values val*)]))))\n" "The definitions of values and call-with-values (and\nconcomitant redefinition of call/cc) in the library below\ndemonstrate that the multiple-return-values interface could be implemented\nin Scheme if it were not already built in.\nNo error checking can be done, however, for the case in which more than one\nvalue is returned to a single-value context, such as the test part\nof an if expression.\n" "\n" "(library (mrvs)\n  (export call-with-values values call/cc\n    (rename (call/cc call-with-current-continuation)))\n  (import\n    (rename\n      (except (rnrs) values call-with-values)\n      (call/cc rnrs:call/cc)))\n\n  (define magic (cons 'multiple 'values))\n\n  (define magic?\n    (lambda (x)\n      (and (pair? x) (eq? (car x) magic))))\n" "\n" "  (define call/cc\n    (lambda (p)\n      (rnrs:call/cc\n        (lambda (k)\n          (p (lambda args\n               (k (apply values args))))))))\n\n  (define values\n    (lambda args\n      (if (and (not (null? args)) (null? (cdr args)))\n          (car args)\n          (cons magic args))))\n\n  (define call-with-values\n    (lambda (producer consumer)\n      (let ([x (producer)])\n        (if (magic? x)\n            (apply consumer (cdr x))\n            (consumer x))))))\n" "Multiple values can be implemented more\nefficiently [citation2], but this\ncode serves to illustrate the meanings of the operators\nand may be used to provide multiple values in older, nonstandard\nimplementations that do not support them.\n\n") ("control:s80" "\nprocedure: (eval obj environment)\nreturns: values of the Scheme expression represented by obj in environment\nlibraries: (rnrs eval)\n" "If obj does not represent a syntactically valid expression, eval\nraises an exception with condition type &syntax.\nThe environments returned by environment,\nscheme-report-environment, and null-environment are\nimmutable.\nThus, eval also raises an exception with condition type\n&syntax if an assignment to any of the variables in the\nenvironment appears within the expression.\n" "\n" "(define cons 'not-cons)\n(eval '(let ([x 3]) (cons x 4)) (environment '(rnrs))) --> (3 . 4)\n\n(define lambda 'not-lambda)\n(eval '(lambda (x) x) (environment '(rnrs))) --> #<procedure>\n\n(eval '(cons 3 4) (environment)) --> exception\n") ("control:s81" "\nprocedure: (environment import-spec ...)\nreturns: an environment\nlibraries: (rnrs eval)\n" "environment returns an environment formed from the combined\nbindings of the given import specifiers.\nEach import-spec must be an s-expression representing a valid\nimport specifier (see Chapter 10).\n" "\n" "(define env (environment '(rnrs) '(prefix (rnrs lists) $)))\n(eval '($cons* 3 4 (* 5 8)) env) --> (3 4 . 40)\n") ("control:s82" "\nprocedure: (null-environment version)\n\nprocedure: (scheme-report-environment version)\nreturns: an R5RS compatibility environment\nlibraries: (rnrs r5rs)\n" "version must be the exact integer 5.\n" "\nnull-environment returns an environment containing\nbindings for the keywords whose meanings are defined by the\nRevised5 Report on Scheme, along with bindings for the\nauxiliary keywords else, =>, ...,\nand _.\n" "\nscheme-report-environment returns an environment containing\nthe same keyword bindings as the environment\nreturned by null-environment along with bindings for\nthe variables whose meanings are defined by the Revised5 Report on\nScheme, except those not defined by the Revised6 Report:\nload, interaction-environment,\ntranscript-on, transcript-off, and\nchar-ready?.\n") ("syntax:s12" "\nsyntax: (define-syntax keyword expr)\nlibraries: (rnrs base), (rnrs)\n" "expr must evaluate to a transformer.\n" "\nThe following example defines let* as a syntactic extension,\nspecifying the transformer with syntax-rules (see Section 8.2).\n" "\n" "(define-syntax let*\n  (syntax-rules ()\n    [(_ () b1 b2 ...) (let () b1 b2 ...)]\n    [(_ ((i1 e1) (i2 e2) ...) b1 b2 ...)\n     (let ([i1 e1])\n       (let* ([i2 e2] ...) b1 b2 ...))]))\n" "All bindings established by a set of internal definitions, whether\nkeyword or variable definitions, are visible everywhere within the\nimmediately enclosing body, including within the definitions themselves.\nFor example, the expression\n" "\n" "(let ()\n  (define even?\n    (lambda (x)\n      (or (= x 0) (odd? (- x 1)))))\n  (define-syntax odd?\n    (syntax-rules ()\n      [(_ x) (not (even? x))]))\n  (even? 10))\n" "is valid and should evaluate to #t.\n" "\nbody-expansionThe expander processes the initial forms in a library, lambda, or other\nbody from left to right.\nIf it encounters a variable definition, it records the fact that the\ndefined identifier is a variable but defers expansion of the\nright-hand-side expression until after all of the definitions have\nbeen processed.\nIf it encounters a keyword definition, it expands and evaluates the\nright-hand-side expression and binds the keyword to the resulting\ntransformer.\nIf it encounters an expression, it fully expands all deferred\nright-hand-side expressions along with the current and remaining\nbody expressions.\n" "\nAn implication of the left-to-right processing order is that one\ninternal definition can affect whether a subsequent form is also a\ndefinition.\nFor example, the expression\n" "\n" "(let ()\n  (define-syntax bind-to-zero\n    (syntax-rules ()\n      [(_ id) (define id 0)]))\n  (bind-to-zero x)\n  x)\n" "evaluates to 0, regardless of any binding for\nbind-to-zero that might appear outside of the let\nexpression.\n\n") ("syntax:s13" "\nsyntax: (let-syntax ((keyword expr) ...) form1 form2 ...)\n\nsyntax: (letrec-syntax ((keyword expr) ...) form1 form2 ...)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "Each expr must evaluate to a transformer.\nFor let-syntax and letrec-syntax both, each keyword\nis bound within the\nforms form1 form2 ....\nFor letrec-syntax the binding scope also includes each expr.\n" "\nletsyntaximplicitbeginA let-syntax or letrec-syntax form may expand into one or more\nexpressions anywhere expressions are permitted, in which case the\nresulting expressions are treated as if enclosed in a begin\nexpression.\nIt may also expand into zero or more definitions anywhere definitions are permitted,\nin which case the definitions are treated as if they appeared in place\nof the let-syntax or letrec-syntax form.\n" "\nThe following example highlights how let-syntax\nand letrec-syntax differ.\n" "\n" "(let ([f (lambda (x) (+ x 1))])\n  (let-syntax ([f (syntax-rules ()\n                       [(_ x) x])]\n               [g (syntax-rules ()\n                       [(_ x) (f x)])])\n    (list (f 1) (g 1)))) --> (1 2)\n\n(let ([f (lambda (x) (+ x 1))])\n  (letrec-syntax ([f (syntax-rules ()\n                       [(_ x) x])]\n                  [g (syntax-rules ()\n                       [(_ x) (f x)])])\n    (list (f 1) (g 1)))) --> (1 1)\n" "The two expressions are identical except that the let-syntax form\nin the first expression is a letrec-syntax form in the second.\nIn the first expression, the f occurring in g refers to\nthe let-bound variable f, whereas in the second it refers\nto the keyword f whose binding is established by the\nletrec-syntax form.\n\n") ("syntax:s14" "\nsyntax: (syntax-rules (literal ...) clause ...)\nreturns: a transformer\nlibraries: (rnrs base), (rnrs)\n" "Each literal must be an identifier other than\nan underscore ( _ ) or ellipsis ( ... ).\nEach clause must take the form below.\n" "\n" "(pattern template)\n" "Each pattern specifies one possible syntax that the input\nform might take, and the corresponding template specifies\nhow the output should appear.\n" "\nPatterns consist of list structure, vector structure,\nidentifiers, and\nconstants.\nEach identifier within a pattern is either a literal,\na pattern variable,\nan underscore,\nor an\nellipsis.\nThe identifier _ is an underscore, and\nthe identifier ... is an ellipsis.\nAny identifier other than _ or ... is a literal if it appears\nin the list of literals\n(literal ...);\notherwise, it is a pattern variable.\nLiterals serve as auxiliary keywords, such as else in\ncase and cond expressions.\nList and vector structure within a pattern specifies the basic structure\nrequired of the input, the underscore and pattern variables specify arbitrary\nsubstructure, and literals and constants specify atomic pieces\nthat must match exactly.\nEllipses specify repeated occurrences of the subpatterns they\nfollow.\n" "\npatternsAn input form F matches a pattern P if and only if\n" "\nP is an underscore or pattern variable,\n\nP is a literal identifier\nand F is an identifier with\nthe same binding as determined by the predicate\nfree-identifier=?\n(Section 8.3),\n\nP is of the form\n(P1 ... Pn)\nand F is a list of n elements that match P1 through\nPn,\n\nP is of the form\n(P1 ... Pn . Px)\nand F is a list or improper list of n or more elements\nwhose first n elements match P1 through Pn\nand\nwhose nth cdr matches Px,\n\nP is of the form\n(P1 ... Pk Pe ellipsis Pm+1 ... Pn),\nwhere ellipsis is the identifier ...\nand F is a proper list of n\nelements whose first k elements match P1 through Pk,\nwhose next m - k elements each match Pe,\nand\nwhose remaining n - m elements match Pm+1 through Pn,\n\nP is of the form\n(P1 ... Pk Pe ellipsis Pm+1 ... Pn . Px),\nwhere ellipsis is the identifier ...\nand F is a list or improper list of n\nelements whose first k elements match P1 through Pk,\nwhose next m - k elements each match Pe,\nwhose next n - m elements match Pm+1 through Pn,\nand \nwhose nth and final cdr matches Px,\n\nP is of the form\n#(P1 ... Pn)\nand F is a vector of n elements that match P1 through\nPn,\n\nP is of the form\n#(P1 ... Pk Pe ellipsis Pm+1 ... Pn),\nwhere ellipsis is the identifier ...\nand F is a vector of n elements\nwhose first k elements match P1 through Pk,\nwhose next m - k elements each match Pe,\nand\nwhose remaining n - m elements match Pm+1 through Pn,\nor\n\nP is a pattern datum (any nonlist, nonvector, nonsymbol\nobject) and F is equal to P in the sense of the\nequal? procedure.\n" "\n" "\nThe outermost structure of a syntax-rules pattern\nmust actually be in one of the list-structured forms above, although\nsubpatterns of the pattern may be in any of the above forms.\nFurthermore, the first element of the outermost pattern is ignored,\nsince it is always assumed to be the keyword naming the\nsyntactic form.\n(These statements do not apply to syntax-case; see\nSection 8.3.)\n" "\nIf an input form passed to a syntax-rules transformer\nmatches the pattern for a given clause, the clause\nis accepted and the form is transformed as specified by the\nassociated template.\nAs this transformation takes place,\npattern variables appearing in the pattern\nare bound to the corresponding input subforms.\nPattern variables appearing within a subpattern followed by\none or more ellipses may be bound to a sequence or sequences of zero or more\ninput subforms.\n" "\nA template is a pattern variable, an identifier that\nis not a pattern\nvariable, a pattern datum, a list of subtemplates\n(S1 ... Sn), an improper list of subtemplates\n(S1 S2 ... Sn . T), or a\nvector of subtemplates #(S1 ... Sn).\nEach subtemplate Si is a template\nfollowed by zero or more ellipses.\nThe final element T of an improper subtemplate list is a template.\n" "\nPattern variables appearing within a template are replaced in\nthe output by the input subforms to which they are bound.\nPattern data and identifiers that are not pattern variables\nare inserted directly into the output.\nList and vector structure within the template remains list and vector\nstructure in the output.\nA subtemplate followed by an ellipsis expands\ninto zero or more occurrences of the subtemplate.\nThe subtemplate\nmust contain at least one pattern variable from a subpattern\nfollowed by an ellipsis.\n(Otherwise, the expander could not determine how many times the subform\nshould be repeated in the output.)\nPattern variables that occur in subpatterns followed by one or more\nellipses may occur only in subtemplates that are\nfollowed by (at least) as many ellipses.\nThese pattern variables are replaced in the output by the input\nsubforms to which  they are bound, distributed as specified.\nIf a pattern variable is followed by more ellipses in the template\nthan in the associated pattern, the input form is replicated as\nnecessary.\n" "\nA template of the form\n(... template) is identical to template, except that\nellipses within the template have no special meaning.\nThat is, any ellipses contained within template are\ntreated as ordinary identifiers.\nIn particular, the template (... ...) produces a single\nellipsis, ....\nThis allows syntactic extensions to expand into forms containing\nellipses, including syntax-rules or syntax-case\npatterns and templates.\n" "\n" "The definition of or below demonstrates the use of\nsyntax-rules.\n" "\n" "(define-syntax or\n  (syntax-rules ()\n    [(_) #f]\n    [(_ e) e]\n    [(_ e1 e2 e3 ...)\n     (let ([t e1]) (if t t (or e2 e3 ...)))]))\n" "The input patterns specify that the input must consist of the\nkeyword and zero or more subexpressions.\nAn underscore ( _ ),\nwhich is a special pattern symbol that matches any input,\nis often used for the keyword position to remind the programmer\nand anyone reading the definition that the keyword\nposition never fails to contain the expected keyword and need not be\nmatched.\n(In fact, as mentioned above, syntax-rules ignores what appears\nin the keyword position.)\nIf more than one subexpression is present (third clause), the\nexpanded code both tests the value of the first subexpression\nand returns the value if it is not false.\nTo avoid evaluating the expression twice, the transformer\nintroduces a binding for the temporary variable t.\n" "\nThe expansion algorithm maintains lexical scoping automatically\nby renaming local identifiers as necessary.\nThus, the binding for t introduced by the transformer is visible\nonly within code introduced by the transformer and not within\nsubforms of the input.\nSimilarly, the references to the identifiers let and if are\nunaffected by any bindings present in the context of the input.\n" "\n" "(let ([if #f])\n  (let ([t 'okay])\n    (or if t))) --> okay\n" "This expression is transformed during expansion to the equivalent of\nthe expression below.\n" "\n" "((lambda (if1)\n   ((lambda (t1)\n      ((lambda (t2)\n         (if t2 t2 t1))\n       if1))\n    'okay))\n #f) --> okay\n" "In this sample expansion, if1, t1, and t2\nrepresent identifiers to which if and t in the\noriginal expression and t in the expansion of or have\nbeen renamed.\n" "\nThe definition of a simplified version of cond below\n(simplified because it requires\nat least one output expression per clause and \ndoes not support the auxiliary keyword =>)\ndemonstrates how auxiliary keywords such as else are recognized\nin the input to a transformer, via inclusion in the list of\nliterals.\n" "\n" "(define-syntax cond\n  (syntax-rules (else)\n    [(_ (else e1 e2 ...)) (begin e1 e2 ...)]\n    [(_ (e0 e1 e2 ...)) (if e0 (begin e1 e2 ...))]\n    [(_ (e0 e1 e2 ...) c1 c2 ...)\n     (if e0 (begin e1 e2 ...) (cond c1 c2 ...))]))\n") ("syntax:s26" "\nsyntax: _\n\nsyntax: ...\nlibraries: (rnrs base), (rnrs syntax-case), (rnrs)\n" "These identifiers are auxiliary keywords for syntax-rules,\nidentifier-syntax, and syntax-case.\nThe second ( ... ) is also an auxiliary keyword for\nsyntax and quasisyntax.\nIt is a syntax violation to reference these identifiers except in\ncontexts where they are recognized as auxiliary keywords.\n\n") ("syntax:s27" "\nsyntax: (identifier-syntax tmpl)\n\nsyntax: (identifier-syntax (id1 tmpl1) ((set! id2 e2) tmpl2))\nreturns: a transformer\nlibraries: (rnrs base), (rnrs)\n" "When a keyword is bound to a transformer produced by the first form of\nidentifier-syntax, references to the keyword within the scope\nof the binding are replaced by tmpl.\n" "\n" "(let ()\n  (define-syntax a (identifier-syntax car))\n  (list (a '(1 2 3)) a)) --> (1 #<procedure>)\n" "With the first form of identifier-syntax, an apparent assignment\nof the associated keyword with set! is a syntax violation.\nThe second, more general, form of identifier-syntax permits\nthe transformer to specify what happens when set! is used.\n" "\n" "(let ([ls (list 0)])\n  (define-syntax a\n    (identifier-syntax\n      [id (car ls)]\n      [(set! id e) (set-car! ls e)]))\n  (let ([before a])\n    (set! a 1)\n    (list before a ls))) --> (0 1 (1))\n" "A definition of identifier-syntax in terms of\nmake-variable-transformer is shown on\npage 307.\n") ("syntax:s30" "\nsyntax: (syntax-case expr (literal ...) clause ...)\nreturns: see below\nlibraries: (rnrs syntax-case), (rnrs)\n" "Each literal must be an identifier.\nEach clause must take one of the following two forms.\n" "\n" "(pattern output-expression)\n(pattern fender output-expression)\n" "syntax-case patterns may be in any of the forms described\nin Section 8.2.\n" "\nsyntax-case first evaluates expr, then attempts\nto match the resulting value against the pattern from the first\nclause.\nThis value may be any Scheme object.\nIf the value matches the pattern and no\nfender is present,\noutput-expression is evaluated and its values returned as the\nvalues of the syntax-case expression.\nIf the value does not match the pattern, the value is compared against\nthe next clause, and so on.\nIt is a syntax violation if the value does not match any of the patterns.\n" "\nIf the optional fender is present, it serves as an additional\nconstraint on acceptance of a clause.\nIf the value of the syntax-case expr matches the pattern for a given\nclause, the corresponding fender is evaluated.\nIf fender evaluates to a true value, the clause is accepted;\notherwise, the clause is rejected as if the input had failed to match\nthe pattern.\nFenders are logically a part of the matching process, i.e., they\nspecify additional matching constraints beyond the basic structure of\nan expression.\n" "\nPattern variables contained within a clause's\npattern are bound to the corresponding pieces of the input\nvalue within the clause's fender (if present) and\noutput-expression.\nPattern variables occupy the same namespace as program variables and\nkeywords; pattern variable bindings created by syntax-case\ncan shadow (and be shadowed by) program variable and keyword bindings as\nwell as other pattern variable bindings.\nPattern variables, however, can be referenced only within syntax\nexpressions.\n" "\nSee the examples following the description of syntax.\n") ("syntax:s33" "\nsyntax: (syntax template)\n\nsyntax: #'template\nreturns: see below\nlibraries: (rnrs syntax-case), (rnrs)\n" "#'template is equivalent to (syntax template).\nThe abbreviated form is converted into the longer form when a program\nis read, prior to macro expansion.\n" "\nA syntax expression is like a quote expression except that the\nvalues of pattern variables appearing within template are\ninserted into template, and\ncontextual information associated both with the input and with the template is\nretained in the output to support lexical scoping.\nA syntax template is identical to a syntax-rules\ntemplate and is treated similarly.\n" "\nList and vector structures within the template become true lists or\nvectors (suitable for direct application of list or vector operations,\nlike map or vector-ref) to the extent that the\nlist or vector structures must be copied to insert the values of\npattern variables, and empty lists are never wrapped.\nFor example, #'(x ...), #'(a b c), #'() are\nall lists if x, a, b, and c are\npattern variables.\n" "\nThe definition of or below is equivalent to the one given in\nSection 8.2 except that it employs syntax-case and\nsyntax in place of syntax-rules.\n" "\n" "(define-syntax or\n  (lambda (x)\n    (syntax-case x ()\n      [(_) #'#f]\n      [(_ e) #'e]\n      [(_ e1 e2 e3 ...)\n       #'(let ([t e1]) (if t t (or e2 e3 ...)))])))\n" "In this version, the lambda expression that produces the\ntransformer is explicit, as are the syntax forms in the output\npart of each clause.\nAny syntax-rules form can be expressed with\nsyntax-case by making the lambda expression and\nsyntax expressions explicit.\nThis observation leads to the following definition of\nsyntax-rules in terms of\nsyntax-case.\n" "\n" "(define-syntax syntax-rules\n  (lambda (x)\n    (syntax-case x ()\n      [(_ (i ...) ((keyword . pattern) template) ...)\n       #'(lambda (x)\n           (syntax-case x (i ...)\n             [(_ . pattern) #'template] ...))])))\n" "An underscore is used in place of\neach keyword since the first position\nof each syntax-rules pattern is always ignored.\n" "\nSince the lambda and syntax expressions are\nimplicit in a syntax-rules form, definitions expressed with\nsyntax-rules are often shorter than the equivalent definitions\nexpressed with syntax-case.\nThe choice of which to use when either suffices is a matter of\ntaste, but many transformers that can be written easily with\nsyntax-case cannot be written easily or at all with syntax-rules\n(see Section 8.4).\n") ("syntax:s35" "\nprocedure: (identifier? obj)\nreturns: #t if obj is an identifier, #f otherwise\nlibraries: (rnrs syntax-case), (rnrs)\n" "identifier? is often used within fenders to verify\nthat certain subforms of an input form are identifiers, as in the\ndefinition of unnamed let below.\n" "\n" "(define-syntax let\n  (lambda (x)\n    (define ids?\n      (lambda (ls)\n        (or (null? ls)\n            (and (identifier? (car ls))\n                 (ids? (cdr ls))))))\n    (syntax-case x ()\n      [(_ ((i e) ...) b1 b2 ...)\n       (ids? #'(i ...))\n       #'((lambda (i ...) b1 b2 ...) e ...)])))\n" "Syntactic extensions ordinarily take the form\n(keyword subform ...), but the\nsyntax-case system permits them to take the form of singleton\nidentifiers as well.\nFor example, the keyword pcar in the expression below may be used\nboth as an identifier (in which case it expands into a call to car)\nor as a structured form (in which case it expands\ninto a call to set-car!).\n" "\n" "(let ([p (cons 0 #f)])\n  (define-syntax pcar\n    (lambda (x)\n      (syntax-case x ()\n        [_ (identifier? x) #'(car p)]\n        [(_ e) #'(set-car! p e)])))\n  (let ([a pcar])\n    (pcar 1)\n    (list a pcar))) --> (0 1)\n" "The fender (identifier? x) is used to recognize the singleton\nidentifier case.\n\n") ("syntax:s37" "\nprocedure: (free-identifier=? identifier1 identifier2)\n\nprocedure: (bound-identifier=? identifier1 identifier2)\nreturns: see below\nlibraries: (rnrs syntax-case), (rnrs)\n" "Symbolic names alone do not distinguish identifiers unless the\nidentifiers are to be used only as symbolic data.\nThe predicates free-identifier=? and bound-identifier=?\nare used to compare identifiers according to their intended use\nas free references or bound identifiers in a given context.\n" "\nfree-identifier=? is used to determine whether two\nidentifiers would be equivalent if they were to appear as free identifiers\nin the output of a transformer.\nBecause identifier references are lexically scoped, this means\n(free-identifier=? id1 id2) is true if and only if the\nidentifiers id1 and id2 refer to the same\nbinding.\n(For this comparison, two like-named identifiers are assumed to have the\nsame binding if neither is bound.)\nLiteral identifiers (auxiliary keywords) appearing in\nsyntax-case patterns (such as else in case\nand cond)\nare matched with free-identifier=?.\n" "\nSimilarly, bound-identifier=? is used to\ndetermine whether two identifiers would be equivalent if they were to appear as\nbound identifiers in the output of a transformer.\nIn other words, if bound-identifier=? returns true for two\nidentifiers, a binding for one will capture references to the\nother within its scope.\nIn general, two identifiers are bound-identifier=? only if\nboth are present in the original program or both are introduced by the\nsame transformer application\n(perhaps implicitly---see datum->syntax).\nbound-identifier=? can be used for detecting\nduplicate identifiers in a binding construct or for other\npreprocessing of a binding construct that requires detecting instances\nof the bound identifiers.\n" "\nThe definition below is equivalent to the earlier definition\nof a simplified version of cond with syntax-rules, except that\nelse is recognized via an explicit call to free-identifier? within\na fender rather than via inclusion in the literals list.\n" "\n" "(define-syntax cond\n  (lambda (x)\n    (syntax-case x ()\n      [(_ (e0 e1 e2 ...))\n       (and (identifier? #'e0) (free-identifier=? #'e0 #'else))\n       #'(begin e1 e2 ...)]\n      [(_ (e0 e1 e2 ...)) #'(if e0 (begin e1 e2 ...))]\n      [(_ (e0 e1 e2 ...) c1 c2 ...)\n       #'(if e0 (begin e1 e2 ...) (cond c1 c2 ...))])))\n" "With either definition of cond, else is not\nrecognized as an auxiliary\nkeyword if an enclosing lexical binding for else exists.\nFor example,\n" "\n" "(let ([else #f])\n  (cond [else (write \"oops\")]))\n" "does not write \"oops\", since else is bound\nlexically and is\ntherefore not the same else that appears in the definition of\ncond.\n" "\nThe following definition of unnamed let\nuses bound-identifier=? to detect duplicate identifiers.\n" "\n" "(define-syntax let\n  (lambda (x)\n    (define ids?\n      (lambda (ls)\n        (or (null? ls)\n            (and (identifier? (car ls)) (ids? (cdr ls))))))\n    (define unique-ids?\n      (lambda (ls)\n        (or (null? ls)\n            (and (not (memp\n                        (lambda (x) (bound-identifier=? x (car ls)))\n                        (cdr ls)))\n                 (unique-ids? (cdr ls))))))\n    (syntax-case x ()\n      [(_ ((i e) ...) b1 b2 ...)\n       (and (ids? #'(i ...)) (unique-ids? #'(i ...)))\n       #'((lambda (i ...) b1 b2 ...) e ...)])))\n" "With the definition of let above, the expression\n" "\n" "(let ([a 3] [a 4]) (+ a a))\n" "is a syntax violation, whereas\n" "\n" "(let ([a 0])\n  (let-syntax ([dolet (lambda (x)\n                        (syntax-case x ()\n                          [(_ b)\n                           #'(let ([a 3] [b 4]) (+ a b))]))])\n    (dolet a)))\n" "evaluates to 7 since the identifier a introduced by dolet\nand the identifier a extracted from the input form are not\nbound-identifier=?.\nSince both occurrences of a, however, if left as free references,\nwould refer to the same binding for a, free-identifier=?\nwould not distinguish them.\n" "\nTwo identifiers that are free-identifier=? may not be\nbound-identifier=?.\nAn identifier introduced by a transformer may refer to the same\nenclosing binding as an identifier not introduced by the transformer,\nbut an introduced binding for one will not capture references to the other.\nOn the other hand, identifiers that are bound-identifier=? are\nfree-identifier=?, as long as the identifiers have valid\nbindings in the context where they are compared.\n\n") ("syntax:s38" "\nsyntax: (with-syntax ((pattern expr) ...) body1 body2 ...)\nreturns: the values of the final body expression\nlibraries: (rnrs syntax-case), (rnrs)\n" "It is sometimes useful to construct a transformer's output in separate\npieces, then put the pieces together.\nwith-syntax facilitates this by allowing the creation of local\npattern bindings.\n" "\npattern is identical in form to a syntax-case pattern.\nThe value of each expr is computed and destructured according\nto the corresponding pattern, and pattern variables within\nthe pattern are bound as with syntax-case to appropriate\nportions of the value within the body body1 body2 ...,\nwhich is processed and evaluated like a lambda body.\n" "\nwith-syntax may be defined as a syntactic extension in terms of\nsyntax-case.\n" "\n" "(define-syntax with-syntax\n  (lambda (x)\n    (syntax-case x ()\n      [(_ ((p e) ...) b1 b2 ...)\n       #'(syntax-case (list e ...) ()\n           [(p ...) (let () b1 b2 ...)])])))\n" "The following definition of full cond\ndemonstrates the use of with-syntax to support transformers\nthat employ recursion internally to construct their output.\n" "\n" "(define-syntax conddefn:cond\n  (lambda (x)\n    (syntax-case x ()\n      [(_ c1 c2 ...)\n       (let f ([c1 #'c1] [cmore #'(c2 ...)])\n         (if (null? cmore)\n             (syntax-case c1 (else =>)\n               [(else e1 e2 ...) #'(begin e1 e2 ...)]\n               [(e0) #'(let ([t e0]) (if t t))]\n               [(e0 => e1) #'(let ([t e0]) (if t (e1 t)))]\n               [(e0 e1 e2 ...) #'(if e0 (begin e1 e2 ...))])\n             (with-syntax ([rest (f (car cmore) (cdr cmore))])\n               (syntax-case c1 (=>)\n                 [(e0) #'(let ([t e0]) (if t t rest))]\n                 [(e0 => e1) #'(let ([t e0]) (if t (e1 t) rest))]\n                 [(e0 e1 e2 ...)\n                  #'(if e0 (begin e1 e2 ...) rest)]))))])))\n") ("syntax:s40" "\nsyntax: (quasisyntax template ...)\n\nsyntax: #`template\n\nsyntax: (unsyntax template ...)\n\nsyntax: #,template\n\nsyntax: (unsyntax-splicing template ...)\n\nsyntax: #,@template\nreturns: see below\nlibraries: (rnrs syntax-case), (rnrs)\n" "#`template is equivalent to (quasisyntax template),\nwhile\n#,template is equivalent to (unsyntax template), and\n#,@template to (unsyntax-splicing template).\nThe abbreviated forms are converted into the longer forms when the program\nis read, prior to macro expansion.\n" "\nquasisyntax is similar to syntax, but it allows parts\nof the quoted text to be evaluated, in a manner similar to\nquasiquote (Section 6.1).\n" "\nWithin a quasisyntax template, subforms of\nunsyntax and unsyntax-splicing forms are evaluated,\nand everything else is treated as ordinary template material, as\nwith syntax.\nThe value of each unsyntax subform is inserted into the output\nin place of the unsyntax form, while the value of each\nunsyntax-splicing subform is spliced into the surrounding list\nor vector structure.\nunsyntax and unsyntax-splicing are valid only within\nquasisyntax expressions.\n" "\nquasisyntax expressions may be nested, with each quasisyntax\nintroducing a new level of syntax quotation and each unsyntax or\nunsyntax-splicing taking away a level of quotation.\nAn expression nested within n quasisyntax expressions must\nbe within n unsyntax or unsyntax-splicing expressions to\nbe evaluated.\n" "\nquasisyntax can be used in place of with-syntax in many\ncases.\nFor example, the following definition of\ncase employs quasisyntax to\nconstruct its output, using internal recursion in a manner similar to the\ndefinition of cond given under the description of\nwith-syntax above.\n" "\n" "(define-syntax casedefn:case\n  (lambda (x)\n    (syntax-case x ()\n      [(_ e c1 c2 ...)\n       #`(let ([t e])\n           #,(let f ([c1 #'c1] [cmore #'(c2 ...)])\n               (if (null? cmore)\n                   (syntax-case c1 (else)\n                     [(else e1 e2 ...) #'(begin e1 e2 ...)]\n                     [((k ...) e1 e2 ...)\n                      #'(if (memv t '(k ...)) (begin e1 e2 ...))])\n                   (syntax-case c1 ()\n                     [((k ...) e1 e2 ...)\n                      #`(if (memv t '(k ...))\n                            (begin e1 e2 ...)\n                            #,(f (car cmore) (cdr cmore)))]))))])))\n" "unsyntax and unsyntax-splicing forms that contain\nzero or more than\none subform are valid only in splicing (list or vector) contexts.\n(unsyntax template ...) is equivalent to\n(unsyntax template) ..., and\n(unsyntax-splicing template ...) is equivalent to\n(unsyntax-splicing template) ....\nThese forms are primarily useful as intermediate forms in the output\nof the quasisyntax expander.\nThey support certain useful nested quasiquotation (quasisyntax)\nidioms [citation3], such as #,@#,@, which has the\neffect of a doubly indirect splicing when used within a doubly nested\nand doubly evaluated quasisyntax expression, as with the\nnested quasiquote examples shown in Section 6.1.\n" "\nunsyntax and unsyntax-splicing are auxiliary keywords for\nquasisyntax.\nIt is a syntax violation to reference these identifiers except in contexts\nwhere they are recognized as auxiliary keywords.\n") ("syntax:s42" "\ndesc:make-variable-transformer\nprocedure: (make-variable-transformer procedure)\nreturns: a variable transformer\nlibraries: (rnrs syntax-case), (rnrs)\n" "As described in the lead-in to this section, transformers may simply be\nprocedures that accept one argument,\na syntax object representing the input form, and return a new syntax object\nrepresenting the output form.\nThe form passed to a transformer usually represents a parenthesized form whose\nfirst subform is the keyword bound to the transformer or just the keyword\nitself.\nmake-variable-transformer may be used to convert a procedure into\na special kind of transformer to which the expander also passes set!\nforms in which the keyword appears just after the set! keyword, as\nif it were a variable to be assigned.\nThis allows the programmer to control what happens when the keyword appears\nin such contexts.\nThe argument, procedure, should accept one argument.\n" "\n" "(let ([ls (list 0)])\n  (define-syntax a\n    (make-variable-transformer\n      (lambda (x)\n        (syntax-case x ()\n          [id (identifier? #'id) #'(car ls)]\n          [(set! _ e) #'(set-car! ls e)]\n          [(_ e ...) #'((car ls) e ...)]))))\n  (let ([before a])\n    (set! a 1)\n    (list before a ls))) --> (0 1 (1))\n" "This syntactic abstraction can be defined more succinctly using\nidentifier-syntax, as shown in Section 8.2,\nbut make-variable-transformer can be used to create\ntransformers that perform arbitrary computations, while\nidentifier-syntax is limited to simple term rewriting,\nlike syntax-rules.\nidentifier-syntax can be defined\nin terms of make-variable-transformer, as shown below.\n" "\n" "(define-syntax identifier-syntaxdefn:identifier-syntax\n  (lambda (x)\n    (syntax-case x (set!)\n      [(_ e)\n       #'(lambda (x)\n           (syntax-case x ()\n             [id (identifier? #'id) #'e]\n             [(_ x (... ...)) #'(e x (... ...))]))]\n      [(_ (id exp1) ((set! var val) exp2))\n       (and (identifier? #'id) (identifier? #'var))\n       #'(make-variable-transformer\n           (lambda (x)\n             (syntax-case x (set!)\n               [(set! var val) #'exp2]\n               [(id x (... ...)) #'(exp1 x (... ...))]\n               [id (identifier? #'id) #'exp1])))])))\n") ("syntax:s44" "\nprocedure: (syntax->datum obj)\nreturns: obj stripped of syntactic information\nlibraries: (rnrs syntax-case), (rnrs)\n" "The procedure syntax->datum\nstrips all syntactic information from a syntax\nobject and returns the corresponding Scheme \"datum.\"\nIdentifiers stripped in this manner are converted to their symbolic\nnames, which can then be compared with eq?.\nThus, a predicate symbolic-identifier=? might be defined as follows.\n" "\n" "(define symbolic-identifier=?\n  (lambda (x y)\n    (eq? (syntax->datum x)\n         (syntax->datum y))))\n" "Two identifiers that are free-identifier=? need not be\nsymbolic-identifier=?: two identifiers that refer to the\nsame binding usually have the same name, but the rename and\nprefix subforms of the library's import form\n(page 345) may\nresult in two identifiers with different names but the same binding.\n") ("syntax:s45" "\nprocedure: (datum->syntax template-identifier obj)\nreturns: a syntax object\nlibraries: (rnrs syntax-case), (rnrs)\n" "datum->syntax constructs a syntax object from obj that\ncontains the same contextual information as\ntemplate-identifier, with the effect that the\nsyntax object behaves\nas if it were introduced into the code when\ntemplate-identifier was introduced.\nThe template identifier is often the keyword of an input form,\nextracted from the form, and the object is often a symbol naming an\nidentifier to be constructed.\n" "\ndatum->syntax allows a transformer to \"bend\" lexical\nscoping rules by creating implicit identifiers\nthat behave as if they were present in the input form,\nthus permitting the definition of syntactic\nextensions that introduce visible bindings for or references to\nidentifiers that do not appear explicitly in the input form.\nFor example, we can define a loop expression that\nbinds the variable break to an escape procedure\nwithin the loop body.\n" "\n" "(define-syntax loop\n  (lambda (x)\n    (syntax-case x ()\n      [(k e ...)\n       (with-syntax ([break (datum->syntax #'k 'break)])\n         #'(call/cc\n             (lambda (break)\n               (let f () e ... (f)))))])))\n\n(let ([n 3] [ls '()])\n  (loop\n    (if (= n 0) (break ls))\n    (set! ls (cons 'a ls))\n    (set! n (- n 1)))) --> (a a a)\n" "Were we to define loop as\n" "\n" "(define-syntax loop\n  (lambda (x)\n    (syntax-case x ()\n      [(_ e ...)\n       #'(call/cc\n           (lambda (break)\n             (let f () e ... (f))))])))\n" "the variable break would not be visible in e ....\n" "\nIt is also useful for obj to represent an arbitrary\nScheme form, as demonstrated by the following definition of\ninclude.\n" "\n" "(define-syntax include\n  (lambda (x)\n    (define read-file\n      (lambda (fn k)\n        (let ([p (open-input-file fn)])\n          (let f ([x (read p)])\n            (if (eof-object? x)\n                (begin (close-port p) '())\n                (cons (datum->syntax k x) (f (read p))))))))\n    (syntax-case x ()\n      [(k filename)\n       (let ([fn (syntax->datum #'filename)])\n         (with-syntax ([(expr ...) (read-file fn #'k)])\n           #'(begin expr ...)))])))\n" "(include \"filename\") expands into a begin expression\ncontaining the forms found in the file named by\n\"filename\".\nFor example, if the file f-def.ss contains the expression\n(define f (lambda () x)), the expression\n" "\n" "(let ([x \"okay\"])\n  (include \"f-def.ss\")\n  (f))\n" "evaluates to \"okay\".\n" "\nThe definition of include uses datum->syntax to convert\nthe objects read from the file into syntax objects in the proper\nlexical context, so that identifier references and definitions within\nthose expressions are scoped where the include form appears.\n") ("syntax:s49" "\nprocedure: (generate-temporaries list)\nreturns: a list of distinct generated identifiers\nlibraries: (rnrs syntax-case), (rnrs)\n" "Transformers can introduce a fixed number of identifiers into their\noutput by naming each identifier.\nIn some cases, however, the number of identifiers to be introduced depends\nupon some characteristic of the input expression.\nA straightforward definition of letrec, for example,\nrequires as many\ntemporary identifiers as there are binding pairs in the\ninput expression.\nThe procedure generate-temporaries is used to construct\nlists of temporary identifiers.\n" "\nlist may be any list; its contents are not important.\nThe number of temporaries generated is the number of elements\nin list.\nEach temporary is guaranteed to be different from all other\nidentifiers.\n" "\nA definition of letrec that\nuses generate-temporaries is shown below.\n" "\n" "(define-syntax letrecdefn:letrec\n  (lambda (x)\n    (syntax-case x ()\n      [(_ ((i e) ...) b1 b2 ...)\n       (with-syntax ([(t ...) (generate-temporaries #'(i ...))])\n         #'(let ([i #f] ...)\n             (let ([t e] ...)\n               (set! i t)\n               ...\n               (let () b1 b2 ...))))])))\n" "Any transformer that uses generate-temporaries in this fashion can\nbe rewritten to avoid using it, albeit with a loss of clarity.\nThe trick is to use a recursively defined intermediate form that\ngenerates one temporary per expansion step and completes the\nexpansion after enough temporaries have been generated.\nfullletvaluesHere is a definition of let-values\n(page 99) that uses this technique to support\nmultiple sets of bindings.\n" "\n" "(define-syntax let-values\n  (syntax-rules ()\n    [(_ () f1 f2 ...) (let () f1 f2 ...)]\n    [(_ ((fmls1 expr1) (fmls2 expr2) ...) f1 f2 ...)\n     (lvhelp fmls1 () () expr1 ((fmls2 expr2) ...) (f1 f2 ...))]))\n\n(define-syntax lvhelp\n  (syntax-rules ()\n    [(_ (x1 . fmls) (x ...) (t ...) e m b)\n     (lvhelp fmls (x ... x1) (t ... tmp) e m b)]\n    [(_ () (x ...) (t ...) e m b)\n     (call-with-values\n       (lambda () e)\n       (lambda (t ...)\n         (let-values m (let ([x t] ...) . b))))]\n    [(_ xr (x ...) (t ...) e m b)\n     (call-with-values\n       (lambda () e)\n       (lambda (t ... . tmpr)\n         (let-values m (let ([x t] ... [xr tmpr]) . b))))]))\n" "The implementation of lvhelp is complicated by the need\nto evaluate all of the right-hand-side expressions before creating\nany of the bindings and by the need to support improper formals\nlists.\n") ("libraries:s17" "\nprocedure: (command-line)\nreturns: a list of strings representing command-line arguments\nlibraries: (rnrs programs), (rnrs)\n" "This procedure may be used within a top-level program to obtain a list\nof the command-line arguments passed to the program.\n") ("libraries:s18" "\nprocedure: (exit)\n\nprocedure: (exit obj)\nreturns: does not return\nlibraries: (rnrs programs), (rnrs)\n" "This procedure may be used to exit from a top-level program to the\noperating system.\nIf no obj is given, the exit value returned to the operating\nsystem should indicate a normal exit.\nIf obj is false, the exit value returned to the operating\nsystem should indicate an abnormal exit.\nOtherwise, obj is translated into an exit value as\nappropriate for the operating system.\n\n") ("records:s13" "\nsyntax: (define-record-type record-name clause ...)\n\nsyntax: (define-record-type (record-name constructor pred) clause ...)\nlibraries: (rnrs records syntactic), (rnrs)\n" "A define-record-type form, or record definition, is a definition\nand may appear anywhere other definitions may appear.\nIt defines a record\ntype identified by record-name, plus a predicate, constructor, accessors,\nand mutators for the record type.\nIf the record definition takes the first form above, the names of the constructor\nand predicate are derived from record-name: make-record-name\nfor the constructor and record-name? for the predicate.\nIf the record definition takes the second form above, the name of the constructor\nis constructor and the name of the predicate is pred.\nAll names defined by a record definition are scoped where the record definition\nappears.\n" "\nThe clauses clause ... of the record definition determine\nthe fields of the record type and the names of their accessors\nand mutators; its parent type, if any; its construction protocol; whether\nit is nongenerative and, if so, whether its uid is specified; whether\nit is sealed; and whether it is opaque.\nThe syntax and impact of each clause is described below.\n" "\nNone of the clauses is required; thus, the simplest record definition is\n" "\n" "(define-record-type record-name)\n" "which defines a new, generative, non-sealed, non-opaque record type with no parent\nand no fields, plus a constructor of no arguments and a predicate.\n" "\nAt most one of each kind of clause may be present in the set of clauses, and\nif a parent clause is present, a parent-rtd clause must not\nbe present.\nThe clauses that appear may appear in any order.\n\n" "\n" "Fields clause.  A (fields field-spec ...) clause\ndeclares the fields of the record type.\nEach field-spec must take one of the following forms:\n" "\n" "field-name\n(immmutable field-name)\n(mutable field-name)\n(immmutable field-name accessor-name)\n(mutable field-name accessor-name mutator-name)\n" "where field-name, accessor-name, and mutator-name are identifiers.\nThe first form, field-name, is equivalent to (immutable field-name).\nThe value of a field declared immutable may not be changed, and no mutator is\ncreated for it.\nWith the first three forms, the name of the accessor is\nrname-fname, where rname is the record\nname and fname is the field name.\nWith the third form, the name of the accessor is\nrname-fname-set!.\nThe fourth and fifth forms explicitly declare the accessor and mutator names.\n" "\nIf no fields clause is present or the list field-spec ...\nis empty, the record type has no fields (other than parent fields, if any).\n\n" "\n" "Parent clause.  A (parent parent-name) clause declares the parent record type;\nparent-name must be the name of a non-sealed record type previously\ndefined via define-record-type.\nInstances of a record type are also considered instances of its parent record\ntype and have all the fields of its parent record type in addition to those\ndeclared via the fields clause.\n" "\n" "Nongenerative clause.  A nongenerative clause may take one of two forms:\n" "\n" "(nongenerative)\n(nongenerative uid)\n" "where uid is a symbol.\nThe first form is equivalent to the second, with a uid generated by the\nimplementation at macro-expansion time.\nWhen a define-record-type form with a nongenerative clause is\nevaluated, a new type is created if and only if the uid is not the uid\nof an existing record type.\n" "\nIf it is the uid of an existing record type, the parent, field-names,\nsealed property, and opaque property must match as follows.\n" "\nIf a parent is specified, the existing record type must have the same\nparent rtd (by eqv?).\nIf a parent is not specified, the existing record type must not have\na parent.\n\nThe same number of fields must be provided, with the same names and in\nthe same order, and the mutability of each field must be the same.\n\nIf a (sealed #t) clause is present, the existing record type\nmust be sealed.\nOtherwise, the existing record type must not be sealed.\n\nIf an (opaque #t) clause is present, the existing record type\nmust be opaque.\nOtherwise, the existing record type must be opaque if and only if\nan opaque parent type is specified.\n" "\n" "\nIf these constraints are met, no new record type is created, and the\nother products of the record-type definition (constructor, predicate,\naccessors, and mutators) operate on records of the existing type.\nIf these constraints are not met, the implementation may treat it as a\nsyntax violation, or it may raise a run-time exception with condition type\n&assertion.\n" "\nWith the first form of nongenerative clause, the generated\nuid can be the uid of an existing record type only if the\nsame definition is executed multiple times, e.g., if it appears in\nthe body of a procedure that is invoked multiple times.\n" "\nIf uid is not the uid of an existing record type, or if no\nnongenerative clause is present, a new record type is created.\n" "\n" "Protocol clause.  A (protocol expression) determines the protocol that\nthe generated constructor uses to construct instances of the record\ntype.\nIt must evaluate to a procedure, and this procedure should be an\nappropriate protocol for the record type, as described on\npage 326.\n" "\n" "Sealed clause.  page:sealedA sealed clause of the form (sealed #t) declares that the\nrecord type is sealed.\nThis means that it cannot be extended, i.e., cannot be used as the\nparent for another record definition or make-record-type-descriptor\ncall.\nIf no sealed clause is present or if one of the form\n(sealed #f) is present, the record type is not sealed.\n" "\n" "Opaque clause.  page:opaqueAn opaque clause of the form (opaque #t) declares that the\nrecord type is opaque.\nInstances of an opaque record type are not considered records by the\nrecord? predicate or, more importantly, the rtd-extraction\nprocedure record-rtd, which are both described in\nSection 9.3.\nThus, it is not possible for code that does not have access to the\nrecord-name, accessors, or mutators to access or modify any\nof the fields of an opaque record type.\nA record type is also opaque if its parent is opaque.\nIf no opaque clause is present or if one of the form\n(opaque #f) is present, and the parent, if any, is not\nopaque, the record type is not opaque.\n" "\n" "Parent-rtd clause.  A (parent-rtd parent-rtd parent-rcd) clause is an alternative\nto the parent clause for specifying the parent record type, along\nwith a parent record constructor descriptor.\nIt is primarily useful when the parent rtd and rcd were obtained via calls to\nmake-record-type-descriptor and make-record-constructor-descriptor.\n" "\nparent-rtd must evaluate to an rtd or #f.\nIf parent-rtd evaluates to #f, parent-rcd must\nalso evaluate to #f.\nOtherwise, parent-rcd must evaluate to an rcd or #f.\nIf parent-rcd evaluates to an rcd, it must encapsulate an rtd\nequivalent (by eqv?) to the value of parent-rtd.\nIf the value of parent-rcd is #f, it is treated as an rcd\nfor the value of parent-rtd with a default protocol.\n" "\nThe define-record-type form is designed in such a way that it is\nnormally possible for a compiler to determine the shapes of the record\ntypes it defines, including the offsets for all fields.\nThis guarantee does not hold, however, when the parent-rtd clause\nis used, since the parent rtd might not be determinable until run time.\nThus, the parent clause is preferred over the parent-rtd\nclause whenever the parent clause suffices.\n\n") ("records:s16" "\nsyntax: fields\n\nsyntax: mutable\n\nsyntax: immutable\n\nsyntax: parent\n\nsyntax: protocol\n\nsyntax: sealed\n\nsyntax: opaque\n\nsyntax: nongenerative\n\nsyntax: parent-rtd\nlibraries: (rnrs records syntactic), (rnrs)\n" "These identifiers are auxiliary keywords for define-record-type.\nIt is a syntax violation to reference these identifiers except in\ncontexts where they are recognized as auxiliary keywords.\n\n") ("records:s20" "\nprocedure: (make-record-type-descriptor name parent uid s? o? fields)\nreturns: a record-type descriptor (rtd) for a new or existing record type\nlibraries: (rnrs records procedural), (rnrs)\n" "name must be a symbol, parent must be #f or the\nrtd of a non-sealed record type, uid must be #f or\na symbol, and fields must be a vector, each element of which\nis a two-element list of the form (mutable field-name)\nor (immutable field-name).\nThe field names field-name ... must be symbols and need\nnot be distinct from each other.\n" "\nIf uid is #f or is not the uid of an existing record\ntype, this procedure creates a new record type and returns a record-type\ndescriptor (rtd) for the new type. \nThe type has the parent type (page 325) described by\nparent, if nonfalse; the uid specified by uid, if nonfalse;\nand the fields specified by fields.\nIt is sealed (page 330) if s? is nonfalse.\nIt is opaque (page 330) if opaque is nonfalse or\nthe parent (if specified) is opaque.\nThe name of the new record type is name and the names of the fields are\nfield-name ....\n" "\nIf uid is nonfalse and is the uid (page 325)\nof an existing record type, the parent, fields, s?,\nand o? arguments must match the corresponding characteristics\nof the existing record type.\nThat is, parent must be the same (by eqv?); the number\nof fields must be the same; the fields must\nhave the same names, be in the same order, and have the same mutability;\ns? must be false if and only\nif the existing record type is sealed; and, if a parent is not specified\nor is not opaque, o? must be false if and only if the existing\nrecord type is opaque.\nIf this is the case, make-record-type-descriptor\nreturns the rtd for the existing record type.\nOtherwise, an exception with condition type &assertion is raised.\n" "\nUsing the rtd returned by make-record-type-descriptor, programs\ncan generate constructors,\ntype predicates, field accessors, and field mutators dynamically.\nThe following code demonstrates how the procedural interface might\nbe used to create a point record type and associated\ndefinitions similar to those of the second point record\ndefinition in Section 9.1, with a mutable\nx field and an immutable y field.\n" "\n" "(define point-rtd (make-record-type-descriptor 'point #f #f #f #f\n                '#((mutable x) (immutable y))))\n(define point-rcd (make-record-constructor-descriptor point-rtd\n                    #f #f))\n(define make-point (record-constructor point-rcd))\n(define point? (record-predicate point-rtd))\n(define point-x (record-accessor point-rtd 0))\n(define point-y (record-accessor point-rtd 1))\n(define point-x-set! (record-mutator point-rtd 0))\n" "See the additional examples given at the end of this section.\n\n") ("records:s23" "\nprocedure: (record-type-descriptor? obj)\nreturns: #f if obj is a record-type descriptor, otherwise #f\nlibraries: (rnrs records procedural), (rnrs)\n" "See the examples given at the end of this section.\n\n") ("records:s24" "\nprocedure: (make-record-constructor-descriptor rtd parent-rcd protocol)\nreturns: a record-constructor descriptor (rcd)\nlibraries: (rnrs records procedural), (rnrs)\n" "An rtd alone is sufficient to create predicates, accessors, and mutators.\nTo create a constructor, however, it is first necessary to create a record-constructor\ndescriptor (rcd) for the record type.\nAn rcd encapsulates three pieces of information: the rtd of the record type\nfor which the rcd has been created, the parent rcd (if any), and the\nprotocol.\n" "\nThe parent-rcd argument must be an rcd or #f.\nIf it is an rcd, rtd must have a parent rtd, and the parent rtd must be\nthe same as the rtd encapsulated within parent-rcd.\nIf parent-rcd is false, either rtd has no parent or an rcd with a default\nprotocol is assumed for the parent.\n" "\nThe protocol argument must be a procedure or #f.\nIf it is #f, a default protocol is assumed.\nProtocols are discussed on page 326.\n" "\nSee the examples given at the end of this section.\n\n") ("records:s28" "\nsyntax: (record-type-descriptor record-name)\nreturns: the rtd for the record type identified by record-name\n\nsyntax: (record-constructor-descriptor record-name)\nreturns: the rcd for the record type identified by record-name\nlibraries: (rnrs records syntactic), (rnrs)\n" "Each record definition creates, behind the scenes, an rtd and rcd for the\ndefined record type.\nThese procedures allow the rtd and rcd to be obtained and used like any\nother rtd or rcd.\nrecord-name must be the name of a record previously defined via\ndefine-record-type.\n\n") ("records:s29" "\nprocedure: (record-constructor rcd)\nreturns: a record constructor for the record type encapsulated within rcd\nlibraries: (rnrs records procedural), (rnrs)\n" "The behavior of the record constructor is determined by the protocol\nand parent rcd (if any) also encapsulated within rcd.\n" "\nSee the examples given at the end of this section.\n\n") ("records:s30" "\nprocedure: (record-predicate rtd)\nreturns: a predicate for rtd\nlibraries: (rnrs records procedural), (rnrs)\n" "This procedure returns a predicate that accepts one argument and returns\n#t if the argument is an instance of the record-type described by\nrtd, #f otherwise.\n" "\nSee the examples given at the end of this section.\n\n") ("records:s31" "\nprocedure: (record-accessor rtd idx)\nreturns: an accessor for the field of rtd specified by idx\nlibraries: (rnrs records procedural), (rnrs)\n" "idx must be a nonnegative integer less than the number of fields of\nrtd, not counting parent fields.\nAn idx value of 0 specifies the first field given in the\ndefine-record-type form or make-record-type-descriptor\ncall that created the record type, 1 specifies the second, and so on.\n" "\nA child rtd cannot be used directly to create accessors for parent fields.\nTo create an accessor for a parent field, the record-type descriptor of\nthe parent must be used instead.\n" "\nSee the examples given at the end of this section.\n\n") ("records:s32" "\nprocedure: (record-mutator rtd idx)\nreturns: a mutator for the field of rtd specified by idx\nlibraries: (rnrs records procedural), (rnrs)\n" "idx must be a nonnegative integer less than the number of fields of\nrtd, not counting parent fields.\nAn idx value of 0 specifies the first field given in the\ndefine-record-type form or make-record-type-descriptor\ncall that created the record type, 1 specifies the second, and so on.\nThe indicated field must be mutable; otherwise, an exception with condition\ntype &assertion is raised.\n" "\nA child rtd cannot be used directly to create mutators for parent fields.\nTo create a mutator for a parent field, the record-type descriptor of\nthe parent must be used instead.\n\n" "\n" "The following example illustrates the creation of parent and child record\ntypes, predicates, accessors, mutators, and constructors using the procedures\ndescribed in this section.\n" "\n" "(define rtd/parent\n  (make-record-type-descriptor 'parent #f #f #f #f\n    '#((mutable x))))\n\n(record-type-descriptor? rtd/parent) --> #t\n(define parent? (record-predicate rtd/parent))\n(define parent-x (record-accessor rtd/parent 0))\n(define set-parent-x! (record-mutator rtd/parent 0))\n\n(define rtd/child\n  (make-record-type-descriptor 'child rtd/parent #f #f #f\n    '#((mutable x) (immutable y))))\n\n(define child? (record-predicate rtd/child))\n(define child-x (record-accessor rtd/child 0))\n(define set-child-x! (record-mutator rtd/child 0))\n(define child-y (record-accessor rtd/child 1))\n\n(record-mutator rtd/child 1) --> exception: immutable field\n\n(define rcd/parent\n  (make-record-constructor-descriptor rtd/parent #f\n    (lambda (new) (lambda (x) (new (* x x))))))\n\n(record-type-descriptor? rcd/parent) --> #f\n\n(define make-parent (record-constructor rcd/parent))\n\n(define p (make-parent 10))\n(parent? p) --> #t\n(parent-x p) --> 100\n(set-parent-x! p 150)\n(parent-x p) --> 150\n\n(define rcd/child\n  (make-record-constructor-descriptor rtd/child rcd/parent\n    (lambda (pargs->new)\n      (lambda (x y)\n        ((pargs->new x) (+ x 5) y)))))\n\n(define make-child (record-constructor rcd/child))\n(define c (make-child 10 'cc))\n(parent? c) --> #t\n(child? c) --> #t\n(child? p) --> #f\n\n(parent-x c) --> 100\n(child-x c) --> 15\n(child-y c) --> cc\n\n(child-x p) --> exception: invalid argument type\n") ("records:s34" "\nprocedure: (record-type-name rtd)\nreturns: the name associated with rtd\nlibraries: (rnrs records inspection), (rnrs)\n" "\n" "\n(define record->name\n  (lambda (x)\n    (and (record? x) (record-type-name (record-rtd x)))))\n\n(define-record-type dim (fields w l h))\n(record->name (make-dim 10 15 6)) --> dim\n\n(define-record-type dim (fields w l h) (opaque #t))\n(record->name (make-dim 10 15 6)) --> #f\n") ("records:s35" "\nprocedure: (record-type-parent rtd)\nreturns: the parent of rtd, or #f if it has no parent\nlibraries: (rnrs records inspection), (rnrs)\n" "\n" "\n(define-record-type point (fields x y))\n(define-record-type cpoint (parent point) (fields color))\n(record-type-parent (record-type-descriptor point)) --> #f\n(record-type-parent (record-type-descriptor cpoint)) --> #<rtd>\n") ("records:s36" "\nprocedure: (record-type-uid rtd)\nreturns: the uid of rtd, or #f if it has no uid\nlibraries: (rnrs records inspection), (rnrs)\n" "Whether a record type created without a programmer-supplied uid\nactually has one anyway is left up to the implementation, so this\nprocedure is never guaranteed to return #f.\n" "\n" "(define-record-type point (fields x y))\n(define-record-type cpoint\n  (parent point)\n  (fields color)\n  (nongenerative e40cc926-8cf4-4559-a47c-cac636630314))\n(record-type-uid (record-type-descriptor point)) --> unspecified\n(record-type-uid (record-type-descriptor cpoint)) -->\n                             e40cc926-8cf4-4559-a47c-cac636630314\n") ("records:s37" "\nprocedure: (record-type-generative? rtd)\nreturns: #t if the record type described by rtd is generative, #f otherwise\n\nprocedure: (record-type-sealed? rtd)\nreturns: #t if the record type described by rtd is sealed, #f otherwise\n\nprocedure: (record-type-opaque? rtd)\nreturns: #t if the record type described by rtd is opaque, #f otherwise\nlibraries: (rnrs records inspection), (rnrs)\n" "\n" "\n(define-record-type table\n  (fields keys vals)\n  (opaque #t))\n(define rtd (record-type-descriptor table))\n(record-type-generative? rtd) --> #t\n(record-type-sealed? rtd) --> #f\n(record-type-opaque? rtd) --> #t\n\n(define-record-type cache-table\n  (parent table)\n  (fields key val)\n  (nongenerative))\n(define rtd (record-type-descriptor cache-table))\n(record-type-generative? rtd) --> #f\n(record-type-sealed? rtd) --> #f\n(record-type-opaque? rtd) --> #t\n") ("records:s38" "\nprocedure: (record-type-field-names rtd)\nreturns: a vector containing the names of the fields of the type described by rtd\nlibraries: (rnrs records inspection), (rnrs)\n" "The vector returned by this procedure is immutable: the effect on rtd\nof modifying it is unspecified.\nThe vector does not include parent field names.\nThe order of the names in the vector is the same as the order in which the\nfields were specified in the define-record-type form or\nmake-record-type-descriptor call that created the record type.\n" "\n" "(define-record-type point (fields x y))\n(define-record-type cpoint (parent point) (fields color))\n(record-type-field-names\n  (record-type-descriptor point)) --> #(x y)\n(record-type-field-names\n  (record-type-descriptor cpoint)) --> #(color)\n") ("records:s39" "\nprocedure: (record-field-mutable? rtd idx)\nreturns: #t if the specified field of rtd is mutable, #f otherwise\nlibraries: (rnrs records inspection), (rnrs)\n" "idx must be a nonnegative integer less than the number of fields of\nrtd, not counting parent fields.\nAn idx value of 0 specifies the first field given in the\ndefine-record-type form or make-record-type-descriptor\ncall that created the record type, 1 specifies the second, and so on.\n" "\n" "(define-record-type point (fields (mutable x) (mutable y)))\n(define-record-type cpoint (parent point) (fields color))\n\n(record-field-mutable? (record-type-descriptor point) 0) --> #t\n(record-field-mutable? (record-type-descriptor cpoint) 0) --> #f\n") ("records:s40" "\nprocedure: (record? obj)\nreturns: #t if obj is a non-opaque record instance, #f otherwise\nlibraries: (rnrs records inspection), (rnrs)\n" "When passed an instance of an opaque record type, record? returns\n#f.\nWhile an instance of an opaque record type is, in essence, a record,\nthe point of opacity is to hide all representation information from the\nparts of a program that should not have access to the information,\nand this includes whether an object is a record.\nFurthermore, the primary purpose of this predicate is to allow programs to\ncheck whether it is possible to obtain from the argument an rtd via the\nrecord-rtd procedure described below.\n" "\n" "(define-record-type statement (fields str))\n(define q (make-statement \"He's dead, Jim\"))\n(statement? q) --> #t\n(record? q) --> #t\n\n(define-record-type opaque-statement (fields str) (opaque #t))\n(define q (make-opaque-statement \"He's moved on, Jim\"))\n(opaque-statement? q) --> #t\n(record? q) --> #f\n") ("records:s41" "\nprocedure: (record-rtd record)\nreturns: the record-type descriptor (rtd) of record\nlibraries: (rnrs records inspection), (rnrs)\n" "The argument must be an instance of a non-opaque record type.\nIn combination with some of the other procedures described in this\nsection and Section 9.2,\nrecord-rtd allows the inspection or mutation\nof record instances, even if the type of the instance is unknown\nto the inspector.\nThis capability is illustrated by the procedure print-fields\nbelow, which accepts a record argument and writes the name and value of\neach field of the record.\n" "\n" "(define print-fields\n  (lambda (r)\n    (unless (record? r)\n      (assertion-violation 'print-fields \"not a record\" r))\n    (let loop ([rtd (record-rtd r)])\n      (let ([prtd (record-type-parent rtd)])\n        (when prtd (loop prtd)))\n      (let* ([v (record-type-field-names rtd)]\n             [n (vector-length v)])\n        (do ([i 0 (+ i 1)])\n            ((= i n))\n          (write (vector-ref v i))\n          (display \"=\")\n          (write ((record-accessor rtd i) r))\n          (newline))))))\n" "With the familiar definitions of point and cpoint:\n" "\n" "(define-record-type point (fields x y))\n(define-record-type cpoint (parent point) (fields color))\n" "the expression (print-fields (make-cpoint -3 7 'blue)) displays\nthe following three lines.\n" "\n" "x=-3\ny=7\ncolor=blue\n") ("binding:s2" "\nsyntax: variable\nreturns: the value of variable\n" "Any identifier appearing as an expression in a program is a variable\nif a visible variable binding for the identifier exists, e.g., the\nidentifier appears within the scope of a binding created by define,\nlambda, let, or some other variable-binding construct.\n" "\n" "list --> #<procedure>\n(define x 'a)\n(list x x) --> (a a)\n(let ([x 'b])\n  (list x x)) --> (b b)\n(let ([let 'let]) let) --> let\n" "It is a syntax violation for an identifier reference to appear within a\nlibrary form or top-level program if it is not bound as a variable,\nkeyword, record name, or other entity.\nSince the scope of the definitions in a library, top-level\nprogram, lambda, or other local body is the entire body, it\nis not necessary for the definition of a variable to appear before\nits first reference appears, as long as the reference is not actually\nevaluated until the definition has been completed.\nSo, for example, the reference to g within the definition of\nf below\n" "\n" "(define f\n  (lambda (x)\n    (g x)))\n(define g\n  (lambda (x)\n    (+ x x)))\n" "is okay, but the reference to g in the definition of\nq below is not.\n" "\n" "(define q (g 3))\n(define g\n  (lambda (x)\n    (+ x x)))\n") ("binding:s3" "\nsyntax: (lambda formals body1 body2 ...)\nreturns: a procedure\nlibraries: (rnrs base), (rnrs)\n" "The lambda syntactic form is used to create procedures.\nAny operation that creates a procedure or establishes local variable\nbindings is ultimately defined in terms of lambda or\ncase-lambda.\n" "\nThe variables in formals are the formal parameters of the\nprocedure, and the sequence of subforms\nbody1 body2 ... is its body.\n" "\nThe body may begin with a sequence of\ndefinitions, in which case the bindings created by the definitions are\nlocal to the body.\nIf definitions are present, the keyword bindings are used and discarded\nwhile expanding the body, and the body is expanded into a\nletrec* expression formed from the variable definitions and the\nremaining expressions, as described on page 292.\nThe remainder of this description of lambda assumes that this\ntransformation has taken place, if necessary, so that the body is a\nsequence of expressions without definitions.\n" "\nWhen the procedure is created, the bindings of all variables occurring\nfree within the body, excluding the formal parameters, are retained with\nthe procedure.\nSubsequently, whenever the procedure is applied to a sequence of\nactual parameters, the formal parameters are bound to the actual\nparameters, the retained bindings are restored, and the body is\nevaluated.\n" "\nUpon application, the formal parameters defined by formals are\nbound to the actual parameters as follows.\n" "\nIf formals is a proper list of variables, e.g., (x y z), each\nvariable is bound to the corresponding actual parameter.\nAn exception with condition type &assertion is raised\nif too few or too many actual parameters are supplied.\n\nIf formals is a single variable (not in a list), e.g., z, it\nis bound to a list of the actual parameters.\n\nIf formals is an improper list of variables terminated by a\nvariable, e.g., (x y . z), each variable but the last is bound\nto the corresponding actual parameter.\nThe last variable is bound to a list of the remaining actual parameters.\nAn exception with condition type &assertion is raised\nif too few actual parameters are supplied.\n" "\n" "\nWhen the body is evaluated, the expressions in the body are evaluated in sequence,\nand the procedure returns the values of the last expression.\n" "\nProcedures do not have a printed representation in the usual sense.\nScheme systems print procedures in different ways; this book uses the\nnotation #<procedure>.\n" "\n" "(lambda (x) (+ x 3)) --> #<procedure>\n((lambda (x) (+ x 3)) 7) --> 10\n((lambda (x y) (* x (+ x y))) 7 13) --> 140\n((lambda (f x) (f x x)) + 11) --> 22\n((lambda () (+ 3 4))) --> 7\n\n((lambda (x . y) (list x y))\n 28 37) --> (28 (37))\n((lambda (x . y) (list x y))\n 28 37 47 28) --> (28 (37 47 28))\n((lambda (x y . z) (list x y z))\n 1 2 3 4) --> (1 2 (3 4))\n((lambda x x) 7 13) --> (7 13)\n") ("binding:s13" "\nsyntax: (case-lambda clause ...)\nreturns: a procedure\nlibraries: (rnrs control), (rnrs)\n" "A case-lambda expression consists of a set of clauses, each\nresembling a lambda expression.\nEach clause has the form below.\n" "\n" "[formals body1 body2 ...]\n" "The formal parameters of a clause are defined by formals in the\nsame manner as for a lambda expression.\nThe number of arguments accepted by the procedure value of a\ncase-lambda expression is\ndetermined by the numbers of arguments accepted by the individual\nclauses.\n" "\nWhen a procedure created with case-lambda is invoked, the clauses\nare considered in order.\nThe first clause that accepts the given number of actual parameters is\nselected, the formal parameters defined by its formals are\nbound to the corresponding actual parameters, and the body is\nevaluated as described for lambda above.\nIf formals in a clause is a proper list of identifiers, then\nthe clause accepts exactly as many actual parameters as there are\nformal parameters (identifiers) in formals.\nAs with a lambda formals, a case-lambda clause\nformals\nmay be a single identifier, in which case the clause accepts any\nnumber of arguments, or an improper list of identifiers terminated\nby an identifier, in which\ncase the clause accepts any number of arguments greater than or\nequal to the number of formal parameters excluding the terminating\nidentifier.\nIf no clause accepts the number of actual parameters supplied, an\nexception with condition type &assertion is raised.\n" "\nThe following definition for make-list uses case-lambda to\nsupport an optional fill parameter.\n" "\n" "(define make-list\n  (case-lambda\n    [(n) (make-list n #f)]\n    [(n x)\n     (do ([n n (- n 1)] [ls '() (cons x ls)])\n         ((zero? n) ls))]))\n" "The substring procedure may be extended with case-lambda to\naccept either no end index, in which case it defaults to the\nend of the string, or no start and end indices, in which\ncase substring is equivalent to string-copy:\n" "\n" "(define substring1\n  (case-lambda\n    [(s) (substring1 s 0 (string-length s))]\n    [(s start) (substring1 s start (string-length s))]\n    [(s start end) (substring s start end)]))\n" "It is also possible to default the start index rather than\nthe end index when only one index is supplied:\n" "\n" "(define substring2\n  (case-lambda\n    [(s) (substring2 s 0 (string-length s))]\n    [(s end) (substring2 s 0 end)]\n    [(s start end) (substring s start end)]))\n" "It is even possible to require that both or neither of the start\nand end indices be supplied, simply by leaving out the middle\nclause:\n" "\n" "(define substring3\n  (case-lambda\n    [(s) (substring3 s 0 (string-length s))]\n    [(s start end) (substring s start end)]))\n") ("binding:s16" "\nsyntax: (let ((var expr) ...) body1 body2 ...)\nreturns: the values of the final body expression\nlibraries: (rnrs base), (rnrs)\n" "let establishes local variable bindings.\nEach variable var is bound to the value of the corresponding\nexpression expr.\nThe body of the let, in which the variables are bound, is\nthe sequence of subforms body1 body2 ... and is\nprocessed and evaluated like a lambda body.\n" "\nThe forms let, let*, letrec, and letrec*\n(the others are described after let) are similar but serve\nslightly different purposes.\nWith let, in contrast with let*, letrec, and letrec*,\nthe expressions expr ... are all outside the scope of\nthe variables var ....\nAlso, in contrast with let* and letrec*, no ordering is implied for the\nevaluation of the expressions expr ....\nThey may be evaluated from left to right, from right to left, or\nin any other order at the discretion of the implementation.\nUse let whenever the values are independent of the variables\nand the order of evaluation is unimportant.\n" "\n" "(let ([x (* 3.0 3.0)] [y (* 4.0 4.0)])\n  (sqrt (+ x y))) --> 5.0\n\n(let ([x 'a] [y '(b c)])\n  (cons x y)) --> (a b c)\n\n(let ([x 0] [y 1])\n  (let ([x y] [y x])\n    (list x y))) --> (1 0)\n" "The following definition of let shows the\ntypical derivation of let from lambda.\n" "\n" "(define-syntax let\n  (syntax-rules ()\n    [(_ ((x e) ...) b1 b2 ...)\n     ((lambda (x ...) b1 b2 ...) e ...)]))\n" "Another form of let, named let, is described in\nSection 5.4, and a definition of the full\nlet can be found on page 312.\n\n") ("binding:s18" "\nsyntax: (let* ((var expr) ...) body1 body2 ...)\nreturns: the values of the final body expression\nlibraries: (rnrs base), (rnrs)\n" "let* is similar to let except that the\nexpressions expr ... are evaluated in sequence\nfrom left to right, and\neach of these expressions is within the scope of the variables to the\nleft.\nUse let* when there is a linear dependency among the values or\nwhen the order of evaluation is important.\n" "\n" "(let* ([x (* 5.0 5.0)]\n       [y (- x (* 4.0 4.0))])\n  (sqrt y)) --> 3.0\n\n(let ([x 0] [y 1])\n  (let* ([x y] [y x])\n    (list x y))) --> (1 1)\n" "Any let* expression may be converted to a set of\nnested let expressions.\nThe following definition of let* demonstrates\nthe typical transformation.\n" "\n" "(define-syntax let*defn:let*\n  (syntax-rules ()\n    [(_ () e1 e2 ...)\n     (let () e1 e2 ...)]\n    [(_ ((x1 v1) (x2 v2) ...) e1 e2 ...)\n     (let ((x1 v1))\n       (let* ((x2 v2) ...) e1 e2 ...))]))\n") ("binding:s20" "\nsyntax: (letrec ((var expr) ...) body1 body2 ...)\nreturns: the values of the final body expression\nlibraries: (rnrs base), (rnrs)\n" "letrec is similar to let and let*, except\nthat all of the expressions expr ...\nare within the scope of all of the variables var ....\nletrec allows the definition of\nmutually recursive procedures.\n" "\n" "(letrec ([sum (lambda (x)\n                (if (zero? x)\n                    0\n                    (+ x (sum (- x 1)))))])\n  (sum 5)) --> 15\n" "The order of evaluation of the expressions\nexpr ... is unspecified, so a program must not\nevaluate a reference\nto any of the variables bound by the letrec expression before\nall of the values have been computed.\n(Occurrence of a variable within a lambda expression does\nnot count as a reference, unless the resulting procedure is applied\nbefore all of the values have been computed.)\nIf this restriction is violated, an exception with condition type\n&assertion is raised.\n" "\nAn expr should not return more than once.\nThat is, it should not return both normally and via the invocation of a\ncontinuation obtained during its evaluation, and it should not return\ntwice via two invocations of such a continuation.\nImplementations are not required to detect a violation of this restriction,\nbut if they do, an exception with condition type &assertion is\nraised.\n" "\nChoose letrec over let or let* when there is a\ncircular dependency among the variables and their values and\nwhen the order of evaluation is unimportant.\nChoose letrec* over letrec when there is a circular\ndependency and the bindings need to be evaluated from left to right.\n" "\nA letrec expression of the form\n" "\n" "(letrec ((var expr) ...) body1 body2 ...)\n" "may be expressed in terms of let and set! as\n" "\n" "(let ((var #f) ...)\n  (let ((temp expr) ...)\n    (set! var temp) ...\n    (let () body1 body2 ...)))\n" "where temp ... are fresh variables, i.e., ones\nthat do not already appear in the letrec expression,\none for each (var expr) pair.\nThe outer let expression establishes the variable bindings.\nThe initial value given each variable is unimportant, so any value\nsuffices in place of #f.\nThe bindings are established first so that expr ...\nmay contain\noccurrences of the variables, i.e., so that the expressions are computed\nwithin the scope of the variables.\nThe middle let evaluates the values and binds them to the temporary\nvariables, and the set! expressions assign each variable\nto the corresponding value.\nThe inner let is present in case the body contains internal\ndefinitions.\n" "\nA definition of letrec that uses this transformation is shown\non page 310.\n" "\nThis transformation does not enforce the restriction that\nthe expr expressions must not evaluate any references of or\nassignments to the variables.\nMore elaborate transformations that enforce this restriction and\nactually produce more efficient code are\npossible [citation31].\n") ("binding:s22" "\ndesc:letrec*\nsyntax: (letrec* ((var expr) ...) body1 body2 ...)\nreturns: the values of the final body expression\nlibraries: (rnrs base), (rnrs)\n" "letrec* is similar to letrec, except that\nletrec* evaluates expr ... in sequence from left to right.\nWhile programs must still not evaluate a reference to any var\nbefore the corresponding expr has been evaluated, references to\nvar may be evaluated any time thereafter, including during\nthe evaluation of the expr of any subsequent binding.\n" "\nA letrec* expression of the form\n" "\n" "(letrec* ((var expr) ...) body1 body2 ...)\n" "may be expressed in terms of let and set! as\n" "\n" "(let ((var #f) ...)\n  (set! var expr) ...\n  (let () body1 body2 ...))\n" "The outer let expression creates the bindings, each assignment\nevaluates an expression and immediately sets the corresponding variable\nto its value, in sequence, and the inner let evaluates the body.\nlet is used in the latter case rather than begin\nsince the body may include internal definitions as well as expressions.\n" "\n" "(letrec* ([sum (lambda (x)\n                 (if (zero? x)\n                     0\n                     (+ x (sum (- x 1)))))]\n          [f (lambda () (cons n n-sum))]\n          [n 15]\n          [n-sum (sum n)])\n  (f)) --> (15 . 120)\n\n(letrec* ([f (lambda () (lambda () g))]\n          [g (f)])\n  (eq? (g) g)) --> #t\n\n(letrec* ([g (f)]\n          [f (lambda () (lambda () g))])\n  (eq? (g) g)) --> exception: attempt to reference undefined variable f\n") ("binding:s23" "\ndesc:let-values\nsyntax: (let-values ((formals expr) ...) body1 body2 ...)\n\nsyntax: (let*-values ((formals expr) ...) body1 body2 ...)\nreturns: the values of the final body expression\nlibraries: (rnrs base), (rnrs)\n" "let-values is a convenient way to receive multiple\nvalues and bind them to variables.\nIt is structured like let but permits an arbitrary\nformals list (like lambda) on each left-hand\nside.\nlet*-values is similar but performs the bindings in\nleft-to-right order, as with let*.\nAn exception with condition type &assertion is raised\nif the number of values returned by an expr is not appropriate\nfor the corresponding formals, as described in the entry\nfor lambda above.\nA definition of let-values is given on page 310.\n" "\n" "(let-values ([(a b) (values 1 2)] [c (values 1 2 3)])\n  (list a b c)) --> (1 2 (1 2 3))\n\n(let*-values ([(a b) (values 1 2)] [(a b) (values b a)])\n  (list a b)) --> (2 1)\n") ("binding:s24" "\nsyntax: (define var expr)\n\nsyntax: (define var)\n\nsyntax: (define (var0 var1 ...) body1 body2 ...)\n\nsyntax: (define (var0 . varr) body1 body2 ...)\n\nsyntax: (define (var0 var1 var2 ... . varr) body1 body2 ...)\nlibraries: (rnrs base), (rnrs)\n" "In the first form, define creates a new binding of var to\nthe value of expr.\nThe expr should not return more than once.\nThat is, it should not return both normally and via the invocation of a\ncontinuation obtained during its evaluation, and it should not return\ntwice via two invocations of such a continuation.\nImplementations are not required to detect a violation of this restriction,\nbut if they do, an exception with condition type &assertion is\nraised.\n" "\nThe second form is equivalent to (define var unspecified),\nwhere unspecified is some unspecified value.\nThe remaining are shorthand forms for\nbinding variables to\nprocedures; they are identical to the following definition in terms of\nlambda.\n" "\n" "(define var\n  (lambda formals\n    body1 body2 ...))\n" "where formals is (var1 ...), varr,\nor (var1 var2 ... . varr) for the third,\nfourth, and fifth define formats.\n" "\nDefinitions may appear at the front of a library body, anywhere\namong the forms of a top-level-program body, and at the front of a\nlambda or case-lambda body or the body of any form\nderived from lambda, e.g., let, or letrec*.\nAny body that begins with a sequence of definitions is transformed\nduring macro expansion into a letrec* expression as described\non page 292.\n" "\nSyntax definitions may appear along with variable definitions wherever\nvariable definitions may appear; see Chapter 8.\n" "\n" "(define x 3)\nx --> 3\n\n(define f\n  (lambda (x y)\n    (* (+ x y) 2)))\n(f 5 4) --> 18\n\n(define (sum-of-squares x y)\n  (+ (* x x) (* y y)))\n(sum-of-squares 3 4) --> 25\n\n(define f\n  (lambda (x)\n    (+ x 1)))\n(let ([x 2])\n  (define f\n    (lambda (y)\n      (+ y x)))\n  (f 3)) --> 5\n(f 3) --> 4\n" "A set of definitions may be grouped by enclosing them in a\nbegin form.\nDefinitions grouped in this manner may appear wherever ordinary\nvariable and syntax definitions may appear.\nThey are treated as if written separately, i.e., without the\nenclosing begin form.\nmulti-define-syntaxThis feature allows syntactic extensions to\nexpand into groups of definitions.\n" "\n" "(define-syntax multi-define-syntax\n  (syntax-rules ()\n    [(_ (var expr) ...)\n     (begin\n       (define-syntax var expr)\n       ...)]))\n(let ()\n  (define plus\n    (lambda (x y)\n        (if (zero? x)\n            y\n            (plus (sub1 x) (add1 y)))))\n  (multi-define-syntax\n    (add1 (syntax-rules () [(_ e) (+ e 1)]))\n    (sub1 (syntax-rules () [(_ e) (- e 1)])))\n  (plus 7 8)) --> 15\n" "Many implementations support an interactive \"top level\" in which variable\nand other definitions may be entered interactively or loaded from files.\nThe behavior of these top-level definitions is outside the scope of the\nRevised6 Report, but as long as top-level variables are defined before\nany references or assignments to them are evaluated, the behavior is\nconsistent across most implementations.\nSo, for example, the reference to g in the top-level definition\nof f below is okay if g is not already defined, and g\nis assumed to name a variable to be defined at some later point.\n" "\n" "(define f\n  (lambda (x)\n    (g x)))\n" "If this is then followed by a definition of g before f is\nevaluated, the assumption that g would be defined as a variable is\nproven correct, and a call to f works as expected.\n" "\n" "(define g\n  (lambda (x)\n    (+ x x)))\n(f 3) --> 6\n" "If g were defined instead as the keyword for a syntactic extension,\nthe assumption that g would be bound as a variable is\nproven false, and if f is not redefined before it is invoked,\nthe implementation is likely to raise an exception.\n\n") ("binding:s28" "\nsyntax: (set! var expr)\nreturns: unspecified\nlibraries: (rnrs base), (rnrs)\n" "set! does not establish a new binding for\nvar but rather alters the value of an existing binding.\nIt first evaluates expr, then assigns\nvar to the value of expr.\nAny subsequent reference to var within the scope of the altered\nbinding evaluates to the new value.\n" "\nAssignments are not employed as frequently in Scheme as in most other\nlanguages, but they are useful for implementing state changes.\n" "\n" "(define flip-flop\n  (let ([state #f])\n    (lambda ()\n      (set! state (not state))\n      state)))\n\n(flip-flop) --> #t\n(flip-flop) --> #f\n(flip-flop) --> #t\n" "Assignments are also useful for caching values.\nThe example below uses a technique called memoization,\nin which a procedure records the values associated with old\ninput values so it need not recompute them, to implement a fast\nversion of the otherwise exponential doubly recursive definition\nof the Fibonacci function (see\npage 69).\n" "\n" "(define memoize\n  (lambda (proc)\n    (let ([cache '()])\n      (lambda (x)\n        (cond\n          [(assq x cache) => cdr]\n          [else\n           (let ([ans (proc x)])\n             (set! cache (cons (cons x ans) cache))\n             ans)])))))\n\n(define fibonacci\n  (memoize\n    (lambda (n)\n      (if (< n 2)\n          1\n          (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))))\n\n(fibonacci 100) --> 573147844013817084101\n") ("exceptions:s3" "\nprocedure: (raise obj)\n\nprocedure: (raise-continuable obj)\nreturns: see below\nlibraries: (rnrs exceptions), (rnrs)\n" "Both of these procedures raise an exception, effectively invoking the\ncurrent exception handler, passing obj as the only argument.\nFor raise, the exception is non-continuable, while\nfor raise-continuable, the exception is continuable.\nAn exception handler may return (with zero or more values) to the\ncontinuation of a continuable exception.\nIf an exception handler attempts to return to the continuation of a\nnon-continuable exception, however, a new exception with condition type\n&non-continuable is raised.\nThus, raise never returns, while raise-continuable\nmay return zero or more values, depending upon the exception handler.\n" "\nIf the current exception handler, p, was established via a\nguard form or call to with-exception-handler, the\ncurrent exception handler is reset to the handler that was current when\np was established before raise or\nraise-continuable invokes p.\nThis allows p to defer to the preexisting exception handler simply\nby reraising the exception, and it helps prevent infinite regression when\nan exception handler inadvertently causes a different exception to be raised.\nIf p returns and the exception is continuable, p is\nreinstated as the current exception handler.\n" "\n" "(raise\n  (condition\n    (make-error)\n    (make-message-condition \"no go\"))) --> error: no go\n(raise-continuable\n  (condition\n    (make-violation)\n    (make-message-condition \"oops\"))) --> violation: oops\n(list\n  (call/cc\n    (lambda (k)\n      (vector\n        (with-exception-handler\n          (lambda (x) (k (+ x 5)))\n          (lambda () (+ (raise 17) 8))))))) --> (22)\n(list\n  (vector\n    (with-exception-handler\n      (lambda (x) (+ x 5))\n      (lambda () (+ (raise-continuable 17) 8))))) --> (#(30))\n(list\n  (vector\n    (with-exception-handler\n      (lambda (x) (+ x 5))\n      (lambda () (+ (raise 17) 8))))) --> violation: non-continuable\n") ("exceptions:s4" "\nprocedure: (error who msg irritant ...)\n\nprocedure: (assertion-violation who msg irritant ...)\nlibraries: (rnrs base), (rnrs)\n" "error raises a non-continuable exception with condition type\n&error and should be used to describe situations for which the\n&error condition type is appropriate, typically a situation\ninvolving the program's interaction with something outside of the program.\nassertion-violation raises a non-continuable exception with\ncondition type &assertion and should be used to describe\nsituations for which the &assertion condition type is\nappropriate, typically an invalid argument to a procedure or invalid value\nof a subexpression of a syntactic form.\n" "\nThe continuation object with which the exception is raised also includes\na &who condition whose who field is who if who is\nnot #f, a &message condition whose message field is\nmsg, and an &irritants condition whose irritants field\nis (irritant ...).\n" "\nwho must be a string, a symbol, or #f identifying the procedure\nor syntactic form reporting the error upon whose behalf the error is being\nreported.\nIt is usually best to identify a procedure the programmer has called rather\nthan some other procedure the programmer may not be aware is involved in\ncarrying out the operation.\nmsg must be a string and should describe the exceptional situation.\nThe irritants may be any Scheme objects and should include values that may\nhave caused or been materially involved in the exceptional situation.\n") ("exceptions:s5" "\nsyntax: (assert expression)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "assert evaluates expression and returns the value of\nexpression if the value is not #f.\nIf the value of expression is #f, assert raises a\nnon-continuable exception with condition types &assertion and\n&message, with an implementation-dependent value in its message\nfield.\nImplementations are encouraged to provide information about the location\nof the assert call within the condition whenever possible.\n\n") ("exceptions:s6" "\nprocedure: (syntax-violation who msg form)\n\nprocedure: (syntax-violation who msg form subform)\nreturns: does not return\nlibraries: (rnrs syntax-case), (rnrs)\n" "This procedure raises a non-continuable exception with a condition of type\n&syntax.\nIt should be used to report a syntax error detected by the transformer of\na syntactic extension.\nThe value of the condition's form field is form, and the value of\nits subform field is subform, or #f if subform is\nnot provided.\n" "\nThe continuation object with which the exception is raised also includes\na &who condition whose who field is who, if who is\nnot #f or is inferred from form, and a &message\ncondition whose message field is msg.\n" "\nwho must be a string, a symbol, or #f.\nIf who is #f, it is inferred to be the symbolic name of form\nif form is an identifier or the symbolic name of the first subform\nof form if form is a list-structured form whose first subform\nis an identifier.\nmessage must be a string.\nform should be the syntax object or datum representation of the\nsyntactic form within which the syntax violation occurred, and\nsubform, if not #f, should be a syntax object or datum\nrepresentation of a subform more specifically involved in the violation.\nFor example, if a duplicate formal parameter is found in a lambda expression,\nform might be the lambda expression and subform might be\nthe duplicated parameter.\n" "\nSome implementations attach source information to syntax objects, e.g.,\nline, character, and filename for forms originating in a file, in which case\nthis information might also be present as some implementation-dependent\ncondition type within the condition object.\n") ("exceptions:s7" "\nprocedure: (with-exception-handler procedure thunk)\nreturns: see below\nlibraries: (rnrs exceptions), (rnrs)\n" "This procedure establishes procedure, which should accept one argument,\nas the current exception handler in place of the old current exception handler,\nold-proc, and invokes thunk without arguments.\nIf the call to thunk returns, old-proc is reestablished as\nthe current exception handler and the values returned by thunk are\nreturned.\nIf control leaves or subsequently reenters the call to thunk via the\ninvocation of a continuation obtained via call/cc, the procedure\nthat was the current exception handler when the continuation was\ncaptured is reinstated.\n" "\n" "(define (try thunk)\n  (call/cc\n    (lambda (k)\n      (with-exception-handler\n        (lambda (x) (if (error? x) (k #f) (raise x)))\n        thunk))))\n(try (lambda () 17)) --> 17\n(try (lambda () (raise (make-error)))) --> #f\n(try (lambda () (raise (make-violation)))) --> violation\n(with-exception-handler\n  (lambda (x)\n    (raise\n      (apply condition\n        (make-message-condition \"oops\")\n        (simple-conditions x))))\n  (lambda ()\n    (try (lambda () (raise (make-violation)))))) --> violation: oops\n") ("exceptions:s8" "\nsyntax: (guard (var clause1 clause2 ...) b1 b2 ...)\nreturns: see below\nlibraries: (rnrs exceptions), (rnrs)\n" "A guard expression establishes a new current exception handler,\nprocedure (described below), in place of the old current exception handler, old-proc,\nand evaluates the body b1 b2 ....\nIf the body returns, guard reestablishes old-proc as the current\nexception handler.\nIf control leaves or subsequently reenters the body via the\ninvocation of a continuation obtained via call/cc, the procedure\nthat was the current exception handler when the continuation was\ncaptured is reinstated.\n" "\nThe procedure procedure established by guard binds var\nto the value it receives and, within the scope of that binding, processes\nthe clauses clause1 clause2 ... in turn, as\nif contained within an implicit cond expression.\nThis implicit cond expression is evaluated in the continuation\nof the guard expression, with old-proc as the current\nexception handler.\n" "\nIf no else clause is provided, guard supplies one\nthat reraises the exception with the same value, as if with\nraise-continuable, in the continuation of the call to procedure,\nwith old-proc as the current exception handler.\n" "\n" "(guard (x [else x]) (raise \"oops\")) --> \"oops\"\n(guard (x [#f #f]) (raise (make-error))) -->  error\n(define-syntax try\n  (syntax-rules ()\n    [(_ e1 e2 ...)\n     (guard (x [(error? x) #f]) e1 e2 ...)]))\n(define open-one\n  (lambda fn*\n    (let loop ([ls fn*])\n      (if (null? ls)\n          (error 'open-one \"all open attempts failed\" fn*)\n          (or (try (open-input-file (car ls)))\n              (loop (cdr ls)))))))\n; say bar.ss exists but not foo.ss:\n(open-one \"foo.ss\" \"bar.ss\") --> #<input port bar.ss>\n") ("exceptions:s13" "\nsyntax: &condition\nlibraries: (rnrs conditions), (rnrs)\n" "&condition is a record-type name (Chapter 9) and\nthe root of the condition-type hierarchy.\nAll simple condition types are extensions of this type, and all\nconditions, whether simple or compound, are considered instances\nof this type.\n") ("exceptions:s14" "\nprocedure: (condition? obj)\nreturns: #t if obj is a condition object, otherwise #f\nlibraries: (rnrs conditions), (rnrs)\n" "A condition object is an instance of a subtype of &condition\nor a compound condition, possibly created by user code with\ncondition.\n" "\n" "(condition? 'stable) --> #f\n(condition? (make-error)) --> #t\n(condition? (make-message-condition \"oops\")) --> #t\n(condition?\n  (condition\n    (make-error)\n    (make-message-condition \"no such element\"))) --> #t\n") ("exceptions:s15" "\nprocedure: (condition condition ...)\nreturns: a condition, possibly compound\nlibraries: (rnrs conditions), (rnrs)\n" "condition is used to create condition objects that may consist\nof multiple simple conditions.\nEach argument condition may be simple or complex; if simple, it is\ntreated as a compound condition with itself as its only simple condition.\nThe simple conditions of the result condition are the simple conditions of\nthe condition arguments, flattened into a single list and appearing\nin order, with the simple conditions of the first condition followed\nby the simple conditions of the second, and so on.\n" "\nIf the list has exactly one element, the result condition may be simple or\ncompound; otherwise it is compound.\nThe distinction between simple and compound conditions is not usually\nimportant but can be detected, if define-record-type rather\nthan define-condition-type is used to extend an existing\ncondition type, via the predicate defined by define-record-type.\n" "\n" "(condition) --> #<condition>\n(condition\n  (make-error)\n  (make-message-condition \"oops\")) --> #<condition>\n\n(define-record-type (&xcond make-xcond xcond?) (parent &condition))\n(xcond? (make-xcond)) --> #t\n(xcond? (condition (make-xcond))) --> #t or #f\n(xcond? (condition)) --> #f\n(xcond? (condition (make-error) (make-xcond))) --> #f\n") ("exceptions:s16" "\nprocedure: (simple-conditions condition)\nreturns: a list of the simple conditions of condition\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "\n(simple-conditions (condition)) --> '()\n(simple-conditions (make-error)) --> (#<condition &error>)\n(simple-conditions (condition (make-error))) --> (#<condition &error>)\n(simple-conditions\n  (condition\n    (make-error)\n    (make-message-condition\n      \"oops\"))) --> (#<condition &error> #<condition &message>)\n\n(let ([c1 (make-error)]\n      [c2 (make-who-condition \"f\")]\n      [c3 (make-message-condition \"invalid argument\")]\n      [c4 (make-message-condition\n            \"error occurred while reading from file\")]\n      [c5 (make-irritants-condition '(\"a.ss\"))])\n  (equal?\n    (simple-conditions\n      (condition\n        (condition (condition c1 c2) c3)\n        (condition c4 (condition c5))))\n    (list c1 c2 c3 c4 c5))) --> #t\n") ("exceptions:s17" "\nsyntax: (define-condition-type name parent constructor pred field ...)\nlibraries: (rnrs conditions), (rnrs)\n" "A define-condition-type form is a definition and may appear anywhere other\ndefinitions may appear.\nIt is used to define new simple condition types.\n" "\nThe subforms name, parent, constructor, and pred\nmust be identifiers.\nEach field must be of the form\n(field-name accessor-name),\nwhere field-name and accessor-name are identifiers.\n" "\ndefine-condition-type defines name as a new record type whose\nparent record type is parent, whose constructor name is\nconstructor, whose predicate name is pred, whose fields\nare field-name ..., and whose field accessors are named\nby accessor-name ....\n" "\nWith the exception of the predicate and field accessors,\ndefine-condition-type is essentially an ordinary record\ndefinition equivalent to\n" "\n" "(define-record-type (name constructor pred)\n  (parent parent)\n  (fields ((immutable field-name accessor-name) ...)))\n" "The predicate differs from one that would be generated by a\ndefine-record-type form in that it returns #t not only\nfor an instance of the new type but also for compound conditions whose simple\nconditions include an instance of the new type.\nSimilarly, field accessors accept instances of the new type as well as\ncompound conditions whose simple conditions include at least one\ninstance of the new record type.\nIf an accessor receives a compound condition whose simple conditions\nlist includes one or more instances of the new type, the accessor\noperates on the first instance in the list.\n" "\n" "(define-condition-type &mistake &condition make-mistake mistake?\n  (type mistake-type))\n\n(mistake? 'booboo) --> #f\n\n(define c1 (make-mistake 'spelling))\n(mistake? c1) --> #t\n(mistake-type c1) --> spelling\n\n(define c2 (condition c1 (make-irritants-condition '(eggregius))))\n(mistake? c2) --> #t\n(mistake-type c2) --> spelling\n(irritants-condition? c2) --> #t\n(condition-irritants c2) --> (eggregius)\n") ("exceptions:s18" "\nprocedure: (condition-predicate rtd)\nreturns: a condition predicate\n\nprocedure: (condition-accessor rtd procedure)\nreturns: a condition accessor\nlibraries: (rnrs conditions), (rnrs)\n" "These procedures may be used to create the same kind of special predicates\nand accessors that are created by define-record-type from a\nrecord-type descriptor, rtd, of a simple condition type or other\ntype derived from a simple condition type.\n" "\nFor both procedures, rtd must be a record-type descriptor of a\nsubtype of &condition, and for condition-accessor,\nprocedure should accept one argument.\n" "\nThe predicate returned by condition-predicate accepts one\nargument, which may be any Scheme value.\nThe predicate returns #t if the value is a condition of the type\ndescribed by rtd, i.e., an instance of the type described by\nrtd (or one of its subtypes) or a compound condition whose simple\nconditions include an instance of the type described by rtd.\nOtherwise, the predicate returns #f.\n" "\nThe accessor returned by condition-accessor accepts one argument,\nc, which must be a condition of the type described by rtd.\nThe accessor applies procedure to a single argument, the first element\nof c's simple condition list that is an instance of the type\ndescribed by rtd (this is c itself if c is a simple\ncondition), and returns the result of this application.\nIn most situations, procedure is a record accessor for a field of the\ntype described by rtd.\n" "\n" "(define-record-type (&mistake make-mistake $mistake?)\n  (parent &condition)\n  (fields (immutable type $mistake-type)))\n\n; define predicate and accessor as if we'd used define-condition-type\n(define rtd (record-type-descriptor &mistake))\n(define mistake? (condition-predicate rtd))\n(define mistake-type (condition-accessor rtd $mistake-type))\n\n(define c1 (make-mistake 'spelling))\n(define c2 (condition c1 (make-irritants-condition '(eggregius))))\n(list (mistake? c1) (mistake? c2)) --> (#t #t)\n(list ($mistake? c1) ($mistake? c2)) --> (#t #f)\n(mistake-type c1) --> spelling\n($mistake-type c1) --> spelling\n(mistake-type c2) --> spelling\n($mistake-type c2) --> violation\n") ("exceptions:s19" "\nsyntax: &serious\n\nprocedure: (make-serious-condition)\nreturns: a condition of type &serious\n\nprocedure: (serious-condition? obj)\nreturns: #t if obj is a condition of type &serious, #f otherwise\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "Conditions of this type indicate situations\nof a serious nature that, if uncaught, generally result in\ntermination of the program's execution.\nConditions of this type typically occur as one of the more\nspecific subtypes &error or &violation.\nThis condition type might be defined as follows.\n" "(define-condition-type &serious &condition\n  make-serious-condition serious-condition?)\n") ("exceptions:s20" "\nsyntax: &violation\n\nprocedure: (make-violation)\nreturns: a condition of type &violation\n\nprocedure: (violation? obj)\nreturns: #t if obj is a condition of type &violation, #f otherwise\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "Conditions of this type indicate that the program has violated\nsome requirement, usually due to a bug in the program.\nThis condition type might be defined as follows.\n" "(define-condition-type &violation &serious\n  make-violation violation?)\n") ("exceptions:s21" "\nsyntax: &assertion\n\nprocedure: (make-assertion-violation)\nreturns: a condition of type &assertion\n\nprocedure: (assertion-violation? obj)\nreturns: #t if obj is a condition of type &assertion, #f otherwise\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "This condition type indicates a specific violation in which \nthe program has passed the wrong number or types of arguments to\na procedure.\nThis condition type might be defined as follows.\n" "(define-condition-type &assertion &violation\n  make-assertion-violation assertion-violation?)\n") ("exceptions:s22" "\nsyntax: &error\n\nprocedure: (make-error)\nreturns: a condition of type &error\n\nprocedure: (error? obj)\nreturns: #t if obj is a condition of type &error, #f otherwise\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "Conditions of this type indicate that an error has occurred with\nthe program's interaction with its operating environment, such as\nthe failure of an attempt to open a file.\nIt is not used to describe situations in which an error in the\nprogram has been detected.\nThis condition type might be defined as follows.\n" "(define-condition-type &error &serious\n  make-error error?)\n") ("exceptions:s23" "\nsyntax: &warning\n\nprocedure: (make-warning)\nreturns: a condition of type &warning\n\nprocedure: (warning? obj)\nreturns: #t if obj is a condition of type &warning, #f otherwise\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "Warning conditions indicate situations that do not prevent the program\nfrom continuing its execution but, in some cases, might result in a more\nserious problem at some later point.\nFor example, a compiler might use a condition of this type to indicate\nthat it has processed a call to a standard procedure with the wrong\nnumber of arguments; this will not become a serious problem unless the\ncall is actually evaluated at some later point.\nThis condition type might be defined as follows.\n" "(define-condition-type &warning &condition\n  make-warning warning?)\n") ("exceptions:s24" "\nsyntax: &message\n\nprocedure: (make-message-condition message)\nreturns: a condition of type &message\n\nprocedure: (message-condition? obj)\nreturns: #t if obj is a condition of type &message, #f otherwise\n\nprocedure: (condition-message condition)\nreturns: the contents of condition's message field\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "Conditions of this type are usually included with a &warning\ncondition or one of the &serious condition subtypes to provide a more\nspecific description of the exceptional situation.\nThe message argument to the constructor may be any\nScheme value but is typically a string.\nThis condition type might be defined as follows.\n" "(define-condition-type &message &condition\n  make-message-condition message-condition?\n  (message condition-message))\n") ("exceptions:s25" "\nsyntax: &irritants\n\nprocedure: (make-irritants-condition irritants)\nreturns: a condition of type &irritants\n\nprocedure: (irritants-condition? obj)\nreturns: #t if obj is a condition of type &irritants, #f otherwise\n\nprocedure: (condition-irritants condition)\nreturns: the contents of condition's irritants field\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "Conditions of this type are usually included with a &message\ncondition to provide information about Scheme values that may have caused\nor been materially involved in the exceptional situation.\nFor example, if a procedure receives the wrong type of argument, it\nmay raise an exception with a compound condition consisting of an\nassertion condition, a who condition naming the procedure,\na message condition stating that the wrong type\nof argument was received, and an irritants condition listing the\nargument.\nThe irritants argument to the constructor should\nbe a list.\nThis condition type might be defined as follows.\n" "(define-condition-type &irritants &condition\n  make-irritants-condition irritants-condition?\n  (irritants condition-irritants))\n") ("exceptions:s26" "\nsyntax: &who\n\nprocedure: (make-who-condition who)\nreturns: a condition of type &who\n\nprocedure: (who-condition? obj)\nreturns: #t if obj is a condition of type &who, #f otherwise\n\nprocedure: (condition-who condition)\nreturns: the contents of condition's who field\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "Conditions of this type are often included with a &message\ncondition to identify the syntactic form or procedure that detected\nthe error.\nThe who argument to the constructor should\nbe a symbol or string.\nThis condition type might be defined as follows.\n" "(define-condition-type &who &condition\n  make-who-condition who-condition?\n  (who condition-who))\n") ("exceptions:s27" "\nsyntax: &non-continuable\n\nprocedure: (make-non-continuable-violation)\nreturns: a condition of type &non-continuable\n\nprocedure: (non-continuable-violation? obj)\nreturns: #t if obj is a condition of type &non-continuable, #f otherwise\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "Conditions of this type indicate that a non-continuable violation has occurred.\nraise raises an exception with this type if the current exception\nhandler returns.\nThis condition type might be defined as follows.\n" "(define-condition-type &non-continuable &violation\n  make-non-continuable-violation\n  non-continuable-violation?)\n") ("exceptions:s28" "\nsyntax: &implementation-restriction\n\nprocedure: (make-implementation-restriction-violation)\nreturns: a condition of type &implementation-restriction\n\nprocedure: (implementation-restriction-violation? obj)\nreturns: #t if obj is a condition of type &implementation-restriction, #f otherwise\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "An implementation-restriction condition indicates that the program has attempted\nto exceed some limitation in the implementation, such as when the value of a\nfixnum addition operation would result in a number that exceeds the implementation's\nfixnum range.\nIt does not normally indicate a deficiency in the implementation but rather a\nmismatch between what the program is attempting to do and what the implementation\ncan support.\nIn many cases, implementation restrictions are dictated by the underlying hardware.\nThis condition type might be defined as follows.\n" "(define-condition-type &implementation-restriction &violation\n  make-implementation-restriction-violation\n  implementation-restriction-violation?)\n") ("exceptions:s29" "\nsyntax: &lexical\n\nprocedure: (make-lexical-violation)\nreturns: a condition of type &lexical\n\nprocedure: (lexical-violation? obj)\nreturns: #t if obj is a condition of type &lexical, #f otherwise\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "Conditions of this type indicate that a lexical error has occurred in the parsing\nof a Scheme program or datum, such as mismatched parentheses or an invalid character\nappearing within a numeric constant.\nThis condition type might be defined as follows.\n" "(define-condition-type &lexical &violation\n  make-lexical-violation lexical-violation?)\n") ("exceptions:s30" "\nsyntax: &syntax\n\nprocedure: (make-syntax-violation form subform)\nreturns: a condition of type &syntax\n\nprocedure: (syntax-violation? obj)\nreturns: #t if obj is a condition of type &syntax, #f otherwise\n\nprocedure: (syntax-violation-form condition)\nreturns: the contents of condition's form field\n\nprocedure: (syntax-violation-subform condition)\nreturns: the contents of condition's subform field\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "Conditions of this type indicate that a syntax error has occurred in the parsing\nof a Scheme program.\nIn most implementations, syntax errors are detected by the macro expander.\nEach of the form and subform arguments to\nmake-syntax-violation should be a syntax object\n(Section 8.3) or datum, the former indicating the containing\nform and the latter indicating the specific subform.\nFor example, if a duplicate formal parameter is found in a lambda expression,\nform might be the lambda expression and subform might be\nthe duplicated parameter.\nIf there is no need to identify a subform, subform should be #f.\nThis condition type might be defined as follows.\n" "(define-condition-type &syntax &violation\n  make-syntax-violation syntax-violation?\n  (form syntax-violation-form)\n  (subform syntax-violation-subform))\n") ("exceptions:s31" "\nsyntax: &undefined\n\nprocedure: (make-undefined-violation)\nreturns: a condition of type &undefined\n\nprocedure: (undefined-violation? obj)\nreturns: #t if obj is a condition of type &undefined, #f otherwise\nlibraries: (rnrs conditions), (rnrs)\n" "\n" "An undefined condition indicates an attempt to reference an unbound variable.\nThis condition type might be defined as follows.\n" "(define-condition-type &undefined &violation\n  make-undefined-violation undefined-violation?)\n" "" "The next several condition types describe conditions that occur when\ninput or output operations fail in some manner.\n") ("exceptions:s32" "\nsyntax: &i/o\n\nprocedure: (make-i/o-error)\nreturns: a condition of type &i/o\n\nprocedure: (i/o-error? obj)\nreturns: #t if obj is a condition of type &i/o, #f otherwise\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)\n" "\n" "A condition of type &i/o indicates that an input/output error\nof some sort has occurred.\nConditions of this type typically occur as one of the more\nspecific subtypes described below.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o &error\n  make-i/o-error i/o-error?)\n") ("exceptions:s33" "\nsyntax: &i/o-read\n\nprocedure: (make-i/o-read-error)\nreturns: a condition of type &i/o-read\n\nprocedure: (i/o-read-error? obj)\nreturns: #t if obj is a condition of type &i/o-read, #f otherwise\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)\n" "\n" "This condition type indicates that an error has occurred while reading\nfrom a port.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-read &i/o\n  make-i/o-read-error i/o-read-error?)\n") ("exceptions:s34" "\nsyntax: &i/o-write\n\nprocedure: (make-i/o-write-error)\nreturns: a condition of type &i/o-write\n\nprocedure: (i/o-write-error? obj)\nreturns: #t if obj is a condition of type &i/o-write, #f otherwise\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)\n" "\n" "This condition type indicates that an error has occurred while writing\nto a port.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-write &i/o\n  make-i/o-write-error i/o-write-error?)\n") ("exceptions:s35" "\nsyntax: &i/o-invalid-position\n\nprocedure: (make-i/o-invalid-position-error position)\nreturns: a condition of type &i/o-invalid-position\n\nprocedure: (i/o-invalid-position-error? obj)\nreturns: #t if obj is a condition of type &i/o-invalid-position, #f otherwise\n\nprocedure: (i/o-error-position condition)\nreturns: the contents of condition's position field\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)\n" "\n" "This condition type indicates an attempt to set a port's position to a\nposition that is out of range for the underlying file or other object.\nThe position argument to the constructor\nshould be the invalid position.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-invalid-position &i/o\n  make-i/o-invalid-position-error\n  i/o-invalid-position-error?\n  (position i/o-error-position))\n") ("exceptions:s36" "\nsyntax: &i/o-filename\n\nprocedure: (make-i/o-filename-error filename)\nreturns: a condition of type &i/o-filename\n\nprocedure: (i/o-filename-error? obj)\nreturns: #t if obj is a condition of type &i/o-filename, #f otherwise\n\nprocedure: (i/o-error-filename condition)\nreturns: the contents of condition's filename field\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)\n" "\n" "This condition type indicates an input/output error that occurred\nwhile operating on a file.\nThe filename argument to the constructor should\nbe the name of the file.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-filename &i/o\n  make-i/o-filename-error i/o-filename-error?\n  (filename i/o-error-filename))\n") ("exceptions:s37" "\nsyntax: &i/o-file-protection\n\nprocedure: (make-i/o-file-protection-error filename)\nreturns: a condition of type &i/o-file-protection\n\nprocedure: (i/o-file-protection-error? obj)\nreturns: #t if obj is a condition of type &i/o-file-protection, #f otherwise\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)\n" "\n" "A condition of this type indicates that an attempt has been made to perform\nsome input/output operation on a file for which the program does not have the\nproper permission.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-file-protection &i/o-filename\n  make-i/o-file-protection-error\n  i/o-file-protection-error?)\n") ("exceptions:s38" "\nsyntax: &i/o-file-is-read-only\n\nprocedure: (make-i/o-file-is-read-only-error filename)\nreturns: a condition of type &i/o-file-is-read-only\n\nprocedure: (i/o-file-is-read-only-error? obj)\nreturns: #t if obj is a condition of type &i/o-file-is-read-only, #f otherwise\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)\n" "\n" "A condition of this type indicates an attempt to treat as writeable a read-only file.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-file-is-read-only &i/o-file-protection\n  make-i/o-file-is-read-only-error\n  i/o-file-is-read-only-error?)\n") ("exceptions:s39" "\nsyntax: &i/o-file-already-exists\n\nprocedure: (make-i/o-file-already-exists-error filename)\nreturns: a condition of type &i/o-file-already-exists\n\nprocedure: (i/o-file-already-exists-error? obj)\nreturns: #t if obj is a condition of type &i/o-file-already-exists, #f otherwise\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)\n" "\n" "A condition of this type indicates a situation in which an operation on a file\nfailed because the file already exists, e.g., an attempt is made to open an\nexisting file for output without the no-fail file option.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-file-already-exists &i/o-filename\n  make-i/o-file-already-exists-error\n  i/o-file-already-exists-error?)\n") ("exceptions:s40" "\nsyntax: &i/o-file-does-not-exist\n\nprocedure: (make-i/o-file-does-not-exist-error filename)\nreturns: a condition of type &i/o-file-does-not-exist\n\nprocedure: (i/o-file-does-not-exist-error? obj)\nreturns: #t if obj is a condition of type &i/o-file-does-not-exist, #f otherwise\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)\n" "\n" "A condition of this type indicates a situation in which an operation on a file\nfailed because the file does not exist, e.g., an attempt is made to open a\nnonexistent file for input only.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-file-does-not-exist &i/o-filename\n  make-i/o-file-does-not-exist-error\n  i/o-file-does-not-exist-error?)\n") ("exceptions:s41" "\nsyntax: &i/o-port\n\nprocedure: (make-i/o-port-error pobj)\nreturns: a condition of type &i/o-port\n\nprocedure: (i/o-port-error? obj)\nreturns: #t if obj is a condition of type &i/o-port, #f otherwise\n\nprocedure: (i/o-error-port condition)\nreturns: the contents of condition's pobj field\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)\n" "\n" "A condition of this type is usually included with a condition of one of the other &i/o\nsubtypes to indicate the port involved in the exceptional situation, if a port\nis involved.\nThe pobj argument to the constructor should be the port.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-port &i/o\n  make-i/o-port-error i/o-port-error?\n  (pobj i/o-error-port))\n") ("exceptions:s42" "\nsyntax: &i/o-decoding\n\nprocedure: (make-i/o-decoding-error pobj)\nreturns: a condition of type &i/o-decoding\n\nprocedure: (i/o-decoding-error? obj)\nreturns: #t if obj is a condition of type &i/o-decoding, #f otherwise\nlibraries: (rnrs io ports), (rnrs)\n" "\n" "A condition of this type indicates that a decoding error has occurred\nduring the transcoding of bytes to characters.\nThe pobj argument to the constructor should be the\nport involved, if any.\nThe port should be positioned past the invalid encoding.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-decoding &i/o-port\n  make-i/o-decoding-error i/o-decoding-error?)\n") ("exceptions:s43" "\nsyntax: &i/o-encoding\n\nprocedure: (make-i/o-encoding-error pobj cobj)\nreturns: a condition of type &i/o-encoding\n\nprocedure: (i/o-encoding-error? obj)\nreturns: #t if obj is a condition of type &i/o-encoding, #f otherwise\n\nprocedure: (i/o-encoding-error-char condition)\nreturns: the contents of condition's cobj field\nlibraries: (rnrs io ports), (rnrs)\n" "\n" "A condition of this type indicates that an encoding error has occurred\nduring the transcoding of characters to bytes.\nThe pobj argument to the constructor should be the\nport involved, if any, and the cobj argument should be the character for\nwhich the encoding failed.\nThis condition type might be defined as follows.\n" "(define-condition-type &i/o-encoding &i/o-port\n  make-i/o-encoding-error i/o-encoding-error?\n  (cobj i/o-encoding-error-char))\n" "" "The final two condition types describe conditions that occur when\nimplementations are required to produce a NaN or infinity but have\nno representations for these values.\n") ("exceptions:s44" "\nsyntax: &no-infinities\n\nprocedure: (make-no-infinities-violation)\nreturns: a condition of type &no-infinities\n\nprocedure: (no-infinities-violation? obj)\nreturns: #t if obj is a condition of type &no-infinities, #f otherwise\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "\n" "This condition indicates that the implementation has no representation for\ninfinity.\nThis condition type might be defined as follows.\n" "(define-condition-type &no-infinities &implementation-restriction\n  make-no-infinities-violation\n  no-infinities-violation?)\n") ("exceptions:s45" "\nsyntax: &no-nans\n\nprocedure: (make-no-nans-violation)\nreturns: a condition of type &no-nans\n\nprocedure: (no-nans-violation? obj)\nreturns: #t if obj is a condition of type &no-nans, #f otherwise\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "\n" "This condition indicates that the implementation has no representation for\nNaN.\nThis condition type might be defined as follows.\n" "(define-condition-type &no-nans &implementation-restriction\n  make-no-nans-violation no-nans-violation?)\n") ("objects:s1" "\nsyntax: constant\nreturns: constant\n" "constant is any self-evaluating constant, i.e., a number,\nboolean, character, string, or bytevector.\nConstants are immutable; see the note in the description of\nquote below.\n" "\n" "3.2 --> 3.2\n#f --> #f\n#\\c --> #\\c\n\"hi\" --> \"hi\"\n#vu8(3 4 5) --> #vu8(3 4 5)\n") ("objects:s2" "\nsyntax: (quote obj)\n\nsyntax: 'obj\nreturns: obj\nlibraries: (rnrs base), (rnrs)\n" "'obj is equivalent to (quote obj).\nThe abbreviated form is converted into the longer form by the Scheme\nreader (see read).\n" "\nquote inhibits the normal evaluation rule for\nobj, allowing obj to be employed as data.\nAlthough any Scheme object may be quoted, quotation is not necessary\nfor self-evaluating constants, i.e., numbers, booleans,\ncharacters, strings, and bytevectors.\n" "\nQuoted and self-evaluating constants are immutable.\nThat is, programs should not alter a constant via set-car!,\nstring-set!, etc., and implementations are permitted to raise\nan exception with condition type &assertion if such an\nalteration is attempted.\nIf an attempt to alter an immutable object is undetected, the behavior of\nthe program is unspecified.\nAn implementation may choose to share storage among different\nconstants to save space.\n" "\n" "(+ 2 3) --> 5\n'(+ 2 3) --> (+ 2 3)\n(quote (+ 2 3)) --> (+ 2 3)\n'a --> a\n'cons --> cons\n'() --> ()\n'7 --> 7\n") ("objects:s5" "\nsyntax: (quasiquote obj ...)\n\nsyntax: `obj\n\nsyntax: (unquote obj ...)\n\nsyntax: ,obj\n\nsyntax: (unquote-splicing obj ...)\n\nsyntax: ,@obj\nreturns: see below\n \nlibraries: (rnrs base), (rnrs)\n" "`obj is equivalent to (quasiquote obj),\n,obj is equivalent to (unquote obj), and\n,@obj is equivalent to (unquote-splicing obj).\nThe abbreviated forms are converted into the longer forms by the\nScheme reader (see read).\n" "\nquasiquote is similar to quote, but it allows parts\nof the quoted text to be \"unquoted.\"\nWithin a quasiquote expression,\nunquote and unquote-splicing subforms are evaluated,\nand everything else is quoted, i.e., left unevaluated.\nThe value of each unquote subform is inserted into the output\nin place of the unquote form, while the value of each\nunquote-splicing subform is spliced into the surrounding list\nor vector structure.\nunquote and unquote-splicing are valid only within\nquasiquote expressions.\n" "\nquasiquote expressions may be nested, with each quasiquote\nintroducing a new level of quotation and each unquote or\nunquote-splicing taking away a level of quotation.\nAn expression nested within n quasiquote expressions must\nbe within n unquote or unquote-splicing expressions to\nbe evaluated.\n" "\n" "`(+ 2 3) --> (+ 2 3)\n\n`(+ 2 ,(* 3 4)) --> (+ 2 12)\n`(a b (,(+ 2 3) c) d) --> (a b (5 c) d)\n`(a b ,(reverse '(c d e)) f g) --> (a b (e d c) f g)\n(let ([a 1] [b 2])\n  `(,a . ,b)) --> (1 . 2)\n\n`(+ ,@(cdr '(* 2 3))) --> (+ 2 3)\n`(a b ,@(reverse '(c d e)) f g) --> (a b e d c f g)\n(let ([a 1] [b 2])\n  `(,a ,@b)) --> (1 . 2)\n`#(,@(list 1 2 3)) --> #(1 2 3)\n\n'`,(cons 'a 'b) --> `,(cons 'a 'b)\n`',(cons 'a 'b) --> '(a . b)\n" "unquote and unquote-splicing forms with zero or more than\none subform are valid only in splicing (list or\nvector) contexts.\n(unquote obj ...) is equivalent to\n(unquote obj) ..., and\n(unquote-splicing obj ...) is equivalent to\n(unquote-splicing obj) ....\nThese forms are primarily useful as intermediate forms in the output\nof the quasiquote expander.\nThey support certain useful nested quasiquotation\nidioms [citation3], such as ,@,@, which has the\neffect of a doubly indirect splicing when used within a doubly nested\nand doubly evaluated quasiquote expression.\n" "\n" "`(a (unquote) b) --> (a b)\n`(a (unquote (+ 3 3)) b) --> (a 6 b)\n`(a (unquote (+ 3 3) (* 3 3)) b) --> (a 6 9 b)\n\n(let ([x '(m n)]) ``(a ,@,@x f)) --> `(a (unquote-splicing m n) f)\n(let ([x '(m n)])\n  (eval `(let ([m '(b c)] [n '(d e)]) `(a ,@,@x f))\n        (environment '(rnrs)))) --> (a b c d e f)\n" "unquote and unquote-splicing are auxiliary keywords for\nquasiquote.\nIt is a syntax violation to reference these identifiers except in contexts\nwhere they are recognized as auxiliary keywords.\n\n") ("objects:s10" "\nprocedure: (eq? obj1 obj2)\nreturns: #t if obj1 and obj2 are identical, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "In most Scheme systems, two objects are considered identical if they\nare represented internally by the same pointer value and distinct\n(not identical) if they are represented internally by different pointer\nvalues, although other criteria, such as time-stamping, are possible.\n" "\nAlthough the particular rules for object identity\nvary somewhat from system to system, the following rules always hold.\n" "\nTwo objects of different types\n(booleans, the empty list, pairs, numbers, characters, strings,\nvectors, symbols, and procedures)\nare distinct.\n\nTwo objects of the same type with different contents or values are distinct.\n\nThe boolean object #t is identical to itself wherever it\nappears, and #f is identical to itself wherever it appears,\nbut #t and #f are distinct.\n\nThe empty list () is identical to itself wherever it appears.\n\nTwo symbols are identical if and only if they have the same name (by\nstring=?).\n\nA constant pair, vector, string, or bytevector is identical to itself, as is a\npair, vector, string, or bytevector created by an application of cons,\nvector, string, make-bytevector, etc.\nTwo pairs, vectors, strings, or bytevectors created by different applications\nof cons, vector, string, make-bytevector,\netc., are distinct.\nOne consequence is that cons, for example, may be used to create\na unique object distinct from all other objects.\n\nTwo procedures that may behave differently are distinct.\nA procedure created by an evaluation of a\nlambda expression is identical to itself.\nTwo procedures created by the same lambda expression at different\ntimes, or by similar lambda expressions, may or may not be\ndistinct.\n" "\n" "\neq? cannot be used to compare numbers and characters\nreliably.\nAlthough every inexact number is distinct from every exact number,\ntwo exact numbers, two inexact numbers, or two characters with the\nsame value may or may not be identical.\n" "\nSince constant objects are immutable, i.e., programs should not modify them via\nvector-set!, set-car!, or any other structure mutation\noperation,\nall or portions of different quoted constants or self-evaluating\nliterals may be represented internally by the same object.\nThus, eq? may return #t when applied to equal parts of different\nimmutable constants.\n" "\neq? is most often used to compare symbols or to check for\npointer equivalence of allocated objects, e.g., pairs, vectors,\nor record instances.\n" "\n" "(eq? 'a 3) --> #f\n(eq? #t 't) --> #f\n(eq? \"abc\" 'abc) --> #f\n(eq? \"hi\" '(hi)) --> #f\n(eq? #f '()) --> #f\n\n(eq? 9/2 7/2) --> #f\n(eq? 3.4 53344) --> #f\n(eq? 3 3.0) --> #f\n(eq? 1/3 #i1/3) --> #f\n\n(eq? 9/2 9/2) --> unspecified\n(eq? 3.4 (+ 3.0 .4)) --> unspecified\n(let ([x (* 12345678987654321 2)])\n  (eq? x x)) --> unspecified\n\n(eq? #\\a #\\b) --> #f\n(eq? #\\a #\\a) --> unspecified\n(let ([x (string-ref \"hi\" 0)])\n  (eq? x x)) --> unspecified\n\n(eq? #t #t) --> #t\n(eq? #f #f) --> #t\n(eq? #t #f) --> #f\n(eq? (null? '()) #t) --> #t\n(eq? (null? '(a)) #f) --> #t\n\n(eq? (cdr '(a)) '()) --> #t\n\n(eq? 'a 'a) --> #t\n(eq? 'a 'b) --> #f\n(eq? 'a (string->symbol \"a\")) --> #t\n\n(eq? '(a) '(b)) --> #f\n(eq? '(a) '(a)) --> unspecified\n(let ([x '(a . b)]) (eq? x x)) --> #t\n(let ([x (cons 'a 'b)])\n  (eq? x x)) --> #t\n(eq? (cons 'a 'b) (cons 'a 'b)) --> #f\n\n(eq? \"abc\" \"cba\") --> #f\n(eq? \"abc\" \"abc\") --> unspecified\n(let ([x \"hi\"]) (eq? x x)) --> #t\n(let ([x (string #\\h #\\i)]) (eq? x x)) --> #t\n(eq? (string #\\h #\\i)\n     (string #\\h #\\i)) --> #f\n\n(eq? '#vu8(1) '#vu8(1)) --> unspecified\n(eq? '#vu8(1) '#vu8(2)) --> #f\n(let ([x (make-bytevector 10 0)])\n  (eq? x x)) --> #t\n(let ([x (make-bytevector 10 0)])\n  (eq? x (make-bytevector 10 0))) --> #f\n\n(eq? '#(a) '#(b)) --> #f\n(eq? '#(a) '#(a)) --> unspecified\n(let ([x '#(a)]) (eq? x x)) --> #t\n(let ([x (vector 'a)])\n  (eq? x x)) --> #t\n(eq? (vector 'a) (vector 'a)) --> #f\n\n(eq? car car) --> #t\n(eq? car cdr) --> #f\n(let ([f (lambda (x) x)])\n  (eq? f f)) --> #t\n(let ([f (lambda () (lambda (x) x))])\n  (eq? (f) (f))) --> unspecified\n(eq? (lambda (x) x) (lambda (y) y)) --> unspecified\n\n(let ([f (lambda (x)\n           (lambda ()\n             (set! x (+ x 1))\n             x))])\n  (eq? (f 0) (f 0))) --> #f\n") ("objects:s12" "\nprocedure: (eqv? obj1 obj2)\nreturns: #t if obj1 and obj2 are equivalent, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "eqv? is similar to eq? except eqv?\nis guaranteed to return #t for two characters that are considered\nequal by char=? and two numbers that are (a) considered\nequal by = and (b) cannot be distinguished by any other\noperation besides eq? and eqv?.\nA consequence of (b) is that (eqv? -0.0 +0.0) is #f even\nthough (= -0.0 +0.0) is #t in systems that distinguish\n-0.0 and +0.0, such as those based on IEEE floating-point\narithmetic.\nThis is because operations such as / can expose the difference:\n" "\n" "(/ 1.0 -0.0) --> -inf.0\n(/ 1.0 +0.0) --> +inf.0\n" "Similarly, although 3.0 and 3.0+0.0i are considered numerically equal,\nthey are not considered equivalent by eqv? if -0.0 and\n0.0 have different representations.\n" "\n" "(= 3.0+0.0i 3.0) --> #t\n(eqv? 3.0+0.0i 3.0) --> #f\n" "The boolean value returned by eqv? is not specified when the\narguments are NaNs.\n" "\n" "(eqv? +nan.0 (/ 0.0 0.0)) --> unspecified\n" "eqv? is less implementation-dependent but generally more\nexpensive than eq?.\n" "\n" "(eqv? 'a 3) --> #f\n(eqv? #t 't) --> #f\n(eqv? \"abc\" 'abc) --> #f\n(eqv? \"hi\" '(hi)) --> #f\n(eqv? #f '()) --> #f\n\n(eqv? 9/2 7/2) --> #f\n(eqv? 3.4 53344) --> #f\n(eqv? 3 3.0) --> #f\n(eqv? 1/3 #i1/3) --> #f\n\n(eqv? 9/2 9/2) --> #t\n(eqv? 3.4 (+ 3.0 .4)) --> #t\n(let ([x (* 12345678987654321 2)])\n  (eqv? x x)) --> #t\n\n(eqv? #\\a #\\b) --> #f\n(eqv? #\\a #\\a) --> #t\n(let ([x (string-ref \"hi\" 0)])\n  (eqv? x x)) --> #t\n\n(eqv? #t #t) --> #t\n(eqv? #f #f) --> #t\n(eqv? #t #f) --> #f\n(eqv? (null? '()) #t) --> #t\n(eqv? (null? '(a)) #f) --> #t\n\n(eqv? (cdr '(a)) '()) --> #t\n\n(eqv? 'a 'a) --> #t\n(eqv? 'a 'b) --> #f\n(eqv? 'a (string->symbol \"a\")) --> #t\n\n(eqv? '(a) '(b)) --> #f\n(eqv? '(a) '(a)) --> unspecified\n(let ([x '(a . b)]) (eqv? x x)) --> #t\n(let ([x (cons 'a 'b)])\n  (eqv? x x)) --> #t\n(eqv? (cons 'a 'b) (cons 'a 'b)) --> #f\n\n(eqv? \"abc\" \"cba\") --> #f\n(eqv? \"abc\" \"abc\") --> unspecified\n(let ([x \"hi\"]) (eqv? x x)) --> #t\n(let ([x (string #\\h #\\i)]) (eqv? x x)) --> #t\n(eqv? (string #\\h #\\i)\n      (string #\\h #\\i)) --> #f\n\n(eqv? '#vu8(1) '#vu8(1)) --> unspecified\n(eqv? '#vu8(1) '#vu8(2)) --> #f\n(let ([x (make-bytevector 10 0)])\n  (eqv? x x)) --> #t\n(let ([x (make-bytevector 10 0)])\n  (eqv? x (make-bytevector 10 0))) --> #f\n\n(eqv? '#(a) '#(b)) --> #f\n(eqv? '#(a) '#(a)) --> unspecified\n(let ([x '#(a)]) (eqv? x x)) --> #t\n(let ([x (vector 'a)])\n  (eqv? x x)) --> #t\n(eqv? (vector 'a) (vector 'a)) --> #f\n\n(eqv? car car) --> #t\n(eqv? car cdr) --> #f\n(let ([f (lambda (x) x)])\n  (eqv? f f)) --> #t\n(let ([f (lambda () (lambda (x) x))])\n  (eqv? (f) (f))) --> unspecified\n(eqv? (lambda (x) x) (lambda (y) y)) --> unspecified\n\n(let ([f (lambda (x)\n           (lambda ()\n             (set! x (+ x 1))\n             x))])\n  (eqv? (f 0) (f 0))) --> #f\n") ("objects:s13" "\nprocedure: (equal? obj1 obj2)\nreturns: #t if obj1 and obj2 have the same\nstructure and contents, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "Two objects are equal if they are equivalent according to eqv?,\nstrings that are string=?, bytevectors that are bytevector=?,\npairs whose cars and cdrs are equal, or\nvectors of the same length whose corresponding elements are equal.\n" "\nequal? is required to terminate even for cyclic arguments and\nreturn #t \"if and only if the (possibly infinite) unfoldings of\nits arguments into regular trees are equal as ordered trees\" [citation24].\nIn essence, two values are equivalent, in the sense of equal?,\nif the structure of the two objects cannot be distinguished by any\ncomposition of pair and vector accessors along with the\neqv?, string=?, and bytevector=? procedures for\ncomparing data at the leaves.\n" "\nImplementing equal? efficiently is tricky [citation1], and\neven with a good implementation, it is likely to be more expensive than\neither eqv? or eq?.\n" "\n" "(equal? 'a 3) --> #f\n(equal? #t 't) --> #f\n(equal? \"abc\" 'abc) --> #f\n(equal? \"hi\" '(hi)) --> #f\n(equal? #f '()) --> #f\n\n(equal? 9/2 7/2) --> #f\n(equal? 3.4 53344) --> #f\n(equal? 3 3.0) --> #f\n(equal? 1/3 #i1/3) --> #f\n\n(equal? 9/2 9/2) --> #t\n(equal? 3.4 (+ 3.0 .4)) --> #t\n(let ([x (* 12345678987654321 2)])\n  (equal? x x)) --> #t\n\n(equal? #\\a #\\b) --> #f\n(equal? #\\a #\\a) --> #t\n(let ([x (string-ref \"hi\" 0)])\n  (equal? x x)) --> #t\n\n(equal? #t #t) --> #t\n(equal? #f #f) --> #t\n(equal? #t #f) --> #f\n(equal? (null? '()) #t) --> #t\n(equal? (null? '(a)) #f) --> #t\n\n(equal? (cdr '(a)) '()) --> #t\n\n(equal? 'a 'a) --> #t\n(equal? 'a 'b) --> #f\n(equal? 'a (string->symbol \"a\")) --> #t\n\n(equal? '(a) '(b)) --> #f\n(equal? '(a) '(a)) --> #t\n(let ([x '(a . b)]) (equal? x x)) --> #t\n(let ([x (cons 'a 'b)])\n  (equal? x x)) --> #t\n(equal? (cons 'a 'b) (cons 'a 'b)) --> #t\n\n(equal? \"abc\" \"cba\") --> #f\n(equal? \"abc\" \"abc\") --> #t\n(let ([x \"hi\"]) (equal? x x)) --> #t\n(let ([x (string #\\h #\\i)]) (equal? x x)) --> #t\n(equal? (string #\\h #\\i)\n        (string #\\h #\\i)) --> #t\n\n(equal? '#vu8(1) '#vu8(1)) --> #t\n(equal? '#vu8(1) '#vu8(2)) --> #f\n(let ([x (make-bytevector 10 0)])\n  (equal? x x)) --> #t\n(let ([x (make-bytevector 10 0)])\n  (equal? x (make-bytevector 10 0))) --> #t\n\n(equal? '#(a) '#(b)) --> #f\n(equal? '#(a) '#(a)) --> #t\n(let ([x '#(a)]) (equal? x x)) --> #t\n(let ([x (vector 'a)])\n  (equal? x x)) --> #t\n(equal? (vector 'a) (vector 'a)) --> #t\n\n(equal? car car) --> #t\n(equal? car cdr) --> #f\n(let ([f (lambda (x) x)])\n  (equal? f f)) --> #t\n(let ([f (lambda () (lambda (x) x))])\n  (equal? (f) (f))) --> unspecified\n(equal? (lambda (x) x) (lambda (y) y)) --> unspecified\n\n(let ([f (lambda (x)\n           (lambda ()\n             (set! x (+ x 1))\n             x))])\n  (equal? (f 0) (f 0))) --> #f\n\n(equal?\n  (let ([x (cons 'x 'x)])\n    (set-car! x x)\n    (set-cdr! x x)\n    x)\n  (let ([x (cons 'x 'x)])\n    (set-car! x x)\n    (set-cdr! x x)\n    (cons x x))) --> #t\n") ("objects:s14" "\nprocedure: (boolean? obj)\nreturns: #t if obj is either #t or #f, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "boolean? is equivalent to\n(lambda (x) (or (eq? x #t) (eq? x #f))).\n" "\n" "(boolean? #t) --> #t\n(boolean? #f) --> #t\n(or (boolean? 't) (boolean? '())) --> #f\n") ("objects:s15" "\nprocedure: (null? obj)\nreturns: #t if obj is the empty list, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "null? is equivalent to (lambda (x) (eq? x '())).\n" "\n" "(null? '()) --> #t\n(null? '(a)) --> #f\n(null? (cdr '(a))) --> #t\n(null? 3) --> #f\n(null? #f) --> #f\n") ("objects:s16" "\nprocedure: (pair? obj)\nreturns: #t if obj is a pair, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(pair? '(a b c)) --> #t\n(pair? '(3 . 4)) --> #t\n(pair? '()) --> #f\n(pair? '#(a b)) --> #f\n(pair? 3) --> #f\n") ("objects:s17" "\nprocedure: (number? obj)\nreturns: #t if obj is a number object, #f otherwise\n\nprocedure: (complex? obj)\nreturns: #t if obj is a complex number object, #f otherwise\n\nprocedure: (real? obj)\nreturns: #t if obj is a real number object, #f otherwise\n\nprocedure: (rational? obj)\nreturns: #t if obj is a rational number object, #f otherwise\n\nprocedure: (integer? obj)\nreturns: #t if obj is an integer object, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "These predicates form a hierarchy: any integer is rational, any\nrational is real, any real is complex, and any complex is numeric.\nMost implementations do not provide internal representations for\nirrational numbers, so all real numbers are typically rational\nas well.\n" "\nThe real?, rational?, and integer? predicates do\nnot recognize as real, rational, or integer complex numbers with inexact\nzero imaginary parts.\n" "\n" "(integer? 1901) --> #t\n(rational? 1901) --> #t\n(real? 1901) --> #t\n(complex? 1901) --> #t\n(number? 1901) --> #t\n\n(integer? -3.0) --> #t\n(rational? -3.0) --> #t\n(real? -3.0) --> #t\n(complex? -3.0) --> #t\n(number? -3.0) --> #t\n\n(integer? 7+0i) --> #t\n(rational? 7+0i) --> #t\n(real? 7+0i) --> #t\n(complex? 7+0i) --> #t\n(number? 7+0i) --> #t\n\n(integer? -2/3) --> #f\n(rational? -2/3) --> #t\n(real? -2/3) --> #t\n(complex? -2/3) --> #t\n(number? -2/3) --> #t\n\n(integer? -2.345) --> #f\n(rational? -2.345) --> #t\n(real? -2.345) --> #t\n(complex? -2.345) --> #t\n(number? -2.345) --> #t\n\n(integer? 7.0+0.0i) --> #f\n(rational? 7.0+0.0i) --> #f\n(real? 7.0+0.0i) --> #f\n(complex? 7.0+0.0i) --> #t\n(number? 7.0+0.0i) --> #t\n\n(integer? 3.2-2.01i) --> #f\n(rational? 3.2-2.01i) --> #f\n(real? 3.2-2.01i) --> #f\n(complex? 3.2-2.01i) --> #t\n(number? 3.2-2.01i) --> #t\n\n(integer? 'a) --> #f\n(rational? '(a b c)) --> #f\n(real? \"3\") --> #f\n(complex? '#(1 2)) --> #f\n(number? #\\a) --> #f\n") ("objects:s18" "\nprocedure: (real-valued? obj)\nreturns: #t if obj is a real number, #f otherwise\n\nprocedure: (rational-valued? obj)\nreturns: #t if obj is a rational number, #f otherwise\n\nprocedure: (integer-valued? obj)\nreturns: #t if obj is an integer, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "These predicates are similar to real?, rational?, and\ninteger?, but treat as real, rational, or integral complex numbers\nwith inexact zero imaginary parts.\n" "\n" "(integer-valued? 1901) --> #t\n(rational-valued? 1901) --> #t\n(real-valued? 1901) --> #t\n\n(integer-valued? -3.0) --> #t\n(rational-valued? -3.0) --> #t\n(real-valued? -3.0) --> #t\n\n(integer-valued? 7+0i) --> #t\n(rational-valued? 7+0i) --> #t\n(real-valued? 7+0i) --> #t\n\n(integer-valued? -2/3) --> #f\n(rational-valued? -2/3) --> #t\n(real-valued? -2/3) --> #t\n\n(integer-valued? -2.345) --> #f\n(rational-valued? -2.345) --> #t\n(real-valued? -2.345) --> #t\n\n(integer-valued? 7.0+0.0i) --> #t\n(rational-valued? 7.0+0.0i) --> #t\n(real-valued? 7.0+0.0i) --> #t\n\n(integer-valued? 3.2-2.01i) --> #f\n(rational-valued? 3.2-2.01i) --> #f\n(real-valued? 3.2-2.01i) --> #f\n" "As with real?, rational?, and integer?, these\npredicates return #f for all non-numeric values.\n" "\n" "(integer-valued? 'a) --> #f\n(rational-valued? '(a b c)) --> #f\n(real-valued? \"3\") --> #f\n") ("objects:s19" "\nprocedure: (char? obj)\nreturns: #t if obj is a character, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(char? 'a) --> #f\n(char? 97) --> #f\n(char? #\\a) --> #t\n(char? \"a\") --> #f\n(char? (string-ref (make-string 1) 0)) --> #t\n") ("objects:s20" "\nprocedure: (string? obj)\nreturns: #t if obj is a string, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(string? \"hi\") --> #t\n(string? 'hi) --> #f\n(string? #\\h) --> #f\n") ("objects:s21" "\nprocedure: (vector? obj)\nreturns: #t if obj is a vector, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(vector? '#()) --> #t\n(vector? '#(a b c)) --> #t\n(vector? (vector 'a 'b 'c)) --> #t\n(vector? '()) --> #f\n(vector? '(a b c)) --> #f\n(vector? \"abc\") --> #f\n") ("objects:s22" "\nprocedure: (symbol? obj)\nreturns: #t if obj is a symbol, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(symbol? 't) --> #t\n(symbol? \"t\") --> #f\n(symbol? '(t)) --> #f\n(symbol? #\\t) --> #f\n(symbol? 3) --> #f\n(symbol? #t) --> #f\n") ("objects:s23" "\nprocedure: (procedure? obj)\nreturns: #t if obj is a procedure, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(procedure? car) --> #t\n(procedure? 'car) --> #f\n(procedure? (lambda (x) x)) --> #t\n(procedure? '(lambda (x) x)) --> #f\n(call/cc procedure?) --> #t\n") ("objects:s24" "\nprocedure: (bytevector? obj)\nreturns: #t if obj is a bytevector, #f otherwise\nlibraries: (rnrs bytevectors), (rnrs)\n" "\n" "\n(bytevector? #vu8()) --> #t\n(bytevector? '#()) --> #f\n(bytevector? \"abc\") --> #f\n") ("objects:s25" "\nprocedure: (hashtable? obj)\nreturns: #t if obj is a hashtable, #f otherwise\nlibraries: (rnrs hashtables), (rnrs)\n" "\n" "(hashtable? (make-eq-hashtable)) --> #t\n(hashtable? '(not a hash table)) --> #f\n") ("objects:s37" "\nprocedure: (cons obj1 obj2)\nreturns: a new pair whose car and cdr are obj1 and obj2\nlibraries: (rnrs base), (rnrs)\n" "cons is the pair constructor procedure.\nobj1 becomes the car and obj2 becomes the cdr of the\nnew pair.\n" "\n" "(cons 'a '()) --> (a)\n(cons 'a '(b c)) --> (a b c)\n(cons 3 4) --> (3 . 4)\n") ("objects:s38" "\nprocedure: (car pair)\nreturns: the car of pair\nlibraries: (rnrs base), (rnrs)\n" "The empty list is not a pair, so the argument must not be the empty list.\n" "\n" "(car '(a)) --> a\n(car '(a b c)) --> a\n(car (cons 3 4)) --> 3\n") ("objects:s39" "\nprocedure: (cdr pair)\nreturns: the cdr of pair\nlibraries: (rnrs base), (rnrs)\n" "The empty list is not a pair, so the argument must not be the empty list.\n" "\n" "(cdr '(a)) --> ()\n(cdr '(a b c)) --> (b c)\n(cdr (cons 3 4)) --> 4\n") ("objects:s40" "\nprocedure: (set-car! pair obj)\nreturns: unspecified\nlibraries: (rnrs mutable-pairs)\n" "set-car! changes the car of pair to obj.\n" "\n" "(let ([x (list 'a 'b 'c)])\n  (set-car! x 1)\n  x) --> (1 b c)\n") ("objects:s41" "\nprocedure: (set-cdr! pair obj)\nreturns: unspecified\nlibraries: (rnrs mutable-pairs)\n" "set-cdr! changes the cdr of pair to obj.\n" "\n" "(let ([x (list 'a 'b 'c)])\n  (set-cdr! x 1)\n  x) --> (a . 1)\n") ("objects:s42" "\nprocedure: (caar pair)\n\nprocedure: (cadr pair)\n\n\n\n\n\n\n\n\n\n\n\n\nmath/tspl/3.gif \nprocedure: (cddddr pair)\nreturns: the caar, cadr, ..., or cddddr of pair\nlibraries: (rnrs base), (rnrs)\n" "These procedures are defined as the composition of up to four cars\nand cdrs.\nThe a's and d's between the c and r represent the\napplication of car or cdr in order from right to left.\nFor example, the procedure cadr applied to a pair yields the car\nof the cdr of the pair and is equivalent to\n(lambda (x) (car (cdr x))).\n" "\n" "(caar '((a))) --> a\n(cadr '(a b c)) --> b\n(cdddr '(a b c d)) --> (d)\n(cadadr '(a (b c))) --> c\n") ("objects:s43" "\nprocedure: (list obj ...)\nreturns: a list of obj ...\nlibraries: (rnrs base), (rnrs)\n" "list is equivalent to (lambda x x).\n" "\n" "(list) --> ()\n(list 1 2 3) --> (1 2 3)\n(list 3 2 1) --> (3 2 1)\n") ("objects:s44" "\nprocedure: (cons* obj ... final-obj)\nreturns: a list of obj ... terminated by final-obj\nlibraries: (rnrs lists), (rnrs)\n" "If the objects obj ... are omitted, the result is simply\nfinal-obj.\nOtherwise, a list of obj ... is constructed, as with list, except\nthat the final cdr field is final-obj instead of ().\nIf final-obj is not a list, the result is an improper list.\n" "\n" "(cons* '()) --> ()\n(cons* '(a b)) --> (a b)\n(cons* 'a 'b 'c) --> (a b . c)\n(cons* 'a 'b '(c d)) --> (a b c d)\n") ("objects:s45" "\nprocedure: (list? obj)\nreturns: #t if obj is a proper list, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "list? must return #f for all improper lists, including cyclic\nlists.\nA definition of list? is shown on page 67.\n" "\n" "(list? '()) --> #t\n(list? '(a b c)) --> #t\n(list? 'a) --> #f\n(list? '(3 . 4)) --> #f\n(list? 3) --> #f\n(let ([x (list 'a 'b 'c)])\n  (set-cdr! (cddr x) x)\n  (list? x)) --> #f\n") ("objects:s46" "\nprocedure: (length list)\nreturns: the number of elements in list\nlibraries: (rnrs base), (rnrs)\n" "length may be defined as follows, using an adaptation of the\nhare and tortoise algorithm used for the definition of list?\non page 67.\n" "\n" "(define length\n  (lambda (x)\n    (define improper-list\n      (lambda ()\n        (assertion-violation 'length \"not a proper list\" x)))\n\n    (let f ([h x] [t x] [n 0])\n      (if (pair? h)\n          (let ([h (cdr h)])\n            (if (pair? h)\n                (if (eq? h t)\n                    (improper-list)\n                    (f (cdr h) (cdr t) (+ n 2)))\n                (if (null? h)\n                    (+ n 1)\n                    (improper-list))))\n          (if (null? h)\n              n\n              (improper-list))))))\n\n(length '()) --> 0\n(length '(a b c)) --> 3\n(length '(a b . c)) --> exception\n(length\n  (let ([ls (list 'a 'b)])\n    (set-cdr! (cdr ls) ls) --> exception\n    ls))\n(length\n  (let ([ls (list 'a 'b)])\n    (set-car! (cdr ls) ls) --> 2\n    ls))\n") ("objects:s47" "\nprocedure: (list-ref list n)\nreturns: the nth element (zero-based) of list\nlibraries: (rnrs base), (rnrs)\n" "n must be an exact nonnegative integer less than\nthe length of list.\nlist-ref may be defined without error checks as follows.\n" "\n" "(define list-refdefn:list-ref\n  (lambda (ls n)\n    (if (= n 0)\n        (car ls)\n        (list-ref (cdr ls) (- n 1)))))\n\n(list-ref '(a b c) 0) --> a\n(list-ref '(a b c) 1) --> b\n(list-ref '(a b c) 2) --> c\n") ("objects:s48" "\nprocedure: (list-tail list n)\nreturns: the nth tail (zero-based) of list\nlibraries: (rnrs base), (rnrs)\n" "n must be an exact nonnegative integer less than or equal to\nthe length of list.\nThe result is not a copy; the tail is eq? to the nth cdr of\nlist (or to list itself, if n is zero).\n" "\nlist-tail may be defined without error checks as follows.\n" "\n" "(define list-taildefn:list-tail\n  (lambda (ls n)\n    (if (= n 0)\n        ls\n        (list-tail (cdr ls) (- n 1)))))\n\n(list-tail '(a b c) 0) --> (a b c)\n(list-tail '(a b c) 2) --> (c)\n(list-tail '(a b c) 3) --> ()\n(list-tail '(a b c . d) 2) --> (c . d)\n(list-tail '(a b c . d) 3) --> d\n(let ([x (list 1 2 3)])\n  (eq? (list-tail x 2)\n       (cddr x))) --> #t\n") ("objects:s49" "\nprocedure: (append)\n\nprocedure: (append list ... obj)\nreturns: the concatenation of the input lists\nlibraries: (rnrs base), (rnrs)\n" "append returns a new list consisting of the elements of the first\nlist followed by the elements of the second list, the elements of the\nthird list, and so on.\nThe new list is made from new pairs for all arguments but the last; the\nlast (which need not be a list) is merely placed at the end of\nthe new structure.\nappend may be defined without error checks as follows.\n" "\n" "(define append\n  (lambda args\n    (let f ([ls '()] [args args])\n      (if (null? args)\n          ls\n          (let g ([ls ls])\n            (if (null? ls)\n                (f (car args) (cdr args))\n                (cons (car ls) (g (cdr ls)))))))))\n\n(append '(a b c) '()) --> (a b c)\n(append '() '(a b c)) --> (a b c)\n(append '(a b) '(c d)) --> (a b c d)\n(append '(a b) 'c) --> (a b . c)\n(let ([x (list 'b)])\n  (eq? x (cdr (append '(a) x)))) --> #t\n") ("objects:s50" "\nprocedure: (reverse list)\nreturns: a new list containing the elements of list in reverse order\nlibraries: (rnrs base), (rnrs)\n" "reverse may be defined without error checks as follows.\n" "\n" "(define reverse\n  (lambda (ls)\n    (let rev ([ls ls] [new '()])\n      (if (null? ls)\n          new\n          (rev (cdr ls) (cons (car ls) new))))))\n\n(reverse '()) --> ()\n(reverse '(a b c)) --> (c b a)\n") ("objects:s51" "\nprocedure: (memq obj list)\n\nprocedure: (memv obj list)\n\nprocedure: (member obj list)\nreturns: the first tail of list whose car is equivalent to obj, or #f\nlibraries: (rnrs lists), (rnrs)\n" "These procedures traverse the argument list in order, comparing the\nelements of list against obj.\nIf an object equivalent to obj is found, the tail of the list whose\nfirst element is that object is returned.\nIf the list contains more than one object equivalent to obj, the first\ntail whose first element is equivalent to obj is returned.\nIf no object equivalent to obj is found, #f is returned.\nThe equivalence test for memq is eq?, for memv is eqv?,\nand for member is equal?.\n" "\nThese procedures are most often used as predicates, but their names do not\nend with a question mark because they return a useful true value in place\nof #t.\nmemq may be defined without error checks as follows.\n" "\n" "(define memq\n  (lambda (x ls)\n    (cond\n      [(null? ls) #f]\n      [(eq? (car ls) x) ls]\n      [else (memq x (cdr ls))])))\n" "memv and member may be defined similarly, with eqv? and equal?\nin place of eq?.\n" "\n" "(memq 'a '(b c a d e)) --> (a d e)\n(memq 'a '(b c d e g)) --> #f\n(memq 'a '(b a c a d a)) --> (a c a d a)\n\n(memv 3.4 '(1.2 2.3 3.4 4.5)) --> (3.4 4.5)\n(memv 3.4 '(1.3 2.5 3.7 4.9)) --> #f\n(let ([ls (list 'a 'b 'c)])\n  (set-car! (memv 'b ls) 'z)\n  ls) --> (a z c)\n\n(member '(b) '((a) (b) (c))) --> ((b) (c))\n(member '(d) '((a) (b) (c))) --> #f\n(member \"b\" '(\"a\" \"b\" \"c\")) --> (\"b\" \"c\")\n\n(let ()\n  (define member?\n    (lambda (x ls)\n      (and (member x ls) #t)))\n  (member? '(b) '((a) (b) (c)))) --> #t\n\n(define count-occurrences\n  (lambda (x ls)\n    (cond\n      [(memq x ls) =>\n       (lambda (ls)\n         (+ (count-occurrences x (cdr ls)) 1))]\n      [else 0])))\n\n(count-occurrences 'a '(a b c d a)) --> 2\n") ("objects:s52" "\nprocedure: (memp procedure list)\nreturns: the first tail of list for whose car procedure returns true, or #f\nlibraries: (rnrs lists), (rnrs)\n" "procedure should accept one argument and return a single value.\nIt should not modify list.\n" "\n" "(memp odd? '(1 2 3 4)) --> (1 2 3 4)\n(memp even? '(1 2 3 4)) --> (2 3 4)\n(let ([ls (list 1 2 3 4)])\n  (eq? (memp odd? ls) ls)) --> #t\n(let ([ls (list 1 2 3 4)])\n  (eq? (memp even? ls) (cdr ls))) --> #t\n(memp odd? '(2 4 6 8)) --> #f\n") ("objects:s53" "\nprocedure: (remq obj list)\n\nprocedure: (remv obj list)\n\nprocedure: (remove obj list)\nreturns: a list containing the elements of list with all occurrences of obj removed\nlibraries: (rnrs lists), (rnrs)\n" "These procedures traverse the argument list, removing any objects\nthat are equivalent to obj.\nThe elements remaining in the output list are in the same order as they appear\nin the input list.\nIf a tail of list (including list itself) contains no occurrences of \nobj, the corresponding tail of the result list may be the same\n(by eq?) as the tail of the input list.\n" "\nThe equivalence test for remq is eq?,\nfor remv is eqv?,\nand for remove is equal?.\n" "\n" "(remq 'a '(a b a c a d)) --> (b c d)\n(remq 'a '(b c d)) --> (b c d)\n\n(remv 1/2 '(1.2 1/2 0.5 3/2 4)) --> (1.2 0.5 3/2 4)\n\n(remove '(b) '((a) (b) (c))) --> ((a) (c))\n") ("objects:s54" "\nprocedure: (remp procedure list)\nreturns: a list of the elements of list for which procedure returns #f\nlibraries: (rnrs lists), (rnrs)\n" "procedure should accept one argument and return a single value.\nIt should not modify list.\n" "\nremp applies procedure to each element of list\nand returns a list containing only the elements for which\nprocedure returns #f.\nThe elements of the returned list appear in the same order as they\nappeared in the original list.\n" "\n" "(remp odd? '(1 2 3 4)) --> (2 4)\n(remp\n  (lambda (x) (and (> x 0) (< x 10)))\n  '(-5 15 3 14 -20 6 0 -9)) --> (-5 15 14 -20 0 -9)\n") ("objects:s55" "\nprocedure: (filter procedure list)\nreturns: a list of the elements of list for which procedure returns true\nlibraries: (rnrs lists), (rnrs)\n" "procedure should accept one argument and return a single value.\nIt should not modify list.\n" "\nfilter applies procedure to each element of list\nand returns a new list containing only the elements for which\nprocedure returns true.\nThe elements of the returned list appear in the same order as they\nappeared in the original list.\n" "\n" "(filter odd? '(1 2 3 4)) --> (1 3)\n(filter\n  (lambda (x) (and (> x 0) (< x 10)))\n  '(-5 15 3 14 -20 6 0 -9)) --> (3 6)\n") ("objects:s56" "\nprocedure: (partition procedure list)\nreturns: see below\nlibraries: (rnrs lists), (rnrs)\n" "procedure should accept one argument and return a single value.\nIt should not modify list.\n" "\npartition applies procedure to each element of list\nand returns two values:\na new list containing only the elements for which\nprocedure returns true, and\na new list containing only the elements for which\nprocedure returns #f.\nThe elements of the returned lists appear in the same order as they\nappeared in the original list.\n" "\n" "(partition odd? '(1 2 3 4)) --> (1 3)\n                            gifs/ghostRightarrow.gif (2 4)\n(partition\n  (lambda (x) (and (> x 0) (< x 10)))\n  '(-5 15 3 14 -20 6 0 -9)) --> (3 6)\n                            gifs/ghostRightarrow.gif (-5 15 14 -20 0 -9)\n" "The values returned by partition can be obtained by calling\nfilter and remp separately, but this would require\ntwo calls to procedure for each element of list.\n") ("objects:s57" "\nprocedure: (find procedure list)\nreturns: the first element of list for which procedure returns true, or #f\nlibraries: (rnrs lists), (rnrs)\n" "procedure should accept one argument and return a single value.\nIt should not modify list.\n" "\nfind traverses the argument list in order, applying\nprocedure to each element in turn.\nIf procedure returns a true value for a given element, find\nreturns that element without applying procedure to the remaining elements.\nIf procedure returns #f for each element of list,\nfind returns #f.\n" "\nIf a program must distinguish between finding #f in the list\nand finding no element at all, memp should be used instead.\n" "\n" "(find odd? '(1 2 3 4)) --> 1\n(find even? '(1 2 3 4)) --> 2\n(find odd? '(2 4 6 8)) --> #f\n(find not '(1 a #f 55)) --> #f\n") ("objects:s58" "page:assq\nprocedure: (assq obj alist)\n\nprocedure: (assv obj alist)\n\nprocedure: (assoc obj alist)\nreturns: first element of alist whose car is equivalent to obj, or #f\nlibraries: (rnrs lists), (rnrs)\n" "The argument alist must be an association list.\nAn association list is a proper list whose elements are key-value pairs\nof the form (key . value).\nAssociations are useful for storing information (values) associated with\ncertain objects (keys).\n" "\nThese procedures traverse the association list, testing each key for equivalence\nwith obj.\nIf an equivalent key is found, the key-value pair is returned.\nOtherwise, #f is returned.\n" "\nThe equivalence test for assq is eq?,\nfor assv is eqv?,\nand for assoc is equal?.\nassq may be defined without error checks as follows.\n" "\n" "(define assq\n  (lambda (x ls)\n    (cond\n      [(null? ls) #f]\n      [(eq? (caar ls) x) (car ls)]\n      [else (assq x (cdr ls))])))\n" "assv and assoc may be defined similarly, with eqv? and equal?\nin place of eq?.\n" "\n" "(assq 'b '((a . 1) (b . 2))) --> (b . 2)\n(cdr (assq 'b '((a . 1) (b . 2)))) --> 2\n(assq 'c '((a . 1) (b . 2))) --> #f\n\n(assv 2/3 '((1/3 . 1) (2/3 . 2))) --> (2/3 . 2)\n(assv 2/3 '((1/3 . a) (3/4 . b))) --> #f\n\n(assoc '(a) '(((a) . a) (-1 . b))) --> ((a) . a)\n(assoc '(a) '(((b) . b) (a . c))) --> #f\n\n(let ([alist (list (cons 2 'a) (cons 3 'b))])\n  (set-cdr! (assv 3 alist) 'c)\n  alist) --> ((2 . a) (3 . c))\n" "The interpreter given in Section 12.7 represents\nenvironments as association lists and uses assq for both\nvariable lookup and assignment.\n") ("objects:s60" "\nprocedure: (assp procedure alist)\nreturns: first element of alist for whose car procedure returns true, or #f\nlibraries: (rnrs lists), (rnrs)\n" "alist must be an association list.\nAn association list is a proper list whose elements are key-value pairs\nof the form (key . value).\nprocedure should accept one argument and return a single value.\nIt should not modify list.\n" "\n" "(assp odd? '((1 . a) (2 . b))) --> (1 . a)\n(assp even? '((1 . a) (2 . b))) --> (2 . b)\n(let ([ls (list (cons 1 'a) (cons 2 'b))])\n  (eq? (assp odd? ls) (car ls))) --> #t\n(let ([ls (list (cons 1 'a) (cons 2 'b))])\n  (eq? (assp even? ls) (cadr ls))) --> #t\n(assp odd? '((2 . b))) --> #f\n") ("objects:s62" "\nprocedure: (list-sort predicate list)\nreturns: a list containing the elements of list sorted according to predicate\nlibraries: (rnrs sorting), (rnrs)\n" "predicate should be a procedure that expects two arguments and\nreturns #t if its first argument must precede its second in\nthe sorted list.\nThat is, if predicate is applied to two elements x and\ny, where x appears after y in the input list,\nit should return true only if x should appear before y\nin the output list.\nIf this constraint is met,\nlist-sort performs a stable sort, i.e., two elements are\nreordered only when necessary according to predicate.\nDuplicate elements are not removed.\nThis procedure may call predicate up to nlogn times, where n is\nthe length of list.\n" "\n" "(list-sort < '(3 4 2 1 2 5)) --> (1 2 2 3 4 5)\n(list-sort > '(0.5 1/2)) --> (0.5 1/2)\n(list-sort > '(1/2 0.5)) --> (1/2 0.5)\n(list->string\n  (list-sort char>?\n    (string->list \"hello\"))) --> \"ollhe\"\n") ("objects:s86" "\nprocedure: (exact? num)\nreturns: #t if num is exact, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(exact? 1) --> #t\n(exact? -15/16) --> #t\n(exact? 2.01) --> #f\n(exact? #i77) --> #f\n(exact? #i2/3) --> #f\n(exact? 1.0-2i) --> #f\n") ("objects:s87" "\nprocedure: (inexact? num)\nreturns: #t if num is inexact, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(inexact? -123) --> #f\n(inexact? #i123) --> #t\n(inexact? 1e23) --> #t\n(inexact? +i) --> #f\n") ("objects:s88" "\nprocedure: (= num1 num2 num3 ...)\n\nprocedure: (< real1 real2 real3 ...)\n\nprocedure: (> real1 real2 real3 ...)\n\nprocedure: (<= real1 real2 real3 ...)\n\nprocedure: (>= real1 real2 real3 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "The predicate = returns #t if its arguments are equal.\nThe predicate < returns #t if its arguments are monotonically\nincreasing, i.e., each argument is greater than the preceding ones,\nwhile > returns #t if its arguments are monotonically decreasing.\nThe predicate <= returns #t if its arguments are monotonically\nnondecreasing, i.e., each argument is not less than the preceding ones,\nwhile >= returns #t if its arguments are monotonically nonincreasing.\n" "\nAs implied by the names of the arguments, = is defined for complex\narguments while the other relational predicates are defined only for real\narguments.\nTwo complex numbers are considered equal if their real and imaginary parts\nare equal.\nComparisons involving NaNs always return #f.\n" "\n" "(= 7 7) --> #t\n(= 7 9) --> #f\n\n(< 2e3 3e2) --> #f\n(<= 1 2 3 3 4 5) --> #t\n(<= 1 2 3 4 5) --> #t\n\n(> 1 2 2 3 3 4) --> #f\n(>= 1 2 2 3 3 4) --> #f\n\n(= -1/2 -0.5) --> #t\n(= 2/3 .667) --> #f\n(= 7.2+0i 7.2) --> #t\n(= 7.2-3i 7) --> #f\n\n(< 1/2 2/3 3/4) --> #t\n(> 8 4.102 2/3 -5) --> #t\n\n(let ([x 0.218723452])\n  (< 0.210 x 0.220)) --> #t\n\n(let ([i 1] [v (vector 'a 'b 'c)])\n  (< -1 i (vector-length v))) --> #t\n\n(apply < '(1 2 3 4)) --> #t\n(apply > '(4 3 3 2)) --> #f\n\n(= +nan.0 +nan.0) --> #f\n(< +nan.0 +nan.0) --> #f\n(> +nan.0 +nan.0) --> #f\n(>= +inf.0 +nan.0) --> #f\n(>= +nan.0 -inf.0) --> #f\n(> +nan.0 0.0) --> #f\n") ("objects:s89" "\nprocedure: (+ num ...)\nreturns: the sum of the arguments num ...\nlibraries: (rnrs base), (rnrs)\n" "When called with no arguments, + returns 0.\n" "\n" "(+) --> 0\n(+ 1 2) --> 3\n(+ 1/2 2/3) --> 7/6\n(+ 3 4 5) --> 12\n(+ 3.0 4) --> 7.0\n(+ 3+4i 4+3i) --> 7+7i\n(apply + '(1 2 3 4 5)) --> 15\n") ("objects:s90" "\nprocedure: (- num)\nreturns: the additive inverse of num\n\nprocedure: (- num1 num2 num3 ...)\nreturns: the difference between num1 and the sum of num2 num3 ...\nlibraries: (rnrs base), (rnrs)\n" "\n" "(- 3) --> -3\n(- -2/3) --> 2/3\n(- 4 3.0) --> 1.0\n(- 3.25+4.25i 1/4+1/4i) --> 3.0+4.0i\n(- 4 3 2 1) --> -2\n") ("objects:s91" "\nprocedure: (* num ...)\nreturns: the product of the arguments num ...\nlibraries: (rnrs base), (rnrs)\n" "When called with no arguments, * returns 1.\n" "\n" "(*) --> 1\n(* 3.4) --> 3.4\n(* 1 1/2) --> 1/2\n(* 3 4 5.5) --> 66.0\n(* 1+2i 3+4i) --> -5+10i\n(apply * '(1 2 3 4 5)) --> 120\n") ("objects:s92" "\nprocedure: (/ num)\nreturns: the multiplicative inverse of num\n\nprocedure: (/ num1 num2 num3 ...)\nreturns: the result of dividing num1 by the product of num2 num3 ...\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(/ -17) --> -1/17\n(/ 1/2) --> 2\n(/ .5) --> 2.0\n(/ 3 4) --> 3/4\n(/ 3.0 4) --> .75\n(/ -5+10i 3+4i) --> 1+2i\n(/ 60 5 4 3 2) --> 1/2\n") ("objects:s93" "\nprocedure: (zero? num)\nreturns: #t if num is zero, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "zero? is equivalent to (lambda (x) (= x 0)).\n" "\n" "(zero? 0) --> #t\n(zero? 1) --> #f\n(zero? (- 3.0 3.0)) --> #t\n(zero? (+ 1/2 1/2)) --> #f\n(zero? 0+0i) --> #t\n(zero? 0.0-0.0i) --> #t\n") ("objects:s94" "\nprocedure: (positive? real)\nreturns: #t if real is greater than zero, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "positive? is equivalent to (lambda (x) (> x 0)).\n" "\n" "(positive? 128) --> #t\n(positive? 0.0) --> #f\n(positive? 1.8e-15) --> #t\n(positive? -2/3) --> #f\n(positive? .001-0.0i) --> exception: not a real number\n") ("objects:s95" "\nprocedure: (negative? real)\nreturns: #t if real is less than zero, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "negative? is equivalent to (lambda (x) (< x 0)).\n" "\n" "(negative? -65) --> #t\n(negative? 0) --> #f\n(negative? -0.0121) --> #t\n(negative? 15/16) --> #f\n(negative? -7.0+0.0i) --> exception: not a real number\n") ("objects:s96" "\nprocedure: (even? int)\nreturns: #t if int is even, #f otherwise\n\nprocedure: (odd? int)\nreturns: #t if int is odd, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(even? 0) --> #t\n(even? 1) --> #f\n(even? 2.0) --> #t\n(even? -120762398465) --> #f\n(even? 2.0+0.0i) --> exception: not an integer\n\n(odd? 0) --> #f\n(odd? 1) --> #t\n(odd? 2.0) --> #f\n(odd? -120762398465) --> #t\n(odd? 2.0+0.0i) --> exception: not an integer\n") ("objects:s97" "\nprocedure: (finite? real)\nreturns: #t if real is finite, #f otherwise\n\nprocedure: (infinite? real)\nreturns: #t if real is infinite, #f otherwise\n\nprocedure: (nan? real)\nreturns: #t if real is a NaN, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(finite? 2/3) --> #t\n(infinite? 2/3) --> #f\n(nan? 2/3) --> #f\n\n(finite? 3.1415) --> #t\n(infinite? 3.1415) --> #f\n(nan? 3.1415) --> #f\n\n(finite? +inf.0) --> #f\n(infinite? -inf.0) --> #t\n(nan? -inf.0) --> #f\n\n(finite? +nan.0) --> #f\n(infinite? +nan.0) --> #f\n(nan? +nan.0) --> #t\n") ("objects:s98" "\nprocedure: (quotient int1 int2)\nreturns: the integer quotient of int1 and int2\n\nprocedure: (remainder int1 int2)\nreturns: the integer remainder of int1 and int2\n\nprocedure: (modulo int1 int2)\nreturns: the integer modulus of int1 and int2\nlibraries: (rnrs r5rs)\n" "The result of remainder has the same sign as int1,\nwhile the result of modulo has the same sign as int2.\n" "\n" "(quotient 45 6) --> 7\n(quotient 6.0 2.0) --> 3.0\n(quotient 3.0 -2) --> -1.0\n\n(remainder 16 4) --> 0\n(remainder 5 2) --> 1\n(remainder -45.0 7) --> -3.0\n(remainder 10.0 -3.0) --> 1.0\n(remainder -17 -9) --> -8\n\n(modulo 16 4) --> 0\n(modulo 5 2) --> 1\n(modulo -45.0 7) --> 4.0\n(modulo 10.0 -3.0) --> -2.0\n(modulo -17 -9) --> -8\n") ("objects:s99" "\nprocedure: (div x1 x2)\n\nprocedure: (mod x1 x2)\n\nprocedure: (div-and-mod x1 x2)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "If x1 and x2 are exact, x2 must not be zero.\nThese procedures implement number-theoretic integer division, with the\ndiv operation being related to quotient and the\nmod operation being related to remainder or\nmodulo, but in both cases extended to handle real numbers.\n" "\nThe value nd of (div x1 x2) is an integer,\nand the value xm of (mod x1 x2) is a real\nnumber such that x1 = nd  x2 + xm and\n0  xm < |x2|.\nIn situations where the implementation cannot represent the mathematical\nresults prescribed by these equations as a number object, div and\nmod return an unspecified number or raise an exception with\ncondition type &implementation-restriction.\n" "\nThe div-and-mod procedure behaves as if defined as follows.\n" "\n" "(define (div-and-mod x1 x2) (values (div x1 x2) (mod x1 x2)))\n" "That is, unless it raises an exception in the circumstance described\nabove, it returns two values: the result of calling div on the\ntwo arguments and the result of calling mod on the two\narguments.\n" "\n" "(div 17 3) --> 5\n(mod 17 3) --> 2\n(div -17 3) --> -6\n(mod -17 3) --> 1\n(div 17 -3) --> -5\n(mod 17 -3) --> 2\n(div -17 -3) --> 6\n(mod -17 -3) --> 1\n\n(div-and-mod 17.5 3) --> 5.0\n                     gifs/ghostRightarrow.gif 2.5\n") ("objects:s100" "\nprocedure: (div0 x1 x2)\n\nprocedure: (mod0 x1 x2)\n\nprocedure: (div0-and-mod0 x1 x2)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "If x1 and x2 are exact, x2 must not be zero.\nThese procedures are similar to div, mod, and\ndiv-and-mod, but constrain the \"mod\" value differently,\nwhich also affects the \"div\" value.\nThe value nd of (div0 x1 x2) is an integer,\nand the value xm of (mod0 x1 x2) is a real\nnumber such that x1 = nd  x2 + xm and\n-|x2/2|  xm < |x2/2|.\nIn situations where the implementation cannot represent the mathematical\nresults prescribed by these equations as a number object, div0 and\nmod0 return an unspecified number or raise an exception with\ncondition type &implementation-restriction.\n" "\nThe div0-and-mod0 procedure behaves as if defined as follows.\n" "\n" "(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))\n" "That is, unless it raises an exception in the circumstance described\nabove, it returns two values: the result of calling div0 on the\ntwo arguments and the result of calling mod0 on the two\narguments.\n" "\n" "(div0 17 3) --> 6\n(mod0 17 3) --> -1\n(div0 -17 3) --> -6\n(mod0 -17 3) --> 1\n(div0 17 -3) --> -6\n(mod0 17 -3) --> -1\n(div0 -17 -3) --> 6\n(mod0 -17 -3) --> 1\n\n(div0-and-mod0 17.5 3) --> 6.0\n                       gifs/ghostRightarrow.gif -0.5\n") ("objects:s101" "\nprocedure: (truncate real)\nreturns: the integer closest to real toward zero\nlibraries: (rnrs base), (rnrs)\n" "If real is an infinity or NaN, truncate returns real.\n" "\n" "(truncate 19) --> 19\n(truncate 2/3) --> 0\n(truncate -2/3) --> 0\n(truncate 17.3) --> 17.0\n(truncate -17/2) --> -8\n") ("objects:s102" "\nprocedure: (floor real)\nreturns: the integer closest to real toward math/tspl/11.gif\nlibraries: (rnrs base), (rnrs)\n" "If real is an infinity or NaN, floor returns real.\n" "\n" "(floor 19) --> 19\n(floor 2/3) --> 0\n(floor -2/3) --> -1\n(floor 17.3) --> 17.0\n(floor -17/2) --> -9\n") ("objects:s103" "\nprocedure: (ceiling real)\nreturns: the integer closest to real toward math/tspl/12.gif\nlibraries: (rnrs base), (rnrs)\n" "If real is an infinity or NaN, ceiling returns real.\n" "\n" "(ceiling 19) --> 19\n(ceiling 2/3) --> 1\n(ceiling -2/3) --> 0\n(ceiling 17.3) --> 18.0\n(ceiling -17/2) --> -8\n") ("objects:s104" "\nprocedure: (round real)\nreturns: the integer closest to real\nlibraries: (rnrs base), (rnrs)\n" "If real is exactly between two integers, the closest even integer\nis returned.\nIf real is an infinity or NaN, round returns real.\n" "\n" "(round 19) --> 19\n(round 2/3) --> 1\n(round -2/3) --> -1\n(round 17.3) --> 17.0\n(round -17/2) --> -8\n(round 2.5) --> 2.0\n(round 3.5) --> 4.0\n") ("objects:s105" "page:abs\nprocedure: (abs real)\nreturns: the absolute value of real\nlibraries: (rnrs base), (rnrs)\n" "abs is equivalent to (lambda (x) (if (< x 0) (- x) x)).\nabs and magnitude\n(see page 183) are identical for real inputs.\n" "\n" "(abs 1) --> 1\n(abs -3/4) --> 3/4\n(abs 1.83) --> 1.83\n(abs -0.093) --> 0.093\n") ("objects:s107" "\nprocedure: (max real1 real2 ...)\nreturns: the maximum of real1 real2 ...\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(max 4 -7 2 0 -6) --> 4\n(max 1/2 3/4 4/5 5/6 6/7) --> 6/7\n(max 1.5 1.3 -0.3 0.4 2.0 1.8) --> 2.0\n(max 5 2.0) --> 5.0\n(max -5 -2.0) --> -2.0\n(let ([ls '(7 3 5 2 9 8)])\n  (apply max ls)) --> 9\n") ("objects:s108" "\nprocedure: (min real1 real2 ...)\nreturns: the minimum of real1 real2 ...\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(min 4 -7 2 0 -6) --> -7\n(min 1/2 3/4 4/5 5/6 6/7) --> 1/2\n(min 1.5 1.3 -0.3 0.4 2.0 1.8) --> -0.3\n(min 5 2.0) --> 2.0\n(min -5 -2.0) --> -5.0\n(let ([ls '(7 3 5 2 9 8)])\n  (apply min ls)) --> 2\n") ("objects:s109" "page:gcd\nprocedure: (gcd int ...)\nreturns: the greatest common divisor of its arguments int ...\nlibraries: (rnrs base), (rnrs)\n" "The result is always nonnegative, i.e., factors of -1 are ignored.\nWhen called with no arguments, gcd returns 0.\n" "\n" "(gcd) --> 0\n(gcd 34) --> 34\n(gcd 33.0 15.0) --> 3.0\n(gcd 70 -42 28) --> 14\n") ("objects:s110" "\nprocedure: (lcm int ...)\nreturns: the least common multiple of its arguments int ...\nlibraries: (rnrs base), (rnrs)\n" "The result is always nonnegative, i.e., common multiples of -1 are\nignored.\nAlthough lcm should probably return math/tspl/13.gif when called with no\narguments, it is defined to return 1.\nIf one or more of the arguments is 0, lcm returns 0.\n" "\n" "(lcm) --> 1\n(lcm 34) --> 34\n(lcm 33.0 15.0) --> 165.0\n(lcm 70 -42 28) --> 420\n(lcm 17.0 0) --> 0.0\n") ("objects:s111" "\nprocedure: (expt num1 num2)\nreturns: num1 raised to the num2 power\nlibraries: (rnrs base), (rnrs)\n" "If both arguments are 0, expt returns 1.\n" "\n" "(expt 2 10) --> 1024\n(expt 2 -10) --> 1/1024\n(expt 2 -10.0) --> 9.765625e-4\n(expt -1/2 5) --> -1/32\n(expt 3.0 3) --> 27.0\n(expt +i 2) --> -1\n") ("objects:s112" "\nprocedure: (inexact num)\nreturns: an inexact representation of num\nlibraries: (rnrs base), (rnrs)\n" "If num is already inexact, it is returned unchanged.\nIf no inexact representation for num is supported by the\nimplementation, an exception with condition type &implementation-violation\nmay be raised.\ninexact may also return +inf.0 or -inf.0 for inputs\nwhose magnitude exceeds the range of the implementation's inexact number\nrepresentations.\n" "\n" "(inexact 3) --> 3.0\n(inexact 3.0) --> 3.0\n(inexact -1/4) --> -.25\n(inexact 3+4i) --> 3.0+4.0i\n(inexact (expt 10 20)) --> 1e20\n") ("objects:s114" "\nprocedure: (exact num)\nreturns: an exact representation of num\nlibraries: (rnrs base), (rnrs)\n" "If num is already exact, it is returned unchanged.\nIf no exact representation for num is supported by the\nimplementation, an exception with condition type &implementation-violation\nmay be raised.\n" "\n" "(exact 3.0) --> 3\n(exact 3) --> 3\n(exact -.25) --> -1/4\n(exact 3.0+4.0i) --> 3+4i\n(exact 1e20) --> 100000000000000000000\n") ("objects:s116" "\nprocedure: (exact->inexact num)\nreturns: an inexact representation of num\n\nprocedure: (inexact->exact num)\nreturns: an exact representation of num\nlibraries: (rnrs r5rs)\n" "These are alternative names for inexact and exact,\nsupported for compatibility with the Revised5 Report.\n\n") ("objects:s117" "\nprocedure: (rationalize real1 real2)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "rationalize\nreturns the simplest rational number that differs from\nreal1 by no more than real2.\nA rational number q1 = n1/m1 is simpler than another rational\nnumber q2 = n2/m2 if |n1|  |n2| and |m1|  |m2|\nand either |n1| < |n2| or |m1| < |m2|.\n" "\n" "(rationalize 3/10 1/10) --> 1/3\n(rationalize .3 1/10) --> 0.3333333333333333\n(eqv? (rationalize .3 1/10) #i1/3) --> #t\n") ("objects:s118" "\nprocedure: (numerator rat)\nreturns: the numerator of rat\nlibraries: (rnrs base), (rnrs)\n" "If rat is an integer, the numerator is rat.\n" "\n" "(numerator 9) --> 9\n(numerator 9.0) --> 9.0\n(numerator 0.0) --> 0.0\n(numerator 2/3) --> 2\n(numerator -9/4) --> -9\n(numerator -2.25) --> -9.0\n") ("objects:s119" "\nprocedure: (denominator rat)\nreturns: the denominator of rat\nlibraries: (rnrs base), (rnrs)\n" "If rat is an integer, including zero, the denominator is one.\n" "\n" "(denominator 9) --> 1\n(denominator 9.0) --> 1.0\n(denominator 0) --> 1\n(denominator 0.0) --> 1.0\n(denominator 2/3) --> 3\n(denominator -9/4) --> 4\n(denominator -2.25) --> 4.0\n") ("objects:s120" "\nprocedure: (real-part num)\nreturns: the real component of num\nlibraries: (rnrs base), (rnrs)\n" "If num is real, real-part returns num.\n" "\n" "(real-part 3+4i) --> 3\n(real-part -2.3+0.7i) --> -2.3\n(real-part -i) --> 0\n(real-part 17.2) --> 17.2\n(real-part -17/100) --> -17/100\n") ("objects:s121" "\nprocedure: (imag-part num)\nreturns: the imaginary component of num\nlibraries: (rnrs base), (rnrs)\n" "If num is real, imag-part returns exact zero.\n\n" "\n" "(imag-part 3+4i) --> 4\n(imag-part -2.3+0.7i) --> 0.7\n(imag-part -i) --> -1\n(imag-part -2.5) --> 0\n(imag-part -17/100) --> 0\n") ("objects:s122" "\nprocedure: (make-rectangular real1 real2)\nreturns: a complex number with real component real1 and imaginary\n  component real2\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(make-rectangular -2 7) --> -2+7i\n(make-rectangular 2/3 -1/2) --> 2/3-1/2i\n(make-rectangular 3.2 5.3) --> 3.2+5.3i\n") ("objects:s123" "\nprocedure: (make-polar real1 real2)\nreturns: a complex number with magnitude real1 and angle\n    real2\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(make-polar 2 0) --> 2\n(make-polar 2.0 0.0) --> 2.0+0.0i\n(make-polar 1.0 (asin -1.0)) --> 0.0-1.0i\n(eqv? (make-polar 7.2 -0.588) 7.2@-0.588) --> #t\n") ("objects:s124" "\nprocedure: (angle num)\nreturns: the angle part of the polar representation of num\nlibraries: (rnrs base), (rnrs)\n" "The range of the result is math/tspl/14.gif (exclusive) to math/tspl/15.gif (inclusive).\n" "\n" "(angle 7.3@1.5708) --> 1.5708\n(angle 5.2) --> 0.0\n") ("objects:s125" "page:magnitude\nprocedure: (magnitude num)\nreturns: the magnitude of num\nlibraries: (rnrs base), (rnrs)\n" "magnitude and abs\n(see page 178) are identical for real arguments.\nThe magnitude of a complex number x + yi is\nmath/tspl/16.gif.\n" "\n" "(magnitude 1) --> 1\n(magnitude -3/4) --> 3/4\n(magnitude 1.83) --> 1.83\n(magnitude -0.093) --> 0.093\n(magnitude 3+4i) --> 5\n(magnitude 7.25@1.5708) --> 7.25\n") ("objects:s127" "\nprocedure: (sqrt num)\nreturns: the principal square root of num\nlibraries: (rnrs base), (rnrs)\n" "Implementations are encouraged, but not required, to return exact\nresults for exact inputs to sqrt whenever feasible.\n" "\n" "(sqrt 16) --> 4\n(sqrt 1/4) --> 1/2\n(sqrt 4.84) --> 2.2\n(sqrt -4.84) --> 0.0+2.2i\n(sqrt 3+4i) --> 2+1i\n(sqrt -3.0-4.0i) --> 1.0-2.0i\n") ("objects:s128" "\nprocedure: (exact-integer-sqrt n)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "This procedure returns two nonnegative exact integers s and r where\nn = s2 + r and n < (s + 1)2.\n" "\n" "(exact-integer-sqrt 0) --> 0\n                       gifs/ghostRightarrow.gif 0\n(exact-integer-sqrt 9) --> 3\n                       --> 0\n(exact-integer-sqrt 19) --> 4\n                        --> 3\n") ("objects:s129" "\nprocedure: (exp num)\nreturns: e to the num power\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(exp 0.0) --> 1.0\n(exp 1.0) --> 2.7182818284590455\n(exp -.5) --> 0.6065306597126334\n") ("objects:s130" "\nprocedure: (log num)\nreturns: the natural logarithm of num\n\nprocedure: (log num1 num2)\nreturns: the base-num2 logarithm of num1\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(log 1.0) --> 0.0\n(log (exp 1.0)) --> 1.0\n(/ (log 100) (log 10)) --> 2.0\n(log (make-polar (exp 2.0) 1.0)) --> 2.0+1.0i\n\n(log 100.0 10.0) --> 2.0\n(log .125 2.0) --> -3.0\n") ("objects:s131" "\nprocedure: (sin num)\n\nprocedure: (cos num)\n\nprocedure: (tan num)\nreturns: the sine, cosine, or tangent of num\nlibraries: (rnrs base), (rnrs)\n" "The argument is specified in radians.\n" "\n" "(sin 0.0) --> 0.0\n(cos 0.0) --> 1.0\n(tan 0.0) --> 0.0\n") ("objects:s132" "\nprocedure: (asin num)\n\nprocedure: (acos num)\nreturns: the arc sine or the arc cosine of num\nlibraries: (rnrs base), (rnrs)\n" "The result is in radians.\nThe arc sine and arc cosine of a complex number z are defined as follows.\n" "\n" "\nmath/tspl/17.gif" "\n" "\nmath/tspl/18.gif" "\n\n" "\n" "(define pi (* (asin 1) 2))\n(= (* (acos 0) 2) pi) --> #t\n") ("objects:s133" "\nprocedure: (atan num)\n\nprocedure: (atan real1 real2)\nreturns: see below\nlibraries: (rnrs base), (rnrs)\n" "When passed a single complex argument num (the first form), atan\nreturns the arc tangent of num.\nThe arc tangent of a complex number z is defined as follows.\n" "\n" "\nmath/tspl/19.gif" "\n\n" "\nWhen passed two real arguments (the second form), atan is equivalent\nto (lambda (y x) (angle (make-rectangular x y))).\n" "\n" "(define pi (* (atan 1) 4))\n(= (* (atan 1.0 0.0) 2) pi) --> #t\n") ("objects:s134" "\nprocedure: (bitwise-not exint)\nreturns: the bitwise not of exint\n\nprocedure: (bitwise-and exint ...)\nreturns: the bitwise and of exint ...\n\nprocedure: (bitwise-ior exint ...)\nreturns: the bitwise inclusive or of exint ...\n\nprocedure: (bitwise-xor exint ...)\nreturns: the bitwise exclusive or of exint ...\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "The inputs are treated as if represented in two's complement, even\nif they are not represented that way internally.\n" "\n" "(bitwise-not 0) --> -1\n(bitwise-not 3) --> -4\n\n(bitwise-and #b01101 #b00111) --> #b00101\n(bitwise-ior #b01101 #b00111) --> #b01111\n(bitwise-xor #b01101 #b00111) --> #b01010\n") ("objects:s135" "\nprocedure: (bitwise-if exint1 exint2 exint3)\nreturns: the bitwise \"if\" of its arguments\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "The inputs are treated as if represented in two's complement, even\nif they are not represented that way internally.\n" "\nFor each bit set in exint1, the corresponding bit of the result\nis taken from exint2, and for each bit not set in exint1,\nthe corresponding bit of the result is taken from x3.\n" "\n" "(bitwise-if #b101010 #b111000 #b001100) --> #b101100\n" "bitwise-if might be defined as follows:\n" "\n" "(define bitwise-if\n  (lambda (exint1 exint2 exint3)\n    (bitwise-ior\n      (bitwise-and exint1 exint2)\n      (bitwise-and (bitwise-not exint1) exint3))))\n") ("objects:s136" "\nprocedure: (bitwise-bit-count exint)\nreturns: see below\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "For nonnegative inputs, bitwise-bit-count returns the number of bits\nset in the two's complement representation of exint.\nFor negative inputs, it returns a negative number whose magnitude is one\ngreater than the number of bits not set in the two's complement\nrepresentation of exint, which is equivalent to\n(bitwise-not (bitwise-bit-count (bitwise-not exint))).\n" "\n" "(bitwise-bit-count #b00000) --> 0\n(bitwise-bit-count #b00001) --> 1\n(bitwise-bit-count #b00100) --> 1\n(bitwise-bit-count #b10101) --> 3\n\n(bitwise-bit-count -1) --> -1\n(bitwise-bit-count -2) --> -2\n(bitwise-bit-count -4) --> -3\n") ("objects:s137" "\nprocedure: (bitwise-length exint)\nreturns: see below\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "This procedure returns the number of bits of the smallest two's\ncomplement representation of exint, not including the sign\nbit for negative numbers.\nFor 0 bitwise-length returns 0.\n" "\n" "(bitwise-length #b00000) --> 0\n(bitwise-length #b00001) --> 1\n(bitwise-length #b00100) --> 3\n(bitwise-length #b00110) --> 3\n\n(bitwise-length -1) --> 0\n(bitwise-length -6) --> 3\n(bitwise-length -9) --> 4\n") ("objects:s138" "\nprocedure: (bitwise-first-bit-set exint)\nreturns: the index of the least significant bit set in exint\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "The input is treated as if represented in two's complement, even\nif it is not represented that way internally.\n" "\nIf exint is 0, bitwise-first-bit-set returns -1.\n" "\n" "(bitwise-first-bit-set #b00000) --> -1\n(bitwise-first-bit-set #b00001) --> 0\n(bitwise-first-bit-set #b01100) --> 2\n\n(bitwise-first-bit-set -1) --> 0\n(bitwise-first-bit-set -2) --> 1\n(bitwise-first-bit-set -3) --> 0\n") ("objects:s139" "\nprocedure: (bitwise-bit-set? exint1 exint2)\nreturns: #t if bit exint2 of exint1 is set, #f otherwise\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "exint2 is taken as a zero-based index for the bits\nin the two's complement representation of exint1.\nThe two's complement representation of a nonnegative number conceptually extends\nto the left (toward more significant bits) with an infinite number of zero bits, and\nthe two's complement representation of a negative number conceptually extends\nto the left with an infinite number of one bits.\nThus, exact integers can be used to represent arbitrarily large sets, where 0 is the\nempty set, -1 is the universe, and bitwise-bit-set? is used to test for\nmembership.\n" "\n" "(bitwise-bit-set? #b01011 0) --> #t\n(bitwise-bit-set? #b01011 2) --> #f\n\n(bitwise-bit-set? -1 0) --> #t\n(bitwise-bit-set? -1 20) --> #t\n(bitwise-bit-set? -3 1) --> #f\n\n(bitwise-bit-set? 0 5000) --> #f\n(bitwise-bit-set? -1 5000) --> #t\n") ("objects:s140" "\nprocedure: (bitwise-copy-bit exint1 exint2 exint3)\nreturns: exint1 with bit exint2 replaced by exint3\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "exint2 is taken as a zero-based index for the bits\nin the two's complement representation of exint1.\nexint3 must be 0 or 1.\nThis procedure effectively clears or sets the specified bit depending\non the value of exint3.\nexint1 is treated as if represented in two's complement, even\nif it is not represented that way internally.\n" "\n" "(bitwise-copy-bit #b01110 0 1) --> #b01111\n(bitwise-copy-bit #b01110 2 0) --> #b01010\n") ("objects:s141" "\nprocedure: (bitwise-bit-field exint1 exint2 exint3)\nreturns: see below\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "exint2 and exint3 must be nonnegative,\nand exint2 must not be greater than exint3.\nThis procedure returns the number represented by extracting from exint1\nthe sequence of bits from exint2 (inclusive) to exint3 (exclusive).\nexint1 is treated as if represented in two's complement, even\nif it is not represented that way internally.\n" "\n" "(bitwise-bit-field #b10110 0 3) --> #b00110\n(bitwise-bit-field #b10110 1 3) --> #b00011\n(bitwise-bit-field #b10110 2 3) --> #b00001\n(bitwise-bit-field #b10110 3 3) --> #b00000\n") ("objects:s142" "\nprocedure: (bitwise-copy-bit-field exint1 exint2 exint3 exint4)\nreturns: see below\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "exint2 and exint3 must be nonnegative, and exint2\nmust not be greater than exint3.\nThis procedure returns exint1 with the n bits from exint2 (inclusive) to\nexint3 (exclusive) replaced by the low-order n bits of exint4.\nexint1 and exint4 are treated as if represented in two's complement, even\nif they are not represented that way internally.\n" "\n" "(bitwise-copy-bit-field #b10000 0 3 #b10101) --> #b10101\n(bitwise-copy-bit-field #b10000 1 3 #b10101) --> #b10010\n(bitwise-copy-bit-field #b10000 2 3 #b10101) --> #b10100\n(bitwise-copy-bit-field #b10000 3 3 #b10101) --> #b10000\n") ("objects:s143" "\nprocedure: (bitwise-arithmetic-shift-right exint1 exint2)\nreturns: exint1 arithmetically shifted right by exint2 bits\n\nprocedure: (bitwise-arithmetic-shift-left exint1 exint2)\nreturns: exint1 shifted left by exint2 bits\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "exint2 must be nonnegative.\nexint1 is treated as if represented in two's complement, even\nif it is not represented that way internally.\n" "\n" "(bitwise-arithmetic-shift-right #b10000 3) --> #b00010\n(bitwise-arithmetic-shift-right -1 1) --> -1\n(bitwise-arithmetic-shift-right -64 3) --> -8\n\n(bitwise-arithmetic-shift-left #b00010 2) --> #b01000\n(bitwise-arithmetic-shift-left -1 2) --> -4\n") ("objects:s144" "\nprocedure: (bitwise-arithmetic-shift exint1 exint2)\nreturns: see below\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "If exint2 is negative, bitwise-arithmetic-shift returns the\nresult of arithmetically shifting exint1 right by -exint2 bits.\nOtherwise, bitwise-arithmetic-shift returns the\nresult of shifting exint1 left by exint2 bits.\nexint1 is treated as if represented in two's complement, even\nif it is not represented that way internally.\n" "\n" "(bitwise-arithmetic-shift #b10000 -3) --> #b00010\n(bitwise-arithmetic-shift -1 -1) --> -1\n(bitwise-arithmetic-shift -64 -3) --> -8\n(bitwise-arithmetic-shift #b00010 2) --> #b01000\n(bitwise-arithmetic-shift -1 2) --> -4\n" "Thus, bitwise-arithmetic-shift behaves as if defined as follows.\n" "\n" "(define bitwise-arithmetic-shift\n  (lambda (exint1 exint2)\n    (if (< exint2 0)\n        (bitwise-arithmetic-shift-right exint1 (- exint2))\n        (bitwise-arithmetic-shift-left exint1 exint2))))\n") ("objects:s145" "\nprocedure: (bitwise-rotate-bit-field exint1 exint2 exint3 exint4)\nreturns: see below\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "exint2, exint3, and exint4 must be nonnegative,\nand exint2 must not be greater than exint3.\nThis procedure returns the result of shifting the bits of\nexint1 from bit exint2 (inclusive) through bit exint3 (exclusive)\nleft by (mod exint4 (- exint3 exint2)) bits,\nwith the bits shifted out of the range inserted\nat the bottom end of the range.\nexint1 is treated as if represented in two's complement, even\nif it is not represented that way internally.\n" "\n" "(bitwise-rotate-bit-field #b00011010 0 5 3) --> #b00010110\n(bitwise-rotate-bit-field #b01101011 2 7 3) --> #b01011011\n") ("objects:s146" "\nprocedure: (bitwise-reverse-bit-field exint1 exint2 exint3)\nreturns: see below\nlibraries: (rnrs arithmetic bitwise), (rnrs)\n" "exint2 and exint3 must be nonnegative, and exint2\nmust not be greater than exint3.\nThis procedure returns the result of reversing the bits of\nexint1 from bit exint2 (inclusive) through bit exint3 (exclusive).\nexint1 is treated as if represented in two's complement, even\nif it is not represented that way internally.\n" "\n" "(bitwise-reverse-bit-field #b00011010 0 5) --> #b00001011\n(bitwise-reverse-bit-field #b01101011 2 7) --> #b00101111\n") ("objects:s147" "\nprocedure: (string->number string)\n\nprocedure: (string->number string radix)\nreturns: the number represented by string, or #f\nlibraries: (rnrs base), (rnrs)\n" "If string is a valid representation of a number, that\nnumber is returned, otherwise #f is returned.\nThe number is interpreted in radix radix, which must be an\nexact integer in the set {2,8,10,16}.\nIf not specified, radix defaults to 10.\nAny radix specifier within string, e.g., #x, overrides the\nradix argument.\n" "\n" "(string->number \"0\") --> 0\n(string->number \"3.4e3\") --> 3400.0\n(string->number \"#x#e-2e2\") --> -738\n(string->number \"#e-2e2\" 16) --> -738\n(string->number \"#i15/16\") --> 0.9375\n(string->number \"10\" 16) --> 16\n") ("objects:s148" "\nprocedure: (number->string num)\n\nprocedure: (number->string num radix)\n\nprocedure: (number->string num radix precision)\nreturns: an external representation of num as a string\nlibraries: (rnrs base), (rnrs)\n" "The num is expressed in radix radix, which must be an\nexact integer in the set {2,8,10,16}.\nIf not specified, radix defaults to 10.\nIn any case, no radix specifier appears in the resulting string.\n" "\nThe external representation is such that, when converted back into\na number using string->number, the resulting numeric value is equivalent\nto num.\nThat is, for all inputs:\n" "\n" "(eqv? (string->number\n        (number->string num radix)\n        radix)\n      num)\n" "returns #t.\nAn exception with condition type\n&implementation-restriction is raised if this\nis not possible.\n" "\nIf precision is provided, it must be an exact positive integer,\nnum must be inexact, and radix must be 10.\nIn this case, the real part and, if present, the imaginary part of\nthe number are each printed with an explicit mantissa width m, where\nm is the least possible value greater than or equal to\nprecision that makes the expression above true.\n" "\nIf radix is 10, inexact values of num are expressed using the\nfewest number of significant digits possible [citation5]\nwithout violating the above restriction.\n" "\n" "(number->string 3.4) --> \"3.4\"\n(number->string 1e2) --> \"100.0\"\n(number->string 1e-23) --> \"1e-23\"\n(number->string -7/2) --> \"-7/2\"\n(number->string 220/9 16) --> \"DC/9\"\n") ("objects:s150" "\nprocedure: (fixnum? obj)\nreturns: #t if obj is a fixnum, #f otherwise\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "\n" "\n(fixnum? 0) --> #t\n(fixnum? -1) --> #t\n(fixnum? (- (expt 2 23))) --> #t\n(fixnum? (- (expt 2 23) 1)) --> #t\n") ("objects:s151" "\nprocedure: (least-fixnum)\nreturns: the least (most negative) fixnum supported by the implementation\n\nprocedure: (greatest-fixnum)\nreturns: the greatest (most positive) fixnum supported by the implementation\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "\n" "\n(fixnum? (- (least-fixnum) 1)) --> #f\n(fixnum? (least-fixnum)) --> #t\n(fixnum? (greatest-fixnum)) --> #t\n(fixnum? (+ (greatest-fixnum) 1)) --> #f\n") ("objects:s152" "\nprocedure: (fixnum-width)\nreturns: the implementation-dependent fixnum width\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "As described in the lead-in to this section, the fixnum width determines\nthe size of the fixnum range and must be at least 24.\n" "\n" "(define w (fixnum-width))\n(= (least-fixnum) (- (expt 2 (- w 1)))) --> #t\n(= (greatest-fixnum) (- (expt 2 (- w 1)) 1)) --> #t\n(>= w 24) --> #t\n") ("objects:s153" "\nprocedure: (fx=? fx1 fx2 fx3 ...)\n\nprocedure: (fx<? fx1 fx2 fx3 ...)\n\nprocedure: (fx>? fx1 fx2 fx3 ...)\n\nprocedure: (fx<=? fx1 fx2 fx3 ...)\n\nprocedure: (fx>=? fx1 fx2 fx3 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "The predicate fx=? returns #t if its arguments are equal.\nThe predicate fx<? returns #t if its arguments are monotonically\nincreasing, i.e., each argument is greater than the preceding ones,\nwhile fx>? returns #t if its arguments are monotonically decreasing.\nThe predicate fx<=? returns #t if its arguments are monotonically\nnondecreasing, i.e., each argument is not less than the preceding ones,\nwhile fx>=? returns #t if its arguments are monotonically nonincreasing.\n" "\n" "(fx=? 0 0) --> #t\n(fx=? -1 1) --> #f\n(fx<? (least-fixnum) 0 (greatest-fixnum)) --> #t\n(let ([x 3]) (fx<=? 0 x 9)) --> #t\n(fx>? 5 4 3 2 1) --> #t\n(fx<=? 1 3 2) --> #f\n(fx>=? 0 0 (least-fixnum)) --> #t\n") ("objects:s154" "\nprocedure: (fxzero? fx)\nreturns: #t if fx is zero, #f otherwise\n\nprocedure: (fxpositive? fx)\nreturns: #t if fx is greater than zero, #f otherwise\n\nprocedure: (fxnegative? fx)\nreturns: #t if fx is less than zero, #f otherwise\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "fxzero? is equivalent to (lambda (x) (fx=? x 0)),\nfxpositive? is equivalent to (lambda (x) (fx>? x 0)), and\nfxnegative? to (lambda (x) (fx<? x 0)).\n\n" "\n" "(fxzero? 0) --> #t\n(fxzero? 1) --> #f\n\n(fxpositive? 128) --> #t\n(fxpositive? 0) --> #f\n(fxpositive? -1) --> #f\n\n(fxnegative? -65) --> #t\n(fxnegative? 0) --> #f\n(fxnegative? 1) --> #f\n") ("objects:s155" "\nprocedure: (fxeven? fx)\nreturns: #t if fx is even, #f otherwise\n\nprocedure: (fxodd? fx)\nreturns: #t if fx is odd, #f otherwise\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "\n" "\n(fxeven? 0) --> #t\n(fxeven? 1) --> #f\n(fxeven? -1) --> #f\n(fxeven? -10) --> #t\n\n(fxodd? 0) --> #f\n(fxodd? 1) --> #t\n(fxodd? -1) --> #t\n(fxodd? -10) --> #f\n") ("objects:s156" "\nprocedure: (fxmin fx1 fx2 ...)\nreturns: the minimum of fx1 fx2 ... \nprocedure: (fxmax fx1 fx2 ...)\nreturns: the maximum of fx1 fx2 ...\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "\n" "\n(fxmin 4 -7 2 0 -6) --> -7\n\n(let ([ls '(7 3 5 2 9 8)])\n  (apply fxmin ls)) --> 2\n\n(fxmax 4 -7 2 0 -6) --> 4\n\n(let ([ls '(7 3 5 2 9 8)])\n  (apply fxmax ls)) --> 9\n") ("objects:s157" "\nprocedure: (fx+ fx1 fx2)\nreturns: the sum of fx1 and fx2\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "\n" "\n(fx+ -3 4) --> 1\n") ("objects:s158" "\nprocedure: (fx- fx)\nreturns: the additive inverse of fx\n\nprocedure: (fx- fx1 fx2)\nreturns: the difference between fx1 and fx2\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "\n" "\n(fx- 3) --> -3\n(fx- -3 4) --> -7\n") ("objects:s159" "\nprocedure: (fx* fx1 fx2)\nreturns: the product of fx1 and fx2\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "\n" "\n(fx* -3 4) --> -12\n") ("objects:s160" "\nprocedure: (fxdiv fx1 fx2)\n\nprocedure: (fxmod fx1 fx2)\n\nprocedure: (fxdiv-and-mod fx1 fx2)\nreturns: see below\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "fx2 must not be zero.\nThese are fixnum-specific versions of the generic div,\nmod, and div-and-mod.\n" "\n" "(fxdiv 17 3) --> 5\n(fxmod 17 3) --> 2\n(fxdiv -17 3) --> -6\n(fxmod -17 3) --> 1\n(fxdiv 17 -3) --> -5\n(fxmod 17 -3) --> 2\n(fxdiv -17 -3) --> 6\n(fxmod -17 -3) --> 1\n\n(fxdiv-and-mod 17 3) --> 5\n                     gifs/ghostRightarrow.gif 2\n") ("objects:s161" "\nprocedure: (fxdiv0 fx1 fx2)\n\nprocedure: (fxmod0 fx1 fx2)\n\nprocedure: (fxdiv0-and-mod0 fx1 fx2)\nreturns: see below\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "fx2 must not be zero.\nThese are fixnum-specific versions of the generic div0,\nmod0, and div0-and-mod0.\n" "\n" "(fxdiv0 17 3) --> 6\n(fxmod0 17 3) --> -1\n(fxdiv0 -17 3) --> -6\n(fxmod0 -17 3) --> 1\n(fxdiv0 17 -3) --> -6\n(fxmod0 17 -3) --> -1\n(fxdiv0 -17 -3) --> 6\n(fxmod0 -17 -3) --> 1\n\n(fxdiv0-and-mod0 17 3) --> 6\n                       gifs/ghostRightarrow.gif -1\n") ("objects:s162" "\nprocedure: (fx+/carry fx1 fx2 fx3)\n\nprocedure: (fx-/carry fx1 fx2 fx3)\n\nprocedure: (fx*/carry fx1 fx2 fx3)\nreturns: see below\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "When an ordinary fixnum addition, subtraction, or multiplication operation\noverflows, an exception is raised.\nThese alternative procedures instead return a carry and also allow the\ncarry to be propagated to the next operation.\nThey can be used to implement portable\ncode for multiple-precision arithmetic.\n" "\nThese procedures return the two\nfixnum values of the following computations.\nFor fx+/carry:\n" "\n" "(let* ([s (+ fx1 fx2 fx3)]\n       [s0 (mod0 s (expt 2 (fixnum-width)))]\n       [s1 (div0 s (expt 2 (fixnum-width)))])\n  (values s0 s1))\n" "for fx-/carry:\n" "\n" "(let* ([d (- fx1 fx2 fx3)]\n       [d0 (mod0 d (expt 2 (fixnum-width)))]\n       [d1 (div0 d (expt 2 (fixnum-width)))])\n  (values d0 d1))\n" "and for fx*/carry:\n" "\n" "(let* ([s (+ (* fx1 fx2) fx3)]\n       [s0 (mod0 s (expt 2 (fixnum-width)))]\n       [s1 (div0 s (expt 2 (fixnum-width)))])\n  (values s0 s1))\n") ("objects:s163" "\nprocedure: (fxnot fx)\nreturns: the bitwise not of fx\n\nprocedure: (fxand fx ...)\nreturns: the bitwise and of fx ...\n\nprocedure: (fxior fx ...)\nreturns: the bitwise inclusive or of fx ...\n\nprocedure: (fxxor fx ...)\nreturns: the bitwise exclusive or of fx ...\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "\n" "\n(fxnot 0) --> -1\n(fxnot 3) --> -4\n\n(fxand #b01101 #b00111) --> #b00101\n(fxior #b01101 #b00111) --> #b01111\n(fxxor #b01101 #b00111) --> #b01010\n") ("objects:s164" "\nprocedure: (fxif fx1 fx2 fx3)\nreturns: the bitwise \"if\" of its arguments\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "For each bit set in fx1, the corresponding bit of the result\nis taken from fx2, and for each bit not set in fx1,\nthe corresponding bit of the result is taken from x3.\n" "\n" "(fxif #b101010 #b111000 #b001100) --> #b101100\n" "fxif might be defined as follows:\n" "\n" "(define fxif\n  (lambda (fx1 fx2 fx3)\n    (fxior (fxand fx1 fx2)\n           (fxand (fxnot fx1) fx3))))\n") ("objects:s165" "\nprocedure: (fxbit-count fx)\nreturns: see below\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "For nonnegative inputs, fxbit-count returns the number of bits\nset in the two's complement representation of fx.\nFor negative inputs, it returns a negative number whose magnitude is one\ngreater than the number of bits not set in fx, which is equivalent to\n(fxnot (fxbit-count (fxnot fx))).\n" "\n" "(fxbit-count #b00000) --> 0\n(fxbit-count #b00001) --> 1\n(fxbit-count #b00100) --> 1\n(fxbit-count #b10101) --> 3\n\n(fxbit-count -1) --> -1\n(fxbit-count -2) --> -2\n(fxbit-count -4) --> -3\n") ("objects:s166" "\nprocedure: (fxlength fx)\nreturns: see below\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "This procedure returns the number of bits of the smallest two's\ncomplement representation of fx, not including the sign\nbit for negative numbers.\nFor 0 fxlength returns 0.\n" "\n" "(fxlength #b00000) --> 0\n(fxlength #b00001) --> 1\n(fxlength #b00100) --> 3\n(fxlength #b00110) --> 3\n\n(fxlength -1) --> 0\n(fxlength -6) --> 3\n(fxlength -9) --> 4\n") ("objects:s167" "\nprocedure: (fxfirst-bit-set fx)\nreturns: the index of the least significant bit set in fx\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "If fx is 0, fxfirst-bit-set returns -1.\n" "\n" "(fxfirst-bit-set #b00000) --> -1\n(fxfirst-bit-set #b00001) --> 0\n(fxfirst-bit-set #b01100) --> 2\n\n(fxfirst-bit-set -1) --> 0\n(fxfirst-bit-set -2) --> 1\n(fxfirst-bit-set -3) --> 0\n") ("objects:s168" "\nprocedure: (fxbit-set? fx1 fx2)\nreturns: #t if bit fx2 of fx1 is set, #f otherwise\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "fx2 must be nonnegative.\nIt is taken as a zero-based index for the bits\nin the two's complement representation of fx1, with the sign\nbit virtually replicated an infinite number of positions to the left.\n" "\n" "(fxbit-set? #b01011 0) --> #t\n(fxbit-set? #b01011 2) --> #f\n\n(fxbit-set? -1 0) --> #t\n(fxbit-set? -1 20) --> #t\n(fxbit-set? -3 1) --> #f\n(fxbit-set? 0 (- (fixnum-width) 1)) --> #f\n(fxbit-set? -1 (- (fixnum-width) 1)) --> #t\n") ("objects:s169" "\nprocedure: (fxcopy-bit fx1 fx2 fx3)\nreturns: fx1 with bit fx2 replaced by fx3\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "fx2 must be nonnegative and less than the value of\n(- (fixnum-width) 1).\nfx3 must be 0 or 1.\nThis procedure effectively clears or sets the specified bit depending\non the value of fx3.\n" "\n" "(fxcopy-bit #b01110 0 1) --> #b01111\n(fxcopy-bit #b01110 2 0) --> #b01010\n") ("objects:s170" "\nprocedure: (fxbit-field fx1 fx2 fx3)\nreturns: see below\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "fx2 and fx3 must be nonnegative and less than the value of\n(fixnum-width), and fx2 must not be greater than fx3.\nThis procedure returns the number represented by extracting from fx1\nthe sequence of bits from fx2 (inclusive) to fx3 (exclusive).\n" "\n" "(fxbit-field #b10110 0 3) --> #b00110\n(fxbit-field #b10110 1 3) --> #b00011\n(fxbit-field #b10110 2 3) --> #b00001\n(fxbit-field #b10110 3 3) --> #b00000\n") ("objects:s171" "\nprocedure: (fxcopy-bit-field fx1 fx2 fx3 fx4)\nreturns: see below\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "fx2 and fx3 must be nonnegative and less than the value of\n(fixnum-width), and fx2 must not be greater than fx3.\nThis procedure returns fx1 with n bits from fx2 (inclusive) to\nfx3 (exclusive) replaced by the low-order n bits of x4.\n" "\n" "(fxcopy-bit-field #b10000 0 3 #b10101) --> #b10101\n(fxcopy-bit-field #b10000 1 3 #b10101) --> #b10010\n(fxcopy-bit-field #b10000 2 3 #b10101) --> #b10100\n(fxcopy-bit-field #b10000 3 3 #b10101) --> #b10000\n") ("objects:s172" "\nprocedure: (fxarithmetic-shift-right fx1 fx2)\nreturns: fx1 arithmetically shifted right by fx2 bits\n\nprocedure: (fxarithmetic-shift-left fx1 fx2)\nreturns: fx1 shifted left by fx2 bits\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "fx2 must be nonnegative and less than the value of\n(fixnum-width).\n" "\n" "(fxarithmetic-shift-right #b10000 3) --> #b00010\n(fxarithmetic-shift-right -1 1) --> -1\n(fxarithmetic-shift-right -64 3) --> -8\n\n(fxarithmetic-shift-left #b00010 2) --> #b01000\n(fxarithmetic-shift-left -1 2) --> -4\n") ("objects:s173" "\nprocedure: (fxarithmetic-shift fx1 fx2)\nreturns: see below\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "The absolute value of fx2 must be less than the value of\n(fixnum-width).\nIf fx2 is negative, fxarithmetic-shift returns the\nresult of arithmetically shifting fx1 right by fx2 bits.\nOtherwise, fxarithmetic-shift returns the\nresult of shifting fx1 left by fx2 bits.\n" "\n" "(fxarithmetic-shift #b10000 -3) --> #b00010\n(fxarithmetic-shift -1 -1) --> -1\n(fxarithmetic-shift -64 -3) --> -8\n(fxarithmetic-shift #b00010 2) --> #b01000\n(fxarithmetic-shift -1 2) --> -4\n" "Thus, fxarithmetic-shift behaves as if defined as follows.\n" "\n" "(define fxarithmetic-shift\n  (lambda (fx1 fx2)\n    (if (fx<? fx2 0)\n        (fxarithmetic-shift-right fx1 (fx- fx2))\n        (fxarithmetic-shift-left fx1 fx2))))\n") ("objects:s174" "\nprocedure: (fxrotate-bit-field fx1 fx2 fx3 fx4)\nreturns: see below\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "fx2, fx3, and fx4 must be nonnegative and less than\nthe value of (fixnum-width), fx2 must not be greater\nthan fx3, and fx4 must not be greater than the difference between\nfx3 and fx2.\n" "\nThis procedure returns the result of shifting the bits of\nfx1 from bit fx2 (inclusive) through bit fx3 (exclusive)\nleft by fx4 bits, with the bits shifted out of the range inserted\nat the bottom end of the range.\n" "\n" "(fxrotate-bit-field #b00011010 0 5 3) --> #b00010110\n(fxrotate-bit-field #b01101011 2 7 3) --> #b01011011\n") ("objects:s175" "\nprocedure: (fxreverse-bit-field fx1 fx2 fx3)\nreturns: see below\nlibraries: (rnrs arithmetic fixnums), (rnrs)\n" "fx2 and fx3 must be nonnegative and less than\nthe value of (fixnum-width), and fx2 must not be greater\nthan fx3.\nThis procedure returns the result of reversing the bits of\nfx1 from bit fx2 (inclusive) through bit fx3 (exclusive).\n" "\n" "(fxreverse-bit-field #b00011010 0 5) --> #b00001011\n(fxreverse-bit-field #b01101011 2 7) --> #b00101111\n") ("objects:s177" "\nprocedure: (flonum? obj)\nreturns: #t if obj is a flonum, otherwise #f\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "\n" "\n(flonum? 0) --> #f\n(flonum? 3/4) --> #f\n(flonum? 3.5) --> #t\n(flonum? .02) --> #t\n(flonum? 1e10) --> #t\n(flonum? 3.0+0.0i) --> #f\n") ("objects:s178" "\nprocedure: (fl=? fl1 fl2 fl3 ...)\n\nprocedure: (fl<? fl1 fl2 fl3 ...)\n\nprocedure: (fl>? fl1 fl2 fl3 ...)\n\nprocedure: (fl<=? fl1 fl2 fl3 ...)\n\nprocedure: (fl>=? fl1 fl2 fl3 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "The predicate fl=? returns #t if its arguments are equal.\nThe predicate fl<? returns #t if its arguments are monotonically\nincreasing, i.e., each argument is greater than the preceding ones,\nwhile fl>? returns #t if its arguments are monotonically decreasing.\nThe predicate fl<=? returns #t if its arguments are monotonically\nnondecreasing, i.e., each argument is not less than the preceding ones,\nwhile fl>=? returns #t if its arguments are monotonically nonincreasing.\nWhen passed only one argument, each of these predicates returns #t.\n" "\nComparisons involving NaNs always return #f.\n" "\n" "(fl=? 0.0 0.0) --> #t\n(fl<? -1.0 0.0 1.0) --> #t\n(fl>? -1.0 0.0 1.0) --> #f\n(fl<=? 0.0 3.0 3.0) --> #t\n(fl>=? 4.0 3.0 3.0) --> #t\n(fl<? 7.0 +inf.0) --> #t\n(fl=? +nan.0 0.0) --> #f\n(fl=? +nan.0 +nan.0) --> #f\n(fl<? +nan.0 +nan.0) --> #f\n(fl<=? +nan.0 +inf.0) --> #f\n(fl>=? +nan.0 +inf.0) --> #f\n") ("objects:s179" "\nprocedure: (flzero? fl)\nreturns: #t if fl is zero, #f otherwise\n\nprocedure: (flpositive? fl)\nreturns: #t if fl is greater than zero, #f otherwise\n\nprocedure: (flnegative? fl)\nreturns: #t if fl is less than zero, #f otherwise\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "flzero? is equivalent to (lambda (x) (fl=? x 0.0)),\nflpositive? is equivalent to (lambda (x) (fl>? x 0.0)), and\nflnegative? to (lambda (x) (fl<? x 0.0)).\n" "\nEven if the flonum representation distinguishes -0.0 from +0.0, -0.0 is\nconsidered both zero and nonnegative.\n" "\n" "(flzero? 0.0) --> #t\n(flzero? 1.0) --> #f\n\n(flpositive? 128.0) --> #t\n(flpositive? 0.0) --> #f\n(flpositive? -1.0) --> #f\n\n(flnegative? -65.0) --> #t\n(flnegative? 0.0) --> #f\n(flnegative? 1.0) --> #f\n\n(flzero? -0.0) --> #t\n(flnegative? -0.0) --> #f\n\n(flnegative? +nan.0) --> #f\n(flzero? +nan.0) --> #f\n(flpositive? +nan.0) --> #f\n\n(flnegative? +inf.0) --> #f\n(flnegative? -inf.0) --> #t\n") ("objects:s180" "\nprocedure: (flinteger? fl)\nreturns: #t if fl is integer, #f otherwise\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "\n" "\n(flinteger? 0.0) --> #t\n(flinteger? -17.0) --> #t\n(flinteger? +nan.0) --> #f\n(flinteger? +inf.0) --> #f\n") ("objects:s181" "\nprocedure: (flfinite? fl)\nreturns: #t if fl is finite, #f otherwise\n\nprocedure: (flinfinite? fl)\nreturns: #t if fl is infinite, #f otherwise\n\nprocedure: (flnan? fl)\nreturns: #t if fl is a NaN, #f otherwise\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "\n" "\n(flfinite? 3.1415) --> #t\n(flinfinite? 3.1415) --> #f\n(flnan? 3.1415) --> #f\n\n(flfinite? +inf.0) --> #f\n(flinfinite? -inf.0) --> #t\n(flnan? -inf.0) --> #f\n\n(flfinite? +nan.0) --> #f\n(flinfinite? +nan.0) --> #f\n(flnan? +nan.0) --> #t\n") ("objects:s182" "\nprocedure: (fleven? fl-int)\nreturns: #t if fl-int is even, #f otherwise\n\nprocedure: (flodd? fl-int)\nreturns: #t if fl-int is odd, #f otherwise\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "fl-int must be an integer-valued flonum.\n" "\n" "(fleven? 0.0) --> #t\n(fleven? 1.0) --> #f\n(fleven? -1.0) --> #f\n(fleven? -10.0) --> #t\n\n(flodd? 0.0) --> #f\n(flodd? 1.0) --> #t\n(flodd? -1.0) --> #t\n(flodd? -10.0) --> #f\n") ("objects:s183" "\nprocedure: (flmin fl1 fl2 ...)\nreturns: the minimum of fl1 fl2 ... \nprocedure: (flmax fl1 fl2 ...)\nreturns: the maximum of fl1 fl2 ...\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "\n" "\n(flmin 4.2 -7.5 2.0 0.0 -6.4) --> -7.5\n\n(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])\n  (apply flmin ls)) --> 2.6\n\n(flmax 4.2 -7.5 2.0 0.0 -6.4) --> 4.2\n\n(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])\n  (apply flmax ls)) --> 8.0\n") ("objects:s184" "\nprocedure: (fl+ fl ...)\nreturns: the sum of the arguments fl ...\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "When called with no arguments, fl+ returns 0.0.\n" "\n" "(fl+) --> 0.0\n(fl+ 1.0 2.5) --> 3.25\n(fl+ 3.0 4.25 5.0) --> 12.25\n(apply fl+ '(1.0 2.0 3.0 4.0 5.0)) --> 15.0\n") ("objects:s185" "\nprocedure: (fl- fl)\nreturns: the additive inverse of fl\n\nprocedure: (fl- fl1 fl2 fl3 ...)\nreturns: the difference between fl1 and the sum of fl2 fl3 ...\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "With an IEEE floating-point representation of flonums,\nthe single-argument fl- is equivalent to\n" "\n" "(lambda (x) (fl* -1.0 x))\n" "or\n" "\n" "(lambda (x) (fl- -0.0 x))\n" "but not\n" "\n" "(lambda (x) (fl- 0.0 x))\n" "since the latter returns 0.0 rather than -0.0 for 0.0.\n" "\n" "(fl- 0.0) --> -0.0\n(fl- 3.0) --> -3.0\n(fl- 4.0 3.0) --> 1.0\n(fl- 4.0 3.0 2.0 1.0) --> -2.0\n") ("objects:s186" "\nprocedure: (fl* fl ...)\nreturns: the product of the arguments fl ...\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "When called with no arguments, fl* returns 1.0.\n" "\n" "(fl*) --> 1.0\n(fl* 1.5 2.5) --> 3.75\n(fl* 3.0 -4.0 5.0) --> -60.0\n(apply fl* '(1.0 -2.0 3.0 -4.0 5.0)) --> 120.0\n") ("objects:s187" "\nprocedure: (fl/ fl)\nreturns: the multiplicative inverse of fl\n\nprocedure: (fl/ fl1 fl2 fl3 ...)\nreturns: the result of dividing fl1 by the product of fl2 fl3 ...\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "\n" "\n(fl/ -4.0) --> -0.25\n(fl/ 8.0 -2.0) --> -4.0\n(fl/ -9.0 2.0) --> -4.5\n(fl/ 60.0 5.0 3.0 2.0) --> 2.0\n") ("objects:s188" "\nprocedure: (fldiv fl1 fl2)\n\nprocedure: (flmod fl1 fl2)\n\nprocedure: (fldiv-and-mod fl1 fl2)\nreturns: see below\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "These are flonum-specific versions of the generic div,\nmod, and div-and-mod.\n" "\n" "(fldiv 17.0 3.0) --> 5.0\n(flmod 17.0 3.0) --> 2.0\n(fldiv -17.0 3.0) --> -6.0\n(flmod -17.0 3.0) --> 1.0\n(fldiv 17.0 -3.0) --> -5.0\n(flmod 17.0 -3.0) --> 2.0\n(fldiv -17.0 -3.0) --> 6.0\n(flmod -17.0 -3.0) --> 1.0\n\n(fldiv-and-mod 17.5 3.75) --> 4.0\n                          gifs/ghostRightarrow.gif 2.5\n") ("objects:s189" "\nprocedure: (fldiv0 fl1 fl2)\n\nprocedure: (flmod0 fl1 fl2)\n\nprocedure: (fldiv0-and-mod0 fl1 fl2)\nreturns: see below\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "These are flonum-specific versions of the generic div0,\nmod0, and div0-and-mod0.\n" "\n" "(fldiv0 17.0 3.0) --> 6.0\n(flmod0 17.0 3.0) --> -1.0\n(fldiv0 -17.0 3.0) --> -6.0\n(flmod0 -17.0 3.0) --> 1.0\n(fldiv0 17.0 -3.0) --> -6.0\n(flmod0 17.0 -3.0) --> -1.0\n(fldiv0 -17.0 -3.0) --> 6.0\n(flmod0 -17.0 -3.0) --> 1.0\n\n(fldiv0-and-mod0 17.5 3.75) --> 5.0\n                            gifs/ghostRightarrow.gif -1.25\n") ("objects:s190" "\nprocedure: (flround fl)\nreturns: the integer closest to fl\n\nprocedure: (fltruncate fl)\nreturns: the integer closest to fl toward zero\n\nprocedure: (flfloor fl)\nreturns: the integer closest to fl toward math/tspl/11.gif\n\nprocedure: (flceiling fl)\nreturns: the integer closest to fl toward math/tspl/12.gif\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "If fl is an integer, NaN, or infinity, each of these procedures returns fl.\nIf fl is exactly between two integers, flround returns the closest\neven integer.\n" "\n" "(flround 17.3) --> 17.0\n(flround -17.3) --> -17.0\n(flround 2.5) --> 2.0\n(flround 3.5) --> 4.0\n\n(fltruncate 17.3) --> 17.0\n(fltruncate -17.3) --> -17.0\n\n(flfloor 17.3) --> 17.0\n(flfloor -17.3) --> -18.0\n\n(flceiling 17.3) --> 18.0\n(flceiling -17.3) --> -17.0\n") ("objects:s191" "\nprocedure: (flnumerator fl)\nreturns: the numerator of fl\n\nprocedure: (fldenominator fl)\nreturns: the denominator of fl\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "If fl is an integer, including 0.0, or infinity, the numerator is fl\nand the denominator is 1.0.\n" "\n" "(flnumerator -9.0) --> -9.0\n(fldenominator -9.0) --> 1.0\n(flnumerator 0.0) --> 0.0\n(fldenominator 0.0) --> 1.0\n(flnumerator -inf.0) --> -inf.0\n(fldenominator -inf.0) --> 1.0\n" "The following hold for IEEE floats, but not necessarily other\nflonum representations.\n" "\n" "(flnumerator 3.5) --> 7.0\n(fldenominator 3.5) --> 2.0\n") ("objects:s192" "\nprocedure: (flabs fl)\nreturns: absolute value of fl\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "\n" "\n(flabs 3.2) --> 3.2\n(flabs -2e-20) --> 2e-20\n") ("objects:s193" "\nprocedure: (flexp fl)\nreturns: e to the fl power\n\nprocedure: (fllog fl)\nreturns: the natural logarithm of fl\n\nprocedure: (fllog fl1 fl2)\nreturns: the base-fl2 logarithm of fl1\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "\n" "\n(flexp 0.0) --> 1.0\n(flexp 1.0) --> 2.7182818284590455\n\n(fllog 1.0) --> 0.0\n(fllog (exp 1.0)) --> 1.0\n(fl/ (fllog 100.0) (fllog 10.0)) --> 2.0\n\n(fllog 100.0 10.0) --> 2.0\n(fllog .125 2.0) --> -3.0\n") ("objects:s194" "\nprocedure: (flsin fl)\nreturns: the sine of fl\n\nprocedure: (flcos fl)\nreturns: the cosine of fl\n\nprocedure: (fltan fl)\nreturns: the tangent of fl\nlibraries: (rnrs arithmetic flonums), (rnrs)\n") ("objects:s195" "\nprocedure: (flasin fl)\nreturns: the arc sine of fl\n\nprocedure: (flacos fl)\nreturns: the arc cosine of fl\n\nprocedure: (flatan fl)\nreturns: the arc tangent of fl\n\nprocedure: (flatan fl1 fl2)\nreturns: the arc tangent of fl1/fl2\nlibraries: (rnrs arithmetic flonums), (rnrs)\n") ("objects:s196" "\nprocedure: (flsqrt fl)\nreturns: the principal square root of fl\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "Returns the principal square root of fl.\nThe square root of -0.0 should be -0.0.\nThe result for other negative numbers may be a NaN or some\nother unspecified flonum.\n" "\n" "(flsqrt 4.0) --> 2.0\n(flsqrt 0.0) --> 0.0\n(flsqrt -0.0) --> -0.0\n") ("objects:s197" "\nprocedure: (flexpt fl1 fl2)\nreturns: fl1 raised to the fl2 power\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "If fl1 is negative and fl2 is not an integer,\nthe result may be a NaN or some other unspecified flonum.\nIf fl1 and fl2 are both zero, the result\nis 1.0.  If fl1 is zero and fl2 is positive,\nthe result is zero.  In other cases where fl1 is\nzero, the result may be a NaN or some other unspecified\nflonum.\n" "\n" "(flexpt 3.0 2.0) --> 9.0\n(flexpt 0.0 +inf.0) --> 0.0\n") ("objects:s198" "\nprocedure: (fixnum->flonum fx)\nreturns: the flonum representation closest to fx\n\nprocedure: (real->flonum real)\nreturns: the flonum representation closest to real\nlibraries: (rnrs arithmetic flonums), (rnrs)\n" "fixnum->flonum is a restricted variant of inexact.\nreal->flonum is a restricted variant of inexact when\nthe input is an exact real; when it is an inexact non-flonum real,\nit coverts the inexact non-flonum real into the closest flonum.\n\n" "\n" "(fixnum->flonum 0) --> 0.0\n(fixnum->flonum 13) --> 13.0\n\n(real->flonum -1/2) --> -0.5\n(real->flonum 1s3) --> 1000.0\n") ("objects:s201" "\nprocedure: (char=? char1 char2 char3 ...)\n\nprocedure: (char<? char1 char2 char3 ...)\n\nprocedure: (char>? char1 char2 char3 ...)\n\nprocedure: (char<=? char1 char2 char3 ...)\n\nprocedure: (char>=? char1 char2 char3 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "These predicates behave in a similar manner to the numeric predicates\n=, <, >, <=, and >=.\nFor example, char=? returns #t when its arguments are\nequivalent characters, and char<? returns #t when its\narguments are monotonically increasing character (Unicode scalar) values.\n" "\n" "(char>? #\\a #\\b) --> #f\n(char<? #\\a #\\b) --> #t\n(char<? #\\a #\\b #\\c) --> #t\n(let ([c #\\r])\n  (char<=? #\\a c #\\z)) --> #t\n(char<=? #\\Z #\\W) --> #f\n(char=? #\\+ #\\+) --> #t\n") ("objects:s202" "\nprocedure: (char-ci=? char1 char2 char3 ...)\n\nprocedure: (char-ci<? char1 char2 char3 ...)\n\nprocedure: (char-ci>? char1 char2 char3 ...)\n\nprocedure: (char-ci<=? char1 char2 char3 ...)\n\nprocedure: (char-ci>=? char1 char2 char3 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (rnrs unicode), (rnrs)\n" "These predicates are identical to the predicates char=?, char<?,\nchar>?, char<=?, and char>=? except that they are\ncase-insensitive, i.e., compare the case-folded versions of their arguments.\nFor example, char=? considers #\\a and #\\A to be\ndistinct values; char-ci=? does not.\n" "\n" "(char-ci<? #\\a #\\B) --> #t\n(char-ci=? #\\W #\\w) --> #t\n(char-ci=? #\\= #\\+) --> #f\n(let ([c #\\R])\n  (list (char<=? #\\a c #\\z)\n        (char-ci<=? #\\a c #\\z))) --> (#f #t)\n") ("objects:s203" "\nprocedure: (char-alphabetic? char)\nreturns: #t if char is a letter, #f otherwise\n\nprocedure: (char-numeric? char)\nreturns: #t if char is a digit, #f otherwise\n\nprocedure: (char-whitespace? char)\nreturns: #t if char is whitespace, #f otherwise\nlibraries: (rnrs unicode), (rnrs)\n" "A character is alphabetic if it has the Unicode \"Alphabetic\" property,\nnumeric if it has the Unicode \"Numeric\" property, and whitespace if has\nthe Unicode \"White_Space\" property.\n" "\n" "(char-alphabetic? #\\a) --> #t\n(char-alphabetic? #\\T) --> #t\n(char-alphabetic? #\\8) --> #f\n(char-alphabetic? #\\$) --> #f\n\n(char-numeric? #\\7) --> #t\n(char-numeric? #\\2) --> #t\n(char-numeric? #\\X) --> #f\n(char-numeric? #\\space) --> #f\n\n(char-whitespace? #\\space) --> #t\n(char-whitespace? #\\newline) --> #t\n(char-whitespace? #\\Z) --> #f\n") ("objects:s204" "\nprocedure: (char-lower-case? char)\nreturns: #t if char is lower case, #f otherwise\n\nprocedure: (char-upper-case? char)\nreturns: #t if char is upper case, #f otherwise\n\nprocedure: (char-title-case? char)\nreturns: #t if char is title case, #f otherwise\nlibraries: (rnrs unicode), (rnrs)\n" "A character is upper-case if it has the Unicode \"Uppercase\" property,\nlower-case if it has the \"Lowercase\" property, and title-case if it is\nin the Lt general category.\n" "\n" "(char-lower-case? #\\r) --> #t\n(char-lower-case? #\\R) --> #f\n\n(char-upper-case? #\\r) --> #f\n(char-upper-case? #\\R) --> #t\n\n(char-title-case? #\\I) --> #f\n(char-title-case? #\\x01C5) --> #t\n") ("objects:s205" "\nprocedure: (char-general-category char)\nreturns: a symbol representing the Unicode general category of char\nlibraries: (rnrs unicode), (rnrs)\n" "The return value is one of the symbols Lu, Ll,\nLt, Lm, Lo, Mn, Mc,\nMe, Nd, Nl, No, Ps,\nPe, Pi, Pf, Pd, Pc,\nPo, Sc, Sm, Sk, So,\nZs, Zp, Zl, Cc, Cf,\nCs, Co, or Cn.\n" "\n" "(char-general-category #\\a) --> Ll\n(char-general-category #\\space) --> Zs\n(char-general-category #\\x10FFFF) --> Cn  \n") ("objects:s206" "\nprocedure: (char-upcase char)\nreturns: the upper-case character counterpart of char\nlibraries: (rnrs unicode), (rnrs)\n" "If char is a lower- or title-case character and has a single\nupper-case counterpart, char-upcase returns the upper-case\ncounterpart.\nOtherwise char-upcase returns char.\n" "\n" "(char-upcase #\\g) --> #\\G\n(char-upcase #\\G) --> #\\G\n(char-upcase #\\7) --> #\\7\n(char-upcase #\\math/tspl/20.gif) --> #\\math/tspl/21.gif\n") ("objects:s207" "\nprocedure: (char-downcase char)\nreturns: the lower-case character equivalent of char\nlibraries: (rnrs unicode), (rnrs)\n" "If char is an upper- or title-case character and has a single\nlower-case counterpart, char-downcase returns the lower-case\ncounterpart.\nOtherwise char-downcase returns char.\n" "\n" "(char-downcase #\\g) --> #\\g\n(char-downcase #\\G) --> #\\g\n(char-downcase #\\7) --> #\\7\n(char-downcase #\\math/tspl/20.gif) --> #\\math/tspl/20.gif\n") ("objects:s208" "\nprocedure: (char-titlecase char)\nreturns: the title-case character equivalent of char\nlibraries: (rnrs unicode), (rnrs)\n" "If char is an upper- or lower-case character and has a single\ntitle-case counterpart, char-titlecase returns the title-case\ncounterpart.\nOtherwise, if it is not a title-case character, has no single title-case\ncounterpart, but does have a single upper-case counterpart,\nchar-titlecase returns the upper-case counterpart.\nOtherwise char-titlecase returns char.\n" "\n" "(char-titlecase #\\g) --> #\\G\n(char-titlecase #\\G) --> #\\G\n(char-titlecase #\\7) --> #\\7\n(char-titlecase #\\math/tspl/20.gif) --> #\\math/tspl/21.gif\n") ("objects:s209" "\nprocedure: (char-foldcase char)\nreturns: the case-folded character equivalent of char\nlibraries: (rnrs unicode), (rnrs)\n" "If char has a case-folded counterpart, char-foldcase\nreturns the case-folded counterpart.\nOtherwise, char-foldcase returns char.\nFor most characters, (char-foldcase char) is\nequivalent to (char-downcase (char-upcase char)),\nbut for Turkic  and ,\nchar-foldcase acts as the identity.\n" "\n" "(char-foldcase #\\g) --> #\\g\n(char-foldcase #\\G) --> #\\g\n(char-foldcase #\\7) --> #\\7\n(char-foldcase #\\math/tspl/20.gif) --> #\\math/tspl/22.gif\n") ("objects:s210" "\nprocedure: (char->integer char)\nreturns: the Unicode scalar value of char as an exact integer\nlibraries: (rnrs base), (rnrs)\n" "\n" "(char->integer #\\newline) --> 10\n(char->integer #\\space) --> 32\n(- (char->integer #\\Z) (char->integer #\\A)) --> 25\n") ("objects:s211" "\nprocedure: (integer->char n)\nreturns: the character corresponding to the Unicode scalar value n\nlibraries: (rnrs base), (rnrs)\n" "n must be an exact integer and a valid Unicode\nscalar value, i.e., math/tspl/23.gif or\nmath/tspl/24.gif.\n" "\n" "(integer->char 48) --> #\\0\n(integer->char #x3BB) --> #\\math/tspl/25.gif\n") ("objects:s215" "\nprocedure: (string=? string1 string2 string3 ...)\n\nprocedure: (string<? string1 string2 string3 ...)\n\nprocedure: (string>? string1 string2 string3 ...)\n\nprocedure: (string<=? string1 string2 string3 ...)\n\nprocedure: (string>=? string1 string2 string3 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "As with =, <, >, <=, and >=, these predicates\nexpress relationships among all of the arguments.\nFor example, string>? determines if the lexicographic ordering\nof its arguments is monotonically decreasing.\n" "\nThe comparisons are based on the character predicates char=?\nand char<?.\nTwo strings are lexicographically equivalent if they are the same length\nand consist of the same sequence of characters according to char=?.\nIf two strings differ only in length, the shorter string is considered to\nbe lexicographically less than the longer string.\nOtherwise, the first character position at which the strings differ (by char=?)\ndetermines which string is lexicographically less than the other, according\nto char<?.\n" "\nTwo-argument string=? may be defined without error checks as follows.\n" "\n" "(define string=?\n  (lambda (s1 s2)\n    (let ([n (string-length s1)])\n      (and (= (string-length s2) n)\n           (let loop ([i 0])\n             (or (= i n)\n                 (and (char=? (string-ref s1 i) (string-ref s2 i))\n                      (loop (+ i 1)))))))))\n" "Two-argument string<? may be defined without error checks as follows.\n" "\n" "(define string<?\n  (lambda (s1 s2)\n    (let ([n1 (string-length s1)] [n2 (string-length s2)])\n      (let loop ([i 0])\n        (and (not (= i n2))\n             (or (= i n1)\n                 (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])\n                   (or (char<? c1 c2)\n                       (and (char=? c1 c2)\n                            (loop (+ i 1)))))))))))\n" "These definitions may be extended straightforwardly to support\nthree or more arguments.\nstring<=?, string>?, and string>=?\nmay be defined similarly.\n" "\n" "(string=? \"mom\" \"mom\") --> #t\n(string<? \"mom\" \"mommy\") --> #t\n(string>? \"Dad\" \"Dad\") --> #f\n(string=? \"Mom and Dad\" \"mom and dad\") --> #f\n(string<? \"a\" \"b\" \"c\") --> #t\n") ("objects:s216" "\nprocedure: (string-ci=? string1 string2 string3 ...)\n\nprocedure: (string-ci<? string1 string2 string3 ...)\n\nprocedure: (string-ci>? string1 string2 string3 ...)\n\nprocedure: (string-ci<=? string1 string2 string3 ...)\n\nprocedure: (string-ci>=? string1 string2 string3 ...)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (rnrs unicode), (rnrs)\n" "These predicates are identical to\nstring=?, string<?, string>?, string<=?, and\nstring>=? except that they are case-insensitive,\ni.e., compare the case-folded versions of their arguments.\n" "\n" "(string-ci=? \"Mom and Dad\" \"mom and dad\") --> #t\n(string-ci<=? \"say what\" \"Say What!?\") --> #t\n(string-ci>? \"N\" \"m\" \"L\" \"k\") --> #t\n(string-ci=? \"Strae\" \"Strasse\") --> #t\n") ("objects:s217" "\nprocedure: (string char ...)\nreturns: a string containing the characters char ...\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(string) --> \"\"\n(string #\\a #\\b #\\c) --> \"abc\"\n(string #\\H #\\E #\\Y #\\!) --> \"HEY!\"\n") ("objects:s218" "\nprocedure: (make-string n)\n\nprocedure: (make-string n char)\nreturns: a string of length n\nlibraries: (rnrs base), (rnrs)\n" "n must be an exact nonnegative integer.\nIf char is supplied, the string is filled with n\noccurrences of char,\notherwise the characters contained in the string are unspecified.\n" "\n" "(make-string 0) --> \"\"\n(make-string 0 #\\x) --> \"\"\n(make-string 5 #\\x) --> \"xxxxx\"\n") ("objects:s219" "\nprocedure: (string-length string)\nreturns: the number of characters in string\nlibraries: (rnrs base), (rnrs)\n" "The length of a string is always an exact nonnegative integer.\n" "\n" "(string-length \"abc\") --> 3\n(string-length \"\") --> 0\n(string-length \"hi there\") --> 8\n(string-length (make-string 1000000)) --> 1000000\n") ("objects:s220" "\nprocedure: (string-ref string n)\nreturns: the nth character (zero-based) of string\nlibraries: (rnrs base), (rnrs)\n" "n must be an exact nonnegative integer less than\nthe length of string.\n" "\n" "(string-ref \"hi there\" 0) --> #\\h\n(string-ref \"hi there\" 5) --> #\\e\n") ("objects:s221" "\nprocedure: (string-set! string n char)\nreturns: unspecified\nlibraries: (rnrs mutable-strings)\n" "n must be an exact nonnegative integer less than\nthe length of string.\nstring-set! changes the nth element of string to char.\n" "\n" "(let ([str (string-copy \"hi three\")])\n  (string-set! str 5 #\\e)\n  (string-set! str 6 #\\r)\n  str) --> \"hi there\"\n") ("objects:s222" "\nprocedure: (string-copy string)\nreturns: a new copy of string\nlibraries: (rnrs base), (rnrs)\n" "This procedure creates a new string with the same length and\ncontents as string.\n" "\n" "(string-copy \"abc\") --> \"abc\"\n\n(let ([str \"abc\"])\n  (eq? str (string-copy str))) --> #f\n") ("objects:s223" "\nprocedure: (string-append string ...)\nreturns: a new string formed by concatenating the strings string ...\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(string-append) --> \"\"\n(string-append \"abc\" \"def\") --> \"abcdef\"\n(string-append \"Hey \" \"you \" \"there!\") --> \"Hey you there!\"\n" "The following implementation of string-append recurs down the\nlist of strings to compute the total length, then allocates the new\nstring, then fills it up as it unwinds the recursion.\n" "\n" "(define string-append\n  (lambda args\n    (let f ([ls args] [n 0])\n      (if (null? ls)\n          (make-string n)\n          (let* ([s1 (car ls)]\n                 [m (string-length s1)]\n                 [s2 (f (cdr ls) (+ n m))])\n            (do ([i 0 (+ i 1)] [j n (+ j 1)])\n                ((= i m) s2)\n              (string-set! s2 j (string-ref s1 i))))))))\n") ("objects:s224" "\nprocedure: (substring string start end)\nreturns: a copy of string from start (inclusive) to end\n  (exclusive)\nlibraries: (rnrs base), (rnrs)\n" "start and end must be exact nonnegative integers;\nstart must be less than or equal to end,\nwhile end must be less than or equal to the length of string.\nIf end = start, a string of length zero is returned.\nsubstring may be defined without error checks as follows.\n" "\n" "(define substring\n  (lambda (s1 m n)\n    (let ([s2 (make-string (- n m))])\n      (do ([j 0 (+ j 1)] [i m (+ i 1)])\n          ((= i n) s2)\n        (string-set! s2 j (string-ref s1 i))))))\n\n(substring \"hi there\" 0 1) --> \"h\"\n(substring \"hi there\" 3 6) --> \"the\"\n(substring \"hi there\" 5 5) --> \"\"\n\n(let ([str \"hi there\"])\n  (let ([end (string-length str)])\n    (substring str 0 end))) --> \"hi there\"\n") ("objects:s225" "\nprocedure: (string-fill! string char)\nreturns: unspecified\nlibraries: (rnrs mutable-strings)\n" "string-fill! sets every character in string to char.\n" "\n" "(let ([str (string-copy \"sleepy\")])\n  (string-fill! str #\\Z)\n  str) --> \"ZZZZZZ\"\n" "string-fill! might be defined as follows:\n" "\n" "(define string-fill!\n  (lambda (s c)\n    (let ([n (string-length s)])\n      (do ([i 0 (+ i 1)])\n          ((= i n))\n          (string-set! s i c)))))\n" "An alternative definition is given on page 276.\n\n") ("objects:s226" "\nprocedure: (string-upcase string)\nreturns: the upper-case equivalent of string\n\nprocedure: (string-downcase string)\nreturns: the lower-case equivalent of string\n\nprocedure: (string-foldcase string)\nreturns: the case-folded equivalent of string\n\nprocedure: (string-titlecase string)\nreturns: the title-case equivalent of string\nlibraries: (rnrs unicode), (rnrs)\n" "These procedures implement Unicode's locale-independent case mappings from\nscalar-value sequences to scalar-value sequences.\nThese mappings do not always map single characters to single characters, so\nthe length of the result string may differ from the length of string.\nIf the result string is the same as string (by string=?),\nstring or a copy of string may be returned.\nOtherwise, the result string is newly allocated.\nstring-foldcase does not use the special mappings for Turkic\nlanguages.\n" "\nstring-titlecase converts the first cased character of each word\nin string to its title-case counterpart and converts each other\ncharacter to its lower-case counterpart.\nWord breaks are recognized as specified in Unicode Standard\nAnnex #29 [citation8].\n" "\n" "(string-upcase \"Hi\") --> \"HI\"\n(string-downcase \"Hi\") --> \"hi\"\n(string-foldcase \"Hi\") --> \"hi\"\n\n(string-upcase \"Strae\") --> \"STRASSE\"\n(string-downcase \"Strae\") --> \"strae\"\n(string-foldcase \"Strae\") --> \"strasse\"\n(string-downcase \"STRASSE\")  --> \"strasse\"\n\n(string-downcase \"math/tspl/21.gif\") --> \"math/tspl/22.gif\"\n\n(string-titlecase \"kNock KNoCK\") --> \"Knock Knock\"\n(string-titlecase \"who's there?\") --> \"Who's There?\"\n(string-titlecase \"r6rs\") --> \"R6rs\"\n(string-titlecase \"R6RS\") --> \"R6rs\"\n") ("objects:s227" "\nprocedure: (string-normalize-nfd string)\nreturns: the Unicode normalized form D of string\n\nprocedure: (string-normalize-nfkd string)\nreturns: the Unicode normalized form KD of string\n\nprocedure: (string-normalize-nfc string)\nreturns: the Unicode normalized form C of string\n\nprocedure: (string-normalize-nfkc string)\nreturns: the Unicode normalized form KC of string\nlibraries: (rnrs unicode), (rnrs)\n" "If the result string is the same as string (by string=?),\nstring or a copy of string may be returned.\nOtherwise, the result string is newly allocated.\n" "\n" "(string-normalize-nfd \"\\xE9;\") --> \"e\\x301;\"\n(string-normalize-nfc \"\\xE9;\") --> \"\\xE9;\"\n(string-normalize-nfd \"\\x65;\\x301;\") --> \"e\\x301;\"\n(string-normalize-nfc \"\\x65;\\x301;\") --> \"\\xE9;\"\n") ("objects:s228" "\nprocedure: (string->list string)\nreturns: a list of the characters in string\nlibraries: (rnrs base), (rnrs)\n" "string->list allows a string to be converted into a list, so that\nScheme's list-processing operations may be applied to the processing of\nstrings.\nstring->list may be defined without error checks as follows.\n" "\n" "(define string->list\n  (lambda (s)\n    (do ([i (- (string-length s) 1) (- i 1)]\n         [ls '() (cons (string-ref s i) ls)])\n        ((< i 0) ls))))\n\n(string->list \"\") --> ()\n(string->list \"abc\") --> (#\\a #\\b #\\c)\n(apply char<? (string->list \"abc\")) --> #t\n(map char-upcase (string->list \"abc\")) --> (#\\A #\\B #\\C)\n") ("objects:s229" "\nprocedure: (list->string list)\nreturns: a string of the characters in list\nlibraries: (rnrs base), (rnrs)\n" "list must consist entirely of characters.\n" "\nlist->string is the functional inverse of string->list.\nA program might use both procedures together, first converting a string\ninto a list, then operating on this list to produce a new list, and\nfinally converting the new list back into a string.\n" "\nlist->string may be defined without error checks as follows.\n" "\n" "(define list->string\n  (lambda (ls)\n    (let ([s (make-string (length ls))])\n      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])\n          ((null? ls) s)\n        (string-set! s i (car ls))))))\n\n(list->string '()) --> \"\"\n(list->string '(#\\a #\\b #\\c)) --> \"abc\"\n(list->string\n  (map char-upcase\n       (string->list \"abc\"))) --> \"ABC\"\n") ("objects:s231" "\nprocedure: (vector obj ...)\nreturns: a vector of the objects obj ...\nlibraries: (rnrs base), (rnrs)\n" "\n" "\n(vector) --> #()\n(vector 'a 'b 'c) --> #(a b c)\n") ("objects:s232" "\nprocedure: (make-vector n)\n\nprocedure: (make-vector n obj)\nreturns: a vector of length n\nlibraries: (rnrs base), (rnrs)\n" "n must be an exact nonnegative integer.\nIf obj is supplied, each element of the vector is filled with\nobj; otherwise, the elements are unspecified.\n" "\n" "(make-vector 0) --> #()\n(make-vector 0 '#(a)) --> #()\n(make-vector 5 '#(a)) --> #(#(a) #(a) #(a) #(a) #(a))\n") ("objects:s233" "\nprocedure: (vector-length vector)\nreturns: the number of elements in vector\nlibraries: (rnrs base), (rnrs)\n" "The length of a vector is always an exact nonnegative integer.\n" "\n" "(vector-length '#()) --> 0\n(vector-length '#(a b c)) --> 3\n(vector-length (vector 1 '(2) 3 '#(4 5))) --> 4\n(vector-length (make-vector 300)) --> 300\n") ("objects:s234" "\nprocedure: (vector-ref vector n)\nreturns: the nth element (zero-based) of vector\nlibraries: (rnrs base), (rnrs)\n" "n must be an exact nonnegative integer less than\nthe length of vector.\n" "\n" "(vector-ref '#(a b c) 0) --> a\n(vector-ref '#(a b c) 1) --> b\n(vector-ref '#(x y z w) 3) --> w\n") ("objects:s235" "\nprocedure: (vector-set! vector n obj)\nreturns: unspecified\nlibraries: (rnrs base), (rnrs)\n" "n must be an exact nonnegative integer less than\nthe length of vector.\nvector-set! changes the nth element of vector to obj.\n" "\n" "(let ([v (vector 'a 'b 'c 'd 'e)])\n  (vector-set! v 2 'x)\n  v) --> #(a b x d e)\n") ("objects:s236" "\nprocedure: (vector-fill! vector obj)\nreturns: unspecified\nlibraries: (rnrs base), (rnrs)\n" "vector-fill! replaces each element of vector with obj.\nIt may be defined without error checks as follows.\n" "\n" "(define vector-fill!\n  (lambda (v x)\n    (let ([n (vector-length v)])\n      (do ([i 0 (+ i 1)])\n          ((= i n))\n        (vector-set! v i x)))))\n\n(let ([v (vector 1 2 3)])\n  (vector-fill! v 0)\n  v) --> #(0 0 0)\n") ("objects:s237" "\nprocedure: (vector->list vector)\nreturns: a list of the elements of vector\nlibraries: (rnrs base), (rnrs)\n" "vector->list provides a convenient method for applying list-processing\noperations to vectors.\nIt may be defined without error checks as follows.\n" "\n" "(define vector->list\n  (lambda (s)\n    (do ([i (- (vector-length s) 1) (- i 1)]\n         [ls '() (cons (vector-ref s i) ls)])\n        ((< i 0) ls))))\n\n(vector->list (vector)) --> ()\n(vector->list '#(a b c)) --> (a b c)\n\n(let ((v '#(1 2 3 4 5)))\n  (apply * (vector->list v))) --> 120\n") ("objects:s238" "\nprocedure: (list->vector list)\nreturns: a vector of the elements of list\nlibraries: (rnrs base), (rnrs)\n" "list->vector is the functional inverse of vector->list.\nThe two procedures are often used in combination\nto take advantage of a list-processing operation.\nA vector may be converted to a list with vector->list, this list\nprocessed in some manner to produce a new list, and the new list\nconverted back into a vector with list->vector.\n" "\nlist->vector may be defined without error checks as follows.\n" "\n" "(define list->vector\n  (lambda (ls)\n    (let ([s (make-vector (length ls))])\n      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])\n          ((null? ls) s)\n        (vector-set! s i (car ls))))))\n\n(list->vector '()) --> #()\n(list->vector '(a b c)) --> #(a b c)\n\n(let ([v '#(1 2 3 4 5)])\n  (let ([ls (vector->list v)])\n    (list->vector (map * ls ls)))) --> #(1 4 9 16 25)\n") ("objects:s239" "\nprocedure: (vector-sort predicate vector)\nreturns: a vector containing the elements of vector, sorted according to predicate\n\nprocedure: (vector-sort! predicate vector)\nreturns: unspecified\nlibraries: (rnrs sorting), (rnrs)\n" "predicate should be a procedure that expects two arguments and\nreturns #t if its first argument must precede its second in\nthe sorted vector.\nThat is, if predicate is applied to two elements x and\ny, where x appears after y in the input vector,\nthe predicate should return true only if\nx should appear before y\nin the output vector.\nIf this constraint is met,\nvector-sort performs a stable sort, i.e., two elements are\nreordered only when necessary according to predicate.\nvector-sort! performs the sort destructively and\ndoes not necessarily perform a stable sort.\nDuplicate elements are not removed.\npredicate should not have any side effects.\n\n" "\nvector-sort may call predicate up to nlogn times,\nwhere n is the length of vector, while\nvector-sort! may call the predicate up to n2 times.\nThe looser bound for vector-sort! allows an implementation to\nuse a quicksort algorithm, which may be faster in some cases than\nalgorithms that have the tighter nlogn bound.\n" "\n" "(vector-sort < '#(3 4 2 1 2 5)) --> #(1 2 2 3 4 5)\n(vector-sort > '#(0.5 1/2)) --> #(0.5 1/2)\n(vector-sort > '#(1/2 0.5)) --> #(1/2 0.5)\n\n(let ([v (vector 3 4 2 1 2 5)])\n  (vector-sort! < v)\n  v) --> #(1 2 2 3 4 5)\n") ("objects:s240" "\nsyntax: (endianness symbol)\nreturns: symbol\nlibraries: (rnrs bytevectors), (rnrs)\n" "symbol must be the symbol little, the symbol big,\nor some other symbol recognized by the implementation as an endianness\nsymbol.\nIt is a syntax violation if symbol is not a symbol or if it is not\nrecognized by the implementation as an endianness symbol.\n" "\n" "(endianness little) --> little\n(endianness big) --> big\n(endianness \"spam\") --> exception\n") ("objects:s241" "\nprocedure: (native-endianness)\nreturns: a symbol naming the implementation's native endianness\nlibraries: (rnrs bytevectors), (rnrs)\n" "The return value is the symbol little, the symbol big,\nor some other endianness symbol recognized by the implementation.\nIt typically reflects the endianness of the underlying hardware.\n" "\n" "(symbol? (native-endianness)) --> #t\n") ("objects:s242" "\nprocedure: (make-bytevector n)\n\nprocedure: (make-bytevector n fill)\nreturns: a new bytevector of length n\nlibraries: (rnrs bytevectors), (rnrs)\n" "If fill is supplied, each element of the bytevector is initialized\nto fill; otherwise, the elements are unspecified.\nThe fill value must be a signed or unsigned 8-bit value, i.e.,\na value in the range -128 to 255 inclusive.\nA negative fill value is treated as its two's complement equivalent.\n" "\n" "(make-bytevector 0) --> #vu8()\n(make-bytevector 0 7) --> #vu8()\n(make-bytevector 5 7) --> #vu8(7 7 7 7 7)\n(make-bytevector 5 -7) --> #vu8(249 249 249 249 249)\n") ("objects:s243" "\nprocedure: (bytevector-length bytevector)\nreturns: the length of bytevector in 8-bit bytes\nlibraries: (rnrs bytevectors), (rnrs)\n" "\n" "\n(bytevector-length #vu8()) --> 0\n(bytevector-length #vu8(1 2 3)) --> 3\n(bytevector-length (make-bytevector 300)) --> 300\n") ("objects:s244" "\nprocedure: (bytevector=? bytevector1 bytevector2)\nreturns: #t if the relation holds, #f otherwise\nlibraries: (rnrs bytevectors), (rnrs)\n" "Two bytevectors are equal by bytevector=? if and only if they\nhave the same length and same contents.\n" "\n" "(bytevector=? #vu8() #vu8()) --> #t\n(bytevector=? (make-bytevector 3 0) #vu8(0 0 0)) --> #t\n(bytevector=? (make-bytevector 5 0) #vu8(0 0 0)) --> #f\n(bytevector=? #vu8(1 127 128 255) #vu8(255 128 127 1)) --> #f\n") ("objects:s245" "\nprocedure: (bytevector-fill! bytevector fill)\nreturns: unspecified\nlibraries: (rnrs bytevectors), (rnrs)\n" "The fill value must be a signed or unsigned 8-bit value, i.e.,\na value in the range -128 to 255 inclusive.\nA negative fill value is treated as its two's complement equivalent.\n" "\nbytevector-fill! replaces each element of bytevector with\nfill.\n" "\n" "(let ([v (make-bytevector 6)])\n  (bytevector-fill! v 255)\n  v) --> #vu8(255 255 255 255 255 255)\n\n(let ([v (make-bytevector 6)])\n  (bytevector-fill! v -128)\n  v) --> #vu8(128 128 128 128 128 128)\n") ("objects:s246" "\nprocedure: (bytevector-copy bytevector)\nreturns: a new bytevector that is a copy of bytevector \nlibraries: (rnrs bytevectors), (rnrs)\n" "bytevector-copy creates a new bytevector with the same length and\ncontents as bytevector.\n" "\n" "(bytevector-copy #vu8(1 127 128 255)) --> #vu8(1 127 128 255)\n\n(let ([v #vu8(1 127 128 255)])\n  (eq? v (bytevector-copy v))) --> #f\n") ("objects:s247" "\nprocedure: (bytevector-copy! src src-start dst dst-start n)\nreturns: unspecified\nlibraries: (rnrs bytevectors), (rnrs)\n" "src and dst must be bytevectors.\nsrc-start, dst-start, and n must be exact nonnegative\nintegers.\nThe sum of src-start and n must not exceed the length of src,\nand the sum of dst-start and n must not exceed the length of dst.\n" "\nbytevector-copy! overwrites the n bytes of dst\nstarting at dst-start with the n bytes of src\nstarting at src-start.\nThis works even if dst is the same bytevector as src and the\nsource and destination locations overlap.\nThat is, the destination is filled with the bytes that appeared at the\nsource before the operation began.\n" "\n" "(define v1 #vu8(31 63 95 127 159 191 223 255))\n(define v2 (make-bytevector 10 0))\n\n(bytevector-copy! v1 2 v2 1 4)\nv2 --> #vu8(0 95 127 159 191 0 0 0 0 0)\n \n(bytevector-copy! v1 5 v2 7 3)\nv2 --> #vu8(0 95 127 159 191 0 0 191 223 255)\n \n(bytevector-copy! v2 3 v2 0 6)\nv2 --> #vu8(159 191 0 0 191 223 0 191 223 255)\n \n(bytevector-copy! v2 0 v2 1 9)\nv2 --> #vu8(159 159 191 0 0 191 223 0 191 223)\n") ("objects:s248" "\nprocedure: (bytevector-u8-ref bytevector n)\nreturns: the 8-bit unsigned byte at index n (zero-based) of bytevector \nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer less than\nthe length of bytevector.\n" "\nThe value is returned as an exact 8-bit unsigned integer, i.e., a value in\nthe range 0 to 255 inclusive.\n" "\n" "(bytevector-u8-ref #vu8(1 127 128 255) 0) --> 1\n(bytevector-u8-ref #vu8(1 127 128 255) 2) --> 128\n(bytevector-u8-ref #vu8(1 127 128 255) 3) --> 255\n") ("objects:s249" "\nprocedure: (bytevector-s8-ref bytevector n)\nreturns: the 8-bit signed byte at index n (zero-based) of bytevector \nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer less than\nthe length of bytevector.\n" "\nThe value returned is an exact 8-bit signed integer, i.e., a value in\nthe range -128 to 127 inclusive, and is the equivalent of the\nstored value treated as a two's complement value.\n" "\n" "(bytevector-s8-ref #vu8(1 127 128 255) 0) --> 1\n(bytevector-s8-ref #vu8(1 127 128 255) 1) --> 127\n(bytevector-s8-ref #vu8(1 127 128 255) 2) --> -128\n(bytevector-s8-ref #vu8(1 127 128 255) 3) --> -1\n") ("objects:s250" "\nprocedure: (bytevector-u8-set! bytevector n u8)\nreturns: unspecified\nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer less than\nthe length of bytevector.\nu8 must be an 8-bit unsigned value, i.e., a value in the range\n0 to 255 inclusive.\n" "\nbytevector-u8-set! changes the 8-bit value at index n (zero-based)\nof bytevector to u8.\n" "\n" "(let ([v (make-bytevector 5 -1)])\n  (bytevector-u8-set! v 2 128)\n  v) --> #vu8(255 255 128 255 255)\n") ("objects:s251" "\nprocedure: (bytevector-s8-set! bytevector n s8)\nreturns: unspecified\nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer less than\nthe length of bytevector.\ns8 must be an 8-bit signed value, i.e., a value in the range\n-128 to 127 inclusive.\n" "\nbytevector-s8-set! changes the 8-bit value at index n\n(zero-based) of bytevector to the two's complement equivalent\nof s8.\n" "\n" "(let ([v (make-bytevector 4 0)])\n  (bytevector-s8-set! v 1 100)\n  (bytevector-s8-set! v 2 -100)\n  v) --> #vu8(0 100 156 0)\n") ("objects:s252" "\nprocedure: (bytevector->u8-list bytevector)\nreturns: a list of the 8-bit unsigned elements of bytevector\nlibraries: (rnrs bytevectors), (rnrs)\n" "\n" "(bytevector->u8-list (make-bytevector 0)) --> ()\n(bytevector->u8-list #vu8(1 127 128 255)) --> (1 127 128 255)\n\n(let ([v #vu8(1 2 3 255)])\n  (apply * (bytevector->u8-list v))) --> 1530\n") ("objects:s253" "\nprocedure: (u8-list->bytevector list)\nreturns: a new bytevector of the elements of list\nlibraries: (rnrs bytevectors), (rnrs)\n" "list must consist entirely of\nexact 8-bit unsigned integers, i.e., values in the range 0 to 255 inclusive.\n" "\n" "(u8-list->bytevector '()) --> #vu8()\n(u8-list->bytevector '(1 127 128 255)) --> #vu8(1 127 128 255)\n\n(let ([v #vu8(1 2 3 4 5)])\n  (let ([ls (bytevector->u8-list v)])\n    (u8-list->bytevector (map * ls ls)))) --> #vu8(1 4 9 16 25)\n") ("objects:s254" "\nprocedure: (bytevector-u16-native-ref bytevector n)\nreturns: the 16-bit unsigned integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-s16-native-ref bytevector n)\nreturns: the 16-bit signed integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-u32-native-ref bytevector n)\nreturns: the 32-bit unsigned integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-s32-native-ref bytevector n)\nreturns: the 32-bit signed integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-u64-native-ref bytevector n)\nreturns: the 64-bit unsigned integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-s64-native-ref bytevector n)\nreturns: the 64-bit signed integer at index n (zero-based) of bytevector \nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer.\nIt indexes the starting byte of the value and must be a multiple of the\nnumber of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit\nvalues, and 8 for 64-bit values.\nThe sum of n and the number of bytes occupied by the value must\nnot exceed the length of bytevector.\nThe native endianness is assumed.\n" "\nThe return value is an exact integer in the appropriate range for\nthe number of bytes occupied by the value.\nSigned values are the equivalent of the stored value treated as a two's\ncomplement value.\n" "\n" "(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))\n" "If native endianness is big:\n" "\n" "(bytevector-u16-native-ref v 2) --> #xfe56\n(bytevector-s16-native-ref v 2) --> #x-1aa\n(bytevector-s16-native-ref v 6) --> #x7898\n\n(bytevector-u32-native-ref v 0) --> #x1234fe56\n(bytevector-s32-native-ref v 0) --> #x1234fe56\n(bytevector-s32-native-ref v 4) --> #x-23458768\n\n(bytevector-u64-native-ref v 0) --> #x1234fe56dcba7898\n(bytevector-s64-native-ref v 0) --> #x1234fe56dcba7898\n" "If native endianness is little:\n" "\n" "(bytevector-u16-native-ref v 2) --> #x56fe\n(bytevector-s16-native-ref v 2) --> #x56fe\n(bytevector-s16-native-ref v 6) --> #x-6788\n\n(bytevector-u32-native-ref v 0) --> #x56fe3412\n(bytevector-s32-native-ref v 0) --> #x56fe3412\n(bytevector-s32-native-ref v 4) --> #x-67874524\n\n(bytevector-u64-native-ref v 0) --> #x9878badc56fe3412\n(bytevector-s64-native-ref v 0) --> #x-67874523a901cbee\n") ("objects:s255" "\nprocedure: (bytevector-u16-native-set! bytevector n u16)\n\nprocedure: (bytevector-s16-native-set! bytevector n s16)\n\nprocedure: (bytevector-u32-native-set! bytevector n u32)\n\nprocedure: (bytevector-s32-native-set! bytevector n s32)\n\nprocedure: (bytevector-u64-native-set! bytevector n u64)\n\nprocedure: (bytevector-s64-native-set! bytevector n s64)\nreturns: unspecified\nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer.\nIt indexes the starting byte of the value and must be a multiple of the\nnumber of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit\nvalues, and 8 for 64-bit values.\nThe sum of n and the number of bytes occupied by the value must\nnot exceed the length bytevector.\nu16 must be a 16-bit unsigned value, i.e., a value in the range\n0 to 216 - 1 inclusive;\ns16 must be a 16-bit signed value, i.e., a value in the range\n-215 to 215 - 1 inclusive;\nu32 must be a 32-bit unsigned value, i.e., a value in the range\n0 to 232 - 1 inclusive;\ns32 must be a 32-bit signed value, i.e., a value in the range\n-231 to 231 - 1 inclusive;\nu64 must be a 64-bit unsigned value, i.e., a value in the range\n0 to 264 - 1 inclusive; and\ns64 must be a 64-bit signed value, i.e., a value in the range\n-263 to 263 - 1 inclusive.\nThe native endianness is assumed.\n" "\nThese procedures store the given value in the 2, 4, or 8 bytes starting\nat index n (zero-based) of bytevector.\nNegative values are stored as their two's complement equivalent.\n" "\n" "(define v (make-bytevector 8 0))\n(bytevector-u16-native-set! v 0 #xfe56)\n(bytevector-s16-native-set! v 2 #x-1aa)\n(bytevector-s16-native-set! v 4 #x7898)\n" "If native endianness is big:\n" "\n" "v --> #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)\n" "If native endianness is little:\n" "\n" "v --> #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)\n" "\n" "(define v (make-bytevector 16 0))\n(bytevector-u32-native-set! v 0 #x1234fe56)\n(bytevector-s32-native-set! v 4 #x1234fe56)\n(bytevector-s32-native-set! v 8 #x-23458768)\n" "If native endianness is big:\n" "\n" "v --> #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56\n  gifs/ghostRightarrow.gif      #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)\n" "If native endianness is little:\n" "\n" "v --> #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12\n  gifs/ghostRightarrow.gif      #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)\n" "\n" "(define v (make-bytevector 24 0))\n(bytevector-u64-native-set! v 0 #x1234fe56dcba7898)\n(bytevector-s64-native-set! v 8 #x1234fe56dcba7898)\n(bytevector-s64-native-set! v 16 #x-67874523a901cbee)\n" "If native endianness is big:\n" "\n" "v --> #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\n  gifs/ghostRightarrow.gif      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\n  gifs/ghostRightarrow.gif      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)\n" "If native endianness is little:\n" "\n" "v --> #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\n  gifs/ghostRightarrow.gif      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\n  gifs/ghostRightarrow.gif      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)\n") ("objects:s256" "\nprocedure: (bytevector-u16-ref bytevector n eness)\nreturns: the 16-bit unsigned integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-s16-ref bytevector n eness)\nreturns: the 16-bit signed integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-u32-ref bytevector n eness)\nreturns: the 32-bit unsigned integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-s32-ref bytevector n eness)\nreturns: the 32-bit signed integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-u64-ref bytevector n eness)\nreturns: the 64-bit unsigned integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-s64-ref bytevector n eness)\nreturns: the 64-bit signed integer at index n (zero-based) of bytevector \nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer and\nindexes the starting byte of the value.\nThe sum of n and the number of bytes occupied by the value\n(2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values)\nmust not exceed the length of bytevector.\nn need not be a multiple of the\nnumber of bytes occupied by the value.\neness must be a valid endianness symbol naming the endianness.\n" "\nThe return value is an exact integer in the appropriate range for\nthe number of bytes occupied by the value.\nSigned values are the equivalent of the stored value treated as a two's\ncomplement value.\n" "\n" "(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))\n(bytevector-u16-ref v 0 (endianness big)) --> #x1234\n(bytevector-s16-ref v 1 (endianness big)) --> #x34fe\n(bytevector-s16-ref v 5 (endianness big)) --> #x-4588\n\n(bytevector-u32-ref v 2 'big) --> #xfe56dcba\n(bytevector-s32-ref v 3 'big) --> #x56dcba78\n(bytevector-s32-ref v 4 'big) --> #x-23458768\n\n(bytevector-u64-ref v 0 'big) --> #x1234fe56dcba7898\n(bytevector-s64-ref v 1 'big) --> #x34fe56dcba78989a\n\n(bytevector-u16-ref v 0 (endianness little)) --> #x3412\n(bytevector-s16-ref v 1 (endianness little)) --> #x-1cc\n(bytevector-s16-ref v 5 (endianness little)) --> #x78ba\n\n(bytevector-u32-ref v 2 'little) --> #xbadc56fe\n(bytevector-s32-ref v 3 'little) --> #x78badc56\n(bytevector-s32-ref v 4 'little) --> #x-67874524\n\n(bytevector-u64-ref v 0 'little) --> #x9878badc56fe3412\n(bytevector-s64-ref v 1 'little) --> #x-6567874523a901cc\n") ("objects:s257" "\nprocedure: (bytevector-u16-set! bytevector n u16 eness)\n\nprocedure: (bytevector-s16-set! bytevector n s16 eness)\n\nprocedure: (bytevector-u32-set! bytevector n u32 eness)\n\nprocedure: (bytevector-s32-set! bytevector n s32 eness)\n\nprocedure: (bytevector-u64-set! bytevector n u64 eness)\n\nprocedure: (bytevector-s64-set! bytevector n s64 eness)\nreturns: unspecified\nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer and\nindexes the starting byte of the value.\nThe sum of n and the number of bytes occupied by the value must\nnot exceed the length of bytevector.\nn need not be a multiple of the\nnumber of bytes occupied by the value.\nu16 must be a 16-bit unsigned value, i.e., a value in the range\n0 to 216 - 1 inclusive;\ns16 must be a 16-bit signed value, i.e., a value in the range\n-215 to 215 - 1 inclusive;\nu32 must be a 32-bit unsigned value, i.e., a value in the range\n0 to 232 - 1 inclusive;\ns32 must be a 32-bit signed value, i.e., a value in the range\n-231 to 231 - 1 inclusive;\nu64 must be a 64-bit unsigned value, i.e., a value in the range\n0 to 264 - 1 inclusive; and\ns64 must be a 64-bit signed value, i.e., a value in the range\n-263 to 263 - 1 inclusive.\neness must be a valid endianness symbol naming the endianness.\n" "\nThese procedures store the given value in the 2, 4, or 8 bytes starting\nat index n (zero-based) of bytevector.\nNegative values are stored as their two's complement equivalent.\n" "\n" "(define v (make-bytevector 8 0))\n(bytevector-u16-set! v 0 #xfe56 (endianness big))\n(bytevector-s16-set! v 3 #x-1aa (endianness little))\n(bytevector-s16-set! v 5 #x7898 (endianness big))\nv --> #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0)\n\n(define v (make-bytevector 16 0))\n(bytevector-u32-set! v 0 #x1234fe56 'little)\n(bytevector-s32-set! v 6 #x1234fe56 'big)\n(bytevector-s32-set! v 11 #x-23458768 'little)\nv --> #vu8(#x56 #xfe #x34 #x12 #x0 #x0\n  gifs/ghostRightarrow.gif      #x12 #x34 #xfe #x56 #x0\n  gifs/ghostRightarrow.gif      #x98 #x78 #xba #xdc #x0)\n\n(define v (make-bytevector 28 0))\n(bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)\n(bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)\n(bytevector-s64-set! v 19 #x-67874523a901cbee 'big)\nv --> #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0\n  gifs/ghostRightarrow.gif      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0\n  gifs/ghostRightarrow.gif      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)\n") ("objects:s258" "\nprocedure: (bytevector-uint-ref bytevector n eness size)\nreturns: the size-byte unsigned integer at index n (zero-based) of bytevector \n\nprocedure: (bytevector-sint-ref bytevector n eness size)\nreturns: the size-byte signed integer at index n (zero-based) of bytevector \nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer and\nindexes the starting byte of the value.\nsize must be an exact positive integer and specifies the number\nof bytes occupied by the value.\nThe sum of n and size must not exceed the length\nof bytevector.\nn need not be a multiple of the\nnumber of bytes occupied by the value.\neness must be a valid endianness symbol naming the endianness.\n" "\nThe return value is an exact integer in the appropriate range for\nthe number of bytes occupied by the value.\nSigned values are the equivalent of the stored value treated as a two's\ncomplement value.\n" "\n" "(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))\n\n(bytevector-uint-ref v 0 'big 1) --> #x12\n(bytevector-uint-ref v 0 'little 1) --> #x12\n(bytevector-uint-ref v 1 'big 3) --> #x34fe56\n(bytevector-uint-ref v 2 'little 7) --> #x9a9878badc56fe\n\n(bytevector-sint-ref v 2 'big 1) --> #x-02\n(bytevector-sint-ref v 1 'little 6) --> #x78badc56fe34\n(bytevector-sint-ref v 2 'little 7) --> #x-6567874523a902\n\n(bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000) --> -1\n") ("objects:s259" "\nprocedure: (bytevector-uint-set! bytevector n uint eness size)\n\nprocedure: (bytevector-sint-set! bytevector n sint eness size)\nreturns: unspecified\nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer and\nindexes the starting byte of the value.\nsize must be an exact positive integer and specifies the number\nof bytes occupied by the value.\nThe sum of n and size must not exceed the length\nof bytevector.\nn need not be a multiple of the\nnumber of bytes occupied by the value.\nuint must be an exact integer in the range\n0 to 2size8 - 1 inclusive.\nsint must be an exact integer in the range\n-2size8-1 to 2size8-1 - 1 inclusive.\neness must be a valid endianness symbol naming the endianness.\n" "\nThese procedures store the given value in the size bytes starting\nat index n (zero-based) of bytevector.\nNegative values are stored as their two's complement equivalent.\n" "\n" "(define v (make-bytevector 5 0))\n(bytevector-uint-set! v 1 #x123456 (endianness big) 3)\nv --> #vu8(0 #x12 #x34 #x56 0)\n\n(define v (make-bytevector 7 -1))\n(bytevector-sint-set! v 1 #x-8000000000 (endianness little) 5)\nv --> #vu8(#xff 0 0 0 0 #x80 #xff)\n") ("objects:s260" "\nprocedure: (bytevector->uint-list bytevector eness size)\nreturns: a new list of the size-byte unsigned elements of bytevector\n\nprocedure: (bytevector->sint-list bytevector eness size)\nreturns: a new list of the size-byte signed elements of bytevector\nlibraries: (rnrs bytevectors), (rnrs)\n" "eness must be a valid endianness symbol naming the endianness.\nsize must be an exact positive integer and specifies the number\nof bytes occupied by the value.\nIt must be a value that evenly divides the length of bytevector.\n" "\n" "(bytevector->uint-list (make-bytevector 0) 'little 3) --> ()\n\n(let ([v #vu8(1 2 3 4 5 6)])\n  (bytevector->uint-list v 'big 3)) --> (#x010203 #x040506)\n\n(let ([v (make-bytevector 80 -1)])\n  (bytevector->sint-list v 'big 20)) --> (-1 -1 -1 -1)\n") ("objects:s261" "\nprocedure: (uint-list->bytevector list eness size)\n\nprocedure: (sint-list->bytevector list eness size)\nreturns: a new bytevector of the elements of list\nlibraries: (rnrs bytevectors), (rnrs)\n" "eness must be a valid endianness symbol naming the endianness.\nsize must be an exact positive integer and specifies the number\nof bytes occupied by the value.\nFor uint-list->bytevector, list must consist entirely of\nsize-byte exact unsigned integers, i.e., values in the range\n0 to 2size8 - 1 inclusive.\nFor sint-list->bytevector, list must consist entirely of\nsize-byte exact signed integers, i.e., values in the range\n-2size8-1 to 2size8-1 - 1 inclusive.\nEach value occupies size bytes in the resulting bytevector, whose\nlength is thus size times the length of list.\n" "\n" "(uint-list->bytevector '() 'big 25) --> #vu8()\n(sint-list->bytevector '(0 -1) 'big 3) --> #vu8(0 0 0 #xff #xff #xff)\n\n(define (f size)\n  (let ([ls (list (- (expt 2 (- (* 8 size) 1)))\n                  (- (expt 2 (- (* 8 size) 1)) 1))])\n    (sint-list->bytevector ls 'little size)))\n(f 6) --> #vu8(#x00 #x00 #x00 #x00 #x00 #x80\n      gifs/ghostRightarrow.gif      #xff #xff #xff #xff #xff #x7f)\n") ("objects:s262" "\nprocedure: (bytevector-ieee-single-native-ref bytevector n)\nreturns: the single floating-point value at index n (zero-based) of bytevector \n\nprocedure: (bytevector-ieee-double-native-ref bytevector n)\nreturns: the double floating-point value at index n (zero-based) of bytevector \nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer.\nIt indexes the starting byte of the value and must be a multiple of the\nnumber of bytes occupied by the value: 4 for single floats, 8 for double.\nThe sum of n and the number of bytes occupied by the value must\nnot exceed the length of bytevector.\nThe native endianness is assumed.\n" "\nThe return value is an inexact real number.\nExamples appear after the mutation operators below.\n") ("objects:s263" "\nprocedure: (bytevector-ieee-single-native-set! bytevector n x)\n\nprocedure: (bytevector-ieee-double-native-set! bytevector n x)\nreturns: unspecified\nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer.\nIt indexes the starting byte of the value and must be a multiple of the\nnumber of bytes occupied by the value: 4 for single floats, 8 for double.\nThe sum of n and the number of bytes occupied by the value must\nnot exceed the length of bytevector.\nThe native endianness is assumed.\n" "\nThese procedures store the given value as an IEEE-754 single or\ndouble floating-point value at index n (zero-based) of bytevector.\n" "\n" "(define v (make-bytevector 8 0))\n(bytevector-ieee-single-native-set! v 0 .125)\n(bytevector-ieee-single-native-set! v 4 -3/2)\n(list\n  (bytevector-ieee-single-native-ref v 0)\n  (bytevector-ieee-single-native-ref v 4)) --> (0.125 -1.5)\n\n(bytevector-ieee-double-native-set! v 0 1e23)\n(bytevector-ieee-double-native-ref v 0) --> 1e23\n") ("objects:s264" "\nprocedure: (bytevector-ieee-single-ref bytevector n eness)\nreturns: the single floating-point value at index n (zero-based) of bytevector \n\nprocedure: (bytevector-ieee-double-ref bytevector n eness)\nreturns: the double floating-point value at index n (zero-based) of bytevector \nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer and\nindexes the starting byte of the value.\nThe sum of n and the number of bytes occupied by the value\n(4 for a single float, 8 for a double)\nmust not exceed the length of bytevector.\nn need not be a multiple of the\nnumber of bytes occupied by the value.\neness must be a valid endianness symbol naming the endianness.\n" "\nThe return value is an inexact real number.\nExamples appear after the mutation operators below.\n\n") ("objects:s265" "\nprocedure: (bytevector-ieee-single-set! bytevector n x eness)\n\nprocedure: (bytevector-ieee-double-set! bytevector n x eness)\nreturns: unspecified\nlibraries: (rnrs bytevectors), (rnrs)\n" "n must be an exact nonnegative integer and\nindexes the starting byte of the value.\nThe sum of n and the number of bytes occupied by the value\n(4 for a single float, 8 for a double)\nmust not exceed the length of bytevector.\nn need not be a multiple of the\nnumber of bytes occupied by the value.\neness must be a valid endianness symbol naming the endianness.\n" "\nThese procedures store the given value as an IEEE-754 single or double\nfloating-point value at index n (zero-based) of bytevector.\n" "\n" "(define v (make-bytevector 10 #xc7))\n(bytevector-ieee-single-set! v 1 .125 'little)\n(bytevector-ieee-single-set! v 6 -3/2 'big)\n(list\n  (bytevector-ieee-single-ref v 1 'little)\n  (bytevector-ieee-single-ref v 6 'big)) --> (0.125 -1.5)\nv --> #vu8(#xc7 #x0 #x0 #x0 #x3e #xc7 #xbf #xc0 #x0 #x0)\n\n(bytevector-ieee-double-set! v 1 1e23 'big)\n(bytevector-ieee-double-ref v 1 'big) --> 1e23\n") ("objects:s268" "\nprocedure: (symbol=? symbol1 symbol2)\nreturns: #t if the two symbols are the same, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "Symbols can also be compared with eq?, which is typically more\nefficient than symbol=?.\n" "\n" "(symbol=? 'a 'a) --> #t\n(symbol=? 'a (string->symbol \"a\")) --> #t\n(symbol=? 'a 'b) --> #f\n") ("objects:s269" "\nprocedure: (string->symbol string)\nreturns: a symbol whose name is string\nlibraries: (rnrs base), (rnrs)\n" "string->symbol records all symbols it creates in an internal table\nthat it shares with the system reader.\nIf a symbol whose name is equivalent to string (according to the predicate\nstring=?) already exists in the table, this symbol is returned.\nOtherwise, a new symbol is created with string as its name; this\nsymbol is entered into the table and returned.\n" "\nThe effect of modifying a string after it is used as an argument to\nstring->symbol is unspecified.\n" "\n" "(string->symbol \"x\") --> x\n\n(eq? (string->symbol \"x\") 'x) --> #t\n(eq? (string->symbol \"X\") 'x) --> #f\n\n(eq? (string->symbol \"x\")\n     (string->symbol \"x\")) --> #t\n\n(string->symbol \"()\") --> \\x28;\\x29;\n") ("objects:s270" "\nprocedure: (symbol->string symbol)\nreturns: a string, the name of symbol\nlibraries: (rnrs base), (rnrs)\n" "The string returned by symbol->string should be treated as\nimmutable.\nUnpredictable behavior can result if a string returned from\nsymbol->string is altered with\nstring-set! or by any other means.\n" "\n" "(symbol->string 'xyz) --> \"xyz\"\n(symbol->string 'Hi) --> \"Hi\"\n(symbol->string (string->symbol \"()\")) --> \"()\"\n") ("objects:s271" "\nprocedure: (boolean=? boolean1 boolean2)\nreturns: #t if the two booleans are the same, #f otherwise\nlibraries: (rnrs base), (rnrs)\n" "The boolean values #t and #f may also be compared with\neq?, which is typically more efficient than boolean=?.\n" "\n" "(boolean=? #t #t) --> #t\n(boolean=? #t #f) --> #f\n(boolean=? #t (< 3 4)) --> #t\n") ("objects:s274" "\nprocedure: (make-eq-hashtable)\n\nprocedure: (make-eq-hashtable size)\nreturns: a new mutable eq hashtable\nlibraries: (rnrs hashtables), (rnrs)\n" "If size is provided, it must be a nonnegative exact integer\nindicating approximately how many elements the hashtable should\ninitially hold.\nHashtables grow as needed, but when the hashtable grows it generally must\nrehash all of the existing elements.\nProviding a nonzero size can help limit the amount of rehashing\nthat must be done as the table is initially populated.\n" "\nAn eq hashtable compares keys using the eq? (pointer equality)\nprocedure and typically employs a hash function based on object addresses.\nIts hash and equivalence functions are suitable for any Scheme object.\n" "\n" "(define ht1 (make-eq-hashtable))\n(define ht2 (make-eq-hashtable 32))\n") ("objects:s275" "\nprocedure: (make-eqv-hashtable)\n\nprocedure: (make-eqv-hashtable size)\nreturns: a new mutable eqv hashtable\nlibraries: (rnrs hashtables), (rnrs)\n" "If size is provided, it must be a nonnegative exact integer\nindicating approximately how many elements the hashtable should\ninitially hold.\nHashtables grow as needed, but when the hashtable grows it generally must\nrehash all of the existing elements.\nProviding a nonzero size can help limit the amount of rehashing\nthat must be done as the table is initially populated.\n" "\nAn eqv hashtable compares keys using the eqv?\nprocedure and typically employs a hash function based on object addresses\nfor objects that are identifiable with eq?.\nIts hash and equivalence functions are suitable for any Scheme object.\n\n") ("objects:s276" "\nprocedure: (make-hashtable hash equiv?)\n\nprocedure: (make-hashtable hash equiv? size)\nreturns: a new mutable hashtable\nlibraries: (rnrs hashtables), (rnrs)\n" "hash and equiv? must be procedures.\nIf size is provided, it must be a nonnegative exact integer\nindicating approximately how many elements the hashtable should\ninitially hold.\nHashtables grow as needed, but when the hashtable grows it generally must\nrehash all of the existing elements.\nProviding a nonzero size can help limit the amount of rehashing\nthat must be done as the table is initially populated.\n" "\nThe new hashtable computes hash values using hash and\ncompares keys using equiv?, neither of which should modify the\nhashtable.\nequiv? should compare two keys and return false only if the two keys\nshould be distinguished.\nhash should accept a key as an argument and return a nonnegative\nexact integer value that is the same each time it is called with arguments\nthat equiv? does not distinguish.\nThe hash and equiv? procedures need not accept arbitrary inputs\nas long as the hashtable is used only for keys that they do accept,\nand both procedures may assume that the keys are immutable as long\nas the keys are not modified while they have associations stored in the table.\nThe hashtable operation may call hash and equiv? once,\nnot at all, or multiple times for each hashtable operation.\n" "\n" "(define ht (make-hashtable string-hash string=?))\n") ("objects:s277" "\nprocedure: (hashtable-mutable? hashtable)\nreturns: #t if hashtable is mutable, #f otherwise\nlibraries: (rnrs hashtables), (rnrs)\n" "Hashtables returned by one of the hashtable creation procedures above are\nmutable, but those created by hashtable-copy may be immutable.\nImmutable hashtables cannot be altered by any of the procedures\nhashtable-set!, hashtable-update!,\nhashtable-delete!, or hashtable-clear!.\n" "\n" "(hashtable-mutable? (make-eq-hashtable)) --> #t\n(hashtable-mutable? (hashtable-copy (make-eq-hashtable))) --> #f\n") ("objects:s278" "\nprocedure: (hashtable-hash-function hashtable)\nreturns: the hash function associated with hashtable\n\nprocedure: (hashtable-equivalence-function hashtable)\nreturns: the equivalence function associated with hashtable\nlibraries: (rnrs hashtables), (rnrs)\n" "hashtable-hash-function returns #f for eq and eqv hashtables.\n" "\n" "(define ht (make-eq-hashtable))\n(hashtable-hash-function ht) --> #f\n(eq? (hashtable-equivalence-function ht) eq?) --> #t\n\n(define ht (make-hashtable string-hash string=?))\n(eq? (hashtable-hash-function ht) string-hash) --> #t\n(eq? (hashtable-equivalence-function ht) string=?) --> #t\n") ("objects:s279" "\nprocedure: (equal-hash obj)\n\nprocedure: (string-hash string)\n\nprocedure: (string-ci-hash string)\n\nprocedure: (symbol-hash symbol)\nreturns: an exact nonnegative integer hash value\nlibraries: (rnrs hashtables), (rnrs)\n" "These procedures are hash functions suitable for use with the appropriate\nScheme predicate: equal? for equal-hash, string=?\nfor string-hash, string-ci=? for string-ci-hash,\nand symbol=? (or eq?) for symbol-hash.\nThe hash values returned by equal-hash, string-hash,\nand string-ci-hash are typically dependent on the current structure\nand contents of the input values and are thus unsuitable if keys\nare modified while they have associations in a hashtable.\n\n") ("objects:s280" "\nprocedure: (hashtable-set! hashtable key obj)\nreturns: unspecified\nlibraries: (rnrs hashtables), (rnrs)\n" "hashtable must be a mutable hashtable.\nkey should be an appropriate key for the hashtable's\nhash and equivalence functions.\nobj may be any Scheme object.\n" "\nhashtable-set! associates key\nwith obj in hashtable, replacing the\nexisting association, if any.\n" "\n" "(define ht (make-eq-hashtable))\n(hashtable-set! ht 'a 73)\n") ("objects:s281" "\nprocedure: (hashtable-ref hashtable key default)\nreturns: see below\nlibraries: (rnrs hashtables), (rnrs)\n" "key should be an appropriate key for the hashtable's\nhash and equivalence functions.\ndefault may be any Scheme object.\n" "\nhashtable-ref returns the value\nassociated with key in hashtable.\nIf no value is associated with key in hashtable,\nhashtable-ref returns default.\n" "\n" "(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n\n(define eqht (make-eq-hashtable))\n(hashtable-set! eqht p1 73)\n(hashtable-ref eqht p1 55) --> 73\n(hashtable-ref eqht p2 55) --> 55\n\n(define equalht (make-hashtable equal-hash equal?))\n(hashtable-set! equalht p1 73)\n(hashtable-ref equalht p1 55) --> 73\n(hashtable-ref equalht p2 55) --> 73\n") ("objects:s282" "\nprocedure: (hashtable-contains? hashtable key)\nreturns: #t if an association for key exists in hashtable, #f otherwise\nlibraries: (rnrs hashtables), (rnrs)\n" "key should be an appropriate key for the hashtable's\nhash and equivalence functions.\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 73)\n(hashtable-contains? ht p1) --> #t\n(hashtable-contains? ht p2) --> #f\n") ("objects:s283" "\nprocedure: (hashtable-update! hashtable key procedure default)\nreturns: unspecified\nlibraries: (rnrs hashtables), (rnrs)\n" "hashtable must be a mutable hashtable.\nkey should be an appropriate key for the hashtable's\nhash and equivalence functions.\ndefault may be any Scheme object.\nprocedure should accept one argument, should return one value, and should\nnot modify hashtable.\n" "\nhashtable-update! applies procedure to the value associated with\nkey in hashtable, or to default if no value is associated with\nkey in hashtable.\nIf procedure returns, hashtable-update! associates key\nwith the value returned by procedure, replacing the old association,\nif any.\n" "\nA version of hashtable-update! that does not verify that it receives\narguments of the proper type might be defined as follows.\n" "\n" "(define hashtable-update!\n  (lambda (ht key proc value)\n    (hashtable-set! ht key\n      (proc (hashtable-ref ht key value)))))\n" "An implementation may, however, be able to implement\nhashtable-update! more efficiently by avoiding multiple\nhash computations and hashtable lookups.\n" "\n" "(define ht (make-eq-hashtable))\n(hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  55)\n(hashtable-ref ht 'a 0) --> 110\n(hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  0)\n(hashtable-ref ht 'a 0) --> 220\n") ("objects:s284" "\nprocedure: (hashtable-delete! hashtable key)\nreturns: unspecified\nlibraries: (rnrs hashtables), (rnrs)\n" "hashtable must be a mutable hashtable.\nkey should be an appropriate key for the hashtable's\nhash and equivalence functions.\n" "\nhashtable-delete! drops any association\nfor key from hashtable.\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 73)\n(hashtable-contains? ht p1) --> #t\n(hashtable-delete! ht p1)\n(hashtable-contains? ht p1) --> #f\n(hashtable-contains? ht p2) --> #f\n(hashtable-delete! ht p2)\n") ("objects:s285" "\nprocedure: (hashtable-size hashtable)\nreturns: number of entries in hashtable\nlibraries: (rnrs hashtables), (rnrs)\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-size ht) --> 0\n(hashtable-set! ht p1 73)\n(hashtable-size ht) --> 1\n(hashtable-delete! ht p1)\n(hashtable-size ht) --> 0\n") ("objects:s286" "\nprocedure: (hashtable-copy hashtable)\n\nprocedure: (hashtable-copy hashtable mutable?)\nreturns: a new hashtable containing the same entries as hashtable\nlibraries: (rnrs hashtables), (rnrs)\n" "If mutable? is present and not false, the copy is mutable;\notherwise, the copy is immutable.\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(hashtable-set! ht p1 \"c\")\n(define ht-copy (hashtable-copy ht))\n(hashtable-mutable? ht-copy) --> #f\n(hashtable-delete! ht p1)\n(hashtable-ref ht p1 #f) --> #f\n(hashtable-delete! ht-copy p1) --> exception: not mutable\n(hashtable-ref ht-copy p1 #f) --> \"c\"\n") ("objects:s287" "\nprocedure: (hashtable-clear! hashtable)\n\nprocedure: (hashtable-clear! hashtable size)\nreturns: unspecified\nlibraries: (rnrs hashtables), (rnrs)\n" "hashtable must be a mutable hashtable.\nIf size is provided, it must be a nonnegative exact integer.\n" "\nhashtable-clear! removes all entries from hashtable.\nIf size is provided, the hashtable is reset to the given size,\nas if newly created by one of the hashtable creation operations\nwith size argument size.\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 \"first\")\n(hashtable-set! ht p2 \"second\")\n(hashtable-size ht) --> 2\n(hashtable-clear! ht)\n(hashtable-size ht) --> 0\n(hashtable-ref ht p1 #f) --> #f\n") ("objects:s288" "\nprocedure: (hashtable-keys hashtable)\nreturns: a vector containing the keys in hashtable\nlibraries: (rnrs hashtables), (rnrs)\n" "The keys may appear in any order in the returned vector.\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 \"one\")\n(hashtable-set! ht p2 \"two\")\n(hashtable-set! ht 'q \"three\")\n(hashtable-keys ht) --> #((a . b) q (a . b))\n") ("objects:s289" "\nprocedure: (hashtable-entries hashtable)\nreturns: two vectors: one of keys and a second of values\nlibraries: (rnrs hashtables), (rnrs)\n" "hashtable-entries returns two values.\nThe first is a vector containing the keys in hashtable, and the second\nis a vector containing the corresponding values.\nThe keys and values may appear in any order, but the order is the same\nfor the keys and for the corresponding values.\n" "\n" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 \"one\")\n(hashtable-set! ht p2 \"two\")\n(hashtable-set! ht 'q \"three\")\n(hashtable-entries ht) --> #((a . b) q (a . b))\n                       gifs/ghostRightarrow.gif #(\"two\" \"three\" \"one\")\n") ("objects:s290" "\nsyntax: (define-enumeration name (symbol ...) constructor)\nlibraries: (rnrs enums), (rnrs)\n" "A define-enumeration form is a definition and can appear\nanywhere any other definition can appear.\n" "\nThe define-enumeration syntax creates a new enumeration set with\nthe specified symbols in the specified order forming the enumeration's universe.\nIt defines a new syntactic form named by name that may be used to verify\nthat a symbol is in the universe.\nIf x is in the universe, (name x) evaluates to\nx.\nIt is a syntax violation if x is not in the universe.\n" "\ndefine-enumeration also defines\na new syntactic form named by constructor that may be used to create\nsubsets of the enumeration type.\nIf x ... are each in the universe,\n(constructor x ...) evaluates to an enumeration set\ncontaining x ....\nOtherwise, it is a syntax violation.\nThe same symbol may appear more than once in x ...,\nbut the resulting set contains only one occurrence of the symbol.\n" "\n" "(define-enumeration weather-element\n  (hot warm cold sunny rainy snowy windy)\n  weather)\n\n(weather-element hot) --> hot\n(weather-element fun) --> syntax violation\n(weather hot sunny windy) --> #<enum-set>\n(enum-set->list (weather rainy cold rainy)) --> (cold rainy)\n") ("objects:s291" "\nprocedure: (make-enumeration symbol-list)\nreturns: an enumeration set\nlibraries: (rnrs enums), (rnrs)\n" "This procedure creates a new enumeration type whose universe comprises\nthe elements of symbol-list, which must be\na list of symbols, in the order of their first appearance in the list.\nIt returns the universe of the new enumeration type as an enumeration\nset.\n" "\n" "(define positions (make-enumeration '(top bottom above top beside)))\n(enum-set->list positions) --> (top bottom above beside)\n") ("objects:s292" "\nprocedure: (enum-set-constructor enum-set)\nreturns: an enumeration-set construction procedure\nlibraries: (rnrs enums), (rnrs)\n" "This procedure returns a procedure p that may be used to create\nsubsets of the universe of enum-set.\np must be passed a list of symbols, and each element of the list\nmust be an element of the universe of enum-set.\nThe enumeration set returned by p contains all and only the\nsymbols in the list it is passed.\nThe value returned by p may contain elements not in enum-set\nif the universe of enum-set contains those elements.\n" "\n" "(define e1 (make-enumeration '(one two three four)))\n(define p1 (enum-set-constructor e1))\n(define e2 (p1 '(one three)))\n(enum-set->list e2) --> (one three)\n(define p2 (enum-set-constructor e2))\n(define e3 (p2 '(one two four)))\n(enum-set->list e3) --> (one two four)\n") ("objects:s293" "\nprocedure: (enum-set-universe enum-set)\nreturns: the universe of enum-set, as an enumeration set\nlibraries: (rnrs enums), (rnrs)\n" "\n" "\n(define e1 (make-enumeration '(a b c a b c d)))\n(enum-set->list (enum-set-universe e1)) --> (a b c d)\n(define e2 ((enum-set-constructor e1) '(c)))\n(enum-set->list (enum-set-universe e2)) --> (a b c d)\n") ("objects:s294" "\nprocedure: (enum-set->list enum-set)\nreturns: a list of the elements of enum-set\nlibraries: (rnrs enums), (rnrs)\n" "The symbols in the resulting list appear in the order given to\nthem when the enumeration type of enum-set was created.\n" "\n" "(define e1 (make-enumeration '(a b c a b c d)))\n(enum-set->list e1) --> (a b c d)\n(define e2 ((enum-set-constructor e1) '(d c a b)))\n(enum-set->list e2) --> (a b c d)\n") ("objects:s295" "\nprocedure: (enum-set-subset? enum-set1 enum-set2)\nreturns: #t if enum-set1 is a subset of enum-set2, #f otherwise\nlibraries: (rnrs enums), (rnrs)\n" "An enumeration set enum-set1 is a subset of an enumeration set enum-set2\nif and only if the universe of enum-set1 is a subset of the universe of enum-set2\nand each element of enum-set1 is an element of enum-set2.\n" "\n" "(define e1 (make-enumeration '(a b c)))\n(define e2 (make-enumeration '(a b c d e)))\n(enum-set-subset? e1 e2) --> #t\n(enum-set-subset? e2 e1) --> #f\n(define e3 ((enum-set-constructor e2) '(a c)))\n(enum-set-subset? e3 e1) --> #f\n(enum-set-subset? e3 e2) --> #t\n") ("objects:s296" "\nprocedure: (enum-set=? enum-set1 enum-set2)\nreturns: #t if enum-set1 and enum-set2 are equivalent, #f otherwise\nlibraries: (rnrs enums), (rnrs)\n" "Two enumeration sets enum-set1 and enum-set2 are equivalent if each is\na subset of the other.\n" "\n" "(define e1 (make-enumeration '(a b c d)))\n(define e2 (make-enumeration '(b d c a)))\n(enum-set=? e1 e2) --> #t\n(define e3 ((enum-set-constructor e1) '(a c)))\n(define e4 ((enum-set-constructor e2) '(a c)))\n(enum-set=? e3 e4) --> #t\n(enum-set=? e3 e2) --> #f\n" "enum-set=? could be defined in terms of enum-set-subset? as follows.\n" "\n" "(define enum-set=?\n  (lambda (e1 e2)\n    (and (enum-set-subset? e1 e2) (enum-set-subset? e2 e1))))\n") ("objects:s297" "\nprocedure: (enum-set-member? symbol enum-set)\nreturns: #t if symbol is an element of enum-set, #f otherwise\nlibraries: (rnrs enums), (rnrs)\n" "\n" "\n(define e1 (make-enumeration '(a b c d e)))\n(define e2 ((enum-set-constructor e1) '(d b)))\n(enum-set-member? 'c e1) --> #t\n(enum-set-member? 'c e2) --> #f\n") ("objects:s298" "\nprocedure: (enum-set-union enum-set1 enum-set2)\nreturns: the union of enum-set1 and enum-set2\n\nprocedure: (enum-set-intersection enum-set1 enum-set2)\nreturns: the intersection of enum-set1 and enum-set2\n\nprocedure: (enum-set-difference enum-set1 enum-set2)\nreturns: the difference of enum-set1 and enum-set2\nlibraries: (rnrs enums), (rnrs)\n" "enum-set1 and enum-set2 must have the same enumeration type.\nEach procedure returns a new enumeration set representing the union, intersection,\nor difference of the two sets.\n" "\n" "(define e1 (make-enumeration '(a b c d)))\n(define e2 ((enum-set-constructor e1) '(a c)))\n(define e3 ((enum-set-constructor e1) '(b c)))\n(enum-set->list (enum-set-union e2 e3)) --> (a b c)\n(enum-set->list (enum-set-intersection e2 e3)) --> (c)\n(enum-set->list (enum-set-difference e2 e3)) --> (a)\n(enum-set->list (enum-set-difference e3 e2)) --> (b)\n(define e4 (make-enumeration '(b d c a)))\n(enum-set-union e1 e4) --> exception: different enumeration types\n") ("objects:s299" "\nprocedure: (enum-set-complement enum-set)\nreturns: the complement of enum-set relative to its universe\nlibraries: (rnrs enums), (rnrs)\n" "\n" "\n(define e1 (make-enumeration '(a b c d)))\n(enum-set->list (enum-set-complement e1)) --> ()\n(define e2 ((enum-set-constructor e1) '(a c)))\n(enum-set->list (enum-set-complement e2)) --> (b d)\n") ("objects:s300" "\nprocedure: (enum-set-projection enum-set1 enum-set2)\nreturns: the projection of enum-set1 into the universe of enum-set2\nlibraries: (rnrs enums), (rnrs)\n" "Any elements of enum-set1 not in the universe of enum-set2 are dropped.\nThe result is of the same enumeration type as enum-set2.\n" "\n" "(define e1 (make-enumeration '(a b c d)))\n(define e2 (make-enumeration '(a b c d e f g)))\n(define e3 ((enum-set-constructor e1) '(a d)))\n(define e4 ((enum-set-constructor e2) '(a c e g)))\n(enum-set->list (enum-set-projection e4 e3)) --> (a c)\n(enum-set->list\n  (enum-set-union e3\n    (enum-set-projection e4 e3))) --> (a c d)\n") ("objects:s301" "\nprocedure: (enum-set-indexer enum-set)\nreturns: a procedure that returns the index of a symbol in the universe of enum-set\nlibraries: (rnrs enums), (rnrs)\n" "enum-set-indexer returns a procedure p that, when applied to a symbol\nin the universe of enum-set, returns the index of the symbol (zero-based) in\nthe ordered set of symbols that form the universe.\nIf applied to a symbol not in the universe, p returns #f.\n" "\n" "(define e1 (make-enumeration '(a b c d)))\n(define e2 ((enum-set-constructor e1) '(a d)))\n(define p (enum-set-indexer e2))\n(list (p 'a) (p 'c) (p 'e)) --> (0 2 #f)\n") ("io:s19" "\nprocedure: (make-transcoder codec)\n\nprocedure: (make-transcoder codec eol-style)\n\nprocedure: (make-transcoder codec eol-style error-handling-mode)\nreturns: a transcoder encapsulating codec, eol-style, and error-handling-mode\nlibraries: (rnrs io ports), (rnrs)\n" "eol-style must be a valid eol-style symbol\n(lf, cr, nel, ls, crlf,\ncrnel, or none); it defaults to the native\neol-style for the platform.\nerror-handling-mode must be a valid error-handling-mode\nsymbol (ignore, raise, or replace)\nand defaults to replace.\n\n") ("io:s20" "\nprocedure: (transcoder-codec transcoder)\nreturns: the codec encapsulated in transcoder\n\nprocedure: (transcoder-eol-style transcoder)\nreturns: the eol-style symbol encapsulated in transcoder\n\nprocedure: (transcoder-error-handling-mode transcoder)\nreturns: the error-handling-mode symbol encapsulated in transcoder\nlibraries: (rnrs io ports), (rnrs)\n") ("io:s21" "\nprocedure: (native-transcoder)\nreturns: the native transcoder\nlibraries: (rnrs io ports), (rnrs)\n" "The native transcoder is implementation-dependent and may vary\nby platform or locale.\n\n") ("io:s22" "\nprocedure: (latin-1-codec)\nreturns: a codec for ISO 8859-1 (Latin 1) character encodings\n\nprocedure: (utf-8-codec)\nreturns: a codec for Unicode UTF-8 character encodings\n\nprocedure: (utf-16-codec)\nreturns: a codec for Unicode UTF-16 character encodings\nlibraries: (rnrs io ports), (rnrs)\n") ("io:s23" "\nsyntax: (eol-style symbol)\nreturns: symbol\nlibraries: (rnrs io ports), (rnrs)\n" "symbol must be one of the symbols lf, cr, nel,\nls, crlf, crnel, or none.\nThe expression (eol-style symbol) is equivalent to the\nexpression (quote symbol) except the former checks at\nexpansion time that symbol is one of the eol-style symbols.\nThe eol-style syntax provides useful documentation as well.\n" "\n" "(eol-style crlf) --> crlf\n(eol-style lfcr) --> syntax violation\n") ("io:s24" "\nprocedure: (native-eol-style)\nreturns: the native eol style\nlibraries: (rnrs io ports), (rnrs)\n" "The native eol style is implementation-dependent and may vary\nby platform or locale.\n\n") ("io:s25" "\nsyntax: (error-handling-mode symbol)\nreturns: symbol\nlibraries: (rnrs io ports), (rnrs)\n" "symbol must be one of the symbols ignore, raise,\nor replace.\nThe expression (error-handling-mode symbol) is equivalent to the\nexpression (quote symbol) except that the former checks at\nexpansion time that symbol is one of the error-handling-mode symbols.\nThe error-handling-mode syntax provides useful documentation as well.\n" "\n" "(error-handling-mode replace) --> replace\n(error-handling-mode relpace) --> syntax violation\n") ("io:s26" "\nsyntax: (file-options symbol ...)\nreturns: a file-options enumeration set\nlibraries: (rnrs io ports), (rnrs)\n" "File-options enumeration sets may be passed to file-open operations to\ncontrol aspects of the open operation.\nThere are three standard file options: no-create, no-fail,\nand no-truncate, which affect only file-open operations that\ncreate output (including input/output) ports.\n" "\nWith the default file options, i.e., the value of (file-options),\nwhen a program attempts to open a file for output, an exception is raised with\ncondition type i/o-file-already-exists if the file already exists,\nand the file is created if it does not already exist.\nIf the no-fail option is included, no exception is raised if the\nfile already exists; instead, the file is opened and truncated to zero\nlength.\nIf the no-create option is included, the file is not created if\nit does not exist; instead, an exception is raised with condition type\ni/o-file-does-not-exist.\nThe no-create option implies the no-fail option.\nThe no-truncate option is relevant only if the no-fail\noption is included or implied, in which case if an existing file is\nopened, it is not truncated, but the port's position is still set to the\nbeginning of the file.\n" "\nIt is perhaps easier to imagine that the default file options are the\nimaginary option symbols create, fail-if-exists, and\ntruncate; no-create removes\ncreate, no-fail removes fail-if-exists, and\nno-truncate removes truncate.\n" "\nImplementations may support additional file option symbols.\nChez Scheme, for example, supports options that control whether the file\nis or should be compressed, whether it is locked for exclusive access, and\nwhat permissions are given to the file if it is created [citation9].\n\n") ("io:s27" "\nsyntax: (buffer-mode symbol)\nreturns: symbol\nlibraries: (rnrs io ports), (rnrs)\n" "symbol must be one of the symbols block, line, or\nnone.\nThe expression (buffer-mode symbol) is equivalent to the\nexpression (quote symbol) except that the former checks at\nexpansion time that symbol is one of the buffer-mode symbols.\nThe buffer-mode syntax provides useful documentation as well.\n" "\n" "(buffer-mode block) --> block\n(buffer-mode cushion) --> syntax violation\n") ("io:s28" "\nsyntax: (buffer-mode? obj)\nreturns: #t if obj is a valid buffer mode, #f otherwise\nlibraries: (rnrs io ports), (rnrs)\n" "\n" "(buffer-mode? 'block) --> #t\n(buffer-mode? 'line) --> #t\n(buffer-mode? 'none) --> #t\n(buffer-mode? 'something-else) --> #f\n") ("io:s29" "\nprocedure: (open-file-input-port path)\n\nprocedure: (open-file-input-port path options)\n\nprocedure: (open-file-input-port path options b-mode)\n\nprocedure: (open-file-input-port path options b-mode ?transcoder)\nreturns: a new input port for the named file\nlibraries: (rnrs io ports), (rnrs)\n" "If ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure returns a textual input port\nwhose transcoder is ?transcoder.\nOtherwise, this procedure returns a binary input port.\nSee the lead-in to this section for a description of the constraints\non and effects of the other arguments.\n\n") ("io:s30" "\nprocedure: (open-file-output-port path)\n\nprocedure: (open-file-output-port path options)\n\nprocedure: (open-file-output-port path options b-mode)\n\nprocedure: (open-file-output-port path options b-mode ?transcoder)\nreturns: a new output port for the named file\nlibraries: (rnrs io ports), (rnrs)\n" "If ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure returns a textual output port\nwhose transcoder is ?transcoder.\nOtherwise, this procedure returns a binary output port.\nSee the lead-in to this section for a description of the constraints\non and effects of the other arguments.\n\n") ("io:s31" "\nprocedure: (open-file-input/output-port path)\n\nprocedure: (open-file-input/output-port path options)\n\nprocedure: (open-file-input/output-port path options b-mode)\n\nprocedure: (open-file-input/output-port path options b-mode ?transcoder)\nreturns: a new input/output port for the named file\nlibraries: (rnrs io ports), (rnrs)\n" "If ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure returns a textual input/output port\nwhose transcoder is ?transcoder.\nOtherwise, this procedure returns a binary input/output port.\nSee the lead-in to this section for a description of the constraints\non and effects of the other arguments.\n\n") ("io:s32" "\nprocedure: (current-input-port)\nreturns: the current input port\n\nprocedure: (current-output-port)\nreturns: the current output port\n\nprocedure: (current-error-port)\nreturns: the current error port\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs)\n" "The current-input, current-output, and current-error ports return\npre-built textual ports that are initially associated with a process's\nstandard input, standard output, and standard error streams.\n" "\nThe values returned by current-input-port and\ncurrent-output-port can be altered temporarily by the\nconvenience I/O procedures\nwith-input-from-file and with-output-to-file\n(Section 7.9).\n") ("io:s33" "\nprocedure: (standard-input-port)\nreturns: a fresh binary input port connected to the standard input stream\n\nprocedure: (standard-output-port)\nreturns: a fresh binary output port connected to the standard output stream\n\nprocedure: (standard-error-port)\nreturns: a fresh binary output port connected to the standard error stream\nlibraries: (rnrs io ports), (rnrs)\n" "Because ports may be buffered, confusion can result if operations on\nmore than one port attached to one of a process's standard streams are\ninterleaved.\nThus, these procedures are typically appropriate only when a program\nno longer needs to use any existing ports attached to the standard\nstreams.\n\n") ("io:s34" "\nprocedure: (open-bytevector-input-port bytevector)\n\nprocedure: (open-bytevector-input-port bytevector ?transcoder)\nreturns: a new input port that draws input from bytevector\nlibraries: (rnrs io ports), (rnrs)\n" "If ?transcoder is present and not #f, it must be a\ntranscoder, and this procedure returns a textual input port\nwhose transcoder is ?transcoder.\nOtherwise, this procedure returns a binary input port.\n" "\nThe effect of modifying bytevector after this procedure is called\nis unspecified.\n" "\n" "(let ([ip (open-bytevector-input-port #vu8(1 2))])\n  (let* ([x1 (get-u8 ip)] [x2 (get-u8 ip)] [x3 (get-u8 ip)])\n    (list x1 x2 (eof-object? x3)))) --> (1 2 #t)\n" "There is no need to close a bytevector port; it's storage will be reclaimed\nautomatically when it is no longer needed, as with any other object, and\nan open bytevector port does not tie up any operating system resources.\n\n") ("io:s35" "\nprocedure: (open-string-input-port string)\nreturns: a new textual input port that draws input from string\nlibraries: (rnrs io ports), (rnrs)\n" "The effect of modifying string after this procedure is called\nis unspecified.\nThe new port may or may not have a transcoder, and if it does, the transcoder\nis implementation-dependent.\nWhile not required, implementations are encouraged to support port-position\nand set-port-position! for string ports.\n" "\n" "(get-line (open-string-input-port \"hi.\\nwhat's up?\\n\")) --> \"hi.\"\n" "There is no need to close a string port; it's storage will be reclaimed\nautomatically when it is no longer needed, as with any other object, and\nan open string port does not tie up any operating system resources.\n") ("io:s36" "\nprocedure: (open-bytevector-output-port)\n\nprocedure: (open-bytevector-output-port ?transcoder)\nreturns: two values, a new output port and an extraction procedure\nlibraries: (rnrs io ports), (rnrs)\n" "If ?transcoder is present and not #f, it must be a\ntranscoder, and the port value is a textual output port\nwhose transcoder is ?transcoder.\nOtherwise, the port value is a binary output port.\n" "\nThe extraction procedure is a procedure that, when called without\narguments, creates a bytevector containing the accumulated bytes in the\nport, clears the port of its accumulated bytes, resets its position to\nzero, and returns the bytevector.\nThe accumulated bytes include any bytes written beyond the end of\nthe current position, if the position has been set back from its\nmaximum extent.\n" "\n" "(let-values ([(op g) (open-bytevector-output-port)])\n  (put-u8 op 15)\n  (put-u8 op 73)\n  (put-u8 op 115)\n  (set-port-position! op 2)\n  (let ([bv1 (g)])\n    (put-u8 op 27)\n    (list bv1 (g)))) --> (#vu8(15 73 115) #vu8(27))\n" "There is no need to close a bytevector port; it's storage will be reclaimed\nautomatically when it is no longer needed, as with any other object, and\nan open bytevector port does not tie up any operating system resources.\n\n") ("io:s37" "\nprocedure: (open-string-output-port)\nreturns: two values, a new textual output port and an extraction procedure\nlibraries: (rnrs io ports), (rnrs)\n" "The extraction procedure is a procedure that, when called without\narguments, creates a string containing the accumulated characters in the\nport, clears the port of its accumulated characters, resets its position to\nzero, and returns the string.\nThe accumulated characters include any characters written beyond the end of\nthe current position, if the position has been set back from its\nmaximum extent.\nWhile not required, implementations are encouraged to support port-position\nand set-port-position! for string ports.\n" "\n" "(let-values ([(op g) (open-string-output-port)])\n  (put-string op \"some data\")\n  (let ([str1 (g)])\n    (put-string op \"new stuff\")\n    (list str1 (g)))) --> (\"some data\" \"new stuff\")\n" "There is no need to close a string port; it's storage will be reclaimed\nautomatically when it is no longer needed, as with any other object, and\nan open string port does not tie up any operating system resources.\n\n") ("io:s38" "\nprocedure: (call-with-bytevector-output-port procedure)\n\nprocedure: (call-with-bytevector-output-port procedure ?transcoder)\nreturns: a bytevector containing the accumulated bytes\nlibraries: (rnrs io ports), (rnrs)\n" "If ?transcoder is present and not #f, it must be a\ntranscoder, and procedure is called with a textual bytevector output port\nwhose transcoder is ?transcoder.\nOtherwise, procedure is called with a binary bytevector output port.\nIf procedure returns, a bytevector containing the bytes accumulated in the port\nis created, the accumulated bytes are cleared from the port, the port's position is\nreset to zero, and the bytevector is returned from call-with-bytevector-output-port.\nThese actions occur each time procedure returns, if it returns\nmultiple times due to the invocation of a continuation created while\nprocedure is active.\n" "\n" "(let ([tx (make-transcoder (latin-1-codec) (eol-style lf)\n            (error-handling-mode replace))])\n  (call-with-bytevector-output-port\n    (lambda (p) (put-string p \"abc\"))\n    tx)) --> #vu8(97 98 99)\n") ("io:s39" "\nprocedure: (call-with-string-output-port procedure)\nreturns: a string containing the accumulated characters\nlibraries: (rnrs io ports), (rnrs)\n" "procedure is called with one argument, a string output port.\nIf procedure returns, a string containing the characters accumulated in the port\nis created, the accumulated characters are cleared from the port, the port's position is\nreset to zero, and the string is returned from call-with-string-output-port.\nThese actions occur each time procedure returns, if it returns\nmultiple times due to the invocation of a continuation created while\nprocedure is active.\n" "\ncall-with-string-output-port can be used along with\nput-datum to define a procedure, object->string, that\nreturns a string containing the printed representation of an object.\n" "\n" "(define (object->string x)\n  (call-with-string-output-port\n    (lambda (p) (put-datum p x))))\n\n(object->string (cons 'a '(b c))) --> \"(a b c)\"\n") ("io:s41" "\nprocedure: (make-custom-binary-input-port id r! gp sp! close)\nreturns: a new custom binary input port\n\nprocedure: (make-custom-binary-output-port id w! gp sp! close)\nreturns: a new custom binary output port\n\nprocedure: (make-custom-binary-input/output-port id r! w! gp sp! close)\nreturns: a new custom binary input/output port\nlibraries: (rnrs io ports), (rnrs)\n" "These procedures allow programs to create ports from arbitrary byte streams.\nid must be a string naming the new port; the name is used for informational\npurposes only, and an implementation may choose to include it in the printed\nsyntax, if any, of a custom port.\nr! and w! must be procedures, while gp, sp!, and\nclose must each be a procedure or #f.\nThese arguments are described below.\n" "\nr! is called to draw input from the custom port, e.g., to support\nget-u8 or get-bytevector-n.\nIt is called with three arguments: bytevector, start, and n.\nstart will be a nonnegative exact integer, n will be a\npositive exact integer, and the sum of start and n will\nnot exceed the length of bytevector.\nIf the byte stream is at end of file, r! should return exact 0.\nOtherwise, it should read at least one and at most n bytes from\nthe stream, store these bytes in consecutive locations of bytevector\nstarting at start, and return as an exact positive integer the\nnumber of bytes actually read.\n" "\nw! is called to send output to the port, e.g., to support\nput-u8 or put-bytevector.\nIt is called with three arguments: bytevector, start, and n.\nstart and n will be nonnegative exact integers, and the\nsum of start and n will not exceed the length of\nbytevector.\nw! should write up to n consecutive bytes from\nbytevector starting at start and return, as an exact nonnegative\ninteger, the number of bytes actually written.\n" "\ngp is called to query the port's position.\nIf it is #f, the port will not support port-position.\nIf it is not #f, it will be passed zero arguments and should\nreturn the current position as a displacement in bytes from the start\nof the byte stream as an exact nonnegative integer.\n" "\nsp! is called to set the port's position.\nIf it is #f, the port will not support set-port-position!.\nIf it is not #f, it will be passed one argument, an exact\nnonnegative integer representing the new position as a displacement in\nbytes from the start of the byte stream, and it should set the position\nto this value.\n" "\nclose is called to close the byte stream.\nIf it is #f, no action will be taken to close the byte stream\nwhen the new port is closed.\nIf it is not #f, it will be passed zero arguments and should\ntake whatever actions are necessary to close the byte stream.\n\n" "\nIf the new port is an input/output port and does not provide either a\ngp or sp! procedure, it may not be possible for the\nimplementation to position the port properly if an output operation occurs\nafter an input operation, due to input buffering that must be done to\nsupport lookahead-u8 and is often done anyway for efficiency.\nFor the same reason, a call to port-position after an input\noperation may not return an accurate position if the sp! procedure is\nnot provided.\nThus, programs that create custom binary input/output ports should generally\nprovide both gp and sp! procedures.\n\n") ("io:s42" "\nprocedure: (make-custom-textual-input-port id r! gp sp! close)\nreturns: a new custom textual input port\n\nprocedure: (make-custom-textual-output-port id w! gp sp! close)\nreturns: a new custom textual output port\n\nprocedure: (make-custom-textual-input/output-port id r! w! gp sp! close)\nreturns: a new custom textual input/output port\nlibraries: (rnrs io ports), (rnrs)\n" "These procedures allow programs to create ports from arbitrary character streams.\nid must be a string naming the new port; the name is used for informational\npurposes only, and an implementation may choose to include it in the printed\nsyntax, if any, of a custom port.\nr! and w! must be procedures, while gp, sp!, and\nclose must each be a procedure or #f.\nThese arguments are described below.\n" "\nr! is called to draw input from the port, e.g., to support\nget-char or get-string-n.\nIt is called with three arguments: string, start, and n.\nstart will be a nonnegative exact integer, n will be a\npositive exact integer, and the sum of start and n will\nnot exceed the length of string.\nIf the character stream is at end of file, r! should return exact 0.\nOtherwise, it should read at least one and at most n characters from\nthe stream, store these characters in consecutive locations of string\nstarting at start, and return as an exact positive integer the\nnumber of characters actually read.\n" "\nw! is called to send output to the port, e.g., to support\nput-char or put-string.\nIt is called with three arguments: string, start, and n.\nstart and n will be nonnegative exact integers, and the\nsum of start and n will not exceed the length of\nstring.\nw! should write up to n consecutive characters from\nstring starting at start and return, as an exact nonnegative\ninteger, the number of characters actually written.\n" "\ngp is called to query the port's position.\nIf it is #f, the port will not support port-position.\nIf it is not #f, it will be passed zero arguments and should\nreturn the current position, which may be an arbitrary value.\n" "\nsp! is called to set the port's position.\nIf it is #f, the port will not support set-port-position!.\nIf it is not #f, it will be passed one argument, pos, a value\nrepresenting the new position.\nIf pos is the result of a previous call to gp, sp! should\nset the position to pos.\n" "\nclose is called to close the character stream.\nIf it is #f, no action will be taken to close the character stream\nwhen the new port is closed.\nIf it is not #f, it will be passed zero arguments and should\ntake whatever actions are necessary to close the character stream.\n\n" "\nIf the new port is an input/output port, it may not be possible for the\nimplementation to position the port properly if an output operation occurs\nafter an input operation, even if the gp and sp! procedures\nare provided, due to input buffering that must be done to support\nlookahead-char and is often done anyway for efficiency.\nSince the representations of port positions are not specified, it is\nnot possible for the implementation to adjust the gp return\nvalue to account for the number of buffered characters.\nFor the same reason, a call to port-position after an input\noperation may not return an accurate position, even if the sp!\nprocedure is provided.\n" "\nIt should, however, be possible to perform output reliably after reading\nif the position is reset to the starting position.\nThus, programs that create custom textual input/output ports should generally\nprovide both gp and sp! procedures, and consumers of these ports\nshould obtain the starting position via port-position before any\ninput operations and reset the position back to the starting position\nbefore doing any output operations.\n\n") ("io:s43" "\nprocedure: (port? obj)\nreturns: #t if obj is a port, #f otherwise\nlibraries: (rnrs io ports), (rnrs)\n") ("io:s44" "\nprocedure: (input-port? obj)\nreturns: #t if obj is an input or input/output port, #f otherwise\n\nprocedure: (output-port? obj)\nreturns: #t if obj is an output or input/output port, #f otherwise\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs)\n") ("io:s45" "\nprocedure: (binary-port? obj)\nreturns: #t if obj is a binary port, #f otherwise\n\nprocedure: (textual-port? obj)\nreturns: #t if obj is a textual port, #f otherwise\nlibraries: (rnrs io ports), (rnrs)\n") ("io:s46" "\nprocedure: (close-port port)\nreturns: unspecified\nlibraries: (rnrs io ports), (rnrs)\n" "If port is not already closed, close-port closes it,\nfirst flushing any buffered bytes or characters to the underlying stream\nif the port is an output port.\nOnce a port has been closed, no more input or output operations may be\nperformed on the port.\nBecause the operating system may place limits on the number of file ports open\nat one time or restrict access to an open file, it is good practice to\nclose any file port that will no longer be used for input or output.\nIf the port is an output port, closing the port explicitly also ensures\nthat buffered data is written to the underlying stream.\nSome Scheme implementations close file ports automatically after they become\ninaccessible to the program or when the Scheme program exits, but it is\nbest to close file ports explicitly whenever possible.\nClosing a port that has already been closed has no effect.\n\n") ("io:s47" "\nprocedure: (transcoded-port binary-port transcoder)\nreturns: a new textual port with the same byte stream as binary-port\nlibraries: (rnrs io ports), (rnrs)\n" "This procedure returns a new textual port with transcoder transcoder\nand the same underlying byte stream as binary-port, positioned at\nthe current position of binary-port.\n" "\nAs a side effect of creating the textual port, binary-port is closed\nto prevent read or write operations on binary-port from interfering\nwith read and write operations on the new textual port.\nThe underlying byte stream remains open, however, until the textual port\nis closed.\n\n") ("io:s48" "\nprocedure: (port-transcoder port)\nreturns: the transcoder associated with port if any, #f otherwise\nlibraries: (rnrs io ports), (rnrs)\n" "This procedure always returns #f for binary ports and may return\n#f for some textual ports.\n\n") ("io:s49" "\nprocedure: (port-position port)\nreturns: the port's current position\n\nprocedure: (port-has-port-position? port)\nreturns: #t if the port supports port-position, #f otherwise\nlibraries: (rnrs io ports), (rnrs)\n" "A port may allow queries to determine its current position in\nthe underlying stream of bytes or characters.\nIf so, the procedure port-has-port-position? returns\n#t and port-position returns the current position.\nFor binary ports, the position is always an exact nonnegative integer byte\ndisplacement from the start of the byte stream.\nFor textual ports, the representation of a position is unspecified; it\nmay not be an exact nonnegative integer and, even if it is, it may not\nrepresent either a byte or character displacement in the underlying stream.\nThe position may be used at some later time to reset the position if the\nport supports set-port-position!.\nIf port-position is called on a port that does not support it,\nan exception with condition type &assertion is raised.\n\n") ("io:s50" "\nprocedure: (set-port-position! port pos)\nreturns: unspecified\n\nprocedure: (port-has-set-port-position!? port)\nreturns: #t if the port supports set-port-position!, #f otherwise\nlibraries: (rnrs io ports), (rnrs)\n" "A port may allow its current position to be moved directly to a different\nposition in the underlying stream of bytes or characters.\nIf so, the procedure port-has-set-port-position!? returns\n#t and set-port-position! changes the current position.\nFor binary ports, the position pos must be an exact nonnegative integer byte\ndisplacement from the start of the byte stream.\nFor textual ports, the representation of a position is unspecified, as\ndescribed in the entry for port-position above, but pos must be\nan appropriate position for the textual port, which is usually guaranteed\nto be the case only if it was obtained from a call to port-position\non the same port.\nIf set-port-position! is called on a port that does not support it,\nan exception with condition type &assertion is raised.\n" "\nIf port is a binary output port and the position is set\nbeyond the current end of the data in the underlying stream, the\nstream is not extended until new data is written at that position.\nIf new data is written at that position, the contents of each\nintervening position is unspecified.\nBinary ports created with open-file-output-port and\nopen-file-input/output-port can always be extended in this manner\nwithin the limits of the underlying operating system.\nIn other cases, attempts to set the port beyond the current end of data\nin the underlying object may result in an exception with condition\ntype &i/o-invalid-position.\n\n") ("io:s51" "\ndesc:call-with-port\nprocedure: (call-with-port port procedure)\nreturns: the values returned by procedure\nlibraries: (rnrs io ports), (rnrs)\n" "call-with-port calls procedure with port as the only\nargument.\nIf procedure returns, call-with-port closes the port and\nreturns the values returned by procedure.\n" "\ncall-with-port does not automatically close the\nport if a continuation created outside of procedure is invoked, since it\nis possible that another continuation created inside of procedure will be\ninvoked at a later time, returning control to procedure.\nIf procedure does not return, an implementation is free to close the\nport only if it can prove that the output port is no longer accessible.\n" "\nThe example below copies the contents of infile to outfile, overwriting\noutfile if it exists.\nUnless an error occurs, the ports are closed after the copy has been\ncompleted.\n" "\n" "(call-with-port (open-file-input-port \"infile\" (file-options)\n                  (buffer-mode block) (native-transcoder))\n  (lambda (ip)\n    (call-with-port (open-file-output-port \"outfile\"\n                      (file-options no-fail)\n                      (buffer-mode block)\n                      (native-transcoder)) \n      (lambda (op)\n        (do ([c (get-char ip) (get-char ip)])\n            ((eof-object? c))\n          (put-char op c))))))\n" "A definition of call-with-port is given on page 135.\n") ("io:s52" "\nprocedure: (output-port-buffer-mode port)\nreturns: the symbol representing the buffer mode of port\nlibraries: (rnrs io ports), (rnrs)\n") ("io:s53" "\nprocedure: (eof-object? obj)\nreturns: #t if obj is an eof object, #f otherwise\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs)\n" "The end-of-file object is returned by input operations, e.g., get-datum,\nwhen an input port has reached the end of input.\n\n") ("io:s54" "\nprocedure: (eof-object)\nreturns: the eof object\nlibraries: (rnrs io ports), (rnrs io simple), (rnrs)\n" "\n" "(eof-object? (eof-object)) --> #t\n") ("io:s55" "\nprocedure: (get-u8 binary-input-port)\nreturns: the next byte from binary-input-port, or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "If binary-input-port is at end of file, the eof object is returned.\nOtherwise, the next available byte is returned as an unsigned 8-bit\nquantity, i.e., an exact unsigned integer less than or equal to 255,\nand the port's position is advanced one byte.\n\n") ("io:s56" "\nprocedure: (lookahead-u8 binary-input-port)\nreturns: the next byte from binary-input-port, or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "If binary-input-port is at end of file, the eof object is returned.\nOtherwise, the next available byte is returned as an unsigned 8-bit\nquantity, i.e., an exact unsigned integer less than or equal to 255.\nIn contrast to get-u8, lookahead-u8 does not consume\nthe byte it reads from the port, so if the next operation on the port\nis a call to lookahead-u8 or get-u8, the same\nbyte is returned.\n\n") ("io:s57" "\nprocedure: (get-bytevector-n binary-input-port n)\nreturns: a nonempty bytevector containing up to n bytes, or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "n must be an exact nonnegative integer.\nIf binary-input-port is at end of file, the eof object is returned.\nOtherwise, get-bytevector-n reads (as if with get-u8)\nas many bytes, up to n, as are available before the port is at end\nof file, and returns a new (nonempty) bytevector containing these bytes.\nThe port's position is advanced past the bytes read.\n\n") ("io:s58" "\nprocedure: (get-bytevector-n! binary-input-port bytevector start n)\nreturns: the count of bytes read or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "start and n must be exact nonnegative integers, and the sum of\nstart and n must not exceed the length of bytevector.\n" "\nIf binary-input-port is at end of file, the eof object is returned.\nOtherwise, get-bytevector-n! reads (as if with get-u8)\nas many bytes, up to n, as are available before the port is at end\nof file, stores the bytes in consecutive locations of bytevector\nstarting at start, and returns the count of bytes read as an exact\npositive integer.\nThe port's position is advanced past the bytes read.\n\n") ("io:s59" "\nprocedure: (get-bytevector-some binary-input-port)\nreturns: a nonempty bytevector or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "If binary-input-port is at end of file, the eof object is returned.\nOtherwise, get-bytevector-some reads (as if with get-u8)\nat least one byte and possibly more, and returns a bytevector containing\nthese bytes.\nThe port's position is advanced past the bytes read.\nThe maximum number of bytes read by this operation is implementation-dependent.\n\n") ("io:s60" "\nprocedure: (get-bytevector-all binary-input-port)\nreturns: a nonempty bytevector or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "If binary-input-port is at end of file, the eof object is returned.\nOtherwise, get-bytevector-all reads (as if with get-u8)\nall of the bytes available before the port is at end of file and\nreturns a bytevector containing these bytes.\nThe port's position is advanced past the bytes read.\n\n") ("io:s61" "\nprocedure: (get-char textual-input-port)\nreturns: the next character from textual-input-port, or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "If textual-input-port is at end of file, the eof object is returned.\nOtherwise, the next available character is returned\nand the port's position is advanced one character.\nIf textual-input-port is a transcoded port, the position in the\nunderlying byte stream may advance by more than one byte.\n\n") ("io:s62" "\nprocedure: (lookahead-char textual-input-port)\nreturns: the next character from textual-input-port, or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "If textual-input-port is at end of file, the eof object is returned.\nOtherwise, the next available character is returned.\nIn contrast to get-char, lookahead-char does not consume\nthe character it reads from the port, so if the next operation on the port\nis a call to lookahead-char or get-char, the same\ncharacter is returned.\n" "\nlookahead-char is provided for applications requiring one\ncharacter of lookahead.\nThe procedure get-word defined below\nreturns the next word from a textual input port as a string, where\na word is defined to be a sequence of alphabetic characters.\nSince get-word does not know until it sees one character\nbeyond the word that it has read the entire word, it uses\nlookahead-char to determine the next character and\nget-char to consume the character.\n" "\n" "(define get-word\n  (lambda (p)\n    (list->string\n      (let f ()\n        (let ([c (lookahead-char p)])\n          (cond\n            [(eof-object? c) '()]\n            [(char-alphabetic? c) (get-char p) (cons c (f))]\n            [else '()]))))))\n") ("io:s63" "\nprocedure: (get-string-n textual-input-port n)\nreturns: a nonempty string containing up to n characters, or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "n must be an exact nonnegative integer.\nIf textual-input-port is at end of file, the eof object is returned.\nOtherwise, get-string-n reads (as if with get-char)\nas many characters, up to n, as are available before the port is at end\nof file, and returns a new (nonempty) string containing these characters.\nThe port's position is advanced past the characters read.\n\n") ("io:s64" "\nprocedure: (get-string-n! textual-input-port string start n)\nreturns: the count of characters read or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "start and n must be exact nonnegative integers, and the sum of\nstart and n must not exceed the length of string.\n" "\nIf textual-input-port is at end of file, the eof object is returned.\nOtherwise, get-string-n! reads (as if with get-char)\nas many characters, up to n, as are available before the port is at end\nof file, stores the characters in consecutive locations of string\nstarting at start, and returns the count of characters read as an exact\npositive integer.\nThe port's position is advanced past the characters read.\n" "\nget-string-n! may be used to implement string-set! and\nstring-fill!, as illustrated below, although this is not its\nprimary purpose.\n" "\n" "(define string-set!backdoor-string-fill\n  (lambda (s i c)\n    (let ([sip (open-string-input-port (string c))])\n      (get-string-n! sip s i 1)\n     ; return unspecified values:\n      (if #f #f))))\n\n(define string-fill!\n  (lambda (s c)\n    (let ([n (string-length s)])\n      (let ([sip (open-string-input-port (make-string n c))])\n        (get-string-n! sip s 0 n)\n       ; return unspecified values:\n        (if #f #f)))))\n\n(let ([x (make-string 3)])\n  (string-fill! x #\\-)\n  (string-set! x 2 #\\))\n  (string-set! x 0 #\\;)\n  x) --> \";-)\"\n") ("io:s65" "\nprocedure: (get-string-all textual-input-port)\nreturns: a nonempty string or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "If textual-input-port is at end of file, the eof object is returned.\nOtherwise, get-string-all reads (as if with get-char)\nall of the characters available before the port is at end of file and\nreturns a string containing these characters.\nThe port's position is advanced past the characters read.\n\n") ("io:s66" "\nprocedure: (get-line textual-input-port)\nreturns: a string or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "If textual-input-port is at end of file, the eof object is returned.\nOtherwise, get-line reads (as if with get-char)\nall of the characters available before the port is at end of file or a\nline-feed character has been read and returns a string containing all but\nthe line-feed character of the characters read.\nThe port's position is advanced past the characters read.\n" "\n" "(let ([sip (open-string-input-port \"one\\ntwo\\n\")])\n  (let* ([s1 (get-line sip)] [s2 (get-line sip)])\n    (list s1 s2 (port-eof? sip)))) --> (\"one\" \"two\" #t)\n\n(let ([sip (open-string-input-port \"one\\ntwo\")])\n  (let* ([s1 (get-line sip)] [s2 (get-line sip)])\n    (list s1 s2 (port-eof? sip)))) --> (\"one\" \"two\" #t)\n") ("io:s67" "\nprocedure: (get-datum textual-input-port)\nreturns: a Scheme datum object or the eof object\nlibraries: (rnrs io ports), (rnrs)\n" "This procedure scans past whitespace and comments to find the start of\nthe external representation of a datum.\nIf textual-input-port reaches end of file before the start of the\nexternal representation of a datum is found, the eof object is returned.\n" "\nOtherwise, get-datum reads as many characters as necessary,\nand no more, to parse a single datum, and returns a newly allocated\nobject whose structure is determined by the external representation.\nThe port's position is advanced past the characters read.\nIf an end-of-file is reached before the external representation of\nthe datum is complete, or an unexpected character is read,\nan exception is raised with condition types &lexical and\ni/o-read.\n" "\n" "(let ([sip (open-string-input-port \"; a\\n\\n one (two)\\n\")])\n  (let* ([x1 (get-datum sip)]\n         [c1 (lookahead-char sip)]\n         [x2 (get-datum sip)])\n    (list x1 c1 x2 (port-eof? sip)))) --> (one #\\space (two) #f)\n") ("io:s68" "\nprocedure: (port-eof? input-port)\nreturns: #t if input-port is at end-of-file, #f otherwise\nlibraries: (rnrs io ports), (rnrs)\n" "This procedure is similar to lookahead-u8 on a binary input port\nor lookahead-char on a textual input port, except that instead\nof returning the next byte/character or eof object, it returns a boolean\nvalue to indicate whether the value would be the eof object.\n\n") ("io:s69" "\nprocedure: (put-u8 binary-output-port octet)\nreturns: unspecified\nlibraries: (rnrs io ports), (rnrs)\n" "octet must be an exact nonnegative integer less than or equal to 255.\nThis procedure writes octet to binary-output-port, advancing\nthe port's position by one byte.\n\n") ("io:s70" "\nprocedure: (put-bytevector binary-output-port bytevector)\n\nprocedure: (put-bytevector binary-output-port bytevector start)\n\nprocedure: (put-bytevector binary-output-port bytevector start n)\nreturns: unspecified\nlibraries: (rnrs io ports), (rnrs)\n" "start and n must be nonnegative exact integers, and the sum of\nstart and n must not exceed the length of bytevector.\nIf not supplied, start defaults to zero and n defaults to\nthe difference between the length of bytevector and start.\n" "\nThis procedure writes the n bytes of bytevector starting at\nstart to the port and advances the its position\npast the end of the bytes written.\n\n") ("io:s71" "\nprocedure: (put-char textual-output-port char)\nreturns: unspecified\nlibraries: (rnrs io ports), (rnrs)\n" "This procedure writes char to textual-output-port, advancing\nthe port's position by one character.\nIf textual-output-port is a transcoded port, the position in the\nunderlying byte stream may advance by more than one byte.\n\n") ("io:s72" "\nprocedure: (put-string textual-output-port string)\n\nprocedure: (put-string textual-output-port string start)\n\nprocedure: (put-string textual-output-port string start n)\nreturns: unspecified\nlibraries: (rnrs io ports), (rnrs)\n" "start and n must be nonnegative exact integers, and the sum of\nstart and n must not exceed the length of string.\nIf not supplied, start defaults to zero and n defaults to\nthe difference between the length of string and start.\n" "\nThis procedure writes the n characters of string starting at\nstart to the port and advances the its position\npast the end of the characters written.\n\n") ("io:s73" "\nprocedure: (put-datum textual-output-port obj)\nreturns: unspecified\nlibraries: (rnrs io ports), (rnrs)\n" "This procedure writes an external representation of obj to\ntextual-output-port.\nIf obj does not have an external representation as a datum,\nthe behavior is unspecified.\nThe precise external representation is implementation-dependent,\nbut when obj does have an external representation as a datum,\nput-datum should produce a sequence of characters that\ncan later be read by get-datum as an object equivalent\n(in the sense of equal?) to obj.\nSee Section 12.5 for an implementation of put-datum,\nwrite, and display.\n\n") ("io:s74" "\nprocedure: (flush-output-port output-port)\nreturns: unspecified\nlibraries: (rnrs io ports), (rnrs)\n" "This procedure forces any bytes or characters in the buffer associated\nwith output-port to be sent immediately to the underlying stream.\n\n") ("io:s75" "\nprocedure: (open-input-file path)\nreturns: a new input port\nlibraries: (rnrs io simple), (rnrs)\n" "path must be a string or some other implementation-dependent \nvalue that names a file.\nopen-input-file creates a new textual input port for the file named by\npath, as if by open-file-input-port\nwith default options, an implementation-dependent buffer\nmode, and an implementation-dependent transcoder.\n" "\nThe following shows the use of open-input-file, read, and\nclose-port in an expression that gathers a list of\nobjects from the file named by \"myfile.ss.\"\n" "\n" "(let ([p (open-input-file \"myfile.ss\")])\n  (let f ([x (read p)])\n    (if (eof-object? x)\n        (begin\n          (close-port p)\n          '())\n        (cons x (f (read p))))))\n") ("io:s76" "\nprocedure: (open-output-file path)\nreturns: a new output port\nlibraries: (rnrs io simple), (rnrs)\n" "path must be a string or some other implementation-dependent \nvalue that names a file.\nopen-output-file creates a new output port for the file named by\npath, as if by open-file-output-port with default options,\nan implementation-dependent buffer mode, and an implementation-dependent\ntranscoder.\n" "\nThe following shows the use of open-output-file \nto write a list of objects (the value of\nlist-to-be-printed), separated by newlines, to the file\nnamed by \"myfile.ss.\"\n" "\n" "(let ([p (open-output-file \"myfile.ss\")])\n  (let f ([ls list-to-be-printed])\n    (if (not (null? ls))\n        (begin\n          (write (car ls) p)\n          (newline p)\n          (f (cdr ls)))))\n  (close-port p))\n") ("io:s77" "\nprocedure: (call-with-input-file path procedure)\nreturns: the values returned by procedure\nlibraries: (rnrs io simple), (rnrs)\n" "path must be a string or some other implementation-dependent \nvalue that names a file.\nprocedure should accept one argument.\n" "\ncall-with-input-file creates a new input port for the file named\nby path, as if with open-input-file, and passes this port to procedure.\nIf procedure returns, call-with-input-file closes the input port\nand returns the values returned by procedure.\n" "\ncall-with-input-file does not automatically close the input\nport if a continuation created outside of procedure is invoked, since it\nis possible that another continuation created inside of procedure will be\ninvoked at a later time, returning control to procedure.\nIf procedure does not return, an implementation is free to close the\ninput port only if it can prove that the input port is no longer accessible.\nAs shown in Section 5.6, dynamic-wind may be used to\nensure that the port is closed if a continuation created outside of\nprocedure is invoked.\n" "\nThe following example shows the use of call-with-input-file\nin an expression that gathers\na list of objects from the file named by \"myfile.ss.\"\nIt is functionally equivalent to the example given for\nopen-input-file above.\n" "\n" "(call-with-input-file \"myfile.ss\"\n  (lambda (p)\n    (let f ([x (read p)])\n      (if (eof-object? x)\n          '()\n          (cons x (f (read p)))))))\n" "call-with-input-file might be defined without error checking as follows.\n" "\n" "(define call-with-input-file\n  (lambda (filename proc)\n    (let ([p (open-input-file filename)])\n      (let-values ([v* (proc p)])\n        (close-port p)\n        (apply values v*)))))\n") ("io:s78" "\nprocedure: (call-with-output-file path procedure)\nreturns: the values returned by procedure\nlibraries: (rnrs io simple), (rnrs)\n" "path must be a string or some other implementation-dependent \nvalue that names a file.\nprocedure should accept one argument.\n" "\ncall-with-output-file creates a new output port for the file named\nby path, as if with open-output-file, and passes this port to procedure.\nIf procedure returns, call-with-output-file closes the output port\nand returns the values returned by procedure.\n" "\ncall-with-output-file does not automatically close the output\nport if a continuation created outside of procedure is invoked, since it\nis possible that another continuation created inside of procedure will be\ninvoked at a later time, returning control to procedure.\nIf procedure does not return, an implementation is free to close the\noutput port only if it can prove that the output port is no longer accessible.\nAs shown in Section 5.6, dynamic-wind may be used to\nensure that the port is closed if a continuation created outside of\nprocedure is invoked.\n" "\nThe following shows the use of call-with-output-file to\nwrite a list of objects (the value of  list-to-be-printed),\nseparated by newlines, to the file named by \"myfile.ss.\"\nIt is functionally equivalent to the example given for\nopen-output-file above.\n" "\n" "(call-with-output-file \"myfile.ss\"\n  (lambda (p)\n    (let f ([ls list-to-be-printed])\n      (unless (null? ls)\n        (write (car ls) p)\n        (newline p)\n        (f (cdr ls))))))\n" "call-with-output-file might be defined without error checking as follows.\n" "\n" "(define call-with-output-file\n  (lambda (filename proc)\n    (let ([p (open-output-file filename)])\n      (let-values ([v* (proc p)])\n        (close-port p)\n        (apply values v*)))))\n") ("io:s79" "\nprocedure: (with-input-from-file path thunk)\nreturns: the values returned by thunk\nlibraries: (rnrs io simple), (rnrs)\n" "path must be a string or some other implementation-dependent \nvalue that names a file.\nthunk must be a procedure and should accept zero arguments.\n" "\nwith-input-from-file temporarily changes the current input port to be the\nresult of opening the file named by path, as if with open-input-file, during the\napplication of thunk.\nIf thunk returns, the port is closed and the current input port\nis restored to its old value.\n" "\nThe behavior of with-input-from-file is unspecified\nif a continuation created outside\nof thunk is invoked before thunk returns.\nAn implementation may close the port and restore the current input\nport to its old value---but it may not.\n\n") ("io:s80" "\nprocedure: (with-output-to-file path thunk)\nreturns: the values returned by thunk\nlibraries: (rnrs io simple), (rnrs)\n" "path must be a string or some other implementation-dependent \nvalue that names a file.\nthunk must be a procedure and should accept zero arguments.\n" "\nwith-output-to-file temporarily rebinds the current output port to be the\nresult of opening the file named by path, as if with open-output-file,\nduring the application of thunk.\nIf thunk returns, the port is closed and the current output port\nis restored to its old value.\n" "\nThe behavior of with-output-to-file is unspecified if a\ncontinuation created outside of thunk is invoked before\nthunk returns.\nAn implementation may close the port and restore the current output\nport to its old value---but it may not.\n\n") ("io:s81" "\nprocedure: (read)\n\nprocedure: (read textual-input-port)\nreturns: a Scheme datum object or the eof object\nlibraries: (rnrs io simple), (rnrs)\n" "If textual-input-port is not supplied, it defaults to the current input port.\nThis procedure is otherwise equivalent to get-datum.\n\n") ("io:s82" "\nprocedure: (read-char)\n\nprocedure: (read-char textual-input-port)\nreturns: the next character from textual-input-port\nlibraries: (rnrs io simple), (rnrs)\n" "If textual-input-port is not supplied, it defaults to the current input port.\nThis procedure is otherwise equivalent to get-char.\n\n") ("io:s83" "\nprocedure: (peek-char)\n\nprocedure: (peek-char textual-input-port)\nreturns: the next character from textual-input-port\nlibraries: (rnrs io simple), (rnrs)\n" "If textual-input-port is not supplied, it defaults to the current input port.\nThis procedure is otherwise equivalent to lookahead-char.\n\n") ("io:s84" "\nprocedure: (write obj)\n\nprocedure: (write obj textual-output-port)\nreturns: unspecified\nlibraries: (rnrs io simple), (rnrs)\n" "If textual-output-port is not supplied, it defaults to the current output port.\nThis procedure is otherwise equivalent to put-datum, with the\narguments reversed.\nSee Section 12.5 for an implementation of put-datum,\nwrite, and display.\n") ("io:s85" "\nprocedure: (display obj)\n\nprocedure: (display obj textual-output-port)\nreturns: unspecified\nlibraries: (rnrs io simple), (rnrs)\n" "If textual-output-port is not supplied, it defaults to the current output port.\n" "\ndisplay is similar to write or put-datum but prints strings\nand characters found within obj directly.\nStrings are printed without quotation marks or escapes for special characters, as if\nby put-string, and characters\nare printed without the #\\ notation, as if by put-char.\nWith display,\nthe three-element list (a b c)\nand the two-element list (\"a b\" c) both print as\n(a b c).\nBecause of this, display should not be used to print objects that\nare intended to be read with read.\ndisplay is useful primarily for printing messages, with obj\nmost often being a string.\nSee Section 12.5 for an implementation of put-datum,\nwrite, and display.\n") ("io:s86" "\nprocedure: (write-char char)\n\nprocedure: (write-char char textual-output-port)\nreturns: unspecified\nlibraries: (rnrs io simple), (rnrs)\n" "If textual-output-port is not supplied, it defaults to the current output port.\nThis procedure is otherwise equivalent to put-char, with the\narguments reversed.\n\n") ("io:s87" "\nprocedure: (newline)\n\nprocedure: (newline textual-output-port)\nreturns: unspecified\nlibraries: (rnrs io simple), (rnrs)\n" "If textual-output-port is not supplied, it defaults to the current output port.\nnewline sends a line-feed character to the port.\n\n") ("io:s88" "\nprocedure: (close-input-port input-port)\n\nprocedure: (close-output-port output-port)\nreturns: unspecified\nlibraries: (rnrs io simple), (rnrs)\n" "close-input-port closes an input port, and\nclose-output-port closes an output port.\nThese procedures are provided for backward compatibility with the Revised5\nReport; they are not actually more convenient to use than close-port.\n\n") ("io:s89" "\nprocedure: (file-exists? path)\nreturns: #t if the file named by path exists, #f otherwise\nlibraries: (rnrs files), (rnrs)\n" "path must be a string or some other implementation-dependent \nvalue that names a file.\nWhether file-exists? follows symbolic links is unspecified.\n\n") ("io:s90" "\nprocedure: (delete-file path)\nreturns: unspecified\nlibraries: (rnrs files), (rnrs)\n" "path must be a string or some other implementation-dependent \nvalue that names a file.\ndelete-file removes the file named by path if it exists\nand can be deleted, otherwise it raises an exception with condition\ntype &i/o-filename.\nWhether delete-file follows symbolic links is unspecified.\n\n") ("io:s91" "\nprocedure: (bytevector->string bytevector transcoder)\nreturns: a string containing the characters encoded in bytevector\nlibraries: (rnrs io ports), (rnrs)\n" "This operation, at least in effect, creates a bytevector input port with\nthe specified transcoder from which all of the available characters\nare read, as if by get-string-all, and placed into the output\nstring.\n" "\n" "(let ([tx (make-transcoder (utf-8-codec) (eol-style lf)\n            (error-handling-mode replace))])\n  (bytevector->string #vu8(97 98 99) tx)) --> \"abc\"\n") ("io:s92" "\nprocedure: (string->bytevector string transcoder)\nreturns: a bytevector containing the encodings of the characters in string\nlibraries: (rnrs io ports), (rnrs)\n" "This operation, at least in effect, creates a bytevector output port with\nthe specified transcoder to which all of the characters of\nstring are written, then extracts a bytevector containing the\naccumulated bytes.\n" "\n" "(let ([tx (make-transcoder (utf-8-codec) (eol-style none)\n            (error-handling-mode raise))])\n  (string->bytevector \"abc\" tx)) --> #vu8(97 98 99)\n") ("io:s93" "\nprocedure: (string->utf8 string)\nreturns: a bytevector containing the UTF-8 encoding of string\nlibraries: (rnrs bytevectors), (rnrs)\n") ("io:s94" "\nprocedure: (string->utf16 string)\n\nprocedure: (string->utf16 string endianness)\n\nprocedure: (string->utf32 string)\n\nprocedure: (string->utf32 string endianness)\nreturns: a bytevector containing the specified encoding of string\nlibraries: (rnrs bytevectors), (rnrs)\n" "endianness must be one of the symbols big or little.\nIf endianness is not provided or is the symbol big,\nstring->utf16 returns the UTF-16BE encoding of string and\nstring->utf32 returns the UTF-32BE encoding of string.\nIf endianness is the symbol little, string->utf16 returns the\nUTF-16LE encoding of string and string->utf32 returns the\nUTF-32LE encoding of string.\nNo byte-order mark is included in the encoding.\n\n") ("io:s95" "\nprocedure: (utf8->string bytevector)\nreturns: a string containing the UTF-8 decoding of bytevector\nlibraries: (rnrs bytevectors), (rnrs)\n") ("io:s96" "\nprocedure: (utf16->string bytevector endianness)\n\nprocedure: (utf16->string bytevector endianness endianness-mandatory?)\n\nprocedure: (utf32->string bytevector endianness)\n\nprocedure: (utf32->string bytevector endianness endianness-mandatory?)\nreturns: a string containing the specified decoding of bytevector\nlibraries: (rnrs bytevectors), (rnrs)\n" "endianness must be one of the symbols big or\nlittle.\nThese procedures return a UTF-16 or UTF-32 decoding of bytevector,\nwith the endianness of the representation determined from the endianness\nargument or byte-order mark (BOM).\nIf endianness-mandatory? is not provided or is #f, the\nendianness is determined by a BOM at the front of bytevector or, if\nno BOM is present, by endianness.\nIf endianness-mandatory? is #t, the endianness is\ndetermined by endianness, and, if a BOM appears at the front of\nbytevector, it is treated as a regular character encoding.\n")))))