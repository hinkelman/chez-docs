(define chez-docs-data (quote ((csug ("compat:s0" "procedure: (make-hash-table) \nprocedure: (make-hash-table weak?)\nreturns: a new hash table \nlibraries: (chezscheme)  \n\n" "If weak? is provided and is non-false, the hash table is a weak hash table, which means that it does not protect keys from the garbage collector. Keys reclaimed by the garbage collector are removed from the table, and their associated values are dropped the next time the table is modified, if not sooner. \n\n") ("compat:s1" "procedure: (hash-table? obj)\nreturns: #t if obj is a hash table, otherwise #f \nlibraries: (chezscheme)  \n\n") ("compat:s2" "procedure: (put-hash-table! ht k v)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "ht must be a hash table. k and v may be any Scheme values. \n\n" "put-hash-table! associates the value v with the key k in ht. \n\n") ("compat:s3" "procedure: (get-hash-table ht k d)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "get-hash-table returns the value associated with k in ht. If no value is associated with k in ht, get-hash-table returns d. \n\n" "Key comparisons are performed with eq?. \n\n" "Because objects may be moved by the garbage collector, get-hash-table may need to rehash some objects and therefore cause side effects in the hash table. Thus, it is not safe to perform concurrent accesses of the same hash table from multiple threads using get-hash-table.  \n\n") ("compat:s4" "procedure: (remove-hash-table! ht k)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "remove-hash-table! drops any association for k from ht. \n\n") ("compat:s5" "procedure: (hash-table-map ht p)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "hash-table-map applies p to each key, value association in ht, in no particular order, and returns a list of the resulting values, again in no particular order. p should accept two arguments, a key and a value. \n\n") ("compat:s6" "procedure: (hash-table-for-each ht p)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "hash-table-for-each applies p to each key, value association in ht, in no particular order. Unlike hash-table-map, it does not create a list of the values; instead, it's value is unspecified. p should accept two arguments, a key and a value. \n\n") ("compat:s8" "syntax: (extend-syntax (name key ...) (pat fender template) ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "The identifier name is the name, or syntax keyword, for the syntactic extension to be defined. When the system expander processes any list expression whose car is name, the syntactic transformation procedure generated by extend-syntax is invoked on this expression. The remaining identifiers key ... are additional keywords to be recognized within input expressions during expansion (such as else in cond or case).  \n\n" "Each clause after the list of keys consists of a pattern pat, an optional fender, and a template. The optional fender is omitted more often than not. The pat specifies the syntax the input expression must have for the clause to be chosen. Identifiers within the pattern that are not keywords (pattern variables) are bound to corresponding pieces of the input expression. If present, the fender is a Scheme expression that specifies additional constraints on the input expression (accessed through the pattern variables) that must be satisfied in order for the clause to be chosen. The template specifies what form the output takes, usually in terms of the pattern variables. \n\n" "During expansion, the transformation procedure extend-syntax generates attempts to match the input expression against each pattern in the order the clauses are given. If the input expression matches the pattern, the pattern variables are bound to the corresponding pieces of the input expression and the fender for the clause, if any, is evaluated. If the fender returns a true value, the given expansion is performed. If input does not match the pattern or if the fender returns a false value, the transformation procedure tries the next clause. An exception is raised with condition type &assertion if no clause can be chosen.  \n\n" "Within the pattern, ellipsis(...) may be used to specify zero or more occurrences of the preceding pattern fragment, or prototype. Similarly, ellipses may be used in the output to specify the construction of zero or more expansion prototypes. In this case, the expansion prototype must contain part of an input pattern prototype. The use of patterns, templates, ellipses within patterns and templates, and fenders is illustrated in the following sequence of examples. \n\n" "The first example, defining rec, uses a single keyword, a single clause with no fender, and no ellipses. \n\n" "" "(extend-syntax (rec)\n  [(rec id val)\n   (let ([id #f])\n     (set! id val)\n     id)])\n\n" "The second example, defining when, shows the use of ellipses. \n\n" "" "(extend-syntax (when)\n  [(when test exp1 exp2 ...)\n   (if test (begin exp1 exp2 ...) #f)])\n\n" "The next example shows the definition of let. The definition of let shows the use of multiple ellipses, employing one for the identifier/value pairs and one for the expressions in the body. It also shows that the prototype need not be a single identifier, and that pieces of the prototype may be separated from one another in the template. \n\n" "" "(extend-syntax (let)\n  [(let ([x e] ...) b1 b2 ...)\n   ((lambda (x ...) b1 b2 ...) e ...)])\n\n" "The next example shows let*, whose syntax is the same as for let, but which is defined recursively in terms of let with two clauses (one for the base case, one for the recursion step) since it must produce a nested structure. \n\n" "" "(extend-syntax (let*)\n  [(let* () b1 b2 ...)\n   (let () b1 b2 ...)]\n  [(let* ([x e] more ...) b1 b2 ...)\n   (let ([x e]) (let* (more ...) b1 b2 ...))])\n\n" "The first pattern/template pair matches any let* expression with no identifier/value pairs and maps it into the equivalent begin expression. This is the base case. The second pattern/template pair matches any let* expression with one or more identifier/value pairs and transforms it into a let expression binding the first pair whose body is a let* expression binding the remaining pairs. This is the recursion step, which will eventually lead us to the base case because we remove one identifier/value pair at each step. Notice that the second pattern uses the pattern variable more for the second and later identifier/value pairs; this makes the pattern and template less cluttered and makes it clear that only the first identifier/value pair is dealt with explicitly. \n\n" "The definition for and requires three clauses. The first clause is necessary to recognize (and), and the second two define all other and forms recursively.  \n\n" "" "(extend-syntax (and)\n  [(and) #t]\n  [(and x) x]\n  [(and x y ...) (if x (and y ...) #f)])\n\n" "The definition for cond requires four clauses. As with let*, cond must be described recursively, partly because it produces nested if expressions, and partly because one ellipsis prototype would not be sufficient to describe all possible cond clauses. The definition of cond also requires that we specify else as a keyword, in addition to cond. Here is the definition: \n\n" "" "(extend-syntax (cond else)\n  [(cond) #f]\n  [(cond (else e1 e2 ...))\n   (begin e1 e2 ...)]\n  [(cond (test) more ...)\n   (or test (cond more ...))]\n  [(cond (test e1 e2 ...) more ...)\n   (if test\n       (begin e1 e2 ...)\n       (cond more ...))])\n\n" "Two of the clauses are base cases and two are recursion steps. The first base case is an empty cond. The value of cond in this case is unspecified, so the choice of #f is somewhat arbitrary. The second base case is a cond containing only an else clause; this is transformed to the equivalent begin expression. The two recursion steps differ in the number of expressions in the cond clause. The value of cond when the first true clause contains only the test expression is the value of the test. This is similar to what or does, so we expand the cond clause into an or expression. On the other hand, when there are expressions following the test expression, the value of the last expression is returned, so we use if and begin.  \n\n" "To be absolutely correct about the syntax of let, we actually must require that the bound identifiers in the input are symbols. If we typed something like (let ([3 x]) x) we would not get an error from let because it does not check to verify that the objects in the identifier positions are symbols. Instead, lambda may complain, or perhaps the system evaluator long after expansion is complete.  This is where fenders are useful. \n\n" "" "(extend-syntax (let)\n  [(let ([x e] ...) b1 b2 ...)\n   (andmap symbol? '(x ...))\n   ((lambda (x ...) b1 b2 ...) e ...)])\n\n" "The andmap of symbol? over '(x ...) assures that each bound identifier is a symbol. A fender is simply a Scheme expression. Within that expression, any quoted object is first expanded by the same rules as the template part of the clause. In this case, '(x ...) is expanded to the list of identifiers from the identifier/value pairs. \n\n" "extend-syntax typically handles everything you need it for, but some syntactic extension definitions require the ability to include the result of evaluating an arbitrary Scheme expression. This ability is provided by with.  \n\n") ("compat:s20" "syntax: (with ((pat expr) ...) template)\nreturns: processed template \n\n" "" "with is valid only within an template inside of extend-syntax. with patterns are the same as extend-syntax patterns, with expressions are the same as extend-syntax fenders, and with templates are the same as extend-syntax templates.  \n\n" "with can be used to introduce new pattern identifiers bound to expressions produced by arbitrary Scheme expressions within extend-syntax templates. That is, with allows an escape from the declarative style of extend-syntax into the procedural style of full Scheme.  \n\n" "One common use of with is the introduction of a temporary identifier or list of temporary identifiers into a template. with is also used to perform complex transformations that might be clumsy or inefficient if performed within the extend-syntax framework. \n\n" "For example, or requires the use of a temporary identifier. We could define or as follows.  \n\n" "" "(extend-syntax (or)\n  [(or) #f]\n  [(or x) x]\n  [(or x y ...)\n   (let ([temp x])\n     (if temp temp (or y ...)))])\n\n" "This would work until we placed an or expression within the scope of an occurrence of temp, in which case strange things could happen, since extend-syntax does not respect lexical scoping. (This is one of the reasons that define-syntax is preferable to extend-syntax.)  \n\n" "" "(let ([temp #t])\n  (or #f temp)) => #f\n\n" "One solution is to use gensym and with to create a temporary identifier, as follows. \n\n" "" "(extend-syntax (or)\n  [(or) #f]\n  [(or x) x]\n  [(or x y ...)\n   (with ([temp (gensym)])\n     (let ([temp x])\n       (if temp temp (or y ...))))])\n\n" "Also, with can be used to combine elements of the input pattern in ways not possible directly with extend-syntax, such as the following folding-plus example.  \n\n" "" "(extend-syntax (folding-plus)\n  [(folding-plus x y)\n   (and (number? 'x) (number? 'y))\n   (with ([val (+ 'x 'y)])\n      val)]\n  [(folding-plus x y) (+ x y)])\n\n" "folding-plus collapses into the value of (+ x y) if both x and y are numeric constants. Otherwise, folding-plus is transformed into (+ x y) for later evaluation. The fender checks that the operands are numbers at expansion time, and the with performs the evaluation. As with fenders, expansion is performed only within a quoted expressions, since quote sets the data apart from the remainder of the Scheme expression. \n\n" "The example below binds a list of pattern variables to a list of temporary symbols, taking advantage of the fact that with allows us to bind patterns to expressions. This list of temporaries helps us to implement the sigma syntactic extension. sigma is similar to lambda, except it assigns the identifiers in the identifier list instead of creating new bindings. It may be used to perform a series of assignments in parallel. \n\n" "" "(extend-syntax (sigma)\n  [(sigma (x ...) e1 e2 ...)\n   (with ([(t ...) (map (lambda (x) (gensym)) '(x ...))])\n     (lambda (t ...)\n       (set! x t) ...\n       e1 e2 ...))]) \n\n(let ([x 'a] [y 'b])\n  ((sigma (x y) (list x y)) y x)) => (b a)\n\n" "The final example below uses extend-syntax to implement define-structure, following a similar example using syntax-case in Section 8.4 of The Scheme Programming Language, 4th Edition. \n\n" "The definition of define-structure makes use of two pattern/template clauses. Two clauses are needed to handle the optionality of the second subexpression. The first clause matches the form without the second subexpression and merely converts it into the equivalent form with the second subexpression present, but empty. \n\n" "The definition also makes heavy use of with to evaluate Scheme expressions at expansion time. The first four with clauses are used to manufacture the identifiers that name the automatically defined procedures. (The procedure format is particularly useful here, but it could be replaced with string-append!, using symbol->string as needed.) The first two clauses yield single identifiers (for the constructor and predicate), while the next two yield lists of identifiers (for the field access and assignment procedures). The fifth with clause (the final clause in the outer with) is used to count the total length vector needed for each instance of the structure, which must include room for the name and all of the fields. The final with clause (the only clause in the inner with) is used to create a list of vector indexes, one for each field (starting at 1, since the structure name occupies position 0). \n\n" "" "(extend-syntax (define-structure)\n  [(define-structure (name id1 ...))\n   (define-structure (name id1 ...) ())]\n  [(define-structure (name id1 ...) ([id2 val] ...))\n   (with ([constructor\n           (string->symbol (format \"make-~a\" 'name))]\n          [predicate\n           (string->symbol (format \"~a?\" 'name))]\n          [(access ...)\n           (map (lambda (x)\n                  (string->symbol\n                    (format \"~a-~a\" 'name x)))\n                '(id1 ... id2 ...))]\n          [(assign ...)\n           (map (lambda (x)\n                  (string->symbol\n                    (format \"set-~a-~a!\" 'name x)))\n                '(id1 ... id2 ...))]\n          [count (length '(name id1 ... id2 ...))])\n     (with ([(index ...)\n             (let f ([i 1])\n               (if (= i 'count)\n                   '()\n                   (cons i (f (+ i 1)))))])\n       (begin\n         (define constructor\n           (lambda (id1 ...)\n             (let* ([id2 val] ...)\n               (vector 'name id1 ... id2 ...))))\n         (define predicate\n           (lambda (obj)\n             (and (vector? obj)\n                  (= (vector-length obj) count)\n                  (eq? (vector-ref obj 0) 'name))))\n         (define access\n           (lambda (obj)\n             (vector-ref obj index)))\n         ...\n         (define assign\n           (lambda (obj newval)\n             (vector-set! obj index newval)))\n         ...)))])\n\n") ("compat:s25" "syntax: (define-structure (name id1 ...) ((id2 expr) ...))\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "A define-structure form is a definition and may appear anywhere and only where other definitions may appear. \n\n" "define-structure defines a new data structure, name, and creates a set of procedures for creating and manipulating instances of the structure. The identifiers id1 ... and id2 ...name the fields of the data structure. \n\n" "The following procedures are defined by define-structure:  \n\n" "\n* a constructor procedure whose name is make-name, \n* a type predicate whose name is name?, \n* an access procedure whose name is name-fieldfor each field name id1 ... and id2 ..., and \n* an assignment procedure whose name is set-name-field!for each field name id1 ... and id2 .... \n\n" "" "The fields named by the identifiers id1 ... are initialized by the arguments to the constructor procedure. The fields named by the identifiers id2 ... are initialized explicitly to the values of the expressions expr .... Each expression is evaluated within the scope of the identifiers id1 ... (bound to the corresponding field values) and any of the identifiers id2 ... (bound to the corresponding field values) appearing before it (as if within a let*).  \n\n" "To clarify, the constructor behaves as if defined as \n\n" "" "(define make-name\n  (lambda (id1 ...)\n    (let* ([id2 expr] ...)\n      body)))\n\n" "where body builds the structure from the values of the identifiers id1 ... and id2 .... \n\n" "If no fields other than those initialized by the arguments to the constructor procedure are needed, the second subexpression, ((id2 expr) ...), may be omitted. \n\n" "The following simple example demonstrates how pairs might be defined in Scheme if they did not already exist. Both fields are initialized by the arguments to the constructor procedure. \n\n" "" "(define-structure (pare car cdr))\n(define p (make-pare 'a 'b)) \n\n(pare? p) => #t\n(pair? p) => #f\n(pare? '(a . b)) => #f \n\n(pare-car p) => a\n(pare-cdr p) => b \n\n(set-pare-cdr! p (make-pare 'b 'c)) \n\n(pare-car (pare-cdr p)) => b\n(pare-cdr (pare-cdr p)) => c\n\n" "The following example defines a handy string data structure, called a stretch-string, that grows as needed. This example uses a field explicitly initialized to a value that depends on the value of the constructor argument fields. \n\n" "" "(define-structure (stretch-string length fill)\n  ([string (make-string length fill)])) \n\n(define stretch-string-ref\n  (lambda (s i)\n    (let ([n (stretch-string-length s)])\n      (when (>= i n) (stretch-stretch-string! s (+ i 1) n))\n      (string-ref (stretch-string-string s) i)))) \n\n(define stretch-string-set!\n  (lambda (s i c)\n    (let ([n (stretch-string-length s)])\n      (when (>= i n) (stretch-stretch-string! s (+ i 1) n))\n      (string-set! (stretch-string-string s) i c)))) \n\n(define stretch-string-fill!\n  (lambda (s c)\n    (string-fill! (stretch-string-string s) c)\n    (set-stretch-string-fill! s c))) \n\n(define stretch-stretch-string!\n  (lambda (s i n)\n    (set-stretch-string-length! s i)\n    (let ([str (stretch-string-string s)]\n          [fill (stretch-string-fill s)])\n      (let ([xtra (make-string (- i n) fill)])\n        (set-stretch-string-string! s\n          (string-append str xtra))))))\n\n" "As often happens, most of the procedures defined automatically are used only to define more specialized procedures, in this case the procedures stretch-string-ref and stretch-string-set!. stretch-string-length and stretch-string-string are the only automatically defined procedures that are likely to be called directly in code that uses stretch strings. \n\n" "" "(define ss (make-stretch-string 2 #\\X)) \n\n(stretch-string-string ss) => \"XX\"\n(stretch-string-ref ss 3) => #\\X\n(stretch-string-length ss) => 4\n(stretch-string-string ss) => \"XXXX\" \n\n(stretch-string-fill! ss #\\@)\n(stretch-string-string ss) => \"@@@@\"\n(stretch-string-ref ss 5) => #\\@\n(stretch-string-string ss) => \"@@@@@@\" \n\n(stretch-string-set! ss 7 #\\=)\n(stretch-string-length ss) => 8\n(stretch-string-string ss) => \"@@@@@@@=\"\n\n" "Section 8.4 of The Scheme Programming Language, 4th Edition defines a simplified variant of define-structure as an example of the use of syntax-case. The definition given below implements the complete version. \n\n" "define-structure expands into a series of definitions for names generated from the structure name and field names. The generated identifiers are created with datum->syntax to make the identifiers visible where the define-structure form appears. Since a define-structure form expands into a begin containing definitions, it is itself a definition and can be used wherever definitions are valid. \n\n" "" "(define-syntax define-structure\n  (lambda (x)\n    (define gen-id\n      (lambda (template-id . args)\n        (datum->syntax template-id\n          (string->symbol\n            (apply string-append\n                   (map (lambda (x)\n                          (if (string? x)\n                              x\n                              (symbol->string\n                                (syntax->datum x))))\n                        args))))))\n    (syntax-case x ()\n      ((_ (name field1 ...))\n       (andmap identifier? #'(name field1 ...))\n       #'(define-structure (name field1 ...) ()))\n      ((_ (name field1 ...) ((field2 init) ...))\n       (andmap identifier? #'(name field1 ... field2 ...))\n       (with-syntax\n         ((constructor (gen-id #'name \"make-\" #'name))\n          (predicate (gen-id #'name #'name \"?\"))\n          ((access ...)\n           (map (lambda (x) (gen-id x #'name \"-\" x))\n                #'(field1 ... field2 ...)))\n          ((assign ...)\n           (map (lambda (x) (gen-id x \"set-\" #'name \"-\" x \"!\"))\n                #'(field1 ... field2 ...)))\n          (structure-length\n           (+ (length #'(field1 ... field2 ...)) 1))\n          ((index ...)\n           (let f ([i 1] [ids #'(field1 ... field2 ...)])\n             (if (null? ids)\n                 '()\n                 (cons i (f (+ i 1) (cdr ids)))))))\n         #'(begin\n             (define constructor\n               (lambda (field1 ...)\n                 (let* ([field2 init] ...)\n                   (vector 'name field1 ... field2 ...))))\n             (define predicate\n               (lambda (x)\n                 (and (vector? x)\n                      (#3%fx= (vector-length x) structure-length)\n                      (eq? (vector-ref x 0) 'name))))\n             (define access (lambda (x) (vector-ref x index)))\n             ...\n             (define assign\n               (lambda (x update) (vector-set! x index update)))\n             ...))))))\n\n") ("threads:s2" "procedure: (fork-thread thunk)\nreturns: a thread object \nlibraries: (chezscheme)  \n\n" "thunk must be a procedure that accepts zero arguments. \n\n" "fork-thread invokes thunk in a new thread and returns a thread object. \n\n" "Threads created by foreign code using some means other than fork-thread must call Sactivate_thread (Section 4.9) before touching any Scheme data or calling any Scheme procedures. \n\n") ("threads:s3" "procedure: (thread-join thread)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Waits until thread has completed. \n\n") ("threads:s4" "procedure: (get-initial-thread) \nreturns: a thread object for the initial thread \nlibraries: (chezscheme)  \n\n") ("threads:s5" "procedure: (thread? obj)\nreturns: #t if obj is a thread object, #f otherwise \nlibraries: (chezscheme)  \n\n") ("threads:s6" "procedure: (get-thread-id) \nreturns: the thread id of the current thread \nlibraries: (chezscheme)  \n\n" "The thread id is a thread number assigned by thread id, and has no relationship to the process id returned by get-process-id, which is the same in all threads. \n\n") ("threads:s8" "procedure: (thread-preserve-ownership!) \nprocedure: (thread-preserve-ownership! thread)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Provides a hint to the storage manager that thread (which defaults to the current thread if not supplied) can particularly benefit from tracking the objects that it allocates for parallel collection. \n\n") ("threads:s9" "procedure: (make-mutex) \nprocedure: (make-mutex name)\nreturns: a new mutex object \nlibraries: (chezscheme)  \n\n" "name, if supplied, must be a symbol which identifies the mutex, or #f for no name. The name is printed every time the mutex is printed, which is useful for debugging. \n\n") ("threads:s10" "procedure: (mutex? obj)\nreturns: #t if obj is a mutex, #f otherwise \nlibraries: (chezscheme)  \n\n") ("threads:s11" "procedure: (mutex-acquire mutex)\nprocedure: (mutex-acquire mutex block?)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "mutex must be a mutex. \n\n" "mutex-acquire acquires the mutex identified by mutex. The optional boolean argument block? defaults to #t and specifies whether the thread should block waiting for the mutex. If block? is omitted or is true, the thread blocks until the mutex has been acquired, and an unspecified value is returned. \n\n" "If block? is false and the mutex currently belongs to a different thread, the current thread does not block. Instead, mutex-acquire returns immediately with the value #f to indicate that the mutex is not available. If block? is false and the mutex is successfully acquired, mutex-acquire returns #t.  \n\n" "Mutexes are recursive in Posix threads terminology, which means that the calling thread can use mutex-acquire to (re)acquire a mutex it already has. In this case, an equal number of mutex-release calls is necessary to release the mutex. \n\n") ("threads:s12" "procedure: (mutex-release mutex)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "mutex must be a mutex. \n\n" "mutex-release releases the mutex identified by mutex. Unpredictable behavior results if the mutex is not owned by the calling thread. \n\n") ("threads:s13" "syntax: (with-mutex mutex body1 body2 ...)\nreturns: the values of the body body1 body2 ...\nlibraries: (chezscheme)  \n\n" "with-mutex evaluates the expression mutex, which must evaluate to a mutex, acquires the mutex, evaluates the body body1 body2 ..., and releases the mutex. The mutex is released whether the body returns normally or via a control operation (that is, throw to a continuation, perhaps because of an error) that results in a nonlocal exit from the with-mutex form. If control subsequently returns to the body via a continuation invocation, the mutex is reacquired. \n\n" "Using with-mutex is generally more convenient and safer than using mutex-acquire and mutex-release directly.  \n\n") ("threads:s14" "procedure: (mutex-name mutex)\nreturns: the name associated with mutex, if any; otherwise #f \nlibraries: (chezscheme)  \n\n" "mutex must be a mutex. \n\n") ("threads:s15" "procedure: (make-condition) \nprocedure: (make-condition name)\nreturns: a new condition object \nlibraries: (chezscheme)  \n\n" "name, if supplied, must be a symbol which identifies the condition object, or #f for no name. The name is printed every time the condition is printed, which is useful for debugging. \n\n") ("threads:s16" "procedure: (thread-condition? obj)\nreturns: #t if obj is a condition object, #f otherwise \nlibraries: (chezscheme)  \n\n") ("threads:s17" "procedure: (condition-wait cond mutex)\nprocedure: (condition-wait cond mutex timeout)\nreturns: #t if the calling thread was awakened by the condition, #f if the calling thread timed out waiting \nlibraries: (chezscheme)  \n\n" "cond must be a condition object, and mutex must be a mutex. The optional argument timeout is a time record of type time-duration or time-utc, or #f for no timeout. It defaults to #f.  \n\n" "condition-wait waits up to the specified timeout for the condition identified by the condition object cond. The calling thread must have acquired the mutex identified by the mutex mutex at the time condition-wait is called. mutex is released as a side effect of the call to condition-wait. When a thread is later released from the condition variable by one of the procedures described below or the timeout expires, mutex is reacquired and condition-wait returns.  \n\n") ("threads:s18" "procedure: (condition-signal cond)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "cond must be a condition object. \n\n" "condition-signal releases one of the threads waiting for the condition identified by cond. \n\n") ("threads:s19" "procedure: (condition-broadcast cond)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "cond must be a condition object. \n\n" "condition-broadcast releases all of the threads waiting for the condition identified by cond. \n\n") ("threads:s20" "procedure: (condition-name condition)\nreturns: the name associated with condition, if any; otherwise #f \nlibraries: (chezscheme)  \n\n" "condition must be a condition. \n\n") ("threads:s22" "syntax: (ftype-init-lock! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-init-lock! ftype-name (a ...) fptr-expr index)\nreturns: unspecified \nsyntax: (ftype-lock! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-lock! ftype-name (a ...) fptr-expr index)\nreturns: #t if the lock is not already locked, #f otherwise \nsyntax: (ftype-spin-lock! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-spin-lock! ftype-name (a ...) fptr-expr index)\nreturns: unspecified \nsyntax: (ftype-unlock! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-unlock! ftype-name (a ...) fptr-expr index)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Each of these has a syntax like and behaves similarly to ftype-set! (page 86), though with an implicit val-expr. In particular, the restrictions on and handling of fptr-expr and the accessors a ... is similar, with one important restriction: the field specified by the last accessor, upon which the form operates,  must be a word-size integer, i.e., an iptr, uptr, or the equivalent, with the native endianness. \n\n" "ftype-init-lock! should be used to initialize the lock prior to the use of any of the other operators; if this is not done, the behavior of the other operators is undefined. \n\n" "ftype-lock! can be used to lock the lock. If it finds the lock unlocked at the time of the operation, it (normally) locks the lock and returns #t; if it finds the lock already locked, it returns #f without changing the lock. On an architecture with a weak memory model, ftype-lock! can spuriously fail, leaving a lock unchanged and returning #f even if the lock is currently unlocked. On success, no memory ordering is implied, which means that memory-order-acquire may be needed to complete an intended synchronization. \n\n" "ftype-spin-lock! can also be used to lock the lock. If it finds the lock unlocked at the time of the operation, it locks the lock and returns; if it finds the lock already locked, it waits until the lock is unlocked, then locks the lock and returns. If no other thread or process unlocks the lock, the operation does not return and cannot be interrupted by normal means, including by the storage manager for the purpose of initiating a garbage collection. There are also no guarantees of fairness, so a process might hang indefinitely even if other processes are actively locking and unlocking the lock. \n\n" "ftype-unlock! is used to unlock a lock. If it finds the lock locked, it unlocks the lock and returns. Otherwise, it returns without changing the lock. On an architecture with a weak memory model, no memory ordering is implied, and memory-order-release may be needed to complete an intended synchronization. \n\n") ("threads:s23" "syntax: (ftype-locked-incr! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-locked-incr! ftype-name (a ...) fptr-expr index)\nreturns: #t if the updated value is 0, #f otherwise \nsyntax: (ftype-locked-decr! ftype-name (a ...) fptr-expr)\nsyntax: (ftype-locked-decr! ftype-name (a ...) fptr-expr index)\nreturns: #t if the updated value is 0, #f otherwise \nlibraries: (chezscheme)  \n\n" "Each of these has a syntax like and behaves similarly to ftype-set! (page 86), though with an implicit val-expr. In particular, the restrictions on and handling of fptr-expr and the accessors a ... is similar, with one important restriction: the field specified by the last accessor, upon which the form operates,  must be a word-size integer, i.e., an iptr, uptr, or the equivalent, with the native endianness. \n\n" "ftype-locked-incr! atomically reads the value of the specified field, adds 1 to the value, and writes the new value back into the field. Similarly, ftype-locked-decr! atomically reads the value of the specified field, subtracts 1 from the value, and writes the new value back into the field. Both return #t if the new value is 0, otherwise #f.  \n\n") ("threads:s28" "syntax: (ftype-guardian ftype-name)\nreturns: a new ftype guardian \nlibraries: (chezscheme)  \n\n" "ftype-name must name an ftype. The first base field of the ftype (or one of the first base fields in the case of unions) must be a word-sized integer (iptr or uptr) with native endianness. This field is assumed to hold a reference count. \n\n" "The return value is a new ftype guardian g, with which ftype-pointers of type ftype-name (or some subtype of ftype-name) can be registered. An ftype pointer is registered with g by invoking g with the ftype pointer as an argument. \n\n" "An ftype guardian does not automatically protect from collection the ftype pointers registered with it,  as a normal guardian would do. Instead, for each registered ftype pointer that becomes inaccessible via normal (non-weak, non-guardian pointers), the guardian decrements the reference count of the object to which the ftype pointer points. If the resulting reference-count value is zero, the ftype pointer is preserved and can be retrieved from the guardian. If the resulting reference-count value is non-zero, however, the ftype pointer is not preserved. Objects retrieved from an ftype guardian (by calling it without arguments) are guaranteed to have zero reference counts, assuming reference counts are maintained properly by code outside the collector. \n\n" "The collector decrements the reference count using the equivalent of ftype-locked-decr! to support systems in which non-Scheme objects are stored in memory shared by multiple processes. In such systems, programs should themselves use ftype-locked-incr! and ftype-locked-decr! or non-Scheme equivalents (e.g., the C LOCKED_INCR and LOCKED_DECR macros in scheme.h, which are described in Section 4.9) to maintain reference counts. \n\n" "The following example defines a simple ftype and an allocator for objects of that ftype that frees any objects of that ftype that were previously allocated and no longer accessible. \n\n" "" "(module (A make-A free-dropped-As)\n  (define-ftype A\n    (struct\n      [refcount uptr]\n      [data int]))\n  (define g (ftype-guardian A))\n  (define free-dropped-As\n    (lambda ()\n      (let ([a (g)])\n        (when a\n          (printf \"freeing ~s\\n\" (ftype-ref A (data) a))\n          (foreign-free (ftype-pointer-address a))\n          (free-dropped-As)))))\n  (define make-A\n    (lambda (n)\n      (free-dropped-As)\n      (let ([a (make-ftype-pointer A (foreign-alloc (ftype-sizeof A)))])\n        (ftype-set! A (refcount) a 1)\n        (ftype-set! A (data) a n)\n        (g a)\n        a))))\n\n" "We can test this by allocating, dropping, and immediately collecting ftype pointers to A. \n\n" "" "> (do ([i 10 (fx- i 1)])\n      ((fx= i 0))\n    (make-A i)\n    (collect))\nfreeing 10\nfreeing 9\nfreeing 8\nfreeing 7\nfreeing 6\nfreeing 5\nfreeing 4\nfreeing 3\nfreeing 2\n> (free-dropped-As)\nfreeing 1\n\n" "Objects guarded by an ftype guardian might contain pointers to other objects whose reference counts should also be incremented upon allocation of the containing object and decremented upon freeing of the containing object. \n\n") ("threads:s33" "procedure: (memory-order-acquire) \nprocedure: (memory-order-release) \nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "These procedures fence memory operations in a way that is consistent with acquire-release patterns. Specifically, memory-order-acquire ensures at least a load-load and load-store fence, and memory-order-release ensures at least a store-store and store-load fence. \n\n") ("threads:s34" "procedure: (make-thread-parameter object)\nprocedure: (make-thread-parameter object procedure)\nreturns: a new thread parameter \nlibraries: (chezscheme)  \n\n" "See Section 12.13 for a general discussion of parameters and the use of the optional second argument. \n\n" "When a thread parameter is created, a separate location is set aside in each current and future thread to hold the value of the parameter's internal state variable. (This location may be eliminated by the storage manager when the parameter becomes inaccessible.) Changes to the thread parameter in one thread are not seen by any other thread. \n\n" "When a new thread is created (see fork-thread), the current value (not location) of each thread parameter is inherited from the forking thread by the new thread. Similarly, when a thread created by some other means is activated for the first time (see Sactivate_thread in Section 4.9), the current value (not location) of each thread parameter is inherited from the main (original) thread by the new thread. \n\n" "Most built-in parameters are thread parameters, but some are global. All are marked as global or thread where they are defined. There is no distinction between built-in global and thread parameters in the nonthreaded versions of the system. \n\n") ("expeditor:s0" "module: expression-editor \nlibraries: (chezscheme)  \n\n" "The expression-editor module exports a set of bindings for parameters and other procedures that can be used to modify how the expression editor interacts with the user, including the particular keys used to invoke the various editing commands. \n\n" "" "Basic use of the expression editor is described in Section 2.2. \n\n") ("expeditor:s1" "global parameter: ee-auto-indent  \n\n" "" "The value of ee-auto-indent is a boolean value that determines whether the expression editor indents expressions as they are entered. Its default value is #t.  \n\n") ("expeditor:s2" "global parameter: ee-standard-indent  \n\n" "" "The value of ee-standard-indent is a nonnegative fixnum value that determines the amount (in single spaces) by which each expression is indented relative to the enclosing expression, if not aligned otherwise by one of the indenter's other heuristics, when ee-auto-indent is true or when one of the indentation commands is invoked explicitly. It's default value is 2.  \n\n") ("expeditor:s3" "global parameter: ee-auto-paren-balance  \n\n" "" "The value of ee-auto-paren-balance is a boolean value that determines whether the expression editor automatically corrects a close parenthesis or bracket, when typed, to match the corresponding open parenthesis or bracket, if any. Its default value is #t.  \n\n") ("expeditor:s4" "global parameter: ee-flash-parens  \n\n" "" "The value of ee-flash-parens is a boolean value that determines whether the expression editor briefly moves the cursor when an open or close parenthesis or bracket is typed to the matching close or open parenthesis or bracket (if any). Its default value is #t.  \n\n") ("expeditor:s5" "global parameter: ee-paren-flash-delay  \n\n" "" "The value of ee-paren-flash-delay is a nonnegative fixnum value that determines the amount of time (in milliseconds) that the expression editor pauses when the cursor is moved to the matching parenthesis or bracket, if any, when a parenthesis or bracket is entered. The value is ignored if the ee-flash-parens is false. Its default value is 100.  \n\n") ("expeditor:s6" "global parameter: ee-default-repeat  \n\n" "" "The value of ee-default-repeat is a nonnegative fixnum value that determines the number of times the next command is repeated after the ee-command-repeat editing command (bound to Esc-^U by default) is used and notfollowed by a sequence of digits. It's default value is 4.  \n\n") ("expeditor:s7" "global parameter: ee-noisy  \n\n" "" "The value of ee-noisy is a boolean value that determines whether the expression editor emits a beep (bell) when an error occurs, such as an attempt to find the matching delimiter for a non-delimiter character. Its default value is #f.  \n\n") ("expeditor:s8" "global parameter: ee-history-limit  \n\n" "" "The value of ee-history-limit is a nonnegative fixnum value that determines the number of history entries retained by the expression editor during and across sessions. Only the last (ee-history-limit) entries are retained.  \n\n") ("expeditor:s9" "global parameter: ee-common-identifiers  \n\n" "" "The value of ee-common-identifiers is list of symbols that are considered common enough that they should appear early when one of the incremental identifier-completion editing commands is invoked. Its default value contains a few dozen entries. They are all more than a few characters long (under the theory that users will most likely type short ones out fully) and all would appear later than they likely should when incremental identifier-completion is used. \n\n") ("expeditor:s10" "procedure: (ee-bind-key key procedure)\n\n" "\nreturns: unspecified \n\n" "The ee-bind-key procedure is used to add to or change the set of key bindings recognized by the expression editor. \n\n" "The key must be a character or string; if it is a string, it must have the following form. \n\n" "[table not shown]\n\n" "where \n\n" "[table not shown]\n\n" "Note that each double-backslash in the syntax actually denotes just one backslash in the string. \n\n" "For example, the key \"\\\\eX\" represents the two-character sequence Escape-x, i.e., the \"escape\" key followed by the (capital) \"X\" key. Similarly, they key \"\\\\e^X\" represents the two-character sequence Escape-Control-x, i.e., the \"escape\" key followed by Control-X. \n\n" "Character keys and string keys consisting of a single plain character always represent a single keystroke. \n\n" "The procedure argument should normally be one of the built-in editing commands described below. It is also possible to define new editing commands with ee-string-macro and ee-compose.  \n\n") ("expeditor:s77" "procedure: (ee-string-macro string)\n\n" "\nreturns: a new editing command \n\n" "The new editing command produced inserts string before the current cursor position. \n\n" "Two string macros are predefined: \n\n" "[table not shown]\n\n") ("expeditor:s78" "procedure: (ee-compose ecmd ...)\n\n" "\nreturns: a new editing command \n\n" "Each ecmd must be an editing command. \n\n" "The new editing command runs each of the editing commands ecmd ... in sequence. \n\n" "For example, the following expression binds ^X-p to an editing command that behaves like ee-history-bwd-prefix but leaves the cursor at the end of the expression rather than at the end of the first line, causing the entire entry to be displayed. \n\n" "" "(let ()\n  (import expression-editor)\n  (ee-bind-key \"^Xp\"\n    (ee-compose ee-history-bwd ee-end-of-entry)))\n\n" "A command such as ee-id-completion that performs a different action when run twice in succession will not recognize that it has been run twice in succession if run as part of a composite command. \n\n" "") ("smgmt:s10" "procedure: (collect) \nprocedure: (collect cg)\nprocedure: (collect cg max-tg)\nprocedure: (collect cg min-tg max-tg)\nprocedure: (collect cg min-tg max-tg objs)\nreturns: a list if objs is a list, unspecified otherwise \nlibraries: (chezscheme)  \n\n" "This procedure causes the storage manager to perform a garbage collection. collect is invoked periodically without arguments by the default collect-request handler, but it may also be called explicitly, e.g., from a custom collect-request handler, between phases of a computation when collection is most likely to be successful, or before timing a computation. In the threaded versions of Chez Scheme, the thread that invokes collect must be the only active thread.  \n\n" "When called without arguments, the system determines automatically which generations to collect and the target generation for each collected generation as described in the lead-in to this section. \n\n" "When called with arguments, the system collects all and only objects in generations less than or equal to cg (the maximum collected generation) into the target generation or generations determined by min-tg (the minimum target generation) and max-tg (the maximum target generation). Specifically, the target generation for any object in a collected generation g is min(max(g+1, min-tg), max-tg), where static is taken to have the value one greater than the maximum nonstatic generation. \n\n" "If present, cg must be a nonnegative fixnum no greater than the maximum nonstatic generation, i.e., the current value of the parameter collect-maximum-generation.  \n\n" "If present, max-tg must be a nonnegative fixnum or the symbol static and either equal to cg or one greater than cg, again treating static as having the value one greater than the maximum nonstatic generation. If max-tg is not present (but cg is), it defaults to cg if cg is equal to the maximum target generation and to one more than cg otherwise. \n\n" "If present, min-tg must be a nonnegative fixnum or the symbol static and no greater than max-tg, again treating static as having the value one greater than the maximum nonstatic generation. Unless max-cg is the same as cg, min-tg must also be greater than cg. If min-tg is not present (but cg is), it defaults to the same value as max-tg. \n\n" "If present, objs must be either #f or a list. If objs is a list, the collection is combined with counting as in compute-size-increments. Counting looks through all generations, as when 'static is the second argument to compute-size-increments, but the returned sizes from collect do not include any objects in a generation older than g. Another difference is that an object later in objs is treated as unreachable by earlier objects in objs only when the later object is a record, thread, or procedure (including continuations). Finally, if an object is included in objs using a weak pair, then the object's result size is 0 unless it is reachable from earlier objects; if the object is not reachable at all, it can be collected. \n\n") ("smgmt:s11" "procedure: (collect-rendezvous) \nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Requests a garbage collection in the same way as when the system determines that a collection should occur. All running threads are coordinated so that one of them calls the collect-request handler, while the other threads pause until the handler returns. If the initial thread is active at the time of the rendezvous, it is used to call the collect-request handler. \n\n" "Note that if the collect-request handler (see collect-request-handler) does not call collect, then collect-rendezvous does not actually perform a garbage collection. \n\n") ("smgmt:s12" "global parameter: collect-notify \nlibraries: (chezscheme)  \n\n" "If collect-notify is set to a true value, the collector prints a message whenever a collection is run. collect-notify is set to #f by default.  \n\n") ("smgmt:s13" "global parameter: collect-trip-bytes \nlibraries: (chezscheme)  \n\n" "This parameter determines the approximate amount of storage that is allowed to be allocated between garbage collections. Its value must be a positive fixnum. \n\n" "Chez Scheme allocates memory internally in large chunks and subdivides these chunks via inline operations for efficiency. The storage manager determines whether to request a collection only once per large chunk allocated. Furthermore, some time may elapse between when a collection is requested by the storage manager and when the collect request is honored, especially if interrupts are temporarily disabled via with-interrupts-disabled or disable-interrupts. Thus, collect-trip-bytes is an approximate measure only.  \n\n") ("smgmt:s16" "global parameter: collect-generation-radix \nlibraries: (chezscheme)  \n\n" "This parameter determines how often each generation is collected when collect is invoked without arguments, as by the default collect-request handler. Its value must be a positive fixnum. Generations are collected once every r^g times a collection occurs, where r is the value of collect-generation-radix and g is the generation number. \n\n" "Setting collect-generation-radix to one forces all generations to be collected each time a collection occurs. Setting collect-generation-radix to a very large number effectively delays collection of older generations indefinitely. \n\n") ("smgmt:s17" "global parameter: collect-maximum-generation-threshold-factor \nlibraries: (chezscheme)  \n\n" "This parameter determines how often the maximum generation is collected when collect is invoked without arguments, as by the default collect-request handler. Its value must be a nonnegative real number. The maximum generation is collected only when the total amount of allocated memory before a collection is k times the amount of memory allocated after the most recent collection of the maximum generation, where kis the value of collect-maximum-generation-threshold-factor.  \n\n" "Setting collect-maximum-generation-threshold-factor to zero causes every regularly scheduled collection of the maximum generation to take place. Setting the value of collect-maximum-generation-threshold-factor to a large number can increase peak memory use by delaying collection of the maximum generation. \n\n") ("smgmt:s18" "global parameter: collect-maximum-generation \nlibraries: (chezscheme)  \n\n" "This parameter determines the maximum nonstatic generation, hence the total number of generations, currently in use. Its value is an exact integer in the range 1 through 6. When set to 1, only two nonstatic generations are used; when set to 2, three nonstatic generations are used, and so on. When set to 6, 7 nonstatic generations are used, plus the single static generation for a total of 8 generations. Increasing the number of generations effectively decreases how often old objects are collected, potentially decreasing collection overhead but potentially increasing the number of inaccessible objects retained in the system and thus the total amount of memory required. \n\n") ("smgmt:s19" "global parameter: collect-request-handler \nlibraries: (chezscheme)  \n\n" "The value of collect-request-handler must be a procedure. The procedure is invoked without arguments whenever the system determines that a collection should occur, i.e., some time after an amount of storage determined by the parameter collect-trip-bytes has been allocated since the last collection. \n\n" "By default, collect-request-handler simply invokes collect without arguments.  \n\n" "Automatic collection may be disabled by setting collect-request-handler to a procedure that does nothing, e.g.: \n\n" "" "(collect-request-handler void)\n\n" "Collection can also be temporarily disabled using critical-section, which prevents any interrupts from being handled. \n\n" "In the threaded versions of Chez Scheme, the collect-request handler is invoked by a single thread with all other threads temporarily suspended. \n\n") ("smgmt:s20" "global parameter: release-minimum-generation \nlibraries: (chezscheme)  \n\n" "This parameter's value must be between 0 and the value of collect-maximum-generation, inclusive, and defaults to the value of collect-maximum-generation.  \n\n" "As new data is allocated and collections occur, the storage-management system automatically requests additional virtual memory address space from the operating system. Correspondingly, in the event the heap shrinks significantly, the system attempts to return some of the virtual-memory previously obtained from the operating system back to the operating system. By default, the system attempts to do so only after a collection that targets the maximum nonstatic generation. The system can be asked to do so after collections targeting younger generations as well by altering the value release-minimum-generation to something less than the value of collect-maximum-generation. When the generation to which the parameter is set, or any older generation, is the target generation of a collection, the storage management system attempts to return unneeded virtual memory to the operating system following the collection. \n\n" "When collect-maximum-generation is set to a new value g, release-minimum-generation is implicitly set to g as well if (a) the two parameters have the same value before the change, or (b) release-minimum-generation has a value greater than g. \n\n") ("smgmt:s21" "global parameter: in-place-minimum-generation \nlibraries: (chezscheme)  \n\n" "This parameter determines when the storage-management system attempts to trade long-term space usage for the benefit of collection time and short-term space usage. When performing a collection at a generation at least as large as this parameter's value, objects already residing at the generation are kept in place---unless the objects are in a memory region where previously keeping them in place resulted in too much fragmentation. \n\n" "Typically, the value of in-place-minimum-generation should match the value of the collect-maximum-generation parameter, but the value of this parameter can be lower to move objects even less frequently, or it can be higher to disable attempts to keep otherwise mobile objects in place. \n\n") ("smgmt:s22" "global parameter: heap-reserve-ratio \nlibraries: (chezscheme)  \n\n" "This parameter determines the approximate amount of memory reserved (not returned to the O/S as described in the entry for release-minimum-generation) in proportion to the amount currently occupied, excluding areas of memory that have been made static. Its value must be an inexact nonnegative flonum value; if set to an exact real value, the exact value is converted to an inexact value. The default value, 1.0, reserves one page of memory for each currently occupied nonstatic page. Setting it to a smaller value may result in a smaller average virtual memory footprint, while setting it to a larger value may result in fewer calls into the operating system to request and free memory space. \n\n") ("smgmt:s23" "procedure: (keep-live v)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Ensures that the value produced by v is retained by the store manager until the keep-live call is performed. This function can be particularly useful for ensuring that an immobile object remains in place. \n\n") ("smgmt:s28" "procedure: (weak-cons obj1 obj2)\nreturns: a new weak pair \nlibraries: (chezscheme)  \n\n" "obj1 becomes the car and obj2 becomes the cdr of the new pair. Weak pairs are indistinguishable from ordinary pairs in all but two ways: \n\n" "\n* weak pairs can be distinguished from pairs using the weak-pair? predicate, and  \n* weak pairs maintain a weak pointer to the object in the car of the pair. \n\n" "" "The weak pointer in the car of a weak pair is just like a normal pointer as long as the object to which it points is accessible through a normal (nonweak) pointer somewhere in the system. If at some point the garbage collector recognizes that there are no nonweak pointers to the object, however, it replaces each weak pointer to the object with the \"broken weak-pointer\" object, #!bwp, and discards the object. \n\n" "The cdr field of a weak pair is not a weak pointer, so weak pairs may be used to form lists of weakly held objects. These lists may be manipulated using ordinary list-processing operations such as length, map, and assv. (Procedures like map that produce list structure always produce lists formed from nonweak pairs, however, even when their input lists are formed from weak pairs.) Weak pairs may be altered using set-car! and set-cdr!; after a set-car! the car field contains a weak pointer to the new object in place of the old object. Weak pairs are especially useful for building association pairs in association lists or hash tables. \n\n" "Weak pairs are printed in the same manner as ordinary pairs; there is no reader syntax for weak pairs. As a result, weak pairs become normal pairs when they are written and then read. \n\n" "" "(define x (cons 'a 'b))\n(define p (weak-cons x '()))\n(car p) => (a . b) \n\n(define x (cons 'a 'b))\n(define p (weak-cons x '()))\n(set! x '*)\n(collect)\n(car p) => #!bwp\n\n" "The latter example above may in fact return (a . b) if a garbage collection promoting the pair into an older generation occurs prior to the assignment of x to *. It may be necessary to force an older generation collection to allow the object to be reclaimed. The storage management system guarantees only that the object will be reclaimed eventually once all nonweak pointers to it are dropped, but makes no guarantees about when this will occur. \n\n") ("smgmt:s29" "procedure: (weak-pair? obj)\nreturns: #t if obj is a weak pair, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(weak-pair? (weak-cons 'a 'b)) => #t\n(weak-pair? (cons 'a 'b)) => #f\n(weak-pair? \"oops\") => #f\n\n") ("smgmt:s30" "procedure: (ephemeron-cons obj1 obj2)\nreturns: a new ephemeron pair \nlibraries: (chezscheme)  \n\n" "obj1 becomes the car and obj2 becomes the cdr of the new pair. Ephemeron pairs are indistinguishable from ordinary pairs in all but two ways: \n\n" "\n* ephemeron pairs can be distinguished from pairs using the ephemeron-pair? predicate, and  \n* ephemeron pairs maintain a weak pointer to the object in the car of the pair, and the cdr of the pair is preserved only as long as the car of the pair is preserved. \n\n" "" "An ephemeron pair behaves like a weak pair, but the cdr is treated specially in addition to the car: the cdr of an ephemeron is set to #!bwp at the same time that the car is set to #!bwp. Since the car and cdr fields are set to #!bwp at the same time, then the fact that the car object may be referenced through the cdr object does not by itself imply that car must be preserved (unlike a weak pair); instead, the car must be saved for some reason independent of the cdr object. \n\n" "Like weak pairs and other pairs, ephemeron pairs may be altered using set-car! and set-cdr!, and ephemeron pairs are printed in the same manner as ordinary pairs; there is no reader syntax for ephemeron pairs. \n\n" "" "(define x (cons 'a 'b))\n(define p (ephemeron-cons x x))\n(car p) => (a . b)\n(cdr p) => (a . b) \n\n(define x (cons 'a 'b))\n(define p (ephemeron-cons x x))\n(set! x '*)\n(collect)\n(car p) => #!bwp\n(cdr p) => #!bwp \n\n(define x (cons 'a 'b))\n(define p (weak-cons x x)) ; not an ephemeron pair\n(set! x '*)\n(collect)\n(car p) => (a . b)\n(cdr p) => (a . b)\n\n" "As with weak pairs, the last two expressions of the middle example above may in fact return (a . b) if a garbage collection promoting the pair into an older generation occurs prior to the assignment of x to *. In the last example above, however, the results of the last two expressions will always be (a . b), because the cdr of a weak pair holds a non-weak reference, and that non-weak reference prevents the car field from becoming #!bwp.  \n\n") ("smgmt:s31" "procedure: (ephemeron-pair? obj)\nreturns: #t if obj is a ephemeron pair, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(ephemeron-pair? (ephemeron-cons 'a 'b)) => #t\n(ephemeron-pair? (cons 'a 'b)) => #f\n(ephemeron-pair? (weak-cons 'a 'b)) => #f\n(ephemeron-pair? \"oops\") => #f\n\n") ("smgmt:s32" "procedure: (bwp-object? obj)\nreturns: #t if obj is the broken weak-pair object, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(bwp-object? #!bwp) => #t\n(bwp-object? 'bwp) => #f \n\n(define x (cons 'a 'b))\n(define p (weak-cons x '()))\n(set! x '*)\n(collect (collect-maximum-generation))\n(car p) => #!bwp\n(bwp-object? (car p)) => #t\n\n") ("smgmt:s33" "procedure: (make-guardian) \nprocedure: (make-guardian ordered?)\nreturns: a new guardian that is unordered unless ordered? is true \nlibraries: (chezscheme)  \n\n" "Guardians are represented by procedures that encapsulate groups of objects registered for preservation. When a guardian is created, the group of registered objects is empty. An object is registered with a guardian by passing the object as an argument to the guardian: \n\n" "" "(define G (make-guardian))\n(define x (cons 'aaa 'bbb))\nx => (aaa . bbb)\n(G x)\n\n" "It is also possible to specify a \"representative\" object when registering an object. Continuing the above example: \n\n" "" "(define y (cons 'ccc 'ddd))\ny => (ccc . ddd)\n(G y 'rep)\n\n" "The group of registered objects associated with a guardian is logically subdivided into two disjoint subgroups: a subgroup referred to as \"accessible\" objects, and one referred to \"inaccessible\" objects. Inaccessible objects are objects that have been proven to be inaccessible (except through the guardian mechanism itself or through the car field of a weak or ephemeron pair), and accessible objects are objects that have not been proven so. The word \"proven\" is important here: it may be that some objects in the accessible group are indeed inaccessible but that this has not yet been proven. This proof may not be made in some cases until long after the object actually becomes inaccessible (in the current implementation, until a garbage collection of the generation containing the object occurs). \n\n" "Objects registered with a guardian are initially placed in the accessible group and are moved into the inaccessible group at some point after they become inaccessible. Objects in the inaccessible group are retrieved by invoking the guardian without arguments. If there are no objects in the inaccessible group, the guardian returns #f. Continuing the above example: \n\n" "" "(G) => #f\n(set! x #f)\n(set! y #f)\n(collect)\n(G) => (aaa . bbb)   ; this might come out second\n(G) => rep           ; and this first\n(G) => #f\n\n" "The initial call to G returns #f, since the pairs bound to x and y are the only object registered with G, and the pairs are still accessible through those bindings. When collect is called, the objects shift into the inaccessible group. The two calls to G therefore return the pair previously bound to x and the representative of the pair previously bound to y, though perhaps in the other order from the one shown. (As noted above for weak pairs, the call to collect may not actually be sufficient to prove the object inaccessible, if the object has migrated into an older generation.) \n\n" "Although an object registered without a representative and returned from a guardian has been proven otherwise inaccessible (except possibly via the car field of a weak or ephemeron pair), it has not yet been reclaimed by the storage management system and will not be reclaimed until after the last nonweak pointer to it within or outside of the guardian system has been dropped. In fact, objects that have been retrieved from a guardian have no special status in this or in any other regard. This feature circumvents the problems that might otherwise arise with shared or cyclic structure. A shared or cyclic structure consisting of inaccessible objects is preserved in its entirety, and each piece registered for preservation with any unordered guardian is placed in the inaccessible set for that guardian. The programmer then has complete control over the order in which pieces of the structure are processed. \n\n" "An ordered guardian, as created by providing a true value for ordered?, treats an object as inaccessible only when it is not accessible from any representative of an object that is in any usable guardian's inaccessible group and that is distinct from the object itself. Cycles among objects registered with ordered guardians can never become inaccessible unless the cycle is broken or some of the relevant guardians are dropped by the program, and each registered object's representative (if different from the object) can contribute to such cycles. If an object is registered to an ordered guardian with a representative that is different from the object but that references the object, then the object is in a cycle and will not become inaccessible unless the reference from the representative to the object is destroyed. Weak references do not count, so objects that form a cycle only when counting weak references may still become inaccessible. \n\n" "An object may be registered with a guardian more than once, in which case it will be retrievable more than once: \n\n" "" "(define G (make-guardian))\n(define x (cons 'aaa 'bbb))\n(G x)\n(G x)\n(set! x #f)\n(collect)\n(G) => (aaa . bbb)\n(G) => (aaa . bbb)\n\n" "It may also be registered with more than one guardian, and guardians themselves can be registered with other guardians. If an object is registered to both an unordered guardian and an ordered guardian and neither guardian is dropped, the object can become inaccessible for the ordered guardian only after it has been determined inaccessible for the unordered guardian and then retrieved and dropped again by the program. \n\n" "An object that has been registered with a guardian without a representative and placed in the car field of a weak or ephemeron pair remains in the car field of the weak or ephemeron pair until after it has been returned from the guardian and dropped by the program or until the guardian itself is dropped. \n\n" "" "(define G (make-guardian))\n(define x (cons 'aaa 'bbb))\n(define p (weak-cons x '()))\n(G x)\n(set! x #f)\n(collect)\n(set! y (G))\ny => (aaa . bbb)\n(car p) => (aaa . bbb)\n(set! y #f)\n(collect 1)\n(car p) => #!bwp\n\n" "(The first collector call above would promote the object at least into generation 1, requiring the second collector call to be a generation 1 collection. This can also be forced by invoking collect several times.)  \n\n" "On the other hand, if a representative (other than the object itself) is specified, the guarded object is dropped from the car field of the weak or ephemeron pair at the same time as the representative becomes available from the guardian. \n\n" "" "(define G (make-guardian))\n(define x (cons 'aaa 'bbb))\n(define p (weak-cons x '()))\n(G x 'rep)\n(set! x #f)\n(collect)\n(G) => rep\n(car p) => #!bwp\n\n" "The following example illustrates that the object is deallocated and the car field of the weak pair set to #!bwp when the guardian itself is dropped: \n\n" "" "(define G (make-guardian))\n(define x (cons 'aaa 'bbb))\n(define p (weak-cons x '()))\n(G x)\n(set! x #f)\n(set! G #f)\n(collect)\n(car p) => #!bwp\n\n" "The example below demonstrates how guardians might be used to deallocate external storage, such as storage managed by the C library \"malloc\" and \"free\" operations. \n\n" "" "(define malloc\n  (let ([malloc-guardian (make-guardian)])\n    (lambda (size)\n      ; first free any storage that has been dropped.  to avoid long\n      ; delays, it might be better to deallocate no more than, say,\n      ; ten objects for each one allocated\n      (let f ()\n        (let ([x (malloc-guardian)])\n          (when x\n            (do-free x)\n            (f))))\n      ; then allocate and register the new storage\n      (let ([x (do-malloc size)])\n        (malloc-guardian x)\n        x))))\n\n" "do-malloc must return a Scheme object \"header\" encapsulating a pointer to the external storage (perhaps as an unsigned integer), and all access to the external storage must be made through this header. In particular, care must be taken that no pointers to the external storage exist outside of Scheme after the corresponding header has been dropped. do-free must deallocate the external storage using the encapsulated pointer. Both primitives can be defined in terms of foreign-alloc and foreign-free or the C-library \"malloc\" and \"free\" operators, imported as foreign procedures.  (See Chapter 4.) \n\n" "If it is undesirable to wait until malloc is called to free dropped storage previously allocated by malloc, a collect-request handler can be used instead to check for and free dropped storage, as shown below. \n\n" "" "(define malloc)\n(let ([malloc-guardian (make-guardian)])\n  (set! malloc\n    (lambda (size)\n      ; allocate and register the new storage\n      (let ([x (do-malloc size)])\n        (malloc-guardian x)\n        x)))\n  (collect-request-handler\n    (lambda ()\n      ; first, invoke the collector\n      (collect)\n      ; then free any storage that has been dropped\n      (let f ()\n        (let ([x (malloc-guardian)])\n          (when x\n            (do-free x)\n            (f)))))))\n\n" "With a bit of refactoring, it would be possible to register the encapsulated foreign address as a representative with each header, in which do-free would take just the foreign address as an argument. This would allow the header to be dropped from the Scheme heap as soon as it becomes inaccessible. \n\n" "Guardians can also be created via ftype-guardian, which supports reference counting of foreign objects. \n\n") ("smgmt:s35" "procedure: (guardian? obj)\nreturns: #t if obj is a guardian, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(guardian? (make-guardian)) => #t\n(guardian? (ftype-guardian iptr)) => #t\n(guardian? (lambda x x)) => #f\n(guardian? \"oops\") => #f\n\n") ("smgmt:s36" "procedure: (unregister-guardian guardian)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "unregister-guardian unregisters the as-yet unresurrected objects currently registered with the guardian, with one caveat. \n\n" "The caveat, which applies only to threaded versions of Chez Scheme, is that objects registered with the guardian by other threads since the last garbage collection might not be unregistered. To ensure that all objects are unregistered in a multithreaded application, a single thread can be used both to register and unregister objects. Alternatively, an application can arrange to define a collect-request handler that calls unregister-guardian after it calls collect.  \n\n" "In any case, unregister-guardian returns a list containing each object (or its representative, if specified) that it unregisters, with duplicates as appropriate if the same object is registered more than once with the guardian. Objects already resurrected but not yet retrieved from the guardian are not included in the list but remain retrievable from the guardian. \n\n" "In the current implementation, unregister-guardian takes time proportional to the number of unresurrected objects currently registered with all guardians rather than those registered just with the corresponding guardian. \n\n" "The example below assumes no collections occur except for those resulting from explicit calls to collect.  \n\n" "" "(define g (make-guardian))\n(define x (cons 'a 'b))\n(define y (cons 'c 'd))\n(g x)\n(g x)\n(g y)\n(g y)\n(set! y #f)\n(collect 0 0)\n(unregister-guardian g) => ((a . b) (a . b))\n(g) => (c . d)\n(g) => (c . d)\n(g) => #f\n\n" "unregister-guardian can also be used to unregister ftype pointers registered with guardians created by ftype-guardian (Section 15.6). \n\n") ("smgmt:s40" "procedure: (lock-object obj)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Locking an object prevents the storage manager from reclaiming or relocating the object. Locking should be used sparingly, as it introduces memory fragmentation and increases storage management overhead. \n\n" "Locking can also lead to accidental retention of storage if objects are not unlocked. Objects may be unlocked via unlock-object or the equivalent C library procedure Sunlock_object.  \n\n" "Locking immediate values, such as fixnums, booleans, and characters, or objects that have been made static is unnecessary but harmless. \n\n") ("smgmt:s42" "procedure: (unlock-object obj)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "An object may be locked more than once by successive calls to lock-object, Slock_object, or both, in which case it must be unlocked by an equal number of calls to unlock-object or Sunlock_object before it is truly unlocked. \n\n" "An object contained within a locked object, such as an object in the car of a locked pair, need not also be locked unless a separate C pointer to the object exists. That is, if the inner object is accessed only via an indirection of the outer object, it should be left unlocked so that the collector is free to relocate it during collection. \n\n" "Unlocking immediate values, such as fixnums, booleans, and characters, or objects that have been made static is unnecessary and ineffective but harmless. \n\n") ("smgmt:s43" "procedure: (locked-object? obj)\nreturns: #t if obj is locked, immediate, or static \nlibraries: (chezscheme)  \n\n" "This predicate returns true if obj cannot be relocated or reclaimed by the collector, including immediate values, such as fixnums, booleans, and characters, and objects that have been made static. \n\n") ("smgmt:s44" "procedure: (box-immobile obj)\nreturns: a box \nlibraries: (chezscheme)  \n\n" "Like box, but creates a box that will not be relocated in memory by the storage management system until it is reclaimed. \n\n") ("smgmt:s45" "procedure: (make-immobile-vector n)\nprocedure: (make-immobile-vector n obj)\nreturns: a vector \nlibraries: (chezscheme)  \n\n" "Like make-vector, but creates a vector that will not be relocated in memory by the storage management system until it is reclaimed. \n\n") ("smgmt:s46" "procedure: (make-immobile-bytevector n)\nprocedure: (make-immobile-bytevector n byte)\nreturns: a vector \nlibraries: (chezscheme)  \n\n" "Like make-bytevector, but creates a bytevector that will not be relocated in memory by the storage management system until it is reclaimed. \n\n") ("smgmt:s48" "procedure: (make-phantom-bytevector n)\nreturns: a phantom bytevector \nlibraries: (chezscheme)  \n\n" "n must be an exact nonnegative integer. \n\n" "Creates a phantom bytevector that reflects n bytes of external allocation. \n\n" "The value n must reflect actual allocation in the sense of consuming a portion of the process's address space. Claiming significantly more bytes than are actually allocated introduces the possibility of overflow within the storage management system's calculations. \n\n") ("smgmt:s49" "procedure: (phantom-bytevector? obj)\nreturns: #t if obj is a phantom bytevector, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(phantom-bytevector? (make-phantom-bytevector 1024)) => #t\n\n") ("smgmt:s50" "procedure: (phantom-bytevector-length pbv)\nreturns: the length of the phantom bytevector \nlibraries: (chezscheme)  \n\n" "pbv must be a phantom bytevector. \n\n" "Returns the number of bytes of external allocation that pbv represents. \n\n" "" "(phantom-bytevector-length (make-phantom-bytevector 1024)) => 1024\n\n") ("smgmt:s51" "procedure: (set-phantom-bytevector-length! pbv n)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "pbv must be a phantom bytevector, and n must be an exact nonnegative integer. \n\n" "Adjusts the allocation represented by pbv to n bytes. For example, when an externally allocated object represented by pbv is deallocated, then pbv's length should be set to 0.  \n\n" "" "(define pbv (make-phantom-bytevector 1024))\n(phantom-bytevector-length pbv) => 1024\n(set-phantom-bytevector-length! pbv 1)\n(phantom-bytevector-length pbv) => 1\n\n" "") ("system:s1" "procedure: (warning who msg irritant ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "warning raises a continuable exception with condition type &warning and should be used to describe situations for which the &warning condition type is appropriate, typically a situation that should not prevent the program from continuing but might result in a more serious problem at some later point. \n\n" "The continuation object with which the exception is raised also includes a &who condition whose who field is who if who is not #f, a &message condition whose message field is msg, and an &irritants condition whose irritants field is (irritant ...). \n\n" "who must be a string, a symbol, or #f identifying the procedure or syntactic form reporting the warning. It is usually best to identify a procedure the programmer has called rather than some other procedure the programmer may not be aware is involved in carrying out the operation. msg must be a string and should describe the exceptional situation. The irritants may be any Scheme objects and should include values that may have caused or been materially involved in the exceptional situation. \n\n") ("system:s2" "procedure: (assertion-violationf who msg irritant ...)\nreturns: does not return \nprocedure: (errorf who msg irritant ...)\nreturns: does not return \nprocedure: (warningf who msg irritant ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "These procedures are like assertion-violation, error, and warning except that msg is assumed to be a format string, as if in a call to format (Section 9.13), with irritant ... treated as the additional arguments to format. This allows programs to control the appearance of the error message, at least when the default exception handler is in place. \n\n" "For each of these procedures, the continuation object with which the exception is raised includes a &format condition to signify that the string contained in the condition object's &message condition is a format string and the objects contained in the condition object's &irritants condition should be treated as the additional format arguments.  \n\n") ("system:s4" "syntax: &format \nprocedure: (make-format-condition) \nreturns: a condition of type &format \nprocedure: (format-condition? obj)\nreturns: #t if obj is a condition of type &format, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "Presence of this condition type within a compound condition indicates that the string provided by the &message condition, if present, is a format string and the list of objects provided by the &irritants condition, if present, should be treated as additional format arguments. This condition type might be defined as follows. \n\n" "(define-condition-type &format &condition\n  make-format-condition format-condition?)\n\n") ("system:s5" "syntax: &source \nprocedure: (make-source-condition form)\nreturns: a condition of type &source \nprocedure: (source-condition? obj)\nreturns: #t if obj is a condition of type &source, #f otherwise \nprocedure: (source-condition-form condition)\nreturns: the contents of condition's form field \nlibraries: (chezscheme)  \n\n" "" "This condition type can be included within a compound condition when a source expression can be identified in situations in which a &syntax condition would be inappropriate, such as when a run-time assertion violation is detected. The form argument should be an s-expression or syntax object representing the source expression. This condition type might be defined as follows. \n\n" "(define-condition-type &source &condition\n  make-source-condition source-condition?\n  (form source-condition-form))\n\n") ("system:s6" "syntax: &continuation \nprocedure: (make-continuation-condition continuation)\nreturns: a condition of type &continuation \nprocedure: (continuation-condition? obj)\nreturns: #t if obj is a condition of type &continuation, #f otherwise \nprocedure: (condition-continuation condition)\nreturns: the contents of condition's continuation field \nlibraries: (chezscheme)  \n\n" "" "This condition type can be included within a compound condition to indicate the current continuation at the point where the exception described by the condition occurred. The continuation of a failed assert or a call to assertion-violation, assertion-violationf, error, errorf, or syntax-error is now included via this condition type in the conditions passed to raise. The continuation argument should be a continuation. This condition type might be defined as follows. \n\n" "(define-condition-type &continuation &condition\n  make-continuation-condition continuation-condition?\n  (continuation condition-continuation))\n\n") ("system:s7" "procedure: (display-condition obj)\nprocedure: (display-condition obj textual-output-port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "If textual-output-port is not supplied, it defaults to the current output port. This procedure displays a message to the effect that an exception has occurred with value obj. If obj is a condition (Chapter 11 of The Scheme Programming Language, 4th Edition), it displays information encapsulated within the condition, handling messages, who conditions, irritants, source information, etc., as appropriate. \n\n") ("system:s8" "procedure: (default-exception-handler obj)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedure is the default value of the base-exception-handler parameter called on a condition when no other exception handler has been defined or when all dynamically established exception handlers have chosen not to handle the condition. It first displays obj, as if with display-condition, to the console error port. For non-serious warning conditions, it returns immediately after displaying the condition. \n\n" "For serious or other non-warning conditions, it saves the condition in the parameter debug-condition, where debug (Section 3.2) can retrieve it and allow it to be inspected. If the debug-on-exception parameter is set to #f (the default unless the --debug-on-exception command-line option is provided), the handler prints a message instructing the user to type (debug) to enter the debugger, then resets to the current caf. Otherwise, the handler invokes debug directly and resets if debug returns.  \n\n" "If an I/O exception occurs while attempting to display the condition, the default exception handler resets (as if by calling reset). The intent is to avoid an infinite regression (ultimately ending in exhaustion of memory) in which the process repeatedly recurs back to the default exception handler trying to write to a console-error port (typically stderr) that is no longer writable, e.g., due to the other end of a pipe or socket having been closed. \n\n") ("system:s10" "global parameter: debug-on-exception \nlibraries: (chezscheme)  \n\n" "The value of this parameter determines whether the default exception handler immediately enters the debugger immediately when it receives a serious or non-warning condition. If the --debug-on-exception command-line option (Section 2.1) has been provided, the initial value of this parameter is #t. Otherwise, the initial value is #f.  \n\n") ("system:s12" "thread parameter: base-exception-handler \nlibraries: (chezscheme)  \n\n" "The value of this parameter must be a procedure, and the procedure should accept one argument. The default value of base-exception-handler is the procedure default-exception-handler.  \n\n" "The value of this parameter is invoked whenever no exception handler established by a program has chosen to handle an exception. \n\n") ("system:s13" "thread parameter: debug-condition \nlibraries: (chezscheme)  \n\n" "This parameter is used by the default exception handler to hold the last serious or non-warning condition received by the handler, where it can be inspected via the debug procedure (Section 3.2). It can also be invoked by user code to store or retrieve a condition. \n\n") ("system:s14" "thread parameter: current-exception-state \nlibraries: (chezscheme)  \n\n" "current-exception-state may be used to get or set the current exception state. When called without arguments, current-exception-state returns an exception state comprising the current stack of handlers established by with-exception-handler and guard. When called with a single argument, which must be an exception state, current-exception-state sets the exception state. When a new thread is created, it starts with a default exception state equivalent to (create-exception-state).  \n\n") ("system:s15" "procedure: (create-exception-state) \nprocedure: (create-exception-state handler)\nlibraries: (chezscheme)  \n\n" "create-exception-state creates an exception state whose stack of exception handlers is empty except for, in effect, an infinite number of occurrences of handler at its base. handler must be a procedure, and should accept one argument. If not provided, handler defaults to a procedure equivalent to the value of the following expression. \n\n" "" "(lambda (x) ((base-exception-handler) x))\n\n") ("system:s16" "procedure: (assert-unreachable) \nlibraries: (chezscheme)  \n\n" "assert-unreachable is an assertion with the special property that at optimize-level 3 the optimizer can assume that the any application of assert-unreachable is, in fact, not reachable.  \n\n" "In code expanded or compiled at optimize-levels less than 3, invoking assert-unreachable raises a non-continuable exception with condition type &assertion.  \n\n" "In code expanded or compiled at optimize-level 3, the behavior of invoking assert-unreachable is undefined, which gives the compiler liberty to pick convenient or efficient behavior. For example: \n\n" "" "(print-gensym #f)\n(optimize-level 3)\n(expand/optimize\n  '(lambda (x)\n     (if (pair? x)\n         (car x)\n         (assert-unreachable)))))\n=> (lambda (x) (#3%car x))\n\n" "because choosing to make (assert-unreachable) behave the same as (#3%car x) makes both branches of the if the same, and then pair? test can be eliminated (since it has no side effects). \n\n") ("system:s18" "procedure: (break who msg irritant ...)\nprocedure: (break who)\nprocedure: (break) \nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "The arguments to break follow the protocol described above for errorf. The default break handler (see break-handler) displays a message and invokes the debugger. The format string and objects may be omitted, in which case the message issued by the default break handler identifies the break using the who argument but provides no more information about the break. If the who argument is omitted as well, no message is generated. The default break handler returns normally if the debugger exits normally. \n\n") ("system:s20" "thread parameter: break-handler \nlibraries: (chezscheme)  \n\n" "The value of this parameter must be a procedure. The current break handler is called by break, which passes along its arguments. See break for a description of the default break handler. The example below shows how to disable breaks. \n\n" "" "(break-handler (lambda args (void)))\n\n") ("system:s21" "thread parameter: keyboard-interrupt-handler \nlibraries: (chezscheme)  \n\n" "The value of this parameter must be a procedure. The keyboard-interrupt handler is called (with no arguments) when a keyboard interrupt occurs. The default keyboard-interrupt handler invokes the interactive debugger. If the debugger exits normally the interrupted computation is resumed. The example below shows how to install a keyboard-interrupt handler that resets without invoking the debugger. \n\n" "" "(keyboard-interrupt-handler\n   (lambda ()\n    (newline (console-output-port))\n    (reset)))\n\n") ("system:s23" "procedure: (set-timer n)\nreturns: previous current timer value \nlibraries: (chezscheme)  \n\n" "n must be a nonnegative integer. When n is nonzero, set-timer starts an internal timer with an initial value of n. When n ticks elapse, a timer interrupt occurs, resulting in invocation of the timer interrupt handler. Each tick corresponds roughly to one nonleaf procedure call (see the introduction to this section); thus, ticks are not uniform time units but instead depend heavily on how much work is done by each procedure call. \n\n" "When n is zero, set-timer turns the timer off.  \n\n" "The value returned in either case is the value of the timer before the call to set-timer. A return value of 0 should not be taken to imply that the timer was not on; the return value may also be 0 if the timer was just about to fire when the call to set-timer occurred.  \n\n" "The engine mechanism (Section 6.4) is built on top of the timer interrupt so timer interrupts should not be used with engines. \n\n") ("system:s25" "thread parameter: timer-interrupt-handler \nlibraries: (chezscheme)  \n\n" "The value of this parameter must be a procedure. The timer interrupt handler is called by the system when the internal timer (set by set-timer) expires. The default handler raises an exception with condition type &assertion to say that the handler has not been defined; any program that uses the timer should redefine the handler before setting the timer. \n\n") ("system:s27" "procedure: (disable-interrupts) \nprocedure: (enable-interrupts) \nreturns: disable count \nlibraries: (chezscheme)  \n\n" "disable-interrupts disables the handling of interrupts, including timer, keyboard, and collect request interrupts. enable-interrupts re-enables these interrupts. The system maintains a disable count that starts at zero; when zero, interrupts are enabled. Each call to disable-interrupts increments the count, effectively disabling interrupts. Each call to enable-interrupts decrements the count, if not already zero, effectively enabling interrupts. For example, two calls to disable-interrupts followed by one call to enable-interrupts leaves interrupts disabled. Calls to enable-interrupts when the count is already zero (and interrupts are enabled) have no effect. The value returned by either procedure is the number of calls to enable-interrupts required to enable interrupts.  \n\n" "Great care should be exercised when using these procedures, since disabling interrupts inhibits the normal processing of keyboard interrupts, timer interrupts, and, perhaps most importantly, collect request interrupts. Since garbage collection does not happen automatically when interrupts are disabled, it is possible for the storage allocator to run out of space unnecessarily should interrupts be disabled for a long period of time. \n\n" "The with-interrupts-disabled syntactic form should be used instead of these more primitive procedures whenever possible, since with-interrupts-disabled ensures that interrupts are re-enabled whenever a nonlocal exit occurs, such as when an exception is handled by the default exception handler. \n\n") ("system:s28" "syntax: (with-interrupts-disabled body1 body2 ...)\nsyntax: (critical-section body1 body2 ...)\nreturns: the values of the body body1 body2 ...\nlibraries: (chezscheme)  \n\n" "with-interrupts-disabled evaluates the body body1 body2 ... with interrupts disabled. That is, upon entry, interrupts are disabled, and upon exit, interrupts are re-enabled. Thus, with-interrupts-disabled allows the implementation of indivisible operations in nonthreaded versions of Chez Scheme or within a single thread in threaded versions of Chez Scheme. critical-section is the same as with-interrupts-disabled and is provided for backward compatibility. \n\n" "with-interrupts-disabled can be defined as follows.  \n\n" "" "(define-syntax with-interrupts-disabled\n  (syntax-rules ()\n    [(_ b1 b2 ...)\n     (dynamic-wind\n       disable-interrupts\n       (lambda () b1 b2 ...)\n       enable-interrupts)]))\n\n" "The use of dynamic-wind ensures that interrupts are disabled whenever the body of the with-interrupts-disabled expression is active and re-enabled whenever it is not. Since calls to disable-interrupts are counted (see the discussion under disable-interrupts and enable-interrupts above), with-interrupts-disabled expressions may be nested with the desired effect. \n\n") ("system:s29" "procedure: (register-signal-handler sig procedure)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "register-signal-handler is used to establish a signal handler for a given low-level signal. sig must be an exact integer identifying a valid signal, and procedure should accept one argument. See your host system's <signal.h> or documentation for a list of valid signals and their numbers. After a signal handler for a given signal has been registered, receipt of the specified signal results in a call to the handler. The handler is passed the signal number, allowing the same handler to be used for different signals while differentiating among them. \n\n" "Signals handled in this fashion are treated like keyboard interrupts in that the handler is not called immediately when the signal is delivered to the process, but rather at some procedure call boundary after the signal is delivered. It is generally not a good idea, therefore, to establish handlers for memory faults, illegal instructions, and the like, since the code that causes the fault or illegal instruction will continue to execute (presumably erroneously) for some time before the handler is invoked. A finite amount of storage is used to buffer as-yet unhandled signals, after which additional signals are dropped. \n\n" "register-signal-handler is supported only on Unix-based systems. \n\n") ("system:s30" "procedure: (environment? obj)\nreturns: #t if obj is an environment, otherwise #f \nlibraries: (chezscheme)  \n\n" "" "(environment? (interaction-environment)) => #t\n(environment? 'interaction-environment) => #f\n(environment? (copy-environment (scheme-environment))) => #t\n(environment? (environment '(prefix (rnrs) $rnrs-))) => #t\n\n") ("system:s31" "procedure: (environment-mutable? env)\nreturns: #t if env is mutable, otherwise #f \nlibraries: (chezscheme)  \n\n" "" "(environment-mutable? (interaction-environment)) => #t\n(environment-mutable? (scheme-environment)) => #f\n(environment-mutable? (copy-environment (scheme-environment))) => #t\n(environment-mutable? (environment '(prefix (rnrs) $rnrs-))) => #f\n\n") ("system:s32" "procedure: (scheme-environment) \nreturns: an environment \nlibraries: (chezscheme)  \n\n" "scheme-environment returns an environment containing the initial top-level bindings. This environment corresponds to the scheme module.  \n\n" "The environment returned by this procedure is immutable. \n\n" "" "(define cons 3)\n(top-level-value 'cons (scheme-environment)) => #<procedure cons>\n(set-top-level-value! 'cons 3 (scheme-environment)) => exception\n\n") ("system:s33" "procedure: (ieee-environment) \nreturns: an IEEE/ANSI standard compatibility environment \nlibraries: (chezscheme)  \n\n" "ieee-environment returns an environment containing bindings for the keywords and variables whose meanings are defined by the IEEE/ANSI Standard for Scheme [26]. \n\n" "The bindings for each of the identifiers in the IEEE environment are those of the corresponding Revised^6 Report library, so this does not provide full backward compatibility. \n\n" "The environment returned by this procedure is immutable. \n\n" "" "(define cons 3)\n(top-level-value 'cons (ieee-environment)) => #<procedure cons>\n(set-top-level-value! 'cons 3 (ieee-environment)) => exception\n\n") ("system:s34" "thread parameter: interaction-environment \nlibraries: (chezscheme)  \n\n" "The original value of interaction-environment is the default top-level environment. It is initially set to a mutable copy of (scheme-environment) and which may be extended or otherwise altered by top-level definitions and assignments. It may be set to any environment, mutable or not, to change the default top-level evaluation environment. \n\n" "An expression's top-level bindings resolve to the environment that is in effect when the expression is expanded, and changing the value of this parameter has no effect on running code. Changes affect only code that is subsequently expanded, e.g., as the result of a call to eval, load, or compile-file.  \n\n" "" "(define cons 3)\ncons => 3\n(top-level-value 'cons (interaction-environment)) => 3 \n\n(interaction-environment (scheme-environment))\ncons => #<procedure cons>\n(set! cons 3) => exception: attempt to assign immutable variable\n(define cons 3) => exception: invalid definition in immutable environment\n\n") ("system:s35" "procedure: (copy-environment env)\nprocedure: (copy-environment env mutable?)\nprocedure: (copy-environment env mutable? syms)\nreturns: a new environment \nlibraries: (chezscheme)  \n\n" "copy-environment returns a copy of env, i.e., a new environment that contains the same bindings as env. \n\n" "The environment is mutable if mutable? is omitted or true; if mutable? is false, the environment is immutable. \n\n" "The set of bindings copied from env to the new environment is determined by syms, which defaults to the value of (environment-symbols env). The binding, if any, for each element of syms is copied to the new environment, and no other bindings are present in the new environment. \n\n" "In the current implementation, the storage space used by an environment is never collected, so repeated use of copy-environment will eventually cause the system to run out of memory. \n\n" "" "(define e (copy-environment (scheme-environment)))\n(eval '(define cons +) e)\n(eval '(cons 3 4) e)                    => 7\n(eval '(cons 3 4) (scheme-environment)) => (3 . 4)\n\n") ("system:s36" "procedure: (environment-symbols env)\nreturns: a list of symbols \nlibraries: (chezscheme)  \n\n" "This procedure returns a list of symbols representing the identifiers bound in environment env. It is primarily useful in building the list of symbols to be copied from one environment to another. \n\n" "" "(define listless-environment\n  (copy-environment\n    (scheme-environment)\n    #t\n    (remq 'list (environment-symbols (scheme-environment)))))\n(eval '(let ([x (cons 3 4)]) x) listless-environment) => (3 . 4)\n(eval '(list 3 4) listless-environment) => exception\n\n") ("system:s37" "procedure: (apropos-list s)\nprocedure: (apropos-list s env)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "This procedure returns a selected list of symbols and pairs. Each symbol in the list represents an identifier bound in env. Each pair represents a set of identifiers exported by a predefined library or a library previously defined or loaded into the system. The car of the pair is the library name, and the cdr is a list of symbols. If s is a string, only entries whose names have s as a substring are included, and if s is a symbol, only those whose names have the name of s as a substring are selected. If no environment is provided, it defaults to the value of interaction-environment.  \n\n" "" "(library (a) (export a-vector-sortof) (import (rnrs))\n  (define a-vector-sortof '(vector 1 2 3)))\n(apropos-list 'vector-sort) =>\n  (vector-sort vector-sort!\n   ((a) a-vector-sortof)\n   ((chezscheme) vector-sort vector-sort!)\n   ((rnrs) vector-sort vector-sort!)\n   ((rnrs sorting) vector-sort vector-sort!)\n   ((scheme) vector-sort vector-sort!))\n\n") ("system:s38" "procedure: (apropos s)\nprocedure: (apropos s env)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "apropos is like apropos-list except the information is displayed to the current output port, as shown in the following transcript. \n\n" "" "> (library (a) (export a-vector-sortof) (import (rnrs))\n    (define a-vector-sortof '(vector 1 2 3)))\n> (apropos 'vector-sort)\ninteraction environment:\n  vector-sort, vector-sort!\n(a):\n  a-vector-sortof\n(chezscheme):\n  vector-sort, vector-sort!\n(rnrs):\n  vector-sort, vector-sort!\n(rnrs sorting):\n  vector-sort, vector-sort!\n(scheme):\n  vector-sort, vector-sort!\n\n") ("system:s39" "procedure: (eval obj)\nprocedure: (eval obj env)\nreturns: value of the Scheme form represented by obj \nlibraries: (chezscheme)  \n\n" "eval treats obj as the representation of an expression. It evaluates the expression in environment env and returns its value. If no environment is provided, it defaults to the environment returned by interaction-environment.  \n\n" "Single-argument eval is a Chez Scheme extension. Chez Scheme also permits obj to be the representation of a nonexpression form, i.e., a definition, whenever the environment is mutable. Chez Scheme further allows obj to be an annotation (Section 11.11), and the default evaluators make use of annotations to incorporate source-file information in error messages and associate source-file information with compiled code. \n\n" "In Chez Scheme, eval is actually a wrapper that simply passes its arguments to the current evaluator. (See current-eval.) The default evaluator is compile, which expands the expression via the current expander (see current-expand), compiles it, executes the resulting code, and returns its value. If the environment argument, env, is present, compile passes it along to the current expander, which is sc-expand by default.  \n\n") ("system:s40" "thread parameter: current-eval \nlibraries: (chezscheme)  \n\n" "current-eval determines the evaluation procedure used by the procedures eval, load, and new-cafe. current-eval is initially bound to the value of compile. (In Petite Chez Scheme, it is initially bound to the value of interpret.) The evaluation procedure should expect one or two arguments: an object to evaluate and an optional environment. The second argument might be an annotation (Section 11.11). \n\n" "" "(current-eval interpret)\n(+ 1 1) => 2 \n\n(current-eval (lambda (x . ignore) x))\n(+ 1 1) => (+ 1 1)\n\n") ("system:s44" "procedure: (compile obj)\nprocedure: (compile obj env)\nreturns: value of the Scheme form represented by obj \nlibraries: (chezscheme)  \n\n" "obj, which can be an annotation (Section 11.11) or unannotated value, is treated as a Scheme expression, expanded with the current expander (the value of current-expand) in the specified environment (or the interaction environment, if no environment is provided), compiled to machine code, and executed. compile is the default value of the current-eval parameter. \n\n") ("system:s45" "procedure: (interpret obj)\nprocedure: (interpret obj env)\nreturns: value of the Scheme form represented by obj \nlibraries: (chezscheme)  \n\n" "interpret is like compile, except that the expression is interpreted rather than compiled. interpret may be used as a replacement for compile, with the following caveats: \n\n" "\n* Interpreted code runs significantly slower. \n* Inspector information is not generated for interpreted code, so the inspector is not as useful for interpreted code as it is for compiled code. \n* Foreign procedure expressions cannot be interpreted, so the interpreter invokes the compiler for all foreign procedure expressions (this is done transparently). \n\n" "" "interpret is sometimes faster than compile when the form to be evaluated is short running, since it avoids some of the work done by compile prior to evaluation.  \n\n") ("system:s46" "procedure: (load path)\nprocedure: (load path eval-proc)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "path must be a string. load reads and evaluates the contents of the file specified by path. The file may contain source or object code. By default, load employs eval to evaluate each source expression found in a source file. If eval-proc is specified, load uses this procedure instead. eval-proc must accept one argument, the expression to evaluate. The expression passed to eval-proc might be an annotation (Section 11.11) or an unannotated value. \n\n" "The eval-proc argument facilitates the implementation of embedded Scheme-like languages and the use of alternate evaluation mechanisms to be used for Scheme programs. eval-proc can be put to other uses as well. For example, \n\n" "" "(load \"myfile.ss\"\n  (lambda (x)\n    (pretty-print\n      (if (annotation? x)\n          (annotation-stripped x)\n          x))\n    (newline)\n    (eval x)))\n\n" "pretty-prints each expression before evaluating it. \n\n" "The parameter source-directories (Section 12.5) determines the set of directories searched for source files not identified by absolute path names or paths that start with ./ (or .\\ under Windows) or ../ (or ..\\ under Windows).  \n\n") ("system:s48" "procedure: (load-library path)\nprocedure: (load-library path eval-proc)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "load-library is identical to load except that it treats the input file as if it were prefixed by an implicit #!r6rs. This effectively disables any non-R6RS lexical syntax except where subsequently overridden by #!chezscheme.  \n\n") ("system:s49" "procedure: (load-program path)\nprocedure: (load-program path eval-proc)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "path must be a string. load-program reads and evaluates the contents of the file specified by path. The file may contain source or object code. If it contains source code, load-program wraps the code in a top-level-program form so that the file's content is treated as an RNRS top-level program (Section 10.3 of The Scheme Programming Language, 4th Edition). By default, load-program employs eval to evaluate each source expression found in the file. If eval-proc is specified, load-program uses this procedure instead. eval-proc must accept one argument, the expression to evaluate. The expression passed to eval-proc might be an annotation (Section 11.11) or an unannotated value. \n\n" "The parameter source-directories (Section 12.5) determines the set of directories searched for source files not identified by absolute path names or paths that start with ./ (or .\\ under Windows) or ../ (or ..\\ under Windows).  \n\n") ("system:s51" "procedure: (verify-loadability situation input ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "situation must be one of the symbols visit, revisit, or load. Each input must be a string pathname or a pair of a string pathname and a library search path. Each of the pathnames should name a file containing object code for a set of libraries and top-level programs, such as would be produced by compile-program, compile-library, compile-whole-program, or compile-whole-library. A library search path must be a suitable argument for library-directories.  \n\n" "verify-loadability verifies, without actually loading any code or defining any libraries, whether the object files named by the specified pathnames and their library dependencies, direct or indirect, are present, readable, and mutually compatible. The type of dependencies for each named object file is determined by the situation argument: compile-time dependencies for visit, run-time dependencies for revisit and both for load. \n\n" "For each input pathname that is paired with a search path, the library-directories parameter is parameterized to the library search path during the recursive search for dependencies of the programs and libraries found in the object file named by the pathname. \n\n" "If verify-loadability finds a problem, such as a missing library dependency or compilation-instance mismatch, it raises an exception with an appropriate condition. Otherwise, it returns an unspecified value. \n\n" "Since verify-loadability does not load or run any code from the files it processes, it cannot determine whether errors unrelated to missing or unreadable files or mutual compatibility will occur when the files are actually loaded. \n\n") ("system:s57" "procedure: (load-compiled-from-port input-port)\nprocedure: (load-compiled-from-port input-port externals)\nreturns: result of the last compiled expression \nlibraries: (chezscheme)  \n\n" "load-compiled-from-port reads and evaluates the object-code contents of input-port as previously created by functions like compile-file, compile-script, compile-library, and compile-to-port.  \n\n" "The externals argument, if supplied, must be a vector. It should cooperate with an ext-pred procedure passed to compile-to-port, analogous to the way a procedure and vector cooperate with fasl-write and fasl-read.  \n\n" "The return value is the value of the last expression whose compiled form is in input-port. If input-port is empty, then the result value is unspecified. The port is left at end-of-file but is not closed. \n\n") ("system:s58" "procedure: (visit-compiled-from-port input-port)\nreturns: result of the last compiled expression processed \nlibraries: (chezscheme)  \n\n" "visit-compiled-from-port reads and evaluates the object-code contents of input-port as previously created by functions like compile-file, compile-script, compile-library, and compile-to-port.  In the process, it skips any revisit (run-time-only) code.  \n\n" "The return value is the value of the last expression whose last non-revisit compiled form is in input-port. If there are no such forms, then the result value is unspecified. The port is left at end-of-file but is not closed. \n\n") ("system:s59" "procedure: (revisit-compiled-from-port input-port)\nreturns: result of the last compiled expression processed \nlibraries: (chezscheme)  \n\n" "revisit-compiled-from-port reads and evaluates the object-code contents of input-port as previously created by functions like compile-file, compile-script, compile-library, and compile-to-port.  In the process, it skips any visit (compile-time-only) code.  \n\n" "The return value is the value of the last expression whose last non-visit compiled form is in input-port. If there are no such forms, then the result value is unspecified. The port is left at end-of-file but is not closed. \n\n") ("system:s60" "procedure: (visit path)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "path must be a string. visit reads the named file, which must contain compiled object code compatible with the current machine type and version, and it runs those portions of the compiled object code that establish compile-time information or correspond to expressions identified as \"visit\" time by eval-when forms contained in the original source file. \n\n" "For example, assume the file t1.ss contains the following forms: \n\n" "" "(define-syntax a (identifier-syntax 3))\n(module m (x) (define x 4))\n(define y 5)\n\n" "If t1.ss is compiled to t1.so, applying load to t1.so has the effect of defining all three identifiers. Applying visit to t1.so, however, has the effect of installing the transformer for a, installing the interface for m (for use by import),  and recording y as a variable. visit is useful when separately compiling one file that depends on bindings defined in another without actually loading and evaluating the code in the supporting file. \n\n" "The parameter source-directories (Section 12.5) determines the set of directories searched for source files not identified by absolute path names or paths that start with ./ (or .\\ under Windows) or ../ (or ..\\ under Windows).  \n\n") ("system:s62" "procedure: (revisit path)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "path must be a string. revisit reads the named file, which must contain compiled object code compatible with the current machine type and version, and it runs those portions of the compiled object code that compute run-time values or correspond to expressions identified as \"revisit\" time by eval-when forms contained in the original source file.  \n\n" "Continuing the example given for visit above, applying revisit to the object file, t1.so, has the effect of establishing the values of the variable x exported from m and the top-level variable y, without installing either the interface for m or the transformer for a.  \n\n" "revisit is useful for loading compiled application code without loading unnecessary compile-time information. Care must be taken when using this feature if the application calls eval or uses top-level-value, set-top-level-value!, or top-level-syntax to access top-level bindings at run-time, since these procedures use compile-time information to resolve top-level bindings. \n\n" "The parameter source-directories (Section 12.5) determines the set of directories searched for source files not identified by absolute path names or paths that start with ./ (or .\\ under Windows) or ../ (or ..\\ under Windows).  \n\n") ("system:s64" "procedure: (compile-file input-filename)\nprocedure: (compile-file input-filename output-filename)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "input-filename and output-filename must be strings. input-filename must name an existing, readable file. It must contain a sequence of zero or more source expressions; if this is not the case, compile-file raises an exception with condition type &syntax.  \n\n" "The normal evaluation process proceeds in two steps: compilation and execution. compile-file performs the compilation process for an entire source file, producing an object file. When the object file is subsequently loaded (see load), the compilation process is not necessary, and the file typically loads several times faster. \n\n" "If the optional output-filename argument is omitted, the actual input and output filenames are determined as follows. If input-filename has no extension, the input filename is input-filename followed by .ss  and the output filename is input-filename followed by .so. If input-filename has the extension .so, the input filename is input-filename and the output filename is input-filename followed by .so. Otherwise, the input filename is input-filename and the output filename is input-filename without its extension, followed by .so. For example, (compile-file \"myfile\") produces an object file with the name \"myfile.so\" from the source file named \"myfile.ss\", (compile-file \"myfile.sls\") produces an object file with the name \"myfile.so\" from the source file named \"myfile.sls\", and (compile-file \"myfile1\" \"myfile2\") produces an object file with the name \"myfile2\" from the source file name \"myfile1\".  \n\n" "Before compiling a file, compile-file saves the values of the following parameters: \n\n" "" "optimize-level\n debug-level\nrun-cp0\ncp0-effort-limit\ncp0-score-limit\ncp0-outer-unroll-limit\ngenerate-inspector-information\ngenerate-procedure-source-information\ncompile-profile\ngenerate-covin-files\ngenerate-interrupt-trap\nenable-cross-library-optimization\nenable-arithmetic-left-associative\nenable-error-source-expression\nenable-unsafe-application\nenable-type-recovery\n\n" "It restores the values after the file has been compiled. This allows the programmer to control the values of these parameters on a per-file basis, e.g., via an eval-when with situation compile embedded in the source file. For example, if \n\n" "" "(eval-when (compile) (optimize-level 3))\n\n" "appears at the top of a source file, the optimization level is set to 3 just while the remainder of file is compiled. \n\n") ("system:s67" "procedure: (compile-script input-filename)\nprocedure: (compile-script input-filename output-filename)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "input-filename and output-filename must be strings. \n\n" "compile-script is like compile-file but differs in that it copies the leading #! line from the source-file script into the object file. \n\n" "compile-script permits compiled script files to be created from source script to reduce script load time. As with source-code scripts, compiled scripts may be run with the --script command-line option. \n\n") ("system:s69" "procedure: (compile-library input-filename)\nprocedure: (compile-library input-filename output-filename)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "input-filename and output-filename must be strings. \n\n" "compile-library is identical to compile-file except that it treats the input file as if it were prefixed by an implicit #!r6rs. This effectively disables any non-R6RS lexical syntax except where subsequently overridden by #!chezscheme.  \n\n") ("system:s70" "procedure: (compile-program input-filename)\nprocedure: (compile-program input-filename output-filename)\nreturns: a list of libraries invoked by the program \nlibraries: (chezscheme)  \n\n" "input-filename and output-filename must be strings. \n\n" "compile-program is like compile-script but differs in that it implements the semantics of RNRS top-level programs, while compile-script implements the semantics of the interactive top-level. The resulting compiled program will also run faster than if compiled via compile-file or compile-script.  \n\n" "compile-program returns a list of libraries directly invoked by the compiled top-level program, excluding built-in libraries like (rnrs) and (chezscheme). The procedure library-requirements may be used to determine the indirect requirements, i.e., additional libraries required by the directly invoked libraries. When combined with library-object-filename, this information can be used to determine the set of files that must be distributed with the compiled program file. \n\n" "A program invokes a library only if it references one or more variables exported from the library. The set of libraries invoked by a top-level program, and hence loaded when the program is loaded, might be smaller than the set imported by the program, and it might be larger than the set directly imported by the program. \n\n" "As with source-code top-level programs, compiled top-level programs may be run with the --program command-line option. \n\n") ("system:s72" "procedure: (maybe-compile-file input-filename)\nprocedure: (maybe-compile-file input-filename output-filename)\nprocedure: (maybe-compile-library input-filename)\nprocedure: (maybe-compile-library input-filename output-filename)\nprocedure: (maybe-compile-program input-filename)\nprocedure: (maybe-compile-program input-filename output-filename)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "These procedures are like their non-maybe counterparts but compile the source file only if the object file is out-of-date. An object file X is considered out-of-date if it does not exist or if it is older than the source file or any files included (via include) when X was created. When the value of the parameter compile-imported-libraries is #t, X is also considered out-of-date if the object file for any library imported when X was compiled is out-of-date. If maybe-compile-file determines that compilation is necessary, it compiles the source file by passing compile-file the input and output filenames. compile-library does so by similarly invoking the value of the compile-library-handler parameter, and compile-program does so by similarly invoking the value of the compile-program-handler parameter.  \n\n" "When output-filename is not specified, the input and output filenames are determined in the same manner as for compile-file.  \n\n") ("system:s73" "thread parameter: compile-library-handler \nlibraries: (chezscheme)  \n\n" "This parameter must be set to a procedure, and the procedure should accept two string arguments naming a source file and an object file. The procedure should typically invoke compile-library and pass it the two arguments, but it can also use one of the other file or port compilation procedures. For example, it might read the source file using its own parser and use compile-to-file to finish the compilation process. The procedure can perform other actions as well, such as parameterizing compilation parameters, establishing guards, or gathering statistics. The default value of this parameter simply invokes compile-library on the two string arguments without taking any other action. \n\n" "The value of this parameter is called by maybe-compile-library when the object file is out-of-date. It is also called by the expander to compile an imported library when compile-imported-libraries is #t and the expander determines the object file is out-of-date. \n\n") ("system:s75" "thread parameter: compile-program-handler \nlibraries: (chezscheme)  \n\n" "This parameter must be set to a procedure, and the procedure should accept two string arguments naming a source file and an object file. The procedure should typically invoke compile-program and pass it the two arguments, but it can also use one of the other file or port compilation procedures. For example, it might read the source file using its own parser and use compile-to-file to finish the compilation process. The procedure can perform other actions as well, such as parameterizing compilation parameters, establishing guards, or gathering statistics. The default value of this parameter simply invokes compile-program on the two string arguments without taking any other action and returns the list of libraries returned by compile-program.  \n\n" "The value of this parameter is called by maybe-compile-program when the object file is out-of-date. \n\n") ("system:s77" "procedure: (compile-whole-program input-filename output-filename)\nprocedure: (compile-whole-program input-filename output-filename libs-visible?)\nreturns: a list of libraries left to be loaded at run time \nlibraries: (chezscheme)  \n\n" "compile-whole-program accepts as input a filename naming a \"whole program optimization\" (wpo) file for a top-level program and produces an object file incorporating the program and each library upon which it depends, provided that a wpo file for the library can be found. \n\n" "If a wpo file for a required library cannot be found, but an object file for the library can, the library is not incorporated in the resulting object file. Such libraries are left to be loaded at run time. compile-whole-program returns a list of such libraries. If there are no such libraries, the resulting object file is self-contained and compile-whole-program returns the empty list. \n\n" "The libraries incorporated into the resulting object file are visible (for use by environment and eval) if the libs-visible? argument is supplied and non-false. Any library incorporated into the resulting object file and required by an object file left to be loaded at run time is also visible, as are any libraries the object file depends upon, regardless of the value of libs-visible?. \n\n" "compile-whole-program linearizes the initialization code for the set of incorporated libraries in a way that respects static dependencies among the libraries but not necessary dynamic dependencies deriving from initialization-time uses of environment or eval. Additional static dependencies can be added in most cases to force an ordering that allows the dynamic imports to succeed, though not in general since a different order might be required each time the program is run. Adding a static dependency of one library on a second requires adding an import of the second in the first as well as a run-time reference to one of the variables exported by the second in the body of the first. \n\n" "input-filename and output-filename must be strings. input-filename must identify a wpo file, and a wpo or object file must also be present for each required library somewhere in the directories specified by the library-directories parameter. \n\n" "To the extent possible given the specified set of visible libraries and requirements of libraries to be loaded at run time, compile-whole-program discards unused code and optimizes across program and library boundaries, potentially reducing program load time, run time, and memory requirements. Some optimization also occurs even across the boundaries of libraries that are not incorporated into the output, though this optimization is limited in nature. \n\n" "The procedures compile-file, compile-program, compile-library, compile-script, and compile-whole-library produce wpo files as well as ordinary object files when the generate-wpo-files parameter is set to #t (the default is #f). compile-port and compile-to-port do so when passed an optional wpo port. \n\n") ("system:s79" "procedure: (compile-whole-library input-filename output-filename)\nreturns: a list of libraries left to be loaded at run time \nlibraries: (chezscheme)  \n\n" "compile-whole-library is like compile-whole-program, except input-filename must specify a wpo file for a library, all libraries are automatically made visible, and a new wpo file is produced (when generate-wpo-files is #t) as well as an object file for the resulting combination of libraries. \n\n" "The comment in the description of compile-whole-program about the effect of initialization-code linearization on dynamic dependencies applies to compile-whole-library as well.  \n\n") ("system:s80" "procedure: (compile-port input-port output-port)\nprocedure: (compile-port input-port output-port sfd)\nprocedure: (compile-port input-port output-port sfd wpo-port)\nprocedure: (compile-port input-port output-port sfd wpo-port covop)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "input-port must be a textual input port. output-port and, if present and non-false, wpo-port must be binary output ports. If present and non-false, sfd must be a source-file descriptor. If present and non-false, covop must be a textual output port. \n\n" "compile-port is like compile-file except that it takes input from an arbitrary textual input port and sends output to an arbitrary binary output port. If sfd is supplied, it is passed to the reader so that source information can be associated with the expressions read from input-port. It is also used to associate block-profiling information with the input file name encapsulated within sfd. If wpo-port is supplied, compile-port sends whole-program optimization information to wpo-port for use by compile-whole-program, as if (and regardless of whether) generate-wpo-files is set. If covop is supplied, compile-port sends coverage information to covop, as if (and regardless of whether) generate-covin-files is set.  \n\n" "The ports are closed automatically after compilation under the assumption the program that opens the ports and invokes compile-port will take care of closing the ports. \n\n") ("system:s81" "procedure: (compile-to-port objs op)\nprocedure: (compile-to-port objs op sfd)\nprocedure: (compile-to-port objs op sfd wpoop)\nprocedure: (compile-to-port objs op sfd wpoop covop)\nprocedure: (compile-to-port objs op sfd wpoop covop mach)\nprocedure: (compile-to-port objs op sfd wpoop covop mach hostop)\nprocedure: (compile-to-port objs op sfd wpoop covop mach hostop ext)\nprocedure: (compile-to-port objs op sfd wpoop covop mach hostop ext nortds?)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "objs must be a list containing a sequence of objects that represent syntactically valid expressions, each possibly annotated (Section 11.11). If any of the objects does not represent a syntactically valid expression, compile-to-port raises an exception with condition type &syntax. op and, if present and non-false, wpoop, covop, and hostop must be binary output ports. If present and non-false, sfd must be a source-file descriptor. If present and non-false, mach must be a symbol. If present and non-false, ext must be or a procedure, but it must be #f if objs does not have exactlty one element. \n\n" "compile-to-port is like compile-file except that it takes input from a list of objects and sends output to an arbitrary binary output port. sfd is used to associate block-profiling information with the input file name encapsulated within sfd. If wpoop is present and not #f, compile-to-port sends whole-program optimization information to wpoop for use by compile-whole-program, as if (and regardless of whether) generate-wpo-files is set. If covop is present and not #f, compile-to-port sends coverage information to covop, as if (and regardless of whether) generate-covin-files is set. If mach is present, compile-to-port compiles for the specified machine type. If hostop is present, compile-to-port compiles for the host machine type to hostp (in addition to writing for machine to op, whether or not the machine types are the same). \n\n" "The ports are not closed automatically after compilation under the assumption the program that opens the port and invokes compile-to-port will take care of closing the port. \n\n" "If ext is present and not #f, it is used like the externals-pred predicate supplied to fasl-write. In that case, a corresponding vector must be provided to\nload-compiled-from-port to load the compiled code, analogous to the vector supplied to fasl-read.  \n\n" "Similarly, if nortds? is present and true, it is used like the omit-rtds? argument supplied to fasl-write:  Any record types relevant to the compiled code are not written to the output port.  When the compiled code is later loaded, these record types must already be declared in the loading context, and the loading context is assumed to have compatible record-type registrations using the same unique ID.  Behavior if the loading context has an incompatible record-type registration using the same (ostensibly unique) ID is undefined. \n\n" "When objs contains a single list-structured element whose first-element is the symbol top-level-program, compile-to-port returns a list of the libraries the top-level program requires at run time, as with compile-program. Otherwise, the return value is unspecified. \n\n") ("system:s82" "procedure: (compile-to-file obj-list output-file)\nprocedure: (compile-to-file obj-list output-file sfd)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "obj-list must be a list containing a sequence of objects that represent syntactically valid expressions, each possibly annotated (Section 11.11). If any of the objects does not represent a syntactically valid expression, compile-to-file raises an exception with condition type &syntax. output-file must be a string. If present, sfd must be a source-file descriptor. \n\n" "compile-to-file is like compile-file except that it takes input from a list of objects. sfd is used to associate block-profiling information with the input file name encapsulated within sfd. \n\n" "When obj-list contains a single list-structured element whose first-element is the symbol top-level-program, compile-to-file returns a list of the libraries the top-level program requires at run time, as with compile-program. Otherwise, the return value is unspecified. \n\n") ("system:s83" "procedure: (concatenate-object-files out-file in-file1 in-file2 ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "out-file and each in-file must be strings. \n\n" "concatenate-object-files combines the header information contained in the object files named by each in-file.  It then writes the combined header information to the file named by out-file, followed by the remaining object code from each input file in turn. \n\n") ("system:s84" "procedure: (make-boot-file output-filename base-boot-list input-filename ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "output-filename, input-filename, and the elements of base-boot-list must be strings. \n\n" "make-boot-file writes a boot header to the file named by output-filename, followed by the object code for each input-filename in turn. If an input file is not already compiled, make-boot-file compiles the file as it proceeds. \n\n" "The boot header identifies the elements of base-boot-list as alternative boot files upon which the new boot file depends. If the list of strings naming base boot files is empty, the first named input file should be a base boot file, i.e., petite.boot or some boot file derived from petite.boot. \n\n" "Boot files are loaded explicitly via the --boot or -b command-line options or implicitly based on the name of the executable (Section 2.9). \n\n" "See Section 2.8 for more information on boot files and the use of make-boot-file.  \n\n") ("system:s87" "procedure: (make-boot-header output-filename base-boot1 base-boot2...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedure has been subsumed by make-boot-file and is provided for backward compatibility. The call \n\n" "" "(make-boot-header output-filename base-boot1 base-boot2 ...)\n\n" "is equivalent to \n\n" "" "(make-boot-file output-filename '(base-boot1 base-boot2 ...))\n\n") ("system:s88" "procedure: (strip-fasl-file input-path output-path options)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "input-path and output-path must be strings. input-path must name an existing, readable file containing object code produced by compile-file, one of the other file-compiling procedures, or an earlier run of strip-fasl-file. options must be an enumeration set over the symbols constituting valid strip options, as described in the fasl-strip-options entry below. \n\n" "The new procedure strip-fasl-file allows the removal of source information of various sorts from a compiled object (fasl) file produced by compile-file or one of the other file compiling procedures. It also allows removal of library visit code from object files containing compiled libraries. Visit code is the code for macro transformers and meta definitions required to compile (but not run) dependent libraries. \n\n" "On most platforms, the input and output paths can be the same, in which case the input file is replaced with a new file containing the stripped object code. Using the same path will likely fail on Windows file systems, which do not generally permit an open file to be removed. \n\n" "If options is empty, the output file is effectively equivalent to the input file, though it will not necessarily be identical. \n\n") ("system:s89" "syntax: (fasl-strip-options symbol ...)\nreturns: a fasl-strip-options enumeration set \nlibraries: (chezscheme)  \n\n" "Fasl-strip-options enumeration sets are passed to strip-fasl-file to determine what is stripped. The available options are described below. \n\n" "\ninspector-source:\n    Strip inspector source information. This includes source expressions that might otherwise be available for procedures and continuations with the \"code\" and \"call\" commands and messages in the interactive and object inspectors. It also includes filename and position information that might otherwise be available for the same via the \"file\" command and \"source\" messages. \n\n" "\nsource-annotations:\n    Strip source annotations, which typically appear only on syntax objects, e.g., identifiers, in the templates of macro transformers. \n\n" "\nprofile-source:\n    Strip source file and character position information from profiled code objects. This does not remove the profile counters or eliminate the overhead for incrementing them at run time. \n\n" "\ncompile-time-information: \n    This strips compile-time information from compiled libraries, potentially reducing the size of the resulting file but making it impossible to use the file to compile dependent code. This option is useful for creating smaller object files to ship as part of a binary-only package. \n\n") ("system:s90" "thread parameter: compile-procedure-realm \nlibraries: (chezscheme)  \n\n" "This parameter can be set to #f or to a symbol. The realm of a procedure (or, more precisely, a procedure's code object) is accessible though the inspector. \n\n") ("system:s91" "procedure: (vfasl-convert-file input-path output-path base-boots)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Converts a compiled file to one that may load more quickly, especially in the case of a boot file. The converted file is a boot file if base-boots is a list of strings, otherwise base-boots must be #f to create a non-boot file.  \n\n") ("system:s92" "procedure: (pbchunk-convert-file in-path out-path c-paths c-names start-index)\nreturns: ending index as a nonnegative exact integer \nlibraries: (chezscheme)  \n\n" "Converts a compiled file in-path for a pb machine variant to a compiled file out-path that uses C chunk functions written to the files in c-paths, where c-paths is a nonempty list of file names. Chunk code is distributed across the files to avoid making a single, over-large source C file. The c-names list provides a list of function names, one for each output file in c-paths, where each function name is defined as a function of no arguments to register the file's chunks with the system. This registration must be performed before the converted compiled code is run. Every set of chunks registered in this way must use a distinct index range, where start-index provides the starting index for this set, and the result value is one more than the index of the last chunk written to the c-paths sources. \n\n") ("system:s93" "procedure: (machine-type) \nreturns: the current machine type \nlibraries: (chezscheme)  \n\n" "Consult the release notes for the current version of Chez Schemefor a list of supported machine types. \n\n") ("system:s94" "procedure: (expand obj)\nprocedure: (expand obj env)\nreturns: expansion of the Scheme form represented by obj \nlibraries: (chezscheme)  \n\n" "expand treats obj as the representation of an expression. It expands the expression in environment env and returns an object representing the expanded form. If no environment is provided, it defaults to the environment returned by interaction-environment.  \n\n" "obj can be an annotation (Section 11.11), and the default expander makes use of annotations to incorporate source-file information in error messages. \n\n" "expand actually passes its arguments to the current expander (see current-expand), initially sc-expand.  \n\n" "See also expand-output (page 396) which can be used to request that the compiler or interpreter show expander output. \n\n") ("system:s96" "thread parameter: current-expand \nlibraries: (chezscheme)  \n\n" "current-expand determines the expansion procedure used by the compiler, interpreter, and direct calls to expand to expand syntactic extensions. current-expand is initially bound to the value of sc-expand.  \n\n" "It may be set another procedure, but since the format of expanded code expected by the compiler and interpreter is not publicly documented, only sc-expand produces correct output, so the other procedure must ultimately be defined in terms of sc-expand.  \n\n" "The first argument to the expansion procedure represents the input expression. It can be an annotation (Section 11.11) or an unannotated value. the second argument is an environment. Additional arguments might be passed to the expansion procedure by the compiler, interpreter, and expand; their number and roles are unspecified. \n\n") ("system:s99" "procedure: (sc-expand obj)\nprocedure: (sc-expand obj env)\nreturns: the expanded form of obj \nlibraries: (chezscheme)  \n\n" "The procedure sc-expand is used to expand programs written using syntax-case macros. sc-expand is the default expander, i.e., the initial value of current-expand. obj represents the program to be expanded, and env must be an environment. obj can be an annotation (Section 11.11) or unannotated value. If not provided, env defaults to the environment returned by interaction-environment.  \n\n") ("system:s100" "procedure: (expand/optimize obj)\nprocedure: (expand/optimize obj env)\nreturns: result of expanding and optimizing form represented by obj \nlibraries: (chezscheme)  \n\n" "expand/optimize treats obj as the representation of an expression. obj can be an annotation (Section 11.11) or unannotated value. expand/optimize expands the expression in environment env and passes the expression through the source optimizer cp0 and a type-inferring optimizer cptypes (unless cp0 and cptypes are disabled via run-cp0, or unless cptypes is disabled via enable-type-recovery). It also simplifies letrec and letrec* expressions within the expression and makes their undefined checks explicit. It returns an object representing the expanded, simplified, and optimized form. If no environment is provided, it defaults to the environment returned by interaction-environment.  \n\n" "expand/optimize is primarily useful for understanding what cp0 plus cptypes does and does not optimize. Many optimizations are performed later in the compiler, so expand/optimize does not give a complete picture of optimizations performed. \n\n" "" "(expand/optimize\n   '(let ([y '(3 . 4)])\n     (+ (car y) (cdr y)))) => 7 \n\n(print-gensym #f)\n(expand/optimize\n  '(let ([y '(3 . 4)])\n     (lambda (x)\n       (* (+ (car y) (cdr y)) x)))) => (lambda (x) (#2%* 7 x)) \n\n(expand/optimize\n  '(let ([n (expt 2 10)])\n     (define even?\n       (lambda (x) (or (zero? x) (not (odd? x)))))\n     (define odd?\n       (lambda (x) (not (even? (- x 1)))))\n     (define f\n       (lambda (x)\n         (lambda (y)\n           (lambda (z)\n             (if (= z 0) (omega) (+ x y z))))))\n     (define omega\n       (lambda ()\n         ((lambda (x) (x x)) (lambda (x) (x x)))))\n     (let ([g (f 1)] [m (f n)])\n       (let ([h (if (> ((g 2) 3) 5)\n                    (lambda (x) (+ x 1))\n                    odd?)])\n         (h n))))) => 1025\n\n" "See also expand/optimize-output (page 396) which can be used to request that the compiler or interpreter show source-optimizer output. \n\n") ("system:s102" "syntax: (eval-when situations form1 form2 ...)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "situations must be a list containing some combination of the symbols eval, compile, load, visit, and revisit.  \n\n" "When source files are loaded (see load), the forms in the file are read, compiled, and executed sequentially, so that each form in the file is fully evaluated before the next one is read. When a source file is compiled (see compile-file), however, the forms are read and compiled, but not executed, in sequence. This distinction matters only when the execution of one form in the file affects the compilation of later forms, e.g., when the form results in the definition of a module or syntactic form or sets a compilation parameter such as optimize-level or case-sensitive.  \n\n" "For example, assume that a file contains the following two forms: \n\n" "" "(define-syntax reverse-define\n  (syntax-rules ()\n    [(_ e x) (define x e)])) \n\n(reverse-define 3 three)\n\n" "Loading this from source has the effect of defining reverse-define as a syntactic form and binding the identifier three to 3. The situation may be different if the file is compiled with compile-file, however. Unless the system or programmer takes steps to assure that the first form is fully executed before the second expression is compiled, the syntax expander will not recognize reverse-define as a syntactic form and will generate code for a procedure call to reverse-define instead of generating code to define three to be 3. When the object file is subsequently loaded, the attempt to reference either reverse-define or three will fail.  \n\n" "As it happens, when a define-syntax, module, import, or import-only form appears at top level, as in the example above, the compiler does indeed arrange to evaluate it before going on to compile the remainder of the file. If the compiler encounters a variable definition for an identifier that was previously something else, it records that fact as well. The compiler also generates the appropriate code so that the bindings will be present as well when the object file is subsequently loaded. This solves most, but not all, problems of this nature, since most are related to the use of define-syntax and modules. Some problems are not so straightforwardly handled, however. For example, assume that the file contains the following definitions for nodups? and mvlet.  \n\n" "" "(define nodups?\n  (lambda (ids)\n    (define bound-id-member?\n      (lambda (id ids)\n        (and (not (null? ids))\n             (or (bound-identifier=? id (car ids))\n                 (bound-id-member? id (cdr ids))))))\n    (or (null? ids)\n        (and (not (bound-id-member? (car ids) (cdr ids)))\n             (nodups? (cdr ids)))))) \n\n(define-syntax mvlet\n  (lambda (x)\n    (syntax-case x ()\n      [(_ ((x ...) expr) b1 b2 ...)\n       (and (andmap identifier? #'(x ...))\n            (nodups? #'(x ...)))\n       #'(call-with-values\n           (lambda () expr)\n           (lambda (x ...) b1 b2 ...))]))) \n\n(mvlet ((a b c) (values 1 2 3))\n  (list (* a a) (* b b) (* c c)))\n\n" "When loaded directly, this results in the definition of nodups? as a procedure and mvlet as a syntactic abstraction before evaluation of the mvlet expression. Because nodups? is defined before the mvlet expression is expanded, the call to nodups? during the expansion of mvlet causes no difficulty. If instead this file were compiled, using compile-file, the compiler would arrange to define mvlet before continuing with the expansion and evaluation of the mvlet expression, but it would not arrange to define nodups?. Thus the expansion of the mvlet expression would fail.  \n\n" "In this case it does not help to evaluate the syntactic extension alone. A solution in this case would be to move the definition of nodups? inside the definition for mvlet, just as the definition for bound-id-member? is placed within nodups?, but this does not work for help routines shared among several syntactic definitions. Another solution is to label the nodups? definition a \"meta\" definition (see Section 11.8) but this does not work for helpers that are used both by syntactic abstractions and by run-time code. \n\n" "A somewhat simpler problem occurs when setting parameters that affect compilation, such as optimize-level and case-sensitive?. If not set prior to compilation, their settings usually will not have the desired effect. \n\n" "eval-when offers a solution to these problems by allowing the programmer to explicitly control what forms should or should not be evaluated during compilation. eval-when is a syntactic form and is handled directly by the expander. The action of eval-when depends upon the situations argument and whether or not the forms form1 form2 ...are being compiled via compile-file or are being evaluated directly. Let's consider each of the possible situation specifiers eval, compile, load, visit, and revisit in turn.  \n\n" "\neval:\n    The eval specifier is relevant only when the eval-when form is being evaluated directly, i.e., if it is typed at the keyboard or loaded from a source file. Its presence causes form1 form2 ... to be expanded and this expansion to be included in the expansion of the eval-when form. Thus, the forms will be evaluated directly as if not contained within an eval-when form.  \n\n" "\ncompile:\n    The compile specifier is relevant only when the eval-when form appears in a file currently being compiled. (Its presence is simply ignored otherwise.) Its presence forces form1 form2 ... to be expanded and evaluated immediately. \n\n" "\nload:\n    The load specifier is also relevant only when the eval-when form appears in a file currently being compiled. Its presence causes form1 form2 ... to be expanded and this expansion to be included in the expansion of the eval-when form. Any code necessary to record binding information and evaluate syntax transformers for definitions contained in the forms is marked for execution when the file is \"visited,\" and any code necessary to compute the values of variable definitions and the expressions contained within the forms is marked for execution when the file is \"revisited.\" \n\n" "\nvisit:\n    The visit specifier is also relevant only when the eval-when form appears in a file currently being compiled. Its presence causes form1 form2 ... to be expanded and this expansion to be included in the expansion of the eval-when form, with an annotation that the forms are to be executed when the file is \"visited.\" \n\n" "\nrevisit:\n    The revisit specifier is also relevant only when the eval-when form appears in a file currently being compiled. Its presence causes form1 form2 ... to be expanded and this expansion to be included in the expansion of the eval-when form, with an annotation that the forms are to be executed when the file is \"revisited.\" \n\n" "A file is considered \"visited\" when it is brought in by either load or visit and \"revisited\" when it is brought in by either load or revisit.  \n\n" "Top-level expressions are treated as if they are wrapped in an eval-when with situations load and eval. This means that, by default, forms typed at the keyboard or loaded from a source file are evaluated, and forms appearing in a file to be compiled are not evaluated directly but are compiled for execution when the resulting object file is subsequently loaded. \n\n" "The treatment of top-level definitions is slightly more involved. All definitions result in changes to the compile-time environment. For example, an identifier defined by define is recorded as a variable, and an identifier defined by define-syntax is recorded as a keyword and associated with the value of its right-hand-side (transformer) expression. These changes are made at eval, compile, and load time as if the definitions were wrapped in an eval-when with situations eval, load, and compile. (This behavior can be altered by changing the value of the parameter eval-syntax-expanders-when.) Some definitions also result in changes to the run-time environment. For example, a variable is associated with the value of its right-hand-side expression. These changes are made just at evaluation and load time as if the definitions were wrapped in an eval-when with situations eval and load.  \n\n" "The treatment of local expressions or definitions (those not at top level) that are wrapped in an eval-when depends only upon whether the situation eval is present in the list of situations. If the situation eval is present, the definitions and expressions are evaluated as if they were not wrapped in an eval-when form, i.e., the eval-when form is treated as a begin form. If the situation eval is not present, the forms are ignored; in a definition context, the eval-when form is treated as an empty begin, and in an expression context, the eval-when form is treated as a constant with an unspecified value. \n\n" "Since top-level syntax bindings are established, by default, at compile time as well as eval and load time, top-level variable bindings needed by syntax transformers should be wrapped in an eval-when form with situations compile, load, and eval. We can thus nodups? problem above by enclosing the definition of nodups? in an eval-when as follows.  \n\n" "" "(eval-when (compile load eval)\n  (define nodups?\n    (lambda (ids)\n      (define bound-id-member?\n        (lambda (id ids)\n          (and (not (null? ids))\n               (or (bound-identifier=? id (car ids))\n                   (bound-id-member? id (cdr ids))))))\n      (or (null? ids)\n          (and (not (bound-id-member? (car ids) (cdr ids)))\n               (nodups? (cdr ids)))))))\n\n" "This forces it to be evaluated before it is needed during the expansion of the mvlet expression.  \n\n" "Just as it is useful to add compile to the default load and eval situations, omitting options is also useful. Omitting one or more of compile, load, and eval has the effect of preventing the evaluation at the given time. Omitting all of the options has the effect of inhibiting evaluation altogether. \n\n" "One common combination of situations is (compile eval), which by the inclusion of compile causes the expression to be evaluated at compile time, and by the omission of load inhibits the generation of code by the compiler for execution when the file is subsequently loaded. This is typically used for the definition of syntactic extensions used only within the file in which they appear; in this case their presence in the object file is not necessary. It is also used to set compilation parameters that are intended to be in effect whether the file is loaded from source or compiled via compile-file  \n\n" "" "(eval-when (compile eval) (case-sensitive #t))\n\n" "Another common situations list is (compile), which might be used to set compilation options to be used only when the file is compiled via compile-file.  \n\n" "" "(eval-when (compile) (optimize-level 3))\n\n" "Finally, one other common combination is (load eval), which might be useful for inhibiting the double evaluation (during the compilation of a file and again when the resulting object file is loaded) of syntax definitions when the syntactic extensions are not needed within the file in which their definitions appear. \n\n" "The behavior of eval-when is usually intuitive but can be understood precisely as follows. The syntax-case expander, which handles eval-when forms, maintains two state sets, one for compile-time forms and one for run-time forms. The set of possible states in each set are \"L\" for load, \"C\" for compile, \"V\" for visit, \"R\" for revisit, and \"E\" for eval.  \n\n" "When compiling a file, the compile-time set initially contains \"L\" and \"C\" and the run-time set initially contains only \"L.\" When not compiling a file (as when a form is evaluated by the read-eval-print loop or loaded from a source file), both sets initially contain only \"E.\" The subforms of an eval-when form at top level are expanded with new compile- and run-time sets determined by the current sets and the situations listed in the eval-when form. Each element of the current set contributes zero or more elements to the new set depending upon the given situations according to the following table. \n\n" "[table not shown]\n\n" "For example, if the current compile-time state set is {L} and the situations are load and compile, the new compile-time state set is {L, C}, since L/load contributes \"L\" and L/compile contributes \"C.\"  \n\n" "The state sets determine how forms are treated by the expander. Compile-time forms such as syntax definitions are evaluated at a time or times determined by the compile-time state set, and run-time forms are evaluated at a time or times determined by the run-time state set. A form is evaluated immediately if \"C\" is in the state set. Code is generated to evaluate the form at visit or revisit time if \"V\" or \"R\" is present. If \"L\" is present in the compile-time set, it is treated as \"V;\" likewise, if \"L\" is present in the run-time set, it is treated as \"R.\" If more than one of states is present in the state set, the form is evaluated at each specified time. \n\n" "\"E\" can appear in the state set only when not compiling a file, i.e., when the expander is invoked from an evaluator such as compile or interpret. When it does appear, the expanded form is returned from the expander to be processed by the evaluator, e.g., compile or interpret, that invoked the expander. \n\n" "The value of the parameter eval-syntax-expanders-when actually determines the initial compile-time state set. The parameter is bound to a list of situations, which defaults to (compile load eval). When compiling a file, compile contributes \"C\" to the state set, load contributes \"L,\" visit contributes \"V,\" revisit contributes \"R,\" and eval contributes nothing. When not compiling a file, eval contributes \"E\" to the state set, and the other situations contribute nothing. There is no corresponding parameter for controlling the initial value of the run-time state set. \n\n" "For RNRS top-level programs, eval-when is essentially ineffective. The entire program is treated as a single expression, so eval-when becomes a local eval-when for which only the eval situation has any relevance. As for any local eval-when form, the subforms are ignored if the eval situation is not present; otherwise, they are treated as if the eval-when wrapper were absent.  \n\n") ("system:s105" "thread parameter: eval-syntax-expanders-when \nlibraries: (chezscheme)  \n\n" "This parameter must be set to a list representing a set of eval-when situations, e.g., a list containing at most one occurrence of each of the symbols eval, compile, load, visit, and revisit. It is used to determine the evaluation time of syntax definitions, module forms, and import forms are expanded. (See the discussion of eval-when above.) The default value is (compile load eval), which causes compile-time information in a file to be established when the file is loaded from source, when it is compiled via compile-file, and when a compiled version of the file is loaded via load or visit.  \n\n") ("system:s106" "thread parameter: current-generate-id \nlibraries: (chezscheme)  \n\n" "This parameter must be set to a procedure that accepts one argument, a symbol, and returns a fresh symbol.  This procedure is called by the macro expander to get symbols to use for a top-level binding, as a record uid, or to identify a library compilation. The default procedure converts the symbol to a string and passes it to gensym.  \n\n" "For example, while expanding the following library, the current-generate-id procedure is called on the symbols a-lib, a-var, and a-var again.  \n\n" "" "(library (a-lib)\n  (export a-var)\n  (import (chezscheme))\n  (define a-var 3)\n  (define-syntax def\n    (syntax-rules ()\n      [(_) (define a-var 'other)]))\n  (def))\n\n" "The procedure held by the current-generate-id parameter is called on a-lib to generate a symbol that identifies this particular library compilation, as opposed to the compilation of a different library named (a-lib). It is called on a-var the first time to select a distinct symbol to hold the value of the a-var defininion, since a-var itself should not be defined directly at the top level. Finally, the current-generate-id procedure is called on a-var to select a name for the macro-introduced definiton of a-var in the expansion of (def)---which turns out to be completely inaccessible since no reference is introduced by the same expansion step. \n\n" "Setting the parameter to a particular, deterministic generator can cause symbols in the expansion of the library to be always the same. That determinism can be helpful if the expansion semantically matches an earlier expansion, so that uses of an earlier compilation remain compatible with the new one. Of course, reusing a symbol runs the risk of creating collisions that the macro and library system normally prevents via distinct symbols, and compiler optimizations may rely on the expectation of distinct symbols for distinct compilations. Configure current-generate-id at your own risk.  \n\n" "As a further example, suppose that the following two forms are compiled separately: \n\n" "" ";; Compile this x.ss to x.so\n(library (x)\n  (export x)\n  (import (chezscheme))\n  (define x '(x))) \n\n;; Compile this y.ss to y.so\n(top-level-program\n (import (chezscheme)\n         (y))\n (printf \"~s\\n\" x))\n\n" "If x.ss is modified and recompiled, loading the new x.so and the old y.so will correctly report an error that the compiled y.so requires a different compilation instance that the one already loaded. \n\n" "Suppose, however, that you're willing to live dangerously to avoid recompiling y.ss by generating the same symbols for every compilation of x.ss. While compiling x.ss, you could set current-generate-id to the result of make-x-generator:  \n\n" "" "(define (make-x-generator)\n  (let ([x-uid \"gf91a5b83ujz3mogjdaij7-x\"]\n        [counter-ht (make-eq-hashtable)])\n    (lambda (sym)\n      (let* ([n (eq-hashtable-ref counter-ht sym 0)]\n             [s ((if (gensym? sym) gensym->unique-string symbol->string) sym)]\n             [g (gensym (symbol->string sym) (format \"~a-~a-~a\" x-uid s n))])\n        (eq-hashtable-set! counter-ht sym (+ n 1))\n        g))))\n\n" "As long as the first and second compilations of x.ss use the result of make-x-generator, the first compilation of y.ss might work with the second compilation of x.ss, even if the change adds, removes, or reorders definitions of variables other than x.  \n\n" "Beware that if the variable x is originally defined as (define x 1), then the compilation of y.ss likely inlines the value 1 in place of its reference to the variable x, so changing x.ss will have no effect without recompiling y.ss. Similarly, if the change to x.ss deletes the definition of x or introduces a macro-generated definition of x before the direct definition, then the previously compiled y.ss is unlikely to refer to the correct definition of x in the new compilation of x.ss. Configure current-generate-id this way only in situations where the potential for unspecified failure is more tolerable than recompilation. \n\n") ("system:s107" "thread parameter: expand-omit-library-invocations \nlibraries: (chezscheme)  \n\n" "This boolean-valued parameter determines whether library uses are recorded in macro expansion. Normally, when an expression expands to a reference to a library-defined identifier, the expansion is prefixed with a check to ensure that the exporting library is defined and invoked. If expand-omit-library-invocations is set to true, the prefix is omitted. \n\n" "Setting expand-omit-library-invocations to true makes sense only when evaluating many small expressions in a context where all referenced libraries are known to be present and already invoked, and only when it's worth saving the small overhead of representing and running the check. \n\n") ("system:s108" "thread parameter: compile-omit-concatenate-support \nlibraries: (chezscheme)  \n\n" "This boolean-valued parameter determines whether code compiled to a file or port includes information needed to support concatenate-object-files. Omitting the information can provide minor space and load-time savings for small compiled objects. \n\n") ("system:s109" "global parameter: source-directories \nlibraries: (chezscheme)  \n\n" "The value of source-directories must be a list of strings, each of which names a directory path. source-directories determines the set of directories searched for source or object files when a file is loaded via load, load-library, load-program, include, visit, or revisit, when a syntax error occurs, or when a source file is opened in the interactive inspector. \n\n" "The default value is the list (\".\"), which means source files will be found only in or relative to the current directory, unless named with an absolute path or a path that starts with ./ (or .\\ under Windows) or ../ (or ..\\ under Windows).  \n\n" "This parameter is never altered by the system, with one exception. The expander temporarily adds (via parameterize) the directory in which a library file resides to the front of the source-directories list when it compiles (when compile-imported-libraries is true) or loads the library from source, which it does only if the library is not already defined. \n\n") ("system:s110" "procedure: (with-source-path who name procedure)\nlibraries: (chezscheme)  \n\n" "The procedure with-source-path searches through the current source-directories path, in order, for a file with the specified name and invokes procedure on the result. If no such file is found, an exception is raised with condition types &assertion and &who with who as who value. \n\n" "If name is an absolute pathname or one beginning with ./ (or .\\ under Windows) or ../ (or ..\\ under Windows), or if the list of source directories contains only \".\", the default, or \"\", which is equivalent to \".\", no searching is performed and name is returned. \n\n" "who must be a symbol, name must be a string, and procedure should accept one argument. \n\n" "The following examples assumes that the file \"pie\" exists in the directory \"../spam\" but not in \"../ham\" or the current directory. \n\n" "" "(define find-file\n  (lambda (fn)\n    (with-source-path 'find-file fn values))) \n\n(find-file \"pie\") => \"pie\" \n\n(source-directories '(\".\" \"../ham\"))\n(find-file \"pie\") => exception in find-file: pie not found\n\n(source-directories '(\".\" \"../spam\"))\n(find-file \"pie\") => \"../spam/pie\" \n\n(source-directories '(\".\" \"../ham\"))\n(find-file \"/pie\") => \"/pie\" \n\n(source-directories '(\".\" \"../ham\"))\n(find-file \"./pie\") => \"./pie\" \n\n(source-directories '(\".\" \"../spam\"))\n(find-file \"../pie\") => \"../ham/pie\"\n\n") ("system:s111" "thread parameter: optimize-level \nlibraries: (chezscheme)  \n\n" "This parameter can take on one of the four values 0, 1, 2, and 3. \n\n" "In theory, this parameter controls the amount of optimization performed by the compiler. In practice, it does so only indirectly, and the only difference is between optimize level 3, at which the compiler generates \"unsafe\" code, and optimize levels 0-2, at which the compiler generates \"safe\" code. Safe code performs full type and bounds checking so that, for example, an attempt to apply a non-procedure, an attempt to take the car of a non-pair, or an attempt to reference beyond the end of a vector each result in an exception being raised. With unsafe code, the same situations may result in invalid memory references, corruption of the Scheme heap (which may cause seemingly unrelated problems later), system crashes, or other undesirable behaviors. Unsafe code is typically faster, but optimize-level 3 should be used with caution and only on sections of well-tested code that must run as quickly as possible. \n\n" "While the compiler produces the same code for optimize levels 0-2, user-defined macro transformers can differentiate among the different levels if desired. \n\n" "One way to use optimize levels is on a per-file basis, using eval-when to force the use of a particular optimize level at compile time. For example, placing: \n\n" "" "(eval-when (compile) (optimize-level 3))\n\n" "at the front of a file will cause all of the forms in the file to be compiled at optimize level 3 when the file is compiled (using compile-file) but does not affect the optimize level used when the file is loaded from source. Since compile-file parameterizes optimize-level (see parameterize), the above expression does not permanently alter the optimize level in the system in which the compile-file is performed.  \n\n" "The optimize level can also be set via the --optimize-level command-line option (Section 2.9). This option is particularly useful for running RNRS top-level programs at optimize-level 3 via the --program command-line option, since eval-when is ineffective for RNRS top-level programs as described on page 385. \n\n") ("system:s116" "syntax: ($primitive variable)\nsyntax: #%variable\nsyntax: ($primitive 2 variable)\nsyntax: #2%variable\nsyntax: ($primitive 3 variable)\nsyntax: #3%variable\nreturns: the primitive value for variable \nlibraries: (chezscheme)  \n\n" "variable must name a primitive procedure. The $primitive syntactic form allows control over the optimize level at the granularity of individual primitive references, and it can be used to access the original value of a primitive, regardless of the lexical context or the current top-level binding for the variable originally bound to the primitive. \n\n" "The expression ($primitive variable) may be abbreviated as #%variable. The reader expands #% followed by an object into a $primitive expression, much as it expands 'objectinto a quote expression.  \n\n" "If a 2 or 3 appears in the form or between the # and % in the abbreviated form, the compiler treats an application of the primitive as if it were compiled at the corresponding optimize level (see the optimize-level parameter). If no number appears in the form, an application of the primitive is treated as an optimize-level 3 application if the current optimize level is 3; otherwise, it is treated as an optimize-level 2 application. \n\n" "" "(#%car '(a b c)) => a\n(let ([car cdr]) (car '(a b c))) => (b c)\n(let ([car cdr]) (#%car '(a b c))) => a\n(begin (set! car cdr) (#%car '(a b c))) => a\n\n") ("system:s117" "thread parameter: debug-level \nlibraries: (chezscheme)  \n\n" "This parameter can take on one of the four values 0, 1, 2, and 3. It is used to tell the compiler how important the preservation of debugging information is, with 0 being least important and 3 being most important. The default value is 1. As of Version 9.0, it is used solely to determine whether an error-causing call encountered in nontail position is treated as if it were in tail position (thus causing the caller's frame not to appear in a stack backtrace); this occurs at debug levels below 2. \n\n") ("system:s118" "thread parameter: generate-interrupt-trap \nlibraries: (chezscheme)  \n\n" "To support interrupts, including keyboard, timer, and collect request interrupts, the compiler inserts a short sequence of instructions at the entry to each nonleaf procedure (Section 12.2). This small overhead may be eliminated by setting generate-interrupt-trap to #f. The default value of this parameter is #t.  \n\n" "It is rarely a good idea to compile code without interrupt trap generation, since a tight loop in the generated code may completely prevent interrupts from being serviced, including the collect request interrupt that causes garbage collections to occur automatically. Disabling trap generation may be useful, however, for routines that act simply as \"wrappers\" for other routines for which code is presumably generated with interrupt trap generation enabled. It may also be useful for short performance-critical routines with embedded loops or recursions that are known to be short running and that make no other calls. \n\n") ("system:s119" "thread parameter: compile-interpret-simple \nlibraries: (chezscheme)  \n\n" "At all optimize levels, when the value of compile-interpret-simple is set to a true value (the default), compile interprets simple expressions. A simple expression is one that creates no procedures. This can save a significant amount of time over the course of many calls to compile or eval (with current-eval set to compile, its default value). When set to false, compile compiles all expressions.  \n\n") ("system:s121" "thread parameter: generate-inspector-information \nlibraries: (chezscheme)  \n\n" "When this parameter is set to a true value (the default), information about the source and contents of procedures and continuations is generated during compilation and retained in tables associated with each code segment. This information allows the inspector to provide more complete information, at the expense of using more memory and producing larger object files (via compile-file). Although compilation and loading may be slower when inspector information is generated, the speed of the compiled code is not affected. If this parameter is changed during the compilation of a file, the original value will be restored. For example, if: \n\n" "" "(eval-when (compile) (generate-inspector-information #f))\n\n" "is included in a file, generation of inspector information will be disabled only for the remainder of that particular file. \n\n") ("system:s122" "thread parameter: generate-procedure-source-information \nlibraries: (chezscheme)  \n\n" "When generate-inspector-information is set to #f and this parameter is set to #t, then a source location is preserved for a procedure, even though other inspector information is not preserved. Source information provides a small amount of debugging support at a much lower cost in memory and object-file size than full inspector information. If this parameter is changed during the compilation of a file, the original value will be restored. \n\n") ("system:s123" "thread parameter: enable-cross-library-optimization \nlibraries: (chezscheme)  \n\n" "This parameter controls whether information is included with the object code for a compiled library to enable propagation of constants and inlining of procedures defined in the library into dependent libraries. When set to #t (the default), this information is included; when set to #f, the information is not included. Setting the parameter to #f potentially reduces the sizes of the resulting object files and the exposure of near-source information via the object file. \n\n") ("system:s124" "thread parameter: enable-arithmetic-left-associative \nlibraries: (chezscheme)  \n\n" "This parameter controls whether the compiler is constrained to implement +, fx+, fl+, cfl+, *, fx*, fl*, and cfl* as left-associative operations when given more than two arguments. The default is #f.  \n\n") ("system:s125" "thread parameter: enable-error-source-expression \nlibraries: (chezscheme)  \n\n" "This parameter controls whether the compiler can convert erroneous expressions into a call to an error function that shows the expression as an S-expression. The default is #t.  \n\n") ("system:s126" "thread parameter: enable-unsafe-application \nlibraries: (chezscheme)  \n\n" "This parameter controls whether application forms are compiled as unsafe (i.e., no check whether the target is a procedure), even when the value of optimize-level is less than 3. The default is #f.  \n\n") ("system:s127" "thread parameter: enable-unsafe-variable-reference \nlibraries: (chezscheme)  \n\n" "This parameter controls whether references to letrec-bound variables are compiled unsafe (i.e., no check whether the variable has a value), even when the value of optimize-level is less than 3. The default is #f.  \n\n") ("system:s128" "thread parameter: generate-wpo-files \nlibraries: (chezscheme)  \n\n" "When this parameter is set to #t (the default is #f), compile-file, compile-library, compile-program, and compile-script produce whole-program optimization (wpo) files for use by compile-whole-program. The name of the wpo file is derived from the output-file name by replacing the object-file extension (normally .so) with .wpo, or adding the extension .wpo if the object filename has no extension or has the extension .wpo.  \n\n") ("system:s130" "thread parameter: compile-file-message \nlibraries: (chezscheme)  \n\n" "When this parameter is set to true, the default, compile-file, compile-library, compile-program, and compile-script print a message of the form:  \n\n" "" "compiling input-path with output to output-path\n\n" "When the parameter is set to #f, the message is not printed.  \n\n") ("system:s131" "thread parameter: run-cp0 \nthread parameter: cp0-effort-limit \nthread parameter: cp0-score-limit \nthread parameter: cp0-outer-unroll-limit \nlibraries: (chezscheme)  \n\n" "These parameters control the operation of cp0 plus cptypes, source optimization passes that run after macro expansion and prior to most other compiler passes. \n\n" "cp0 performs procedure inlining, in which the code of one procedure is inlined at points where it is called by other procedures, as well as copy propagation, constant folding, useless code elimination, and several related optimizations. The algorithm used by the optimizer is described in detail in the paper \"Fast and effective procedure inlining\" [31]. \n\n" "cptypes performs additional optimizations based on type information about primitives, such as the fact that + always returns a number; since it primarily removes unnecessary run-time checks, cptypes primarily benefits compilation in safe mode. The cptypes pass can be independently disabled through the enable-type-recovery parameter.  \n\n" "When cp0 is enabled, the programmer can count on the compiler to fold constants, eliminate unnecessary let bindings, and eliminate unnecessary and inaccessible code. This is particularly useful when writing macros, since the programmer can usually handle only the general case and let the compiler simplify the code when possible. For example, the programmer can define case as follows:  \n\n" "" "(define-syntax case\n  (syntax-rules ()\n    [(_ e [(k ...) a1 a2 ...] ... [else b1 b2 ...])\n     (let ([t e])\n       (cond\n         [(memv t '(k ...)) a1 a2 ...]\n         ...\n         [else b1 b2 ...]))]\n    [(_ e [(k ...) a1 a2 ...] ...)\n     (let ([t e])\n       (cond\n         [(memv t '(k ...)) a1 a2 ...]\n         ...))]))\n\n" "and count on the introduced let expression to be eliminated if e turns out to be an unassigned variable, and count on the entire case expression to be folded if e turns out to be a constant. \n\n" "It is possible to see what cp0 plus cptypes does with an expression via the procedure expand/optimize, which expands its argument and passes the result through cp0 and cptypes, as illustrated by the following transcript. \n\n" "" "> (print-gensym #f)\n> (expand/optimize\n    '(lambda (x)\n       (case x [(a) 1] [(b c) 2] [(d) 3] [else 4])))\n(lambda (x)\n  (if (#2%member x '(a))\n      1\n      (if (#2%member x '(b c)) 2 (if (#2%member x '(d)) 3 4))))\n> (expand/optimize\n    '(+ (let ([f (lambda (x)\n                (case x [(a) 1] [(b c) 2] [(d) 3] [else 4]))])\n          (f 'b))\n         15))\n17\n\n" "In the first example, the let expression produced by case is eliminated, and in the second, the entire expression is optimized down to the constant 17. Although not shown by expand/optimize, the member calls in the output code for the first example will be replaced by calls to the less expensive eq? by a later pass of the compiler. Additional examples are given in the description of expand/optimize.  \n\n" "The value of run-cp0 must be a procedure. Whenever the compiler is invoked on a Scheme form, the value p of this parameter is called to determine whether and how cp0 and cptypes are run. p receives two arguments: cp0, the entry point into the cp0 plus cptypes passes, and x, the form being compiled. The default value of run-cp0 simply invokes cp0 on x, then cp0 again on the result. The second run is useful in some cases because the first run may not eliminate bindings for certain variables that appear to be referenced but are not actually referenced after inlining. The marginal benefit of the second run is usually minimal, but so is the cost. \n\n" "Interesting variants include \n\n" "" "(run-cp0 (lambda (cp0 x) x))\n\n" "which bypasses (disables) cp0, and  \n\n" "" "(run-cp0 (lambda (cp0 x) (cp0 x)))\n\n" "which runs cp0 just once.  \n\n" "The value of cp0-effort-limit determines the maximum amount of effort spent on each inlining attempt. The time spent optimizing a program is a linear function of this limit and the number of calls in the program's source, so small values for this parameter enforce a tighter bound on compile time. When set to zero, inlining is disabled except when the name of a procedure is referenced only once. The value of cp0-score-limit determines the maximum amount of code produced per inlining attempt. Small values for this parameter limit the amount of overall code expansion. These parameters must be set to nonnegative fixnum values. \n\n" "The parameter cp0-outer-unroll-limit controls the amount of inlining performed by the optimizer for recursive procedures. With the parameter's value set to the default value of 0, recursive procedures are not inlined. A nonzero value for the outer unroll limit allows calls external to a recursive procedure to be inlined. For example, the expression \n\n" "" "(letrec ([fact (lambda (x) (if (zero? x) 1 (* x (fact (- x 1)))))])\n  (fact 10))\n\n" "would be left unchanged with the outer unroll limit set to zero, but would be converted into \n\n" "" "(letrec ([fact (lambda (x) (if (zero? x) 1 (* x (fact (- x 1)))))])\n  (* 10 (fact 9)))\n\n" "with the outer unroll limit set to one. \n\n" "Interesting effects can be had by varying several of these parameters at once. For example, setting the effort and outer unroll limits to large values and the score limit to 1 has the effect of inlining even complex recursive procedures whose values turn out to be constant at compile time without risking any code expansion. For example, \n\n" "" "(letrec ([fact (lambda (x) (if (zero? x) 1 (* x (fact (- x 1)))))])\n  (fact 10))\n\n" "would be reduced to 3628800, but  \n\n" "" "(letrec ([fact (lambda (x) (if (zero? x) 1 (* x (fact (- x 1)))))])\n  (fact z))\n\n" "would be left unchanged, although the optimizer may take a while to reach this decision if the effort and outer unroll limits are large. \n\n") ("system:s133" "thread parameter: enable-type-recovery \nlibraries: (chezscheme)  \n\n" "A parameter that controls whether the compiler attempts to optimize programs by performing a pass similar to type inference, which can avoid more checks and statically resolve more predicates than cp0 by itself, but at the cost of extra compile time. The default is #t.  \n\n") ("system:s134" "thread parameter: commonization-level \nlibraries: (chezscheme)  \n\n" "After running the main source optimization pass (cp0) for the last time, the compiler optionally runs a commonization pass. The pass commonizes the code for lambda expressions that have identical structure by abstracting differences at certain leaves of the program, namely constants, references to unassigned variables, and references to primitives. The parameter commonization-level controls whether commonization is run and, if so, how aggressive it is. Its value must be a nonnegative exact integer ranging from 0 through 9. When the parameter is set to 0, the default, commonization is not run. Otherwise, higher values result in more commonization. \n\n" "Commonization can undo some of the effects of cp0's inlining, can add run-time overhead, and can complicate debugging, particularly at higher commonization levels, which is why it is disabled by default. On the other hand, for macros or other meta programs that can generate large, mostly similar lambda expressions, enabling commonization can result in significant savings in object-code size and even reduce run-time overhead by making more efficient use of instruction caches. \n\n") ("system:s135" "thread parameter: undefined-variable-warnings \nlibraries: (chezscheme)  \n\n" "When undefined-variable-warnings is set to #t, the compiler issues a warning message whenever it cannot determine that a variable bound by letrec, letrec*, or an internal definition will not be referenced before it is defined. The default value is #f.  \n\n" "Regardless of the setting of this parameter, the compiler inserts code to check for the error, except at optimize level 3. The check is fairly inexpensive and does not typically inhibit inlining or other optimizations. In code that must be carefully tuned, however, it is sometimes useful to reorder bindings or make other changes to eliminate the checks. Enabling undefined-variable warnings can facilitate this process. \n\n" "The checks are also visible in the output of expand/optimize.  \n\n") ("system:s136" "thread parameter: expand-output \nthread parameter: expand/optimize-output \nlibraries: (chezscheme)  \n\n" "The parameters expand-output and expand/optimize-output can be used to request that the compiler and interpreter print expander and source-optimizer output produced during the compilation or interpretation process. Each parameter must be set to either #f (the default) or a textual output port. \n\n" "When expand-output is set to a textual output port, the output of the expander is printed to the port as a side effect of running compile, interpret, or any of the file compiling primitives, e.g., compile-file or compile-library. Similarly, when expand/optimize-output is set to a textual output port, the output of the source optimizer is printed. \n\n" "See also expand (page 379) and expand-optimize (page 380), which can be used to run the expander or the expander and source optimizer directly on an individual form. \n\n") ("system:s139" "syntax: (pariah expr1 expr2 ...)\nreturns: the values of the last subexpression \nlibraries: (chezscheme)  \n\n" "A pariah expression is just like a begin expression except that it informs the compiler that the code is expected to be executed infrequently. The compiler uses this information to optimize code layout, register assignments, and other aspects of the generated code. The pariah form can be used in performance-critical code to mark the branches of a conditional (e.g., if, cond, or case) that are less likely to be executed than the others. \n\n") ("system:s152" "thread parameter: compile-profile \nlibraries: (chezscheme)  \n\n" "When this parameter is set to the symbol source or the boolean value #t, the compiler instruments the code it generates with instructions that count the number of times each section of source code is executed. When set to the symbol block, the compiler similarly instruments the code it generates with instructions that count the number of times each block of code is executed. When set to #f (the default), the compiler does not insert these instructions. \n\n" "The general description of profiling above describes how the source and block profile information can be viewed or used for optimization. \n\n" "The code generated when compile-profile is non-false is larger and less efficient, so this parameter should be set only when profile information is needed. \n\n" "The profile counters for code compiled when profile instrumentation is enabled are retained indefinitely, even if the code with which they are associated is reclaimed by the garbage collector. This results in more complete and accurate profile data but can lead to space leaks in programs that dynamically generate or load code. Such programs can avoid the potential space leak by releasing the counters explicitly via the procedure profile-release-counters.  \n\n") ("system:s154" "thread parameter: generate-covin-files \nlibraries: (chezscheme)  \n\n" "When this parameter is set to #t, the compiler generates \"coverage-information\" (covin) files that can be used in connection with profile information to measure coverage of a source-code base by a set of tests. One covin file is created for each object file, with the object-file extension replaced by the extension .covin. Each covin file contains the printed representation of a source table (Section 11.12), compressed using the compression format and level specified by compress-format and compress-level. This information can be read via get-source-table! and used as a universe of source expressions to identify source expressions that are not evaluated during the running of a set of tests. \n\n") ("system:s156" "syntax: (profile source-object)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "A profile form has the effect of accounting to the source position identified by source-object the number of times the profile form is executed. Profile forms are generated implicitly by the expander for source expressions in annotated input, e.g., input read by the compiler or interpreter from a Scheme source file, so this form is typically useful only when unannotated source code is produced by the front end for some language that targets Scheme. \n\n") ("system:s157" "thread parameter: (generate-profile-forms) \nlibraries: (chezscheme)  \n\n" "When this parameter is set to #t, the default, the expander implicitly introduces profile forms for each annotated input expression, unless the annotation has not been marked for use in profiling  (Section 11.11). It can be set to #f to inhibit the expander's implicit generation of profile forms, typically when explicit profile forms are already present for all source positions that should be profiled. \n\n") ("system:s158" "procedure: (profile-clear) \nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Calling this procedure causes profile information to be cleared, i.e., the counts associated with each section of code are set to zero. \n\n") ("system:s159" "procedure: (profile-release-counters) \nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Calling this procedure causes profile information associated with reclaimed code objects to be dropped. \n\n") ("system:s160" "procedure: (profile-dump) \nreturns: a list of pairs of source-object and count \nlibraries: (chezscheme)  \n\n" "This procedure produces a dump of all profile information gathered since startup or the last call to profile-clear. It returns a list of pairs, where the car of each pair is a source object (Section 11.11) and the cdr is an exact nonnegative integer count. \n\n" "The list might contain more than one entry per source object due to macro expansion and procedure inlining, and it might contain more than one (non-eq) source object per file and source position due to separate compilation. In such cases, the counts are not overlapping and can be summed together to obtain the full count. \n\n" "The advantage of profile-dump over profile-dump-list is that profile-dump performs only minimal processing and preserves complete source objects, including their embedded source-file descriptors. It might be used, for example, to dump profile information to a fasl file on one machine for subsequent processing on another. \n\n" "with-profile-tracker can be used to obtain the same set of counts as a source table. \n\n") ("system:s162" "procedure: (with-profile-tracker thunk)\nprocedure: (with-profile-tracker preserve-existing? thunk)\nreturns: a source table and the values returned by thunk \nlibraries: (chezscheme)  \n\n" "thunk must be a procedure and should accept zero arguments. It may return any number of values. \n\n" "with-profile-tracker invokes thunk without arguments. If thunk returns n values x1, x2, ..., xn, with-profile-tracker returns n + 1 values st, x1, x2, ..., xn, where st is a source table associating source objects with profile counts. If preserve-existing? is absent or #f, each count represents the number of times the source expression represented by the associated source object is evaluated during the invocation of thunk. Otherwise, each count represents the number of times the source expression represented by the associated source object is evaluated before or during the invocation of thunk. \n\n" "Profile data otherwise cleared by a call to profile-clear or profile-release-counters during the invocation of thunk is included in the resulting table. That is, invoking these procedures while thunk is running has no effect on the resulting counts. On the other hand, profile data cleared before with-profile-tracker is invoked is not included in the resulting table. \n\n" "The idiom (with-profile-tracker #t values) can be used to obtain the current set of profile counts as a source table. \n\n") ("system:s165" "procedure: (source-table-dump source-table)\nreturns: a list of pairs of source objects and their associated values in source-table \nlibraries: (chezscheme)  \n\n" "This procedure can be used to convert a source-table produced by with-profile-tracker or some other mechanism into the form returned by profile-dump for use as an argument to profile-dump-html, profile-dump-list, or profile-dump-data.  \n\n") ("system:s171" "procedure: (profile-dump-html) \nprocedure: (profile-dump-html prefix)\nprocedure: (profile-dump-html prefix dump)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedure produces one or more HTML files, including profile.html, which contains color-coded summary information, and one file source.html for each source file source containing a color-coded copy of the source code, as described in the lead-in to this section. If prefix is specified, it must be a string and is prepended to the names of the generated HTML files. For example, if prefix is \"/tmp/\", the generated files are placed in the directory /tmp. The raw profile information is obtained from dump, which defaults to the value returned by profile-dump.  \n\n") ("system:s172" "thread parameter: (profile-palette) \nlibraries: (chezscheme)  \n\n" "This value of this parameter must be a nonempty vector of at least three pairs. The car of each pair is a background color and the cdr is a foreground (text) color. Each color must be a string, and each string should contain an HTML cascading style sheet (CSS) color specifier. The first pair is used for unprofiled code, and the second is used for unexecuted profiled code. The third is used for code that is executed least frequently, the fourth for code executed next-least frequently, and so on, with the last being used for code that is executed most frequently. Programmers may wish to supply their own palette to enhance visibility or to change the number of colors used. \n\n" "By default, a black background is used for unprofiled code, and a gray background is used for unexecuted profiled code. Background colors ranging from purple to red are used for executed profiled code, depending on frequency of execution, with red for the most frequently executed code. \n\n" "" "(profile-palette) =>\n  #((\"#111111\" . \"white\") (\"#607D8B\" . \"white\")\n    (\"#9C27B0\" . \"black\") (\"#673AB7\" . \"white\")\n    (\"#3F51B5\" . \"white\") (\"#2196F3\" . \"black\")\n    (\"#00BCD4\" . \"black\") (\"#4CAF50\" . \"black\")\n    (\"#CDDC39\" . \"black\") (\"#FFEB3B\" . \"black\")\n    (\"#FFC107\" . \"black\") (\"#FF9800\" . \"black\")\n    (\"#F44336\" . \"white\"))\n(profile-palette\n ; set palette with rainbow colors and black text\n ; for all but unprofiled or unexecuted code\n  '#((\"#000000\" . \"white\")    ; black\n     (\"#666666\" . \"white\")    ; gray\n     (\"#8B00FF\" . \"black\")    ; violet\n     (\"#6600FF\" . \"black\")    ; indigo\n     (\"#0000FF\" . \"black\")    ; blue\n     (\"#00FF00\" . \"black\")    ; green\n     (\"#FFFF00\" . \"black\")    ; yellow\n     (\"#FF7F00\" . \"black\")    ; orange\n     (\"#FF0000\" . \"black\")))  ; red\n\n") ("system:s173" "thread parameter: (profile-line-number-color) \nlibraries: (chezscheme)  \n\n" "This value of this parameter must be a string or #f. If it is a string, the string should contain an HTML cascading style sheet (CSS) color specifier. If the parameter is set to a string, profile-dump-html includes line numbers in its html rendering of each source file, using the specified color. If the parameter is set to #f, no line numbers are included.  \n\n") ("system:s174" "procedure: (profile-dump-list) \nprocedure: (profile-dump-list warn?)\nprocedure: (profile-dump-list warn? dump)\nreturns: a list of profile entries (see below) \nlibraries: (chezscheme)  \n\n" "This procedure produces a dump of all profile information present in dump, which defaults to the value returned by profile-dump. It returns a list of entries, each of which is itself a list containing the following elements identifying one block of code and how many times it has been executed. \n\n" " \n* execution count  \n* pathname  \n* beginning file position in characters (inclusive)  \n* ending file position in characters (exclusive)  \n* line number of beginning file position  \n* character position of beginning file position \n\n" "" "profile-dump-list may be unable to locate an unmodified copy of the file in the current source directories or at the absolute address, if an absolute address was used when the file was compiled or loaded. If this happens, the line number and character position of the beginning file position are #f and the pathname is the pathname originally used. A warning is also issued (an exception with condition type &warning is raised) unless the warn? argument is provided and is false. \n\n" "Otherwise, the pathname is the path to an unmodified copy of the source and the line and character positions are set to exact nonnegative integers. \n\n" "In either case, the execution count, beginning file position, and ending file position are all exact nonnegative integers, and the pathname is a string. \n\n" "For source positions in files that cannot be found, the list might contain more than one entry per position due to macro expansion, procedure inlining, and separate compilation. In such cases, the counts are not overlapping and can be summed together to obtain the full count. \n\n" "The information returned by profile-dump-list can be used to implement a custom viewer or used as input for offline analysis of profile information. \n\n" "The advantage of profile-dump-list over profile-dump is that it attempts to determine the line number and character position for each source point and, if successful, aggregates multiple counts for the source point into a single entry. \n\n") ("system:s175" "procedure: (profile-dump-data path)\nprocedure: (profile-dump-data path dump)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "path must be a string. \n\n" "This procedure writes, in a machine-readable form consumable by profile-load-data, profile counts represented by dump to the file named by path, replacing the file if it already exists. dump defaults to the value returned by profile-dump.  \n\n") ("system:s176" "procedure: (profile-load-data path ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Each path must be a string. \n\n" "This procedure reads profile information from the files named by path ... and stores it in the compiler's internal database of profile information. The contents of the files must have been created originally by profile-dump-data using the same version of Chez Scheme. \n\n" "The database stores a weight for each source expression or block rather than the actual count. When a single file is loaded into the database, the weight is the proportion of the actual count over the maximum count for all expressions or blocks represented in the file. When more than one file is loaded, either by one or multiple calls to profile-load-data, the weights are averaged.  \n\n") ("system:s177" "procedure: (profile-query-weight obj)\nreturns: obj's profile weight, or #f if obj is not in the database \nlibraries: (chezscheme)  \n\n" "The compiler's profile database maps source objects (Section 11.11) to weights. If obj is a source object, the profile-query-weight returns the weight associated with the source object or #f if the database does not have a weight recorded for the source object. obj can also be an annotation or syntax object, in which case profile-query-weight first extracts the source object, if any, using syntax->annotation and annotation-source, returning #f if no source-object is found.  \n\n" "A weight is a flonum in the range 0.0 to 1.0, inclusive, and denotes the ratio of the actual count to the maximum count as described in the description of profile-load-data.  \n\n" "profile-query-weight can be used by a macro to determine the relative frequency with which its subexpressions were executed in the run or runs that generated the information in the database. This information can be used to guide the generation of code that is likely to be more efficient. For example, the case macro uses profile information, when available, to order the clauses so that those whose keys matched more frequently are tested before those whose keys matched less frequently. \n\n") ("system:s178" "procedure: (profile-clear-database) \nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedure clears the compiler's profile database. It has no impact on the counts associated with individual sections of instrumented code; profile-clear can be used to reset those counts. \n\n") ("system:s179" "procedure: (new-cafe) \nprocedure: (new-cafe eval-proc)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "Chez Scheme interacts with the user through a waiter, or read-eval-print loop (REPL). The waiter operates within a context called a caf. When the system starts up, the user is placed in a caf and given a waiter. new-cafe opens a new Scheme caf, stacked on top of the old one. In addition to starting the waiter, new-cafe sets up the caf's reset and exit handlers (see reset-handler and exit-handler). Exiting a caf resumes the continuation of the call to new-cafe that created the caf. Exiting from the initial caf leaves Scheme altogether. A caf may be exited from either by an explicit call to exit or by receipt of end-of-file (\"control-D\" on Unix systems) in response to the waiter's prompt. In the former case, any values passed to exit are returned from new-cafe.  \n\n" "If the optional eval-proc argument is specified, eval-proc is used to evaluate forms entered from the console. Otherwise, the value of the parameter current-eval is used. eval-proc must accept one argument, the expression to evaluate. \n\n" "Interesting values for eval-proc include expand, which causes the macro expanded value of each expression entered to be printed and (lambda (x) x), which simply causes each expression entered to be printed. An arbitrary procedure of one argument may be used to facilitate testing of a program on a series of input values. \n\n" "" "> (new-cafe (lambda (x) x))\n>> 3\n3\n>> (a . (b . (c . ())))\n(a b c)\n\n" "" "(define sum\n  (lambda (ls)\n    (if (null? ls)\n        0\n        (+ (car ls) (sum (cdr ls))))))\n> (new-cafe sum)\n>> (1 2 3)\n6\n\n" "The default waiter reader (see waiter-prompt-and-read) displays the current waiter prompt (see waiter-prompt-string) to the current value of console-output-port and reads from the current value of console-input-port. The default waiter printer (see waiter-write) sends output to the current value of console-output-port. These parameters, along with current-eval, can be modified to change the behavior of the waiter. \n\n") ("system:s186" "thread parameter: waiter-prompt-string \nlibraries: (chezscheme)  \n\n" "The value of waiter-prompt-string must be a string. It is used by the default waiter prompter (see the parameter waiter-prompt-and-read) to print a prompt. Nested cafs are marked by repeating the prompt string once for each nesting level. \n\n" "" "> (waiter-prompt-string)\n\">\"\n> (waiter-prompt-string \"%\")\n% (waiter-prompt-string)\n\"%\"\n% (new-cafe)\n%% (waiter-prompt-string)\n\"%\"\n\n") ("system:s187" "thread parameter: waiter-prompt-and-read \nlibraries: (chezscheme)  \n\n" "waiter-prompt-and-read must be set to a procedure. It is used by the waiter to print a prompt and read an expression. The value of waiter-prompt-and-read is called by the waiter with a positive integer that indicates the caf nesting level. It should return an expression to be evaluated by the current evaluator (see new-cafe and current-eval).  \n\n") ("system:s188" "procedure: (default-prompt-and-read level)\nlibraries: (chezscheme)  \n\n" "level must be a positive integer indicating the cafe nesting level as described above. \n\n" "This procedure is the default value of the waiter-prompt-and-read parameter whenever the expression editor (Section 2.2, Chapter 14) is not enabled. It might be defined as follows. \n\n" "" "(define default-prompt-and-read\n  (lambda (n)\n    (unless (and (integer? n) (>= n 0))\n       (assertion-violationf 'default-prompt-and-read\n         \"~s is not a nonnegative integer\"\n         n))\n    (let ([prompt (waiter-prompt-string)])\n      (unless (string=? prompt \"\")\n        (do ([n n (- n 1)])\n            ((= n 0)\n             (write-char #\\space (console-output-port))\n             (flush-output-port (console-output-port)))\n            (display prompt (console-output-port))))\n      (let ([x (read (console-input-port))])\n         (when (and (eof-object? x) (not (string=? prompt \"\")))\n            (newline (console-output-port))\n            (flush-output-port (console-output-port)))\n         x))))\n\n") ("system:s189" "thread parameter: waiter-write \nlibraries: (chezscheme)  \n\n" "The value of waiter-write must be a procedure. The waiter uses the value of waiter-write to print the results of each expression read and evaluated by the waiter. The following example installs a procedure equivalent to the default waiter-write:  \n\n" "" "(waiter-write\n   (lambda (x)\n    (unless (eq? x (void))\n      (pretty-print x (console-output-port)))\n    (flush-output-port (console-output-port))))\n\n") ("system:s190" "procedure: (reset) \nreturns: does not return \nlibraries: (chezscheme)  \n\n" "reset invokes the current reset handler (see reset-handler) without arguments. \n\n") ("system:s191" "thread parameter: reset-handler \nlibraries: (chezscheme)  \n\n" "The value of this parameter must be a procedure and should accept zero arguments. The current reset handler is called by reset. The default reset handler resets to the current caf. \n\n") ("system:s192" "procedure: (exit obj ...)\nreturns: does not return \nlibraries: (chezscheme)  \n\n" "exit invokes the current exit handler (see exit-handler), passing along its arguments, if any.  \n\n") ("system:s193" "thread parameter: exit-handler \nlibraries: (chezscheme)  \n\n" "The value of this parameter must be a procedure and should accept any number of arguments. The current exit handler is called by exit.  \n\n" "The default exit handler exits from the current caf, returning its arguments as the values of the call to new-cafe that created the current caf. If the current caf is the original caf, or if exit is called from a script, exit exits from Scheme. In this case, the exit code for the Scheme process is 0 if no arguments were supplied or if the first argument is void, the value of the first argument cast to a C int if it is an exact integer of the host machine's bit width, and 1 otherwise. \n\n") ("system:s194" "procedure: (abort) \nprocedure: (abort obj)\nreturns: does not return \nlibraries: (chezscheme)  \n\n" "abort invokes the current abort handler (see abort-handler), passing along its argument, if any. \n\n") ("system:s195" "thread parameter: abort-handler \nlibraries: (chezscheme)  \n\n" "The value of this parameter must be a procedure and should accept either zero arguments or one argument. The current abort handler is called by abort.  \n\n" "The default abort handler exits the Scheme process. The exit code for the Scheme process is -1 if no arguments were supplied, 0 if the first argument is void, the value of the first argument if it is a 32-bit exact integer, and -1 otherwise. \n\n") ("system:s196" "global parameter: scheme-start \nlibraries: (chezscheme)  \n\n" "The value of scheme-start is a procedure that determines the system's action upon start-up. The procedure receives zero or more arguments, which are strings representing the file names (or command-line arguments not recognized by the Scheme executable) after given on the command line. The default value first loads the files named by the arguments, then starts up the initial caf: \n\n" "" "(lambda fns\n  (for-each load fns)\n  (new-cafe))\n\n" "scheme-start may be altered to start up an application or to perform customization prior to normal system start-up. \n\n" "To have any effect, this parameter must be set within a boot file. (See Chapter 2.) \n\n") ("system:s197" "global parameter: scheme-script \nlibraries: (chezscheme)  \n\n" "The value of scheme-script is a procedure that determines the system's action upon start-up, when the --script option is used. The procedure receives one or more arguments. The first is a string identifying the script filename and the remainder are strings representing the remaining file names (or command-line arguments not recognized by the Scheme executable) given on the command line. The default value of this parameter is a procedure that sets the command-line and command-line-arguments parameters, loads the script using load, and returns void, which is translated into a 0 exit status for the script process. \n\n" "" "(lambda (fn . fns)\n  (command-line (cons fn fns))\n  (command-line-arguments fns)\n  (load fn))\n\n" "scheme-script may be altered to start up an application or to perform customization prior to normal system start-up. \n\n" "To have any effect, this parameter must be set within a boot file. (See Chapter 2.) \n\n") ("system:s201" "global parameter: scheme-program \nlibraries: (chezscheme)  \n\n" "The value of scheme-program is a procedure that determines the system's action upon start-up when the --program (RNRS top-level program) option is used. The procedure receives one or more arguments. The first is a string identifying the program filename and the remainder are strings representing the remaining file names (or command-line arguments not recognized by the Scheme executable) given on the command line. The default value of this parameter is a procedure that sets the command-line and command-line-arguments parameters, loads the program using load-program, and returns void, which is translated into a 0 exit status for the script process. \n\n" "" "(lambda (fn . fns)\n  (command-line (cons fn fns))\n  (command-line-arguments fns)\n  (load-program fn))\n\n" "scheme-program may be altered to start up an application or to perform customization prior to normal system start-up. \n\n" "To have any effect, this parameter must be set within a boot file. (See Chapter 2.) \n\n") ("system:s205" "global parameter: command-line \nlibraries: (chezscheme)  \n\n" "This parameter is set by the default values of scheme-script and scheme-program to a list representing the command line, with the script name followed by the command-line arguments, when the --script or --program option is used on system startup.  \n\n") ("system:s207" "global parameter: command-line-arguments \nlibraries: (chezscheme)  \n\n" "This parameter is set by the default values of scheme-script and scheme-program to a list of the command-line arguments when the --script or --program option is used on system startup.  \n\n") ("system:s209" "global parameter: suppress-greeting \nlibraries: (chezscheme)  \n\n" "The value of suppress-greeting is a boolean value that determines whether Chez Scheme prints an identifying banner and copyright notice. The parameter defaults to #f but may be set to #t for use in batch processing applications where the banner would be disruptive. \n\n" "To have any effect, this parameter must be set within a boot file. (See Chapter 2.) \n\n") ("system:s211" "procedure: (transcript-on path)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "path must be a string. \n\n" "transcript-on opens the file named by path for output, and it copies to this file all input from the current input port and all output to the current output port. An exception is raised with condition-type i/o-filename if the file cannot be opened for output. \n\n") ("system:s212" "procedure: (transcript-off) \nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "transcript-off ends transcription and closes the transcript file.  \n\n") ("system:s213" "procedure: (transcript-cafe path)\nlibraries: (chezscheme)  \n\n" "path must be a string. transcript-cafe opens a transcript file as with transcript-on and enters a new caf; exiting from this caf (see exit) also ends transcription and closes the transcript file. Invoking transcript-off while in a transcript caf ends transcription and closes the transcript file but does not cause an exit from the caf. \n\n") ("system:s214" "procedure: (current-time) \nprocedure: (current-time time-type)\nreturns: a time object representing the current time \nlibraries: (chezscheme)  \n\n" "time-type must be one of the time-type symbols listed above and defaults to time-utc.  \n\n" "" "(current-time) => #<time-utc 1198815722.473668000>\n(current-time 'time-process) => #<time-process 0.120534264>\n\n") ("system:s215" "procedure: (make-time type nsec sec)\nreturns: a time object \nlibraries: (chezscheme)  \n\n" "type must be one of the time-type symbols listed above. nsec represents nanoseconds and must be an exact nonnegative integer less than 10^9. sec represents seconds and must be an exact integer. \n\n" "" "(make-time 'time-utc 787511000 1198783214)\n(make-time 'time-duration 10 5)\n(make-time 'time-duration 10 -5)\n\n") ("system:s216" "procedure: (time? obj)\nreturns: #t if obj is a time object, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(time? (current-time)) => #t\n(time? (make-time 'time-utc 0 0)) => #t\n(time? \"1400 hours\") => #f\n\n") ("system:s217" "procedure: (time-type time)\nreturns: the time type of time \nprocedure: (time-nanosecond time)\nreturns: the nanosecond of time \nprocedure: (time-second time)\nreturns: the second of time \nlibraries: (chezscheme)  \n\n" "time must be a time object. \n\n" "" "(time-type (current-time)) => time-utc\n(time-type (current-time 'time-process)) => time-process\n(time-type (make-time 'time-duration 0 50)) => time-duration\n(time-second (current-time)) => 1198816497\n(time-nanosecond (current-time)) => 2399000\n(time-second (make-time 'time-duration 10 -5)) => -5\n(time-nanosecond (make-time 'time-duration 10 -5)) => 10\n\n") ("system:s218" "procedure: (set-time-type! time type)\nreturns: unspecified \nprocedure: (set-time-nanosecond! time nsec)\nreturns: unspecified \nprocedure: (set-time-second! time sec)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "time must be a time object. type must be one of the time-type symbols listed above. nsec represents nanoseconds and must be an exact nonnegative integer less than 10^9. sec represents seconds and must be an exact integer. \n\n" "Each of these procedures modifies the time object, changing one aspect while leaving the others unaffected. For example, set-time-nanosecond! changes the nanosecond of time without changing the second or type. In particular, no conversion of values is performed when the type of a time object is changed. \n\n") ("system:s219" "procedure: (time=? time1 time2)\nprocedure: (time<? time1 time2)\nprocedure: (time<=? time1 time2)\nprocedure: (time>=? time1 time2)\nprocedure: (time>? time1 time2)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (chezscheme)  \n\n" "time1 and time2 must be time objects and must have the same type. \n\n" "" "(let ([t (current-time)])\n  (time=? t t)) => #t\n(let ([t (current-time)])\n  (let loop ()\n    (when (time=? (current-time) t))\n      (loop))\n  (time>? (current-time) t)) => #t\n\n") ("system:s220" "procedure: (copy-time time)\nreturns: a copy of time \nlibraries: (chezscheme)  \n\n" "" "(define t1 (current-time))\n(define t2 (copy-time t1))\n(eq? t2 t1) => #f\n(eqv? (time-second t2) (time-second t1)) => #t\n(eqv? (time-nanosecond t2) (time-nanosecond t1)) => #t\n\n") ("system:s221" "procedure: (time-difference time1 time2)\nreturns: the result of subtracting time2 from time1\nprocedure: (time-difference! time1 time2)\nreturns: the result of subtracting time2 from time1\nprocedure: (add-duration time timed)\nreturns: the result of adding timed to time \nprocedure: (add-duration! time timed)\nreturns: the result of adding timed to time \nprocedure: (subtract-duration time timed)\nreturns: the result of subtracting timed from time \nprocedure: (subtract-duration! time timed)\nreturns: the result of subtracting timed from time \nlibraries: (chezscheme)  \n\n" "For time-difference, time1 and time2 must have the same time type, and the result is a time object with time type time-duration. For add-duration, add-duration!, subtract-duration, and subtract-duration!, timed must have time type time-duration, and the result is a time object with the same time type as time. time-difference!, add-duration!, and subtract-duration! are potentially destructive, i.e., each might modify and return its first argument, or it might allocate a new time object. \n\n" "" "(let ([delay (make-time 'time-duration 0 1)])\n  (let ([t1 (current-time 'time-monotonic)])\n    (sleep delay)\n    (let ([t2 (current-time 'time-monotonic)])\n      (let ([t3 (time-difference t2 t1)])\n        (and\n          (eq? (time-type t3) 'time-duration)\n          (time>=? t3 delay)\n          (time=? (add-duration t1 t3) t2)\n          (time=? (subtract-duration t2 t3) t1)))))) => #t\n\n") ("system:s222" "procedure: (current-date) \nprocedure: (current-date offset)\nreturns: a date object representing the current date \nlibraries: (chezscheme)  \n\n" "offset represents the time-zone offset in seconds east of UTC, as described above. It must be an exact integer in the range -86400 to +86400, inclusive and defaults to the local time-zone offset. UTC may be obtained by passing an offset of zero. \n\n" "If offset is not provided, then the current time zone's offset is used, and date-dst? and date-zone-name report information about the time zone. If offset is provided, then date-dst? and date-zone-name on the resulting date object produce #f.  \n\n" "The following examples assume the local time zone is EST. \n\n" "" "(current-date) => #<date Thu Dec 27 23:23:20 2007>\n(current-date 0) => #<date Fri Dec 28 04:23:20 2007> \n\n(date-zone-name (current-date)) => \"EST\" or other system-provided string\n(date-zone-name (current-date 0)) => #f\n\n") ("system:s223" "procedure: (make-date nsec sec min hour day mon year)\nprocedure: (make-date nsec sec min hour day mon year offset)\nreturns: a date object \nlibraries: (chezscheme)  \n\n" "nsec represents nanoseconds and must be an exact nonnegative integer less than 10^9. sec represents seconds and must be an exact nonnegative integer less than 62. min represents minutes and must be an exact nonnegative integer less than 60. hour must be an exact nonnegative integer less than 24. day must be an exact integer, 1 <= day <= 31. (The actual upper limit may be less depending on the month and year.) mon represents the month must be an exact integer, 1 <= mon <= 12. year must be an exact integer. It should be at least 1970. offset represents the time-zone offset in seconds east of UTC, as described above. It must be an exact integer in the range -86400 to +86400, inclusive. UTC may be specified by passing an offset of zero. \n\n" "If offset is not provided, then the current time zone's offset is used, and date-dst? and date-zone-name report information about the time zone. If offset is provided, then date-dst? and date-zone-name on the resulting date object produce #f.  \n\n" "" "(make-date 0 0 0 0 1 1 1970 0) => #<date Thu Jan  1 00:00:00 1970>\n(make-date 0 30 7 9 23 9 2007 -14400) => #<date Sun Sep 23 09:07:30 2007> \n\n(date-zone-name (make-date 0 30 7 9 23 9 2007 -14400)) => #f\n(string? (date-zone-name (make-date 0 30 7 9 23 9 2007))) => #t\n\n") ("system:s224" "procedure: (date? obj)\nreturns: #t if obj is a date object, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(date? (current-date))\n(date? (make-date 0 30 7 9 23 9 2007 -14400))\n(date? \"Sun Sep 23 09:07:30 2007\") => #f\n\n") ("system:s225" "procedure: (date-nanosecond date)\nreturns: the nanosecond of date \nprocedure: (date-second date)\nreturns: the second of date \nprocedure: (date-minute date)\nreturns: the minute of date \nprocedure: (date-hour date)\nreturns: the hour of date \nprocedure: (date-day date)\nreturns: the day of date \nprocedure: (date-month date)\nreturns: the month of date \nprocedure: (date-year date)\nreturns: the year of date \nprocedure: (date-zone-offset date)\nreturns: the time-zone offset of date \nlibraries: (chezscheme)  \n\n" "date must be a date object. \n\n" "" "(define d (make-date 0 30 7 9 23 9 2007 -14400))\n(date-nanosecond d) => 0\n(date-second d) => 30\n(date-minute d) => 7\n(date-hour d) => 9\n(date-day d) => 23\n(date-month d) => 9\n(date-year d) => 2007\n(date-zone-offset d) => -14400\n\n") ("system:s226" "procedure: (date-week-day date)\nreturns: the week-day of date \nprocedure: (date-year-day date)\nreturns: the year-day of date \nlibraries: (chezscheme)  \n\n" "These procedures allow the day-of-week or day-of-year to be determined for the date represented by date. A week-day is an exact nonnegative integer less than 7, where 0 represents Sunday, 1 represents Monday, and so on. A year-day is an exact nonnegative integer less than 367, where 0 represents the first day of the year (January 1), 1 the second day, 2 the third, and so on. \n\n" "" "(define d1 (make-date 0 0 0 0 1 1 1970 -18000))\nd1 => #<date Thu Jan  1 00:00:00 1970>\n(date-week-day d1) => 4\n(date-year-day d1) => 0 \n\n(define d2 (make-date 0 30 7 9 23 9 2007 -14400))\nd2 => #<date Sun Sep 23 09:07:30 2007>\n(date-week-day d2) => 0\n(date-year-day d2) => 265\n\n") ("system:s227" "procedure: (date-dst? date)\nreturns: whether date is in Daylight Saving Time \nprocedure: (date-zone-name date)\nreturns: #f or a string naming the time zone of date \nlibraries: (chezscheme)  \n\n" "These procedures report time-zone information for the date represented by date for a date object that is constructed without an explicit time-zone offset. When a date object is created instead with explicit time-zone offset, these procedures produce #f.  \n\n" "Daylight Saving Time status for the current time zone and a name string for the time zone are computed using platform-specific routines. In particular, the format of the zone name is platform-specific. \n\n" "" "(define d (make-date 0 30 7 9 23 9 2007))\n(date-zone-offset d) => -14400 assuming Eastern U.S. time zone\n(date-dst? d) => #t\n(date-zone-name d) => \"EDT\" or some system-provided string\n\n") ("system:s228" "procedure: (time-utc->date time)\nprocedure: (time-utc->date time offset)\nreturns: a date object corresponding to time \nprocedure: (date->time-utc date)\nreturns: a time object corresponding to date \nlibraries: (chezscheme)  \n\n" "These procedures are used to convert between time and date objects. The time argument to time-utc->date must have time-type utc, and date->time-utc always returns a time object with time-type utc.  \n\n" "For time-utc->date, offset represents the time-zone offset in seconds east of UTC, as described at the beginning of this section. It must be an exact integer in the range -86400 to +86400, inclusive and defaults to the local time-zone offset. UTC may be obtained by passing an offset of zero. \n\n" "If offset is not provided to time-utc->date, then the current time zone's offset is used, and date-dst? and date-zone-name report information about the time zone. If offset is provided, then date-dst? and date-zone-name on the resulting date object produce #f.  \n\n" "" "(define d (make-date 0 30 7 9 23 9 2007 -14400))\n(date->time-utc d) => #<time-utc 1190552850.000000000>\n(define t (make-time 'time-utc 0 1190552850))\n(time-utc->date t) => #<date Sun Sep 23 09:07:30 2007>\n(time-utc->date t 0) => #<date Sun Sep 23 13:07:30 2007>\n\n") ("system:s229" "procedure: (date-and-time) \nprocedure: (date-and-time date)\nreturns: a string giving the current date and time \nlibraries: (chezscheme)  \n\n" "The string is always in the format illustrated by the examples below and always has length 24. \n\n" "" "(date-and-time) => \"Fri Jul 13 13:13:13 2001\"\n(define d (make-date 0 0 0 0 1 1 2007 0))\n(date-and-time d) => \"Mon Jan 01 00:00:00 2007\"\n\n") ("system:s230" "procedure: (sleep time)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "time must be a time object with type time-duration. sleep causes the invoking thread to suspend operation for approximately the amount of time indicated by the time object, unless the process receives a signal that interrupts the sleep operation. The actual time slept depends on the granularity of the system clock and how busy the system is running other threads and processes. \n\n") ("system:s231" "syntax: (time expr)\nreturns: the values of expr \nlibraries: (chezscheme)  \n\n" "time evaluates expr and, as a side-effect, prints (to the console-output port) the amount of cpu time, the amount of real time, the number of bytes allocated, and the amount of collection overhead associated with evaluating expr. \n\n" "" "> (time (collect))\n(time (collect))\n    1 collection\n    1 ms elapsed cpu time, including 1 ms collecting\n    1 ms elapsed real time, including 1 ms collecting\n    160 bytes allocated, including 8184 bytes reclaimed\n\n") ("system:s232" "procedure: (display-statistics) \nprocedure: (display-statistics textual-output-port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedure displays a running total of the amount of cpu time, real time, bytes allocated, and collection overhead. If textual-output-port is not supplied, it defaults to the current output port. \n\n") ("system:s233" "procedure: (cpu-time) \nreturns: the amount of cpu time consumed since system start-up \nlibraries: (chezscheme)  \n\n" "The amount is in milliseconds. The amount includes \"system\" as well as \"user\" time, i.e., time spent in the kernel on behalf of the process as well as time spent in the process itself. \n\n" "See also current-time, which returns more precise information.  \n\n") ("system:s234" "procedure: (real-time) \nreturns: the amount of real time that has elapsed since system start-up \nlibraries: (chezscheme)  \n\n" "The amount is in milliseconds. \n\n" "See also current-time, which returns more precise information.  \n\n") ("system:s235" "procedure: (bytes-allocated) \nprocedure: (bytes-allocated g)\nreturns: the number of bytes currently allocated \nlibraries: (chezscheme)  \n\n" "If g is supplied, bytes-allocated returns the number of bytes currently allocated for Scheme objects in the specified generation plus externally allocated bytes as represented by phantom bytevectors in the generation. g must be a nonnegative exact integer no greater than the maximum nonstatic generation, i.e., the value returned by collect-maximum-generation, or the symbol static. If g is not supplied, bytes-allocated returns the total number of bytes allocated in all generations. \n\n") ("system:s236" "procedure: (initial-bytes-allocated) \nreturns: the total number of bytes allocated after loading boot files \nlibraries: (chezscheme)  \n\n") ("system:s237" "procedure: (bytes-deallocated) \nreturns: the total number of bytes deallocated by the garbage collector \nlibraries: (chezscheme)  \n\n" "The total number of bytes allocated by the current process, whether still in use or not, can be obtained by summing (bytes-deallocated) and (bytes-allocated) and possibly subtracting (initial-bytes-allocated).  \n\n") ("system:s238" "procedure: (bytes-finalized) \nreturns: the number of bytes queued in guardians \nlibraries: (chezscheme)  \n\n" "The number of bytes associated with objects that were registered in guardians as otherwise inaccessible (including the bytes for objects reachable only through registered objects) during the most recent garbage collection. \n\n") ("system:s239" "procedure: (current-memory-bytes) \nreturns: the total number of bytes currently allocated, including overhead \nlibraries: (chezscheme)  \n\n" "current-memory-bytes returns the total size of the heap in bytes, including not only the bytes occupied for Scheme objects but also various forms of overhead, including fragmentation and reserved but not currently occupied memory, and is thus an accurate measure of the amount of heap memory currently reserved from the operating system for the current process. The result is only for Scheme's storage management, however, so it does not include sizes for externally allocated objects (even those that are represented by phantom bytevectors). \n\n") ("system:s240" "procedure: (maximum-memory-bytes) \nreturns: the maximum number of bytes ever allocated, including overhead \nlibraries: (chezscheme)  \n\n" "maximum-memory-bytes returns the maximum size of the heap in bytes, i.e., the maximum value that current-memory-bytes returned or could have returned, since the last call to reset-maximum-memory-bytes! or, if there has been no such call, since the process started. \n\n") ("system:s241" "procedure: (reset-maximum-memory-bytes!) \nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "reset-maximum-memory-bytes! resets the maximum recorded size of the heap to the current size of the heap. \n\n") ("system:s242" "procedure: (collections) \nreturns: the number garbage collections so far \nlibraries: (chezscheme)  \n\n") ("system:s243" "procedure: (statistics) \nreturns: a sstats record containing current statistics \nlibraries: (chezscheme)  \n\n" "statistics packages together various timing and allocation statistics into a single sstats record. A sstats record has the following fields:  \n\n" "\ncpu,\n     the cpu time consumed, \nreal,\n     the elapsed real time, \nbytes,\n     the number of bytes allocated, \ngc-count,\n     the number of collections, \ngc-cpu,\n     the cpu time consumed during collections, \ngc-real,\n     the elapsed real time during collections, and \ngc-bytes,\n     the number of bytes reclaimed by the collector. \n\n" "All values are computed since system start-up. The time values are time objects (Section 12.10), and the bytes and count values are exact integers. \n\n" "statistics might be defined as follows:  \n\n" "" "(define statistics\n  (lambda ()\n    (make-sstats\n      (current-time 'time-thread)\n      (current-time 'time-monotonic)\n      (- (+ (bytes-allocated) (bytes-deallocated))\n         (initial-bytes-allocated))\n      (collections)\n      (current-time 'time-collector-cpu)\n      (current-time 'time-collector-real)\n      (bytes-deallocated))))\n\n") ("system:s244" "procedure: (make-sstats cpu real bytes gc-count gc-cpu gc-real gc-bytes)\nreturns: a sstats record \nlibraries: (chezscheme)  \n\n" "The time arguments (cpu, real, gc-cpu, and gc-real) must be time objects. The other arguments must be exact integers. \n\n") ("system:s245" "procedure: (sstats? obj)\nreturns: #t if obj is a sstats record, otherwise #f \nlibraries: (chezscheme)  \n\n") ("system:s246" "procedure: (sstats-cpu s)\nprocedure: (sstats-real s)\nprocedure: (sstats-bytes s)\nprocedure: (sstats-gc-count s)\nprocedure: (sstats-gc-cpu s)\nprocedure: (sstats-gc-real s)\nprocedure: (sstats-gc-bytes s)\nreturns: the value of the corresponding field of s \nlibraries: (chezscheme)  \n\n" "s must be a sstats record. \n\n") ("system:s247" "procedure: (set-sstats-cpu! s new-value)\nprocedure: (set-sstats-real! s new-value)\nprocedure: (set-sstats-bytes! s new-value)\nprocedure: (set-sstats-gc-count! s new-value)\nprocedure: (set-sstats-gc-cpu! s new-value)\nprocedure: (set-sstats-gc-real! s new-value)\nprocedure: (set-sstats-gc-bytes! s new-value)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "s must be a sstats record, the new-value arguments for the time fields (cpu, real, gc-cpu, and gc-real) must be time objects, and the other new-value arguments must be exact integers. Each procedure sets the value of the corresponding field of s to new-value. \n\n") ("system:s248" "procedure: (sstats-difference s1 s2)\nreturns: a sstats record representing the difference between s1 and s2\nlibraries: (chezscheme)  \n\n" "s1 and s2 must be sstats records. sstats-difference subtracts each field of s2 from the corresponding field of s1 to produce the resulting sstats record. \n\n") ("system:s249" "procedure: (sstats-print s)\nprocedure: (sstats-print s textual-output-port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "s must be a sstats record. If textual-output-port is not supplied, it defaults to the current output port. sstats-print displays the fields of s in a manner similar to display-statistics and time.  \n\n") ("system:s250" "global parameter: enable-object-counts \nlibraries: (chezscheme)  \n\n" "The value of enable-object-counts is a boolean value that determines whether the collector records object counts as it runs and hence whether the object counts returned by the procedure object-counts are accurate. The parameter is set to #f by default, since enabling object counts adds overhead to collection. \n\n" "Counts for the static generation are always correct. Counts for a nonstatic generation n are correct immediately after a collection of generation m >= n (regardless of whether the target generation is m or m + 1) if enable-object-counts was set to #t during the collection.  \n\n" "One strategy for collecting object counts with minimal overhead is to enable object counts only while collecting the maximum nonstatic generation and to obtain the object counts immediately after that collection. \n\n") ("system:s251" "procedure: (object-counts) \nreturns: see below \nlibraries: (chezscheme)  \n\n" "The procedure object-counts returns a nested association list representing object counts and bytes allocated for each heap-allocated primitive type and record type with at least one live instance in one or more generations. (Heap-allocated primitive types include, e.g., pairs and vectors, but not, e.g., fixnums or characters.) Object counts are gathered by the collector only when enable-object-counts is #t. The description of enable-object-counts details the circumstances under which the counts are accurate. \n\n" "The association list returned by object-counts has the following structure: \n\n" "" "((type (generation count . bytes) ...) ...)\n\n" "type is either the name of a primitive type, represented as a symbol, e.g., pair, or a record-type descriptor (rtd). generation is a nonnegative fixnum between 0 and the value of (collect-maximum-generation), inclusive, or the symbol static representing the static generation. count and bytes are nonnegative fixnums. \n\n" "" "(collect-request-handler void)\n(enable-object-counts #t)\n(define-record-type frob (fields x))\n(define x (make-frob (make-frob #f)))\n(collect 3 3)\n(cdr (assoc 3\n       (cdr (assoc (record-type-descriptor frob)\n              (object-counts)))))                => (2 . 16)\n\n") ("system:s252" "global parameter: enable-object-backreferences \nlibraries: (chezscheme)  \n\n" "The value of enable-object-backreferences is a boolean value that determines whether the collector records information about which other object caused an object to be retained and hence whether the backreferences reported by the procedure object-backreferences are accurate. The parameter is set to #f by default, since backreference recording adds overhead to collection. \n\n" "Beware that backreference recording can have small performance effects even after it is disabled---at least until the next collection over the same generations---since backreference records constrain the way that the collector stores some objects. \n\n") ("system:s253" "procedure: (object-backreferences) \nreturns: a list of list of pairs \nlibraries: (chezscheme)  \n\n" "The procedure object-backreferences returns a list of backreference lists. Each backreference list is a list of pairs, where the car of the pair is a referenced object, and the cdr of the pair is either #f or a value that caused the car's value or be retained during collection. The cdr of a backreference pair is #f if the object in the car is retained by a root reference within the system's implementation or static generation. By locating the cdr of one pair as the car of another, chains of objects as discovered by the collector can be traced back to roots. \n\n" "The list returned by object-backreferences contains one backreference list for each nonstatic generation (in order, starting with generation 0). An object is recorded in a backreference list for the destination generation to which it is moved by collection. The collector records backreference information only when enable-object-backreferences is set to a true value, and only for objects that start in generations that are collected. \n\n" "For example, assuming that backreferences have not been previously enabled, the result of \n\n" "(collect-request-handler void)\n(enable-object-backreferences #t)\n(collect 0)\n(enable-object-backreferences #f)\n(object-backreferences)\n\n" "will have a non-empty backreference list only for the second list in the result (i.e., the list for generation 1).  \n\n" "Although object-backreferences reports generation-specific information to reflect its cooperation with generational collection, backreference information is most useful after a collection of all generations up to the maximum nonstatic generation. In that case, backreference information can be used to discover why a particular value or kind of value remains allocated or remains in a weak pair after garbage collection. \n\n" "" "(collect-request-handler void)\n(enable-object-backreferences #t)\n(define b (box \"hello\"))\n(collect 0)\n(assq (unbox b) (cadr (object-backreferences))) => (\"hello\" . #&\"hello\")\n\n") ("system:s254" "thread parameter: generate-allocation-counts \nlibraries: (chezscheme)  \n\n" "When this parameter has a true value, the compiler inserts a short sequence of instructions at each allocation point in generated code to track the amount of allocation that occurs. This parameter is initially false. \n\n") ("system:s255" "thread parameter: generate-instruction-counts \nlibraries: (chezscheme)  \n\n" "When this parameter has a true value, the compiler inserts a short sequence of instructions in each block of generated code to track the number of instructions executed by that block. This parameter is initially false. \n\n") ("system:s256" "procedure: (make-cost-center) \nreturns: a new cost center \nlibraries: (chezscheme)  \n\n" "The recorded costs of the new cost center are initialized to zero. \n\n") ("system:s257" "procedure: (cost-center? obj)\nreturns: #t if obj is a cost center, otherwise #f \nlibraries: (chezscheme)  \n\n") ("system:s258" "procedure: (with-cost-center cost-center thunk)\nprocedure: (with-cost-center timed? cost-center thunk)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "thunk must be a procedure that accepts zero arguments. with-cost-center invokes thunk without arguments and returns its values. It also tracks, dynamically, the bytes allocated, instructions executed, and cpu time elapsed while evaluating the invocation of thunk and adds the tracked costs to the cost center's running record of these costs. \n\n" "As described above, allocation counts are tracked only for code compiled with the parameter generate-allocation-counts set to true, and instruction counts are tracked only for code compiled with generate-instruction-counts set to true. Cpu time is tracked only if timed? is provided and not false and includes cpu time spent in instrumented, uninstrumented, and non-Scheme code. \n\n") ("system:s259" "procedure: (cost-center-instruction-count cost-center)\nreturns: the number of instructions tracked by cost-center \nlibraries: (chezscheme)  \n\n") ("system:s260" "procedure: (cost-center-allocation-count cost-center)\nreturns: the number of allocated bytes tracked by cost-center \nlibraries: (chezscheme)  \n\n") ("system:s261" "procedure: (cost-center-time cost-center)\nreturns: the cpu time tracked by cost-center \nlibraries: (chezscheme)  \n\n" "The cpu time is returned as a time object with time-type time-duration.  \n\n") ("system:s262" "procedure: (reset-cost-center! cost-center)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedure resets the costs recorded by cost-center to zero. \n\n") ("system:s263" "procedure: (make-parameter object)\nprocedure: (make-parameter object procedure)\nreturns: a parameter (procedure) \nlibraries: (chezscheme)  \n\n" "make-parameter accepts one or two arguments. The first argument is the initial value of the internal variable, and the second, if present, is a filter applied to the initial value and all subsequent values. The filter should accept one argument. If the value is not appropriate, the filter should raise an exception or convert the value into a more appropriate form. \n\n" "For example, the default value of print-length is defined as follows: \n\n" "" "(define print-length\n  (make-parameter\n    #f\n    (lambda (x)\n      (unless (or (not x) (and (fixnum? x) (fx>= x 0)))\n        (assertion-violationf 'print-length\n          \"~s is not a positive fixnum or #f\"\n          x))\n      x)))\n\n" "" "(print-length)  => #f\n(print-length 3)\n(print-length)  => 3\n(format \"~s\" '(1 2 3 4 5 6))  => \"(1 2 3 ...)\"\n(print-length #f)\n(format \"~s\" '(1 2 3 4 5 6))  => \"(1 2 3 4 5 6)\"\n\n" "The definition of make-parameter is straightforward using case-lambda:  \n\n" "" "(define make-parameter\n  (case-lambda\n    [(init guard)\n     (let ([v (guard init)])\n       (case-lambda\n         [() v]\n         [(u) (set! v (guard u))]))]\n    [(init)\n     (make-parameter init (lambda (x) x))]))\n\n" "In threaded versions of Chez Scheme, make-parameter creates global parameters. The procedure make-thread-parameter, described in Section 15.8, may be used to make thread parameters. \n\n") ("system:s265" "syntax: (parameterize ((param expr) ...) body1 body2 ...)\nreturns: the values of the body body1 body2 ...\nlibraries: (chezscheme)  \n\n" "Using the syntactic form parameterize, the values of parameters can be changed in a manner analogous to fluid-let for ordinary variables. Each param is set to the value of the corresponding expr while the body is evaluated. When control leaves the body by normal return or by the invocation of a continuation created outside of the body, the parameters are restored to their original values. If control returns to the body via a continuation created during the execution of the body, the parameters are again set to their temporary values. \n\n" "" "(define test\n  (make-parameter 0))\n(test)  => 0\n(test 1)\n(test)  => 1\n(parameterize ([test 2])\n  (test))  => 2\n(test)  => 1\n(parameterize ([test 2])\n  (test 3)\n  (test))  => 3\n(test)  => 1\n(define k (lambda (x) x))\n(begin (set! k (call/cc k))\n       'k)  => k\n(parameterize ([test 2])\n  (test (call/cc k))\n  (test))  => k\n(test)  => 1\n(k 3)  => 3\n(test)  => 1\n\n" "The definition of parameterize is similar to the definition of fluid-let (page 121): \n\n" "" "(define-syntax parameterize\n  (lambda (x)\n    (syntax-case x ()\n      [(_ () b1 b2 ...) #'(begin b1 b2 ...)]\n      [(_ ((x e) ...) b1 b2 ...)\n       (with-syntax ([(p ...) (generate-temporaries #'(x ...))]\n                     [(y ...) (generate-temporaries #'(x ...))])\n         #'(let ([p x] ... [y e] ...)\n             (let ([swap (lambda ()\n                           (let ([t (p)]) (p y) (set! y t))\n                           ...)])\n               (dynamic-wind swap (lambda () b1 b2 ...) swap))))])))\n\n") ("system:s266" "procedure: (virtual-register-count) \nreturns: the number of virtual registers \nlibraries: (chezscheme)  \n\n" "As of Version 9.0, the number of virtual registers is set at 16. It cannot be changed except by recompiling Chez Scheme from source. \n\n") ("system:s267" "procedure: (set-virtual-register! k x)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "set-virtual-register! stores x in virtual register k. k must be a nonnegative fixnum less than the value of (virtual-register-count).  \n\n") ("system:s268" "procedure: (virtual-register k)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "virtual-register returns the value most recently stored in virtual register k (on the current thread, in threaded versions of the system). \n\n") ("system:s269" "procedure: (scheme-version) \nprocedure: (scheme-version show-pre-release?)\nreturns: a version string \nlibraries: (chezscheme)  \n\n" "The version string is in the form \n\n" "" "\"Chez Scheme Version version\"\n\n" "for Chez Scheme, and \n\n" "" "\"Petite Chez Scheme Version version\"\n\n" "for Petite Chez Scheme. \n\n" "version includes the major, minor, and patch version numbers separated by ..  If show-pre-release? is provided and is a true value, and the current version is a pre-release version (i.e., (scheme-pre-release) is a number), then version additionally has -pre-release. and the pre-release number appended. \n\n" "" "(scheme-version) => \"Chez Scheme Version 9.9.9\"\n(scheme-version #t) => \"Chez Scheme Version 9.9.9-pre-release.11\"\n\n") ("system:s270" "procedure: (scheme-version-number) \nreturns: three values: the major, minor, and patch version numbers \nlibraries: (chezscheme)  \n\n" "Each of the three return values is a nonnegative fixnum. \n\n" "In Chez Scheme Version 9.7.3 or 9.7.3-pre-release.3: \n\n" "" "(scheme-version-number) => 9\n                           7\n                           3\n\n") ("system:s271" "procedure: (scheme-pre-release) \nreturns: a pre-release number or #f \nlibraries: (chezscheme)  \n\n" "The return value is a positive fixnum for a pre-release version, or it is #f for a release version (which is after any version that has a pre-release number and the same major, minor, and patch number). \n\n" "In Chez Scheme Version 9.7.3: \n\n" "" "(scheme-pre-release) => #f\n\n" "In Chez Scheme Version 9.7.3-pre-release.3: \n\n" "" "(scheme-pre-release) => 3\n\n") ("system:s272" "procedure: (petite?) \nreturns: #t if called in Petite Chez Scheme, #f otherwise \nlibraries: (chezscheme)  \n\n" "The only difference between Petite Chez Scheme and Chez Scheme is that the compiler is not available in the former, so this predicate can serve as a way to determine if the compiler is available. \n\n") ("system:s273" "procedure: (threaded?) \nreturns: #t if called in a threaded version of the system, #f otherwise \nlibraries: (chezscheme)  \n\n") ("system:s274" "procedure: (interactive?) \nreturns: #t if system is run interactively, #f otherwise \nlibraries: (chezscheme)  \n\n" "This predicate returns #t if the Scheme process's stdin and stdout are connected to a tty (Unix-based systems) or console (Windows). Otherwise, it returns #f.  \n\n") ("system:s275" "procedure: (get-process-id) \nreturns: the operating system process id of the current process \nlibraries: (chezscheme)  \n\n") ("system:s276" "procedure: (getenv key)\nreturns: environment value of key or #f \nlibraries: (chezscheme)  \n\n" "key must be a string. getenv returns the operating system shell's environment value associated with key, or #f if no environment value is associated with key. \n\n" "" "(getenv \"HOME\") => \"/u/freddy\"\n\n") ("system:s277" "procedure: (putenv key value)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "key and value must be strings. \n\n" "putenv stores the key, value pair in the environment of the process, where it is available to the current process (e.g., via getenv) and any spawned processes. \n\n" "" "(putenv \"SCHEME\" \"rocks!\")\n(getenv \"SCHEME\") => \"rocks!\"\n\n") ("system:s278" "procedure: (get-registry key)\nreturns: registry value of key or #f \nprocedure: (put-registry! key val)\nprocedure: (remove-registry! key)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "key and val must be strings. \n\n" "get-registry returns a string containing the registry value of key if the value exists. If no registry value for key exists, get-registry returns #f.  \n\n" "put-registry! sets the registry value of key to val. It raises an exception with condition type &assertion if the value cannot be set, which may happen if the user has insufficient access. \n\n" "remove-registry! removes the registry key or value named by key. It raises an exception with condition type &assertion if the value cannot be removed. Reasons for failure include the key not being present, the user having insufficient access, or key being a key with subkeys. \n\n" "These routines are defined for Windows only. \n\n" "" "(get-registry \"hkey_local_machine\\\\Software\\\\North\\\\South\") => #f\n(put-registry! \"hkey_local_machine\\\\Software\\\\North\\\\South\" \"east\")\n(get-registry \"hkey_local_machine\\\\Software\\\\North\\\\South\") => \"east\"\n(remove-registry! \"hkey_local_machine\\\\Software\\\\North\")\n(get-registry \"hkey_local_machine\\\\Software\\\\North\\\\South\") => #f\n\n") ("system:s279" "thread parameter: subset-mode \nlibraries: (chezscheme)  \n\n" "The value of this parameter must be #f (the default) or the symbol system. Setting subset-mode to system allows the manipulation of various undocumented system variables, data structures, and settings. It is typically used only for system debugging. \n\n") ("syntax:s0" "syntax: (fluid-let-syntax ((keyword expr) ...) form1 form2 ...)\nreturns: see explanation \nlibraries: (chezscheme)  \n\n" "Each expr must evaluate to a transformer. fluid-let-syntax is similar to the standard let-syntax, except that instead of introducing new bindings for the keywords keyword ..., fluid-let-syntax temporarily alters the existing bindings for the keywords during the expansion of its body. That is, during the expansion of form1 form2 ..., the visible lexical (or top-level) binding for each keyword is temporarily replaced by a new association between the keyword and the corresponding transformer. This affects any references to the keyword that resolve to the same lexical (or top-level) binding whether the references occur in the text of the body or are introduced during its expansion. In contrast, let-syntax captures only those references that occur within the text of its body. \n\n" "The following example shows how fluid-let-syntax differs from let-syntax.  \n\n" "" "(let ([f (lambda (x) (+ x 1))])\n  (let-syntax ([g (syntax-rules ()\n                    [(_ x) (f x)])])\n    (let-syntax ([f (syntax-rules ()\n                      [(_ x) x])])\n      (g 1)))) => 2 \n\n(let ([f (lambda (x) (+ x 1))])\n  (let-syntax ([g (syntax-rules ()\n                    [(_ x) (f x)])])\n    (fluid-let-syntax ([f (syntax-rules ()\n                            [(_ x) x])])\n      (g 1)))) => 1\n\n" "The two expressions are identical except that the inner let-syntax form in the first expression is a fluid-let-syntax form in the second. In the first expression, the f occurring in the expansion of (g 1) refers to the let-bound variable f, whereas in the second it refers to the keyword f by virtue of the fluid syntax binding for f.  \n\n" "The following code employs fluid-let-syntax in the definition of a define-integrable form that is similar to define for procedure definitions except that it causes the code for the procedure to be integrated, or inserted, wherever a direct call to the procedure is found. No semantic difference is visible between procedures defined with define-integrable and those defined with define, except that a top-level define-integrable form must appear before the first reference to the defined identifier. Lexical scoping is preserved, the actual parameters in an integrated call are evaluated once and at the proper time, integrable procedures may be used as first-class values, and recursive procedures do not cause indefinite recursive expansion. \n\n" "" "(define-syntax define-integrable\n  (syntax-rules (lambda)\n    [(_ name (lambda formals form1 form2 ...))\n     (begin\n       (define xname\n         (fluid-let-syntax ([name (identifier-syntax xname)])\n           (lambda formals form1 form2 ...)))\n       (define-syntax name\n         (lambda (x)\n           (syntax-case x ()\n             [_ (identifier? x) #'xname]\n             [(_ arg (... ...))\n              #'((fluid-let-syntax ([name (identifier-syntax xname)])\n                   (lambda formals form1 form2 ...))\n                  arg\n                  (... ...))]))))]))\n\n" "A define-integrable has the following form.  \n\n" "" "(define-integrable name lambda-expression)\n\n" "A define-integrable form expands into a pair of definitions: a syntax definition of name and a variable definition of xname. The transformer for name converts apparent calls to name into direct calls to lambda-expression. Since the resulting forms are merely direct lambda applications (the equivalent of let expressions), the actual parameters are evaluated exactly once and before evaluation of the procedure's body, as required. All other references to name are replaced with references to xname. The definition of xname binds it to the value of lambda-expression. This allows the procedure to be used as a first-class value. Because xname is introduced by the transformer, the binding for xname is not visible anywhere except where references to it are introduced by the transformer for name. \n\n" "Within lambda-expression, wherever it appears, name is rebound to a transformer that expands all references into references to xname. The use of fluid-let-syntax for this purpose prevents indefinite expansion from indirect recursion among integrable procedures. This allows the procedure to be recursive without causing indefinite expansion. Nothing special is done by define-integrable to maintain lexical scoping, since lexical scoping is maintained automatically by the expander. \n\n" "Chez Scheme integrates locally defined procedures automatically when it is appropriate to do so. It cannot integrate procedures defined at top-level, however, since code that assigns top-level variables can be introduced into the system (via eval or load) at any time. define-integrable can be used to force the integration of procedures bound at top-level, even if the integration of locally bound procedures is left to the compiler. It can also be used to force the integration of large procedures that the compiler would not normally integrate. (The expand/optimize procedure is useful for determining when integration does or does not take place.) \n\n") ("syntax:s4" "syntax: (syntax-rules (literal ...) clause ...)\nreturns: a transformer \nlibraries: (chezscheme)  \n\n" "Each literal must be an identifier other than an underscore ( _ ) or ellipsis ( ... ). Each clause must take the form below. \n\n" "" "(pattern template)\n(pattern fender template)\n\n" "The first form is the only form supported by the Revised^6 Report. \n\n") ("syntax:s6" "procedure: (syntax->list syntax-object)\nreturns: a list of syntax objects \nlibraries: (chezscheme)  \n\n" "This procedure takes a syntax object representing a list-structured form and returns a list of syntax objects, each representing the corresponding subform of the input form. \n\n" "syntax->list may be defined as follows.  \n\n" "" "(define syntax->list\n  (lambda (ls)\n    (syntax-case ls ()\n      [() '()]\n      [(x . r) (cons #'x (syntax->list #'r))]))) \n\n#'(a b c) => #<syntax (a b c)>\n(syntax->list #'(a b c)) => (#<syntax a> #<syntax b> #<syntax c>)\n\n" "syntax->list is not required for list structures constructed from individual pattern variable values or sequences of pattern-variable values, since such structures are already lists. For example: \n\n" "" "(list? (with-syntax ([x #'a] [y #'b] [z #'c]) #'(x y z)))) => #t\n(list? (with-syntax ([(x ...) #'(a b c)]) #'(x ...))) => #t\n\n") ("syntax:s7" "procedure: (syntax->vector syntax-object)\nreturns: a vector of syntax objects \nlibraries: (chezscheme)  \n\n" "This procedure takes a syntax object representing a vector-structured form and returns a vector of syntax objects, each representing the corresponding subform of the input form. \n\n" "syntax->vector may be defined as follows.  \n\n" "" "(define syntax->vector\n  (lambda (v)\n    (syntax-case v ()\n      [#(x ...) (apply vector (syntax->list #'(x ...)))]))) \n\n#'#(a b c) => #<syntax #(a b c)>\n(syntax->vector #'#(a b c)) => #(#<syntax a> #<syntax b> #<syntax c>)\n\n" "syntax->vector is not required for vector structures constructed from individual pattern variable values or sequences of pattern-variable values, since such structures are already vectors. For example: \n\n" "" "(vector? (with-syntax ([x #'a] [y #'b] [z #'c]) #'#(x y z)))) => #t\n(vector? (with-syntax ([(x ...) #'(a b c)]) #'#(x ...))) => #t\n\n") ("syntax:s8" "procedure: (syntax-object->datum obj)\nreturns: obj stripped of syntactic information \nlibraries: (chezscheme)  \n\n" "syntax-object->datum is identical to the Revised^6 Report syntax->datum.  \n\n") ("syntax:s9" "syntax: (datum template)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "(datum template) is a convenient shorthand syntax for \n\n" "" "(syntax->datum (syntax template))\n\n" "datum may be defined simply as follows. \n\n" "" "(define-syntax datum\n  (syntax-rules ()\n    [(_ t) (syntax->datum #'t)])) \n\n(with-syntax ((a #'(a b c))) (datum a)) => (a b c)\n\n") ("syntax:s10" "procedure: (datum->syntax-object template-identifier obj)\nreturns: a syntax object \nlibraries: (chezscheme)  \n\n" "datum->syntax-object is identical to the Revised^6 Report datum->syntax.  \n\n") ("syntax:s11" "syntax: (quote-syntax datum)\nreturns: a syntax object \nlibraries: (chezscheme)  \n\n" "A quote-syntax expression is like a quote expression, except that contextual information associated with the datum is retained. \n\n" "Unlike syntax, quote-syntax does not substitute pattern variables bound by with-syntax or syntax-case.  \n\n" "" "(let-syntax ([m (lambda (stx)\n                  (syntax-case stx ()\n                    [(_ x)\n                     #`(list 'x '#,(quote-syntax x))]))])\n  (m y)) => (y x)\n\n") ("syntax:s12" "syntax: (with-implicit (id0 id1 ...) body1 body2 ...)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "This form abstracts over the common usage of datum->syntax for creating implicit identifiers (see above). The form \n\n" "" "(with-implicit (id0 id1 ...)\n  body1 body2 ...)\n\n" "is equivalent to \n\n" "" "(with-syntax ([id1 (datum->syntax #'id0 'id1)] ...)\n  body1 body2 ...)\n\n" "with-implicit can be defined simply as follows.  \n\n" "" "(define-syntax with-implicit\n  (syntax-rules ()\n    [(_ (tid id ...) b1 b2 ...)\n     (with-syntax ([id (datum->syntax #'tid 'id)] ...)\n       b1 b2 ...)]))\n\n" "We can use with-implicit to simplify the (correct version of) loop above.  \n\n" "" "(define-syntax loop\n  (lambda (x)\n    (syntax-case x ()\n      [(k e ...)\n       (with-implicit (k break)\n         #'(call-with-current-continuation\n             (lambda (break)\n               (let f () e ... (f)))))])))\n\n") ("syntax:s13" "syntax: (include path)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "path must be a string. include expands into a begin expression containing the forms found in the file named by path. For example, if the file f-def.ss contains (define f (lambda () x)), the expression \n\n" "" "(let ([x \"okay\"])\n  (include \"f-def.ss\")\n  (f))\n\n" "evaluates to \"okay\". An include form is treated as a definition if it appears within a sequence of definitions and the forms on the file named by path are all definitions, as in the above example. If the file contains expressions instead, the include form is treated as an expression. \n\n" "include may be defined portably as follows, although Chez Scheme uses an implementation-dependent definition that allows it to capture and maintain source information for included code. \n\n" "" "(define-syntax include\n  (lambda (x)\n    (define read-file\n      (lambda (fn k)\n        (let ([p (open-input-file fn)])\n          (let f ([x (read p)])\n            (if (eof-object? x)\n                (begin (close-input-port p) '())\n                (cons (datum->syntax k x)\n                      (f (read p))))))))\n    (syntax-case x ()\n      [(k filename)\n       (let ([fn (datum filename)])\n         (with-syntax ([(exp ...) (read-file fn #'k)])\n           #'(begin exp ...)))])))\n\n" "The definition of include uses datum->syntax to convert the objects read from the file into syntax objects in the proper lexical context, so that identifier references and definitions within those expressions are scoped where the include form appears.  \n\n" "In Chez Scheme's implementation of include, the parameter source-directories (Section 12.5) determines the set of directories searched for source files not identified by absolute path names. \n\n") ("syntax:s14" "procedure: (syntax-error obj string ...)\nreturns: does not return \nlibraries: (chezscheme)  \n\n" "Syntax errors may be reported with syntax-error, which produces a message by concatenating string ... and a printed representation of obj. If no string arguments are provided, the string \"invalid syntax\"is used instead. When obj is a syntax object, the syntax-object wrapper is stripped (as with syntax->datum) before the printed representation is created. If source file information is present in the syntax-object wrapper, syntax-error incorporates this information into the error message. \n\n" "syntax-case and syntax-rules call syntax-error automatically if the input fails to match one of the clauses. \n\n" "We can use syntax-error to precisely report the cause of the errors detected in the following definition of (unnamed) let.  \n\n" "" "(define-syntax let\n  (lambda (x)\n    (define check-ids!\n      (lambda (ls)\n        (unless (null? ls)\n          (unless (identifier? (car ls))\n            (syntax-error (car ls) \"let cannot bind non-identifier\"))\n          (check-ids! (cdr ls)))))\n    (define check-unique!\n      (lambda (ls)\n        (unless (null? ls)\n          (let ([x (car ls)])\n            (when (let mem? ([ls (cdr ls)])\n                    (and (not (null? ls))\n                         (or (bound-identifier=? x (car ls))\n                             (mem? (cdr ls)))))\n              (syntax-error x \"let cannot bind two occurrences of\")))\n          (check-unique! (cdr ls)))))\n    (syntax-case x ()\n      [(_ ((i e) ...) b1 b2 ...)\n       (begin\n         (check-ids! #'(i ...))\n         (check-unique! #'(i ...))\n         #'((lambda (i ...) b1 b2 ...) e ...))])))\n\n" "With this change, the expression \n\n" "" "(let ([a 3] [a 4]) (+ a a))\n\n" "produces the error message \"let cannot bind two occurrences of a.\"  \n\n") ("syntax:s15" "procedure: (literal-identifier=? identifier1 identifier2)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "This procedure is identical to the Revised^6 Report free-identifier=?, and is provided for backward compatibility only. \n\n") ("syntax:s16" "procedure: (make-compile-time-value obj)\nreturns: a compile-time value \nlibraries: (chezscheme)  \n\n" "A compile time value is a kind of transformer with which a keyword may be associated by any of the keyword binding constructs, e.g., define-syntax or let-syntax. The transformer encapsulates the supplied obj. The encapsulated object may be retrieved as described above. \n\n" "The following example illustrates how this feature might be used to define a simple syntactic record-definition mechanism where the record type descriptor is generated at expansion time. \n\n" "" "(define-syntax drt\n  (lambda (x)\n    (define construct-name\n      (lambda (template-identifier . args)\n        (datum->syntax template-identifier\n          (string->symbol\n            (apply string-append\n              (map (lambda (x)\n                     (if (string? x)\n                         x\n                         (symbol->string (syntax->datum x))))\n                   args))))))\n    (define do-drt\n      (lambda (rname fname* prtd)\n        (with-syntax ([rname rname]\n                      [rtd (make-record-type-descriptor\n                             (syntax->datum rname) prtd #f #f #f\n                             (list->vector\n                               (map (lambda (fname)\n                                      `(immutable ,(syntax->datum fname)))\n                                    fname*)))]\n                      [make-rname (construct-name rname \"make-\" rname)]\n                      [rname? (construct-name rname rname \"?\")]\n                      [(rname-fname ...)\n                       (map (lambda (fname)\n                              (construct-name fname rname \"-\" fname))\n                            fname*)]\n                      [(i ...) (enumerate fname*)])\n          #'(begin\n              (define-syntax rname (make-compile-time-value 'rtd))\n              (define rcd (make-record-constructor-descriptor 'rtd #f #f))\n              (define make-rname (record-constructor rcd))\n              (define rname? (record-predicate 'rtd))\n              (define rname-fname (record-accessor 'rtd i))\n              ...))))\n    (syntax-case x (parent)\n      [(_ rname (fname ...))\n       (for-all identifier? #'(rname fname ...))\n       (do-drt #'rname #'(fname ...) #f)]\n      [(_ rname pname (fname ...))\n       (for-all identifier? #'(rname pname fname ...))\n       (lambda (lookup)\n         (let ([prtd (lookup #'pname)])\n           (unless (record-type-descriptor? prtd)\n             (syntax-error #'pname \"unrecognized parent record type\"))\n           (do-drt #'rname #'(fname ...) prtd)))])))\n\n" "" "(drt prec (x y))\n(drt crec prec (z))\n(define r (make-crec 1 2 3))\n(prec? r) => #t\n(prec-x r) => 1\n(crec-z r) => 3\nprec => exception: invalid syntax prec\n\n") ("syntax:s17" "procedure: (compile-time-value? obj)\nreturns: #t if obj is a compile-time value; #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(define-syntax x (make-compile-time-value \"eggs\"))\n(compile-time-value? (top-level-syntax 'x)) => #t\n\n") ("syntax:s18" "procedure: (compile-time-value-value ctv)\nreturns: the value of a compile-time value \nlibraries: (chezscheme)  \n\n" "" "(define-syntax x (make-compile-time-value \"eggs\"))\n(compile-time-value-value (top-level-syntax 'x)) => \"eggs\"\n\n") ("syntax:s19" "syntax: (define-property id key expr)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "A define-property form attaches a property to an existing identifier binding without disturbing the existing meaning of the identifier in the scope of that binding. It is typically used by one macro to record information about a binding for use by another macro. Both id and key must be identifiers. The expression expr is evaluated when the define-property form is expanded, and a new property associating key with the value of expr is attached to the existing binding of id, which must have a visible local or top-level binding. \n\n" "define-property is a definition and can appear anywhere other definitions can appear. The scope of a property introduced by define-property is the entire body in which the define-property form appears or global if it appears at top level, except where it is replaced by a property for the same id and key or where the binding to which it is attached is shadowed. Any number of properties can be attached to the same binding with different keys. Attaching a new property with the same name as an property already attached to a binding shadows the existing property with the new property. \n\n" "The following example defines a macro, get-info, that retrieves the info property of a binding, defines the variable x, attaches an info property to the binding of x, retrieves the property via get-info, references x to show that its normal binding is still intact, and uses get-info again within the scope of a different binding of x to show that the properties are shadowed as well as the outer binding of x.  \n\n" "" "(define info)\n(define-syntax get-info\n  (lambda (x)\n    (lambda (lookup)\n      (syntax-case x ()\n        [(_ q)\n         (let ([info-value (lookup #'q #'info)])\n           #`'#,(datum->syntax #'* info-value))]))))\n(define x \"x-value\")\n(define-property x info \"x-info\")\n(get-info x) => \"x-info\"\nx => \"x-value\"\n(let ([x \"inner-x-value\"]) (get-info x)) => #f\n\n" "For debugging, it is often useful to have a form that retrieves an arbitrary property, given an identifier and a key. The get-property macro below does just that. \n\n" "" "(define-syntax get-property\n  (lambda (x)\n    (lambda (r)\n      (syntax-case x ()\n        [(_ id key)\n         #`'#,(datum->syntax #'* (r #'id #'key))]))))\n(get-property x info) => \"x-info\"\n\n" "The bindings for both identifiers must be visible where get-property is used.  \n\n" "The version of drt defined below is like the one defined using make-compile-time-value above, except that it defines the record name as a macro that raises an exception with a more descriptive message, while attaching the record type descriptor to the binding as a separate property. The variable drt-key defined along with drt is used only as the key for the property that drt attaches to a record name. Both drt-key and drt are defined within a module that exports only the latter, ensuring that the properties used by drt cannot be accessed or forged. \n\n" "" "(library (drt) (export drt) (import (chezscheme))\n  (define drt-key)\n  (define-syntax drt\n    (lambda (x)\n      (define construct-name\n        (lambda (template-identifier . args)\n          (datum->syntax template-identifier\n            (string->symbol\n              (apply string-append\n                (map (lambda (x)\n                       (if (string? x)\n                           x\n                           (symbol->string (syntax->datum x))))\n                     args))))))\n      (define do-drt\n        (lambda (rname fname* prtd)\n          (with-syntax ([rname rname]\n                        [rtd (make-record-type-descriptor\n                               (syntax->datum rname) prtd #f #f #f\n                               (list->vector\n                                 (map (lambda (fname)\n                                        `(immutable ,(syntax->datum fname)))\n                                      fname*)))]\n                        [make-rname (construct-name rname \"make-\" rname)]\n                        [rname? (construct-name rname rname \"?\")]\n                        [(rname-fname ...)\n                         (map (lambda (fname)\n                                (construct-name fname rname \"-\" fname))\n                              fname*)]\n                        [(i ...) (enumerate fname*)])\n            #'(begin\n                (define-syntax rname\n                  (lambda (x)\n                    (syntax-error x \"invalid use of record name\")))\n                (define rcd (make-record-constructor-descriptor 'rtd #f #f))\n                (define-property rname drt-key 'rtd)\n                (define make-rname (record-constructor rcd))\n                (define rname? (record-predicate 'rtd))\n                (define rname-fname (record-accessor 'rtd i))\n                ...))))\n      (syntax-case x (parent)\n        [(_ rname (fname ...))\n         (for-all identifier? #'(rname fname ...))\n         (do-drt #'rname #'(fname ...) #f)]\n        [(_ rname pname (fname ...))\n         (for-all identifier? #'(rname pname fname ...))\n         (lambda (lookup)\n           (let ([prtd (lookup #'pname #'drt-key)])\n             (unless prtd\n               (syntax-error #'pname \"unrecognized parent record type\"))\n             (do-drt #'rname #'(fname ...) prtd)))]))))\n\n" "" "(import (drt))\n(drt prec (x y))\n(drt crec prec (z))\n(define r (make-crec 1 2 3))\n(prec? r) => #t\n(prec-x r) => 1\n(crec-z r) => 3\nprec => exception: invalid use of record name prec\n\n") ("syntax:s22" "syntax: (module name interface defn ... init ...)\nsyntax: (module interface defn ... init ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "name is an identifier, defn ...are definitions, and init ... are expressions. interface is a list of exports (export ...), where each export is either an identifier identifier or of the form (identifier export ...). \n\n" "The first syntax for module establishes a named scope that encapsulates a set of identifier bindings. The exported bindings may be made visible via import or import-only (Section 10.4) anywhere the module name is visible. The second syntax for module introduces an anonymous module whose bindings are implicitly imported (as if by import of a hidden module name) where the module form appears. \n\n" "A module consists of a (possibly empty) set of definitions and a (possibly empty) sequence of initialization expressions. The identifiers defined within a module are visible within the body of the module and, if exported, within the scope of an import for the module. Each identifier listed in a module's interface must be defined within or imported into that module. A module form is a definition and can appear anywhere other definitions can appear, including at the top level of a program, nested within the bodies of lambda expressions, nested within library and top-level program forms, and nested within other modules. Also, because module names are scoped like other identifiers, modules and libraries may export module names as well as variables and keywords. \n\n" "When an interface contains an export of the form (identifier export ...), only identifier is visible in the importing context. The identifiers within export ... are indirect imports, as if declared via an indirect-export form (Section 10.4). \n\n" "Module names occupy the same namespace as other identifiers and follow the same scoping rules. Unless exported, identifiers defined within a module are visible only within that module. \n\n" "Expressions within a module can reference identifiers bound outside of the module. \n\n" "" "(let ([x 3])\n  (module m (plusx)\n    (define plusx (lambda (y) (+ x y))))\n  (import m)\n  (let ([x 4])\n    (plusx 5))) => 8\n\n" "Similarly, import does not prevent access to identifiers that are visible where the import form appears, except for those variables shadowed by the imported identifiers. \n\n" "" "(module m (y) (define y 'm-y))\n(let ([x 'local-x] [y 'local-y])\n  (import m)\n  (list x y)) => (local-x m-y)\n\n" "On the other hand, use of import-only within a module establishes an isolated scope in which the only visible identifiers are those exported by the imported module. \n\n" "" "(module m (y) (define y 'm-y))\n(let ([x 'local-x] [y 'local-y])\n  (import-only m)\n  x) => Error: x is not visible\n\n" "This is sometimes desirable for static verification that no identifiers are used except those explicitly imported into a module or local scope. \n\n" "Unless a module imported via import-only exports import or import-only and the name of at least one module, subsequent imports within the scope of the import-only form are not possible. To create an isolated scope containing the exports of more than one module without making import or import-only visible, all of the modules to be imported must be listed in the same import-only form.  \n\n" "Another solution is to create a single module that contains the exports of each of the other modules. \n\n" "" "(module m2 (y) (define y 'y))\n(module m1 (x) (define x 'x))\n(module mega-module (cons x y)\n  (import m1)\n  (import m2)\n  (import scheme))\n(let ([y 3])\n  (import-only mega-module)\n  (cons x y)) => (x . y)\n\n" "" "Before it is compiled, a source program is translated into a core language program containing no syntactic abstractions, syntactic definitions, library definitions, module definitions, or import forms. Translation is performed by a syntax expander that processes the forms in the source program via recursive descent. \n\n" "A define-syntax form associates a keyword with a transformer in a translation-time environment. When the expander encounters a keyword, it invokes the associated transformer and reprocesses the resulting form. A module form associates a module name with an interface. When the expander encounters an import form, it extracts the corresponding module interface from the translation-time environment and makes the exported bindings visible in the scope where the import form appears. \n\n" "Internal definitions and definitions within a module body are processed from left to right so that a module's definition and import may appear within the same sequence of definitions. Expressions appearing within a body and the right-hand sides of variable definitions, however, are translated only after the entire set of definitions has been processed, allowing full mutual recursion among variable and syntactic definitions. \n\n" "Module and import forms affect only the visibility of identifiers in the source program, not their meanings. In particular, variables are bound to locations whether defined within or outside of a module, and import does not introduce new locations. Local variables are renamed as necessary to preserve the scoping relationships established by both modules and syntactic abstractions. Thus, the expression: \n\n" "" "(let ([x 1])\n  (module m (x setter)\n    (define-syntax x (identifier-syntax z))\n    (define setter (lambda (x) (set! z x)))\n    (define z 5))\n  (let ([y x] [z 0])\n    (import m)\n    (setter 3)\n    (+ x y z))) => 4\n\n" "is equivalent to the following program in which identifiers have been consistently renamed as indicated by subscripts. \n\n" "" "(let ([x0 1])\n  (define-syntax x1 (identifier-syntax z1))\n  (define setter1 (lambda (x2) (set! z1 x2)))\n  (define z1 5)\n  (let ([y3 x0] [z3 0])\n    (setter1 3)\n    (+ x1 y3 z3)))\n\n" "Definitions within a top-level begin, lambda, top-level program, library, or module body are processed from left to right by the expander at expand time, and the variable definitions are evaluated from left-to-right at run time. Initialization expressions appearing within a module body are evaluated in sequence after the evaluation of the variable definitions. \n\n" "Mutually recursive modules can be defined in several ways. In the following program, a and b are mutually recursive modules exported by an anonymous module whose local scope is used to statically link the two. For example, the free variable y within module a refers to the binding for y, provided by importing b, in the enclosing module. \n\n" "" "(module (a b)\n  (module a (x) (define x (lambda () y)))\n  (module b (y) (define y (lambda () x)))\n  (import a)\n  (import b))\n\n" "The following syntactic abstraction generalizes this pattern to permit the definition of multiple mutually recursive modules. \n\n" "" "(define-syntax rec-modules\n  (syntax-rules (module)\n    [(_ (module m (id ...) form ...) ...)\n     (module (m ...)\n       (module m (id ...) form ...) ...\n       (import m) ...)]))\n\n" "Because a module can re-export imported bindings, it is quite easy to provide multiple views on a single module, as s and t provide for r below, or to combine several modules into a compound, as r does.  \n\n" "" "(module p (x y)\n  (define x 1) (define y 2))\n(module q (y z)\n  (define y 3) (define z 4))\n(module r (a b c d)\n  (import* p (a x) (b y))\n  (import* q (c y) (d z)))\n(module s (a c) (import r))\n(module t (b d) (import r))\n\n" "To allow interfaces to be separated from implementations, the following syntactic abstractions support the definition and use of named interfaces. \n\n" "" "(define-syntax define-interface\n  (syntax-rules ()\n    [(_ name (export ...))\n     (define-syntax name\n       (lambda (x)\n         (syntax-case x ()\n           [(_ n defs)\n            (with-implicit (n export ...)\n              #'(module n (export ...) .\n                  defs))])))])) \n\n(define-syntax define-module\n  (syntax-rules ()\n    [(_ name interface defn ...)\n     (interface name (defn ...))]))\n\n" "define-interface creates an interface macro that, given a module name and a list of definitions, expands into a module definition with a concrete interface. \n\n" "with-implicit is used to ensure that the introduced export identifiers are visible in the same scope as the name of the module in the define-module form.  \n\n" "define-interface and define-module can be used as follows. \n\n" "" "(define-interface simple (a b))\n(define-module m simple\n  (define-syntax a (identifier-syntax 1))\n  (define b (lambda () c))\n  (define c 2))\n(let () (import m) (+ a (b))) => 3\n\n" "The abstract module facility defined below allows a module interface to be satisfied incrementally when module forms are evaluated. This permits flexibility in the separation between the interface and implementation, supports separate compilation of mutually recursive modules, and permits redefinition of module implementations. \n\n" "" "(define-syntax abstract-module\n  (syntax-rules ()\n    [(_ name (ex ...) (kwd ...) defn ...)\n     (module name (ex ... kwd ...)\n       (declare ex) ...\n       defn ...)])) \n\n(define-syntax implement\n  (syntax-rules ()\n    [(_ name form ...)\n     (module () (import name) form ...)]))\n\n" "Within an abstract-module form, each of the exports in the list ex ... must be variables. The values of these variables are supplied by one or more separate implement forms. Since keyword bindings must be present at compile time, they cannot be satisfied incrementally and are instead listed as separate exports and defined within the abstract module. \n\n" "Within an implement form, the sequence of forms form ... is a sequence of zero or more definitions followed by a sequence of zero or more expressions. Since the module used in the expansion of implement does not export anything, the definitions are all local to the implement form. The expressions may be arbitrary expressions, but should include one satisfy form for each variable whose definition is supplied by the implement form. A satisfy form has the syntax  \n\n" "" "(satisfy variable expr)\n\n" "declare and satisfy may simply be the equivalents of define and set!.  \n\n" "" "(define-syntax declare (identifier-syntax define))\n(define-syntax satisfy (identifier-syntax set!))\n\n" "Alternatively, declare can initialize the declared variable to the value of a flag known only to declare and satisfy, and satisfy can verify that this flag is still present to insure that only one attempt to satisfy the value of a given identifier is made. \n\n" "" "(module ((declare cookie) (satisfy cookie))\n  (define cookie \"chocolate chip\")\n  (define-syntax declare\n    (syntax-rules () [(_ var) (define var cookie)]))\n  (define-syntax satisfy\n    (syntax-rules ()\n      [(_ var exp)\n       (if (eq? var cookie)\n           (set! var exp)\n           (assertion-violationf 'satisfy\n             \"value of variable ~s has already been satisfied\"\n             'var))])))\n\n" "Using abstract-module and implement, we can define mutually recursive and separately compilable modules as follows. \n\n" "" "(abstract-module e (even?) (pred)\n  (define-syntax pred\n    (syntax-rules () [(_ exp) (- exp 1)]))) \n\n(abstract-module o (odd?) ()) \n\n(implement e\n  (import o)\n  (satisfy even?\n    (lambda (x)\n      (or (zero? x) (odd? (pred x)))))) \n\n(implement o\n  (import e)\n  (satisfy odd?\n    (lambda (x) (not (even? x))))) \n\n(let () (import-only e) (even? 38)) => #t\n\n") ("syntax:s23" "syntax: only \nsyntax: except \nsyntax: add-prefix \nsyntax: drop-prefix \nsyntax: rename \nsyntax: alias \nlibraries: (chezscheme)  \n\n" "These identifiers are auxiliary keywords for import and import-only. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords. \n\n") ("syntax:s29" "module: scheme \nlibraries: (chezscheme)  \n\n" "scheme contains all user-visible top-level bindings (variables, keywords, and module names) built into Chez Scheme. \n\n") ("syntax:s30" "module: r5rs \nlibraries: (chezscheme)  \n\n" "r5rs contains all top-level bindings (variables and keywords) defined in the Revised^5 Report on Scheme. The bindings exported from r5rs are precisely those that are available within an expression evaluated via eval with the environment specifier returned by scheme-report-environment.  \n\n") ("syntax:s32" "module: r5rs-syntax \nlibraries: (chezscheme)  \n\n" "r5rs-syntax contains all top-level keyword bindings defined in the Revised^5 Report on Scheme. The bindings exported from r5rs-syntax are precisely those that are available within an expression evaluated via eval with the environment specifier returned by null-environment.  \n\n") ("syntax:s34" "module: ieee \nlibraries: (chezscheme)  \n\n" "ieee contains all top-level bindings (variables and keywords) defined in the ANSI/IEEE standard for Scheme. The bindings exported from ieee are precisely those that are available within an expression evaluated via eval with the environment specifier returned by ieee-environment.  \n\n") ("syntax:s36" "module: $system \nlibraries: (chezscheme)  \n\n" "$system contains all user-visible top-level bindings built into Chez Scheme along with various undocumented system bindings. \n\n") ("syntax:s37" "syntax: (meta . definition)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "The meta keyword is actually a prefix that can be placed in front of any definition keyword, e.g., \n\n" "" "(meta define x 3)\n\n" "It tells the expander that any variable definition resulting from the definition is to be an expand-time definition available only to the right-hand sides of other meta definitions and, most importantly, transformer expressions. It is used to define expand-time helpers and other information for use by one or more syntax-case transformers.  \n\n" "" "(module M (helper1 a b)\n  (meta define helper1\n    (lambda (---)\n      ---))\n  (meta define helper2\n    (lambda (---)\n      --- (helper2 ---) ---))\n  (define-syntax a\n    (lambda (x)\n      --- (helper1 ---) ---))\n  (define-syntax b\n    (lambda (x)\n      --- (helper1 ---) ---\n      --- (helper2 ---) ---)))\n\n" "The right-hand-side expressions of a syntax definition or meta definition can refer only to identifiers whose values are already available in the compile-time environment. Because of the left-to-right expansion order for library, module, lambda, and similar bodies, this implies a semantics similar to let* for a sequence of meta definitions, in which each right-hand side can refer only to the variables defined earlier in the sequence. An exception is that the right-hand side of a meta definition can refer to its own name as long as the reference is not evaluated until after the value of the expression has been computed. This permits meta definitions to be self-recursive but not mutually recursive. The right-hand side of a meta definition can, however, build syntax objects containing occurrences of any identifiers defined in the body in which the meta definition appears. \n\n" "Meta definitions propagate through macro expansion, so one can write, for example: \n\n" "" "(module (a)\n  (meta define-record foo (x))\n  (define-syntax a\n    (let ([q (make-foo #''q)])\n      (lambda (x) (foo-x q)))))\na => q\n\n" "where define-record is a macro that expands into a set of defines. \n\n" "It is also sometimes convenient to write \n\n" "" "(meta begin defn ...)\n\n" "or \n\n" "" "(meta module {exports} defn ...)\n\n" "or \n\n" "" "(meta include \"path\")\n\n" "to create groups of meta bindings. \n\n") ("syntax:s38" "syntax: (meta-cond clause1 clause2 ...)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "Each clause but the last must take the form: \n\n" "" "(test expr1 expr2 ...)\n\n" "The last may take the same form or be an else clause of the form:  \n\n" "" "(else expr1 expr2 ...)\n\n" "During expansion, the test expressions are evaluated in order until one evaluates to a true value or until all of the tests have been evaluated. If a test evaluates to a true value, the meta-cond form expands to a begin form containing the corresponding expressions expr1 expr2 .... If no test evaluates to a true value and an else clause is present, the meta-cond form expands to a begin form containing the expressions expr1 expr2 ... from the else clause. Otherwise the meta-cond expression expands into a call to the void procedure.  \n\n" "meta-cond might be defined as follows.  \n\n" "" "(define-syntax meta-cond\n  (syntax-rules ()\n    [(_ [a0 a1 a2 ...] [b0 b1 b2 ...] ...)\n     (let-syntax ([expr (cond\n                          [a0 (identifier-syntax (begin a1 a2 ...))]\n                          [b0 (identifier-syntax (begin b1 b2 ...))]\n                          ...)])\n       expr)]))\n\n" "meta-cond is used to choose, at expansion time, from among a set of possible forms. For example, one might have safe (error-checking) and unsafe (non-error-checking) versions of a procedure and decide which to call based on the compile-time optimization level, as shown below. \n\n" "" "(meta-cond\n   [(= (optimize-level) 3) (unsafe-frob x)]\n  [else (safe-frob x)])\n\n") ("syntax:s39" "syntax: (alias id1 id2)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "alias is a definition and can appear anywhere other definitions can appear. It is used to transfer the binding from one identifier to another. \n\n" "" "(let ([x 3]) (alias y x) (set! y 4) (list x y)) => (4 4) \n\n(module lisp (if)\n  (module (scheme:if)\n    (import scheme)\n    (alias scheme:if if))\n  (define-syntax if\n    (syntax-rules ()\n      [(_ e_1 e_2 e_3)\n       (scheme:if (not (memq e_1 '(#f ()))) e_2 e_3)])))\n(define (length ls)\n  (import lisp)\n  (if ls (+ (length (cdr ls)) 1) 0))\n(length '(a b c)) => 3\n\n" "Because of left-to-right expansion order, aliases should appear after the definition of the right-hand-side identifier, e.g.: \n\n" "" "(let ()\n  (import-only (chezscheme))\n  (define y 3)\n  (alias x y)\n  x) => 3\n\n" "rather than: \n\n" "" "(let ()\n  (import-only (chezscheme))\n  (alias x y)\n  (define y 3)\n  x) => exception: unbound identifier\n\n") ("syntax:s50" "procedure: (make-annotation obj source-object stripped-obj)\nprocedure: (make-annotation obj source-object stripped-obj options)\nreturns: an annotation \nlibraries: (chezscheme)  \n\n" "The annotation is formed with obj as its expression component, source-object as its source-object component, and stripped-obj as its stripped component. obj should represent an expression, possibly with embedded annotations. stripped-obj should be a stripped version of obj, i.e., equivalent to obj with each annotation replaced by its expression component. options, if present must be an enumeration set over the symbols debug and profile, and defaults to an enumeration set containing both debug and profile. Annotations marked debug are used for compile-time error reporting and run-time error reporting and inspection; annotations marked profile are used for profiling.  \n\n") ("syntax:s51" "procedure: (annotation? obj)\nreturns: #t if obj is an annotation, otherwise #f \nlibraries: (chezscheme)  \n\n") ("syntax:s52" "procedure: (annotation-expression annotation)\nreturns: the expression component of annotation \nlibraries: (chezscheme)  \n\n") ("syntax:s53" "procedure: (annotation-source annotation)\nreturns: the source-object component of annotation \nlibraries: (chezscheme)  \n\n") ("syntax:s54" "procedure: (annotation-stripped annotation)\nreturns: the stripped component of annotation \nlibraries: (chezscheme)  \n\n") ("syntax:s55" "procedure: (annotation-option-set annotation)\nreturns: the options enumeration set of annotation \nlibraries: (chezscheme)  \n\n") ("syntax:s56" "procedure: (make-source-object sfd bfp efp)\nprocedure: (make-source-object sfd bfp efp line column)\nreturns: a source object \nlibraries: (chezscheme)  \n\n" "sfd must be a source-file descriptor. bfp and efp must be exact nonnegative integers, and bfp should not be greater than efp. line and column must be exact positive integers. \n\n") ("syntax:s57" "procedure: (source-object? obj)\nreturns: #t if obj is a source object, otherwise #f \nlibraries: (chezscheme)  \n\n") ("syntax:s58" "procedure: (source-object-sfd source-object)\nreturns: the sfd component of source-object \nlibraries: (chezscheme)  \n\n") ("syntax:s59" "procedure: (source-object-bfp source-object)\nreturns: the bfp component of source-object \nlibraries: (chezscheme)  \n\n") ("syntax:s60" "procedure: (source-object-efp source-object)\nreturns: the efp component of source-object \nlibraries: (chezscheme)  \n\n") ("syntax:s61" "procedure: (source-object-line source-object)\nreturns: the line component of source-object if present, otherwise #f \nlibraries: (chezscheme)  \n\n") ("syntax:s62" "procedure: (source-object-column source-object)\nreturns: the column component of source-object if present, otherwise #f \nlibraries: (chezscheme)  \n\n") ("syntax:s63" "thread parameter: current-make-source-object \nlibraries: (chezscheme)  \n\n" "current-make-source-object is used by the reader to construct a source object for an annotation. current-make-source-object is initially bound to make-source-object, and the reader always calls the function bound to the parameter with three arguments. \n\n" "Adjust this parameter to, for example, eagerly convert a position integer to a file-position object, instead of delaying the conversion to locate-source.  \n\n") ("syntax:s64" "procedure: (make-source-file-descriptor obj binary-input-port)\nprocedure: (make-source-file-descriptor obj binary-input-port reset?)\nreturns: a source-file descriptor \nlibraries: (chezscheme)  \n\n" "To compute the checksum encapsulated in the source-file descriptor, this procedure must read all of the data from binary-input-port. If reset? is present and #t, the port is reset to its original position, as if via port-position. Otherwise, it is left pointing at end-of-file. \n\n") ("syntax:s65" "procedure: (source-file-descriptor? obj)\nreturns: #t if obj is a source-file descriptor, otherwise #f \nlibraries: (chezscheme)  \n\n") ("syntax:s66" "procedure: (source-file-descriptor-checksum sfd)\nreturns: the checksum component of sfd \nlibraries: (chezscheme)  \n\n") ("syntax:s67" "procedure: (source-file-descriptor-path sfd)\nreturns: the path component of sfd \nlibraries: (chezscheme)  \n\n" "sfd must be a source-file descriptor. The result is typically a string, but a source file descriptor can have any value representing a path. \n\n") ("syntax:s68" "procedure: (source-file-descriptor path checksum)\nreturns: a new source-file-descriptor \nlibraries: (chezscheme)  \n\n" "checksum must be an exact nonnegative integer.  path is usually a string, but may be any object. This procedure can be used to construct custom source-file descriptors or to reconstitute source-file descriptors from the path and checksum components. \n\n") ("syntax:s69" "syntax: (annotation-options symbol ...)\nreturns: an annotation-options enumeration set \nlibraries: (chezscheme)  \n\n" "Annotation-options enumeration sets may be passed to make-annotation to control whether the annotation is used for debugging, profiling, both, or neither. Accordingly, each symbol must be either debug or profile.  \n\n") ("syntax:s70" "procedure: (syntax->annotation obj)\nreturns: an annotation or #f \nlibraries: (chezscheme)  \n\n" "If obj is an annotation or syntax-object encapsulating an annotation, the annotation is returned. \n\n") ("syntax:s71" "procedure: (get-datum/annotations textual-input-port sfd bfp)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "sfd must be a source-file descriptor. bfp must be an exact nonnegative integer and should be the character position of the next character to be read from textual-input-port. \n\n" "This procedure returns two values: an annotated object and an ending file position. In most cases, bfp should be 0 for the first call to get-datum/annotation at the start of a file, and it should be the second return value of the preceding call to get-datum/annotation for each subsequent call. This protocol is necessary to handle files containing multiple-byte characters, since file positions do not necessarily correspond to character positions. \n\n") ("syntax:s72" "procedure: (open-source-file sfd)\nreturns: a port or #f \nlibraries: (chezscheme)  \n\n" "sfd must be a source-file descriptor. This procedure attempts to locate and open the source file identified by sfd. It returns a textual input port, positioned at the beginning of the file, if successful, and #f otherwise. It can fail even if a file with the correct name exists in one of the source directories when the file's checksum does not match the checksum recorded in sfd. \n\n") ("syntax:s73" "procedure: (locate-source sfd pos)\nprocedure: (locate-source sfd pos use-cache?)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "sfd must be a source-file descriptor, and pos must be an exact nonnegative integer. \n\n" "This procedure either uses cached information from a previous request for sfd (only when use-cache? is provided as true) or attempts to locate and open the source file identified by sfd (which can only work when its path is a string). If successful, it returns three values: a string path, an exact nonnegative integer line, and an exact nonnegative integer char representing the absolute pathname, line, and character position within the line represented by the specified source-file descriptor and file position. If unsuccessful, it returns zero values. It can fail even if a file with the correct name exists in one of the source directories when the file's checksum does not match the checksum recorded in sfd. \n\n") ("syntax:s74" "procedure: (locate-source-object-source source-object get-start? use-cache?)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "This procedure is similar to locate-source, but instead of taking an sfd and a position, it takes a source object plus a request for either the start or end location. \n\n" "If get-start? is true and source-object has a line and column, this procedure returns the path in source-objects's sfd, source-object's line, and source-objects's column. \n\n" "Otherwise, this procedure calls locate-source on source-object's sfd, either source-object's bfp or efp depending on get-start?, and use-cache?. \n\n") ("syntax:s75" "thread parameter: current-locate-source-object-source \nlibraries: (chezscheme)  \n\n" "current-locate-source-object-source determines the source-location lookup function that is used by the system to report errors based on source objects. This parameter is initially bound to locate-source-object-object.  \n\n" "Adjust this parameter to control the way that source locations are extracted from source objects, possibly using recorded information, caches, and the filesystem in a way different from locate-source-object-object.  \n\n") ("syntax:s82" "procedure: (make-source-table) \nreturns: a source table \nlibraries: (chezscheme)  \n\n" "A source table contains associations between source objects and arbitrary values.  For purposes of the source-table operations described below, two source objects are the same if they have the same source-file descriptor, equal beginning file positions and equal ending file positions. Two source-file descriptors are the same if they have the same path and checksum. \n\n") ("syntax:s83" "procedure: (source-table? obj)\nreturns: #t if obj is a source-table; #f otherwise \nlibraries: (chezscheme)  \n\n") ("syntax:s84" "procedure: (source-table-set! source-table source-object obj)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "source-table-set! associates source-object with obj in source-table, replacing the existing association, if any. \n\n") ("syntax:s85" "procedure: (source-table-ref source-table source-object default)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "default may be any Scheme value. \n\n" "source-table-ref returns the value associated with source-object in source-table. If no value is associated with source-object in source-table, source-table-ref returns default. \n\n") ("syntax:s86" "procedure: (source-table-contains? source-table source-object)\nreturns: #t if an association for source-object exists in source-table, #f otherwise \nlibraries: (chezscheme)  \n\n") ("syntax:s87" "procedure: (source-table-cell source-table source-object default)\nreturns: a pair (see below) \nlibraries: (chezscheme)  \n\n" "default may be any Scheme value. \n\n" "If no value is associated with source-object in source-table, source-table-cell modifies source-table to associate source-object with default. Regardless, it returns a pair whose car is source-object and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate source-object with a new value. The car field of the pair should not be modified. \n\n") ("syntax:s88" "procedure: (source-table-delete! source-table source-object)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "source-table-delete! drops the association for source-object from source-table, if one exists. \n\n") ("syntax:s89" "procedure: (source-table-size source-table)\nreturns: the number of entries in source-table \nlibraries: (chezscheme)  \n\n") ("syntax:s90" "procedure: (put-source-table textual-output-port source-table)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedure writes a representation of the information stored in source-table to the port. \n\n") ("syntax:s91" "procedure: (get-source-table! textual-input-port source-table)\nprocedure: (get-source-table! textual-input-port source-table combine)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "The port must be positioned at a representation of source-table information written by some previous call to put-source-table, which reads the information and merges it into source-table.  \n\n" "If present and non-false, combine must be a procedure and should accept two arguments. It is called whenever associations for the same source object are present both in source-table and in the information read from the port. In this case, combine is passed two arguments: the associated value from source-table and the associated value from the port (in that order) and must return one value, which is recorded as the new associated value for the source object in source-table. \n\n" "If combine is not present, combine is #f, or no association for a source object read from the port already exists in source-table, the value read from the port is recorded as the associated value of the source object in source-table. \n\n" "" "(define st (make-source-table))\n(call-with-port (open-input-file \"profile.out1\")\n  (lambda (ip) (get-source-table! ip st)))\n(call-with-port (open-input-file \"profile.out2\")\n  (lambda (ip) (get-source-table! ip st +)))\n\n" "") ("libraries:s13" "syntax: (library name exports imports library-body)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "The library form defines a new library with the specified name, exports, imports, and body. Details on the syntax and semantics of the library form are given in Section 10.3 of The Scheme Programming Language, 4th Edition and in the Revised^6Report. \n\n" "Only one version of a library can be loaded at any given time, and an exception is raised if a library is implicitly loaded via import when another version of the library has already been loaded. Chez Scheme permits a different version of the library, or a new instance of the same version, to be entered explicitly into the REPL or loaded explicitly from a file, to facilitate interactive testing and debugging. The programmer should take care to make sure that any code that uses the library is also reentered or reloaded, to make sure that code accesses the bindings of the new instance of the library. \n\n" "" "(library (test (1)) (export x) (import (rnrs)) (define x 3))\n(import (test))\n(define f (lambda () x))\n(f) => 3 \n\n(library (test (1)) (export x) (import (rnrs)) (define x 4))\n(import (test))\n(f) => 3    ; oops---forgot to redefine f\n(define f (lambda () x))\n(f) => 4 \n\n(library (test (2)) (export x) (import (rnrs)) (define x 5))\n(import (test))\n(define f (lambda () x))\n(f) => 5\n\n" "As with module imports (Section 11.5), a library import may appear anywhere a definition may appear, including at top level in the REPL, in a file to be loaded by load, or within a lambda, let, letrec, letrec*, etc., body. The same import form may be used to import from both libraries and modules. \n\n" "" "(library (foo) (export a) (import (rnrs)) (define a 'a-from-foo))\n(module bar (b) (define b 'b-from-bar))\n(let () (import (foo) bar) (list a b)) => (a-from-foo b-from-bar)\n\n" "The import keyword is not visible within a library body unless the library imports it from the (chezscheme) library.  \n\n") ("libraries:s14" "syntax: (top-level-program imports body)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "A top-level-program form may be entered into the REPL or placed in a file to be loaded via load, where it behaves as if its subforms were placed in a file and loaded via load-program. Details on the syntax and semantics of a top-level program are given in Section 10.3 of The Scheme Programming Language, 4th Edition and in the Revised^6Report. \n\n" "The following transcript illustrates a top-level-program being tested in the REPL. \n\n" "" "> (top-level-program (import (rnrs))\n    (display \"hello!\\n\"))\nhello!\n\n") ("libraries:s16" "syntax: (import import-spec ...)\nsyntax: (import-only import-spec ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "An import or import-only form is a definition and can appear anywhere other definitions can appear, including at the top level of a program, nested within the bodies of lambda expressions, and nested within modules and libraries. \n\n" "Each import-spec must take one of the following forms. \n\n" "" "import-set\n(for import-set import-level ...)\n\n" "The for wrapper and import-level are described in  Chapter 10 of The Scheme Programming Language, 4th Edition. They are ignored by Chez Scheme, which determines automatically the levels at which identifiers must be imported, as permitted by the Revised^6 Report. This frees the programmer from the obligation to do so and results in more generality as well as more precision in the set of libraries actually imported at compile and run time [21,19]. \n\n" "An import-set must take one of the following forms: \n\n" "" "library-spec\nmodule-name\n(only import-set identifier ...)\n(except import-set identifier ...)\n(prefix import-set prefix)\n(add-prefix import-set prefix)\n(drop-prefix import-set prefix)\n(rename import-set (import-name internal-name) ...)\n(alias import-set (import-name internal-name) ...)\n\n" "Several of these are specified by the Revised^6 Report; the remainder are Chez Scheme extensions, including module-name and the add-prefix, drop-prefix, and alias forms.  \n\n" "An import or import-only form makes the specified bindings visible in the scope in which they appear. Except at top level, they differ in that import leaves all bindings except for those shadowed by the imported names visible, whereas import-only hides all existing bindings, i.e., makes only the imported names visible. At top level, import-only behaves like import.  \n\n" "Each import-set identifies a set of names to make visible as follows. \n\n" "\nlibrary-spec:\n    all exports of the library identified by the Revised^6 Report library-spec (Chapter 10). \n\n" "\nmodule-name:\n    all exports of module named by the identifier module-name \n\n" "\n(only import-set identifier ...):\n    of those specified by import-set, just identifier ...\n\n" "\n(except import-set identifier ...):\n    all specified by import-set except identifier ...\n\n" "\n(prefix import-set prefix):\n    all specified by import-set, each prefixed by prefix \n\n" "\n(add-prefix import-set prefix):\n    all specified by import-set, each prefixed by prefix (just like prefix)  \n\n" "\n(drop-prefix import-set prefix):\n    all specified by import-set, with prefix prefix removed \n\n" "\n(rename import-set (import-name internal-name) ...):\n    all specified by import-set, with each identifier import-name renamed to the corresponding identifier internal-name \n\n" "\n(alias import-set (import-name internal-name) ...):\n    all specified by import-set, with each internal-name as an alias for import-name \n\n" "The alias form differs from the rename form in that both import-name and internal-name are in the resulting set, rather than just internal-name. \n\n" "It is a syntax violation if the given selection or transformation cannot be made because of a missing export or prefix. \n\n" "An identifier made visible via an import of a module or library is scoped as if its definition appears where the import occurs. The following example illustrates these scoping rules, using a local module m.  \n\n" "" "(library (A) (export x) (import (rnrs)) (define x 0))\n(let ([x 1])\n  (module m (x setter)\n    (define-syntax x (identifier-syntax z))\n    (define setter (lambda (x) (set! z x)))\n    (define z 2))\n  (let ([y x] [z 3])\n    (import m (prefix (A) a:))\n    (setter 4)\n    (list x a:x y z))) => (4 0 1 3)\n\n" "The inner let expression binds y to the value of the x bound by the outer let. The import of m makes the definitions of x and setter visible within the inner let. The import of (A) makes the variable x exported from (A) visible as a:x within the body of the inner let. Thus, in the expression (list x a:x y z), x refers to the identifier macro exported from m while a:x refers to the variable x exported from (A) and y and z refer to the bindings established by the inner let. The identifier macro x expands into a reference to the variable z defined within the module.  \n\n" "With local import forms, it is rarely necessary to use the extended import specifiers. For example, an abstraction that encapsulates the import and reference can easily be defined and used as follows. \n\n" "" "(define-syntax from\n  (syntax-rules ()\n    [(_ m id) (let () (import-only m) id)])) \n\n(library (A) (export x) (import (rnrs)) (define x 1))\n(let ([x 10])\n  (module M (x) (define x 2))\n  (cons (from (A) x) (from M x))) => (1 . 2)\n\n" "The definition of from could use import rather than import-only, but by using import-only we get feedback if an attempt is made to import an identifier from a library or module that does not export the identifier. With import instead of import-only, the current binding, if any, would be visible if the library or module does not export the specified name. \n\n" "" "(define-syntax lax-from\n  (syntax-rules ()\n    [(_ m id) (let () (import m) id)])) \n\n(library (A) (export x) (import (rnrs)) (define x 1)) \n\n(let ([x 10])\n  (module M (x) (define x 2))\n  (+ (from (A) x) (from M y))) => exception: unbound identifier y\n \n(let ([x 10] [y 20])\n  (module M (x) (define x 2))\n  (+ (lax-from (A) x) (lax-from M y))) => 21\n\n" "Import visibility interacts with hygienic macro expansion in such a way that, as one might expect, an identifier x imported from a module M is treated in the importing context as if the corresponding export identifier had been present in the import form along with M. \n\n" "The from abstraction above works because both M and id appear in the input to the abstraction, so the imported id captures the reference to id. \n\n" "The following variant of from also works, because both names are introduced into the output by the transformer. \n\n" "" "(module M (x) (define x 'x-of-M))\n(define-syntax x-from-M\n  (syntax-rules ()\n    [(_) (let () (import M) x)])) \n\n(let ([x 'local-x]) (x-from-M)) => x-of-M\n\n" "On the other hand, imports of introduced module names do not capture free references. \n\n" "" "(let ([x 'local-x])\n  (define-syntax alpha\n    (syntax-rules ()\n      [(_ var) (let () (import M) (list x var))]))\n \n  (alpha x)) => (x-of-M local-x)\n\n" "Similarly, imports from free module names do not capture references to introduced variables. \n\n" "" "(let ([x 'local-x])\n  (define-syntax beta\n    (syntax-rules ()\n      [(_ m var) (let () (import m) (list x var))])) \n\n  (beta M x)) => (local-x x-of-M)\n\n" "This semantics extends to prefixed, renamed, and aliased bindings created by the extended import specifiers prefix, rename, and alias.  \n\n" "The from abstraction works for variables but not for exported keywords, record names, or module names, since the output is an expression and may thus appear only where expressions may appear. A generalization of this technique is used in the following definition of import*, which supports renaming of imported bindings and selective import of specific bindings---without the use of the built-in import subforms for selecting and renaming identifiers  \n\n" "" "(define-syntax import*\n  (syntax-rules ()\n    [(_ m) (begin)]\n    [(_ m (new old))\n     (module (new)\n       (module (tmp)\n         (import m)\n         (alias tmp old))\n       (alias new tmp))]\n    [(_ m id) (module (id) (import m))]\n    [(_ m spec0 spec1 ...)\n     (begin (import* m spec0) (import* m spec1 ...))]))\n\n" "To selectively import an identifier from module or library m, the import* form expands into an anonymous module that first imports all exports of m then re-exports only the selected identifier. To rename on import the macro expands into an anonymous module that instead exports an alias (Section 11.10) bound to the new name. \n\n" "If the output placed the definition of new in the same scope as the import of m, a naming conflict would arise whenever new is also present in the interface of m. To prevent this, the output instead places the import within a nested anonymous module and links old and new by means of an alias for the introduced identifier tmp.  \n\n" "The macro expands recursively to handle multiple import specifications. Each of the following examples imports cons as + and + as cons, which is probably not a very good idea.  \n\n" "" "(let ()\n  (import* scheme (+ cons) (cons +))\n  (+ (cons 1 2) (cons 3 4))) => (3 . 7) \n\n(let ()\n  (import* (rnrs) (+ cons) (cons +))\n  (+ (cons 1 2) (cons 3 4))) => (3 . 7)\n\n") ("libraries:s17" "syntax: (export export-spec ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "An export form is a definition and can appear with other definitions at the front of a library or module. It is a syntax error for an export form to appear in other contexts, including at top level or among the definitions of a top-level program or lambda body.  \n\n" "Each export-spec must take one of the following forms. \n\n" "" "identifier\n(rename (internal-name export-name) ...)\n(import import-spec ...)\n\n" "where each internal-name and export-name is an identifier. The first two are syntactically identical to library export-specs, while the third is syntactically identical to a Chez Scheme import form, which is an extension of the R6RS library import subform. The first form names a single export, identifier, whose export name is the same as its internal name. The second names a set of exports, each of whose export name is given explicitly and may differ from its internal name. \n\n" "For the third, the identifiers identified by the import form become exports, with aliasing, renaming, prefixing, etc., as specified by the import-specs. The module or library whose bindings are exported by an import form appearing within an export form can be defined within or outside the exporting module or library and need not be imported elsewhere within the exporting module or library. \n\n" "The following library exports a two-armed-only variant of if along with all remaining bindings of the (rnrs) library.  \n\n" "" "(library (rnrs-no-one-armed-if) (export) (import (except (chezscheme) if))\n  (export if (import (except (rnrs) if)))\n  (define-syntax if\n    (let ()\n      (import (only (rnrs) if))\n      (syntax-rules ()\n        [(_ tst thn els) (if tst thn els)])))) \n\n(import (rnrs-no-one-armed-if))\n(if #t 3 4) => 3\n(if #t 3) => exception: invalid syntax\n\n" "Another way to define the same library would be to define the two-armed-only if with a different internal name and use rename to export it under the name if:  \n\n" "" "(library (rnrs-no-one-armed-if) (export) (import (chezscheme))\n  (export (rename (two-armed-if if)) (import (except (rnrs) if)))\n  (define-syntax two-armed-if\n    (syntax-rules ()\n      [(_ tst thn els) (if tst thn els)]))) \n\n(import (rnrs-no-one-armed-if))\n(if #t 3 4) => 3\n(if #t 3) => exception: invalid syntax\n\n" "The placement of the export form in the library body is irrelevant, e.g., the export form can appear after the definition in the examples above. \n\n") ("libraries:s18" "syntax: (indirect-export id indirect-id ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This form is a definition and can appear wherever any other definition can appear. \n\n" "An indirect-export form declares that the named indirect-ids are indirectly exported to top level if id is exported to top level. \n\n" "In general, if an identifier is not directly exported by a library or module, it can be referenced outside of the library or module only in the expansion of a macro defined within and exported from the library or module. Even this cannot occur for libraries or modules defined at top level (or nested within other libraries or modules), unless either (1) the library or module has been set up to implicitly export all identifiers as indirect exports, or (2) each indirectly exported identifier is explicitly declared as an indirect export of some other identifier that is exported, either directly or indirectly, from the library or module, via an indirect-export or the built-in indirect export feature of a module export subform. By default, (1) is true for a library and false for a module, but the default can be overridden via the implicit-exports form, which is described below. \n\n" "This form is meaningful only within a top-level library, top-level module, or module enclosed within a library or top-level module, although it has no effect if the library or module already implicitly exports all bindings. It is allowed anywhere else definitions can appear, however, so macros that expand into indirect export forms can be used in any definition context. \n\n" "Indirect exports are listed so the compiler can determine the exact set of bindings (direct and indirect) that must be inserted into the top-level environment, and conversely, the set of bindings that may be treated more efficiently as local bindings (and perhaps discarded, if they are not used). \n\n" "In the example below, indirect-export is used to indirectly export count to top level when current-count is exported to top level. \n\n" "" "(module M (bump-count current-count)\n  (define-syntax current-count (identifier-syntax count))\n  (indirect-export current-count count)\n  (define count 0)\n  (define bump-count\n    (lambda ()\n      (set! count (+ count 1))))) \n\n(import M)\n(bump-count)\ncurrent-count => 1\ncount => exception: unbound identifier count\n\n" "An indirect-export form is not required to make count visible for bump-count, since it is a procedure whose code is contained within the module rather than a macro that might expand into a reference to count somewhere outside the module.  \n\n" "It is often useful to use indirect-export in the output of a macro that expands into another macro named a if a expands into references to identifiers that might not be directly exported, as illustrated by the alternative definition of module M above.  \n\n" "" "(define-syntax define-counter\n  (syntax-rules ()\n    [(_ getter bumper init incr)\n     (begin\n       (define count init)\n       (define-syntax getter (identifier-syntax count))\n       (indirect-export getter count)\n       (define bumper\n         (lambda ()\n           (set! count (incr count)))))])) \n\n(module M (bump-count current-count)\n  (define-counter current-count bump-count 0 add1))\n\n") ("libraries:s19" "syntax: (implicit-exports #t)\nsyntax: (implicit-exports #f)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "An implicit-exports form is a definition and can appear with other definitions at the front of a library or module. It is a syntax error for an implicit-exports form to appear in other contexts, including at top level or among the definitions of a top-level program or lambda body.  \n\n" "The implicit-exports form determines whether identifiers not directly exported from a module or library are automatically indirectly exported to the top level if any meta-binding (keyword, meta definition, or property definition) is directly exported to top level from the library or module. The default for libraries is #t, to match the behavior required by the Revised^6 Report, while the default for modules is #f. The implicit-exports form is meaningful only within a library, top-level module, or module enclosed within a library or top-level module. It is allowed in a module enclosed within a lambda, let, or similar body, but ignored there because none of that module's bindings can be exported to top level. \n\n" "The advantage of (implicit-exports #t) is that indirect exports need not be listed explicitly, which is convenient. A disadvantage is that it often results in more bindings than necessary being elevated to top level where they cannot be discarded as useless by the optimizer. For modules, another disadvantage is such bindings cannot be proven immutable, which inhibits important optimizations such as procedure inlining. This can result in significantly lower run-time performance. \n\n") ("libraries:s20" "procedure: (invoke-library libref)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "libref must be an s-expression in the form of a library reference. The syntax for library references is given in Chapter 10 of The Scheme Programming Language, 4th Edition and in the Revised^6Report. \n\n" "A library is implicitly invoked when or before some expression outside the library (e.g., in another library or in a top-level program) evaluates a reference to one of the library's exported variables. When the library is invoked, its body expressions (the right-hand-sides of the library's variable definitions and its initialization expressions) are evaluated. Once invoked, the library is not invoked again within the same process, unless it is first explicitly redefined or reloaded. \n\n" "invoke-library explicitly invokes the library specified by libref if it has not already been invoked or has since been redefined or reloaded. If the library has not yet been loaded, invoke-library first loads the library via the process described in Section 2.4. \n\n" "invoke-library is typically only useful for libraries whose body expressions have side effects. It is useful to control when the side effects occur and to force invocation of a library that has no exported variables. Invoking a library does not force the compile-time code (macro transformer expressions and meta definitions) to be loaded or evaluated, nor does it cause the library's bindings to become visible. \n\n" "It is good practice to avoid externally visible side effects in library bodies so the library can be used equally well at compile time and run time. When feasible, consider moving the side effects of a library body to an initialization routine and adding a top-level program that imports the library and calls the initialization routine. With this structure, calls to invoke-library on the library can be replaced by calls to  load-program on the top-level program. \n\n") ("libraries:s23" "thread parameter: library-directories \nthread parameter: library-extensions \nlibraries: (chezscheme)  \n\n" "The parameter library-directories determines where the files containing library source and object code are located in the file system, and the parameter library-extensions determines the filename extensions for the files holding the code, as described in section 2.4. The values of both parameters are lists of pairs of strings. The first string in each library-directories pair identifies a source-file root directory, and the second identifies the corresponding object-file root directory. Similarly, the first string in each library-extensions pair identifies a source-file extension, and the second identifies the corresponding object-file extension. The full path of a library source or object file consists of the source or object root followed by the components of the library name prefixed by slashes, with the library extension added on the end. For example, for root /usr/lib/scheme, library name (app lib1), and extension .sls, the full path is /usr/lib/scheme/app/lib1.sls. If the library name portion forms an absolute pathname, e.g., ~/.myappinit, the library-directories parameter is ignored and no prefix is added. \n\n" "The initial values of these parameters are shown below. \n\n" "" "(library-directories) => ((\".\" . \".\")) \n\n(library-extensions) => ((\".chezscheme.sls\" . \".chezscheme.so\")\n                         (\".ss\" . \".so\")\n                         (\".sls\" . \".so\")\n                         (\".scm\" . \".so\")\n                         (\".sch\" . \".so\"))\n\n" "As a convenience, when either of these parameters is set, any element of the list can be specified as a single source string, in which case the object string is determined automatically. For library-directories, the object string is the same as the source string, effectively naming the same directory as a source- and object-code root. For library-extensions, the object string is the result of removing the last (or only) extension from the string and appending \".so\". The library-directories and library-extensions parameters also accept as input strings in the format described in Section 2.5for the --libdirs and --libexts command-line options. \n\n") ("libraries:s26" "thread parameter: compile-imported-libraries \nlibraries: (chezscheme)  \n\n" "When the value of this parameter is #t, import automatically calls the value of the compile-library-handler parameter (which defaults to a procedure that simply calls compile-library) on any imported library if the object file is missing, older than the corresponding source file, older than any source files included (via include) when the object file was created, or itself requires a library that has been or must be recompiled, as described in Section 2.4. The library-timestamp-mode parameter controls the meaning of \"older.\" The default initial value of this parameter is #f. It can be set to #t via the command-line option --compile-imported-libraries.  \n\n" "When import compiles a library via this mechanism, it does not also load the compiled library, because this would cause portions of library to be reevaluated. Because of this, run-time expressions in the file outside of a library form will not be evaluated. If such expressions are present and should be evaluated, the library should be loaded explicitly. \n\n") ("libraries:s29" "thread parameter: import-notify \nlibraries: (chezscheme)  \n\n" "When the new parameter import-notify is set to a true value, import displays messages to the console-output port as it searches for the file containing each library it needs to load. The default value of this parameter is #f.  \n\n") ("libraries:s30" "thread parameter: library-search-handler \nlibraries: (chezscheme)  \n\n" "The value of parameter must be a procedure that follows the protocol described below for default-library-search-handler, which is the default value of this parameter. \n\n" "The value of this parameter is invoked to locate the source or object code for a library during import, compile-whole-program, or compile-whole-library.  \n\n") ("libraries:s31" "procedure: (default-library-search-handler who library directories extensions)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "This procedure is the default value of the library-search-handler, which is called to locate the source or object code for a library during import, compile-whole-program, or compile-whole-library. who is a symbol that provides context in import-notify messages. library is the name of the desired library. directories is a list of source and object directory pairs in the form returned by library-directories. extensions is a list of source and object extension pairs in the form returned by library-extensions.  \n\n" "This procedure searches the specified directories until it finds a library source or object file with one of the specified extensions. If it finds the source file first, it constructs the corresponding object file path and checks whether the file exists. If it finds the object file first, the procedure looks for a corresponding source file with one of the given source extensions in a source directory paired with that object directory. The procedure returns three values: the file-system path of the library source file or #f if not found, the file-system path of the corresponding object file, which may be #f, and a boolean that is true if the object file exists. \n\n") ("libraries:s32" "thread parameter: library-timstamp-mode \nlibraries: (chezscheme)  \n\n" "The value of parameter must be either 'modification-time (the default) or 'exists. If it is 'modification-time, the timestamp of library source and object files is obtained with file-modification-time to determine whether a file is older than the other. If the parameter's value is 'exists, then all files that exist are considered to have the same age. This parameter's value can be set to 'exists via the command-line option --disable-library-timestamps.  \n\n") ("libraries:s34" "procedure: (library-list) \nreturns: a list of the libraries currently defined \nlibraries: (chezscheme)  \n\n" "The set of libraries initially defined includes those listed in Section 10.1 above. \n\n") ("libraries:s35" "procedure: (library-version libref)\nreturns: the version of the specified library \nprocedure: (library-exports libref)\nreturns: a list of the exports of the specified library \nprocedure: (library-requirements libref)\nreturns: a list of libraries required by the specified library \nprocedure: (library-requirements libref options)\nreturns: a list of libraries required by the specified library, filtered by options \nprocedure: (library-object-filename libref)\nreturns: the name of the object file holding the specified library, if any \nlibraries: (chezscheme)  \n\n" "Information can be obtained only for built-in libraries or libraries previously loaded into the system. libref must be an s-expression in the form of a library reference. The syntax for library references is given in Chapter 10 of The Scheme Programming Language, 4th Edition and in the Revised^6Report. \n\n" "The library-version return value is a list of numbers (possibly empty) representing the library's version. \n\n" "The list of exports returned by library-exports is a list of symbols, each identifying one of the library's exports. The order in which the elements appear is unspecified. \n\n" "When the optional options argument is supplied, it must be an enumeration set over the symbols constituting valid library-requirements options, as described in the library-requirements-options entry below. It defaults to a set containing all of the options. Each element of the list of libraries returned by library-requirements is an s-expression form of a library reference. The library reference includes the actual version of the library that is present in the system (if nonempty), even if a version was not specified when it was imported. The order in which the libraries appear in the list returned by library-requirements is unspecified.  \n\n" "library-object-filename returns a string naming the object file if the specified library was loaded from or compiled to an object file. Otherwise, it returns #f.  \n\n" "" "(with-output-to-file \"A.ss\"\n  (lambda ()\n    (pretty-print\n      '(library (A (1 2)) (export x z)\n         (import (rnrs))\n         (define x 'ex)\n         (define y 23)\n         (define-syntax z\n           (syntax-rules ()\n             [(_ e) (+ y e)])))))\n  'replace)\n(with-output-to-file \"B.ss\"\n  (lambda ()\n    (pretty-print\n      '(library (B) (export x w)\n         (import (rnrs) (A))\n         (define w (cons (z 12) x)))))\n  'replace)\n(compile-imported-libraries #t)\n(import (B))\n(library-exports '(A)) => (x z) ; or (z x)\n(library-exports '(A (1 2))) => (x z) ; or (z x)\n(library-exports '(B)) => (x w) ; or (w x)\n(library-version '(A)) => (1 2)\n(library-version '(B)) => ()\n(library-requirements '(A)) => ((rnrs (6)))\n(library-requirements '(B)) => ((rnrs (6)) (A (1 2)))\n(library-object-filename '(A)) => \"A.so\"\n(library-object-filename '(B)) => \"B.so\"\n\n") ("libraries:s36" "syntax: (library-requirements-options symbol ...)\nreturns: a library-requirements-options enumeration set \nlibraries: (chezscheme)  \n\n" "Library-requirements-options enumeration sets are passed to library-requirements to determine the library requirements to be listed.  The available options are described below. \n\n" "\nimport:\n    Include the libraries that must be imported when the specified library is imported. \n\n" "\nvisit@visit:\n    Includes the libraries that must be visited when the specified library is visited. \n\n" "\ninvoke@visit:\n    Include the libraries that must be invoked when the specified library is visited. \n\n" "\ninvoke:\n    Includes the libraries that must be invoked when the specified library is invoked. \n\n" "") ("io:s9" "procedure: (utf-16-codec) \nprocedure: (utf-16-codec endianness)\nprocedure: (utf-16le-codec) \nprocedure: (utf-16be-codec) \nreturns: a codec \nlibraries: (chezscheme)  \n\n" "endianness must be the symbol big or the symbol little.  \n\n" "The codec returned by utf-16-codec can be used to create and process data written UTF-16 format. When called without the endianness argument or with endianness big, utf-16-codec returns a codec for standard UTF-16 data, i.e., one that defaults to big-endian format if no byte-order mark (BOM) is found. \n\n" "When output is transcoded with a transcoder based on this codec, a BOM is emitted just before the first character written, and each character is written as a UTF-16 character in big-endian format. For input, a BOM is looked for at the start of the input and, if present, controls the byte order of the remaining UTF-16 characters. If no BOM is present, big-endian order is assumed. For input-output ports, the BOM is not emitted if the file is read before written, and a BOM is not looked for if the file is written before read. \n\n" "For textual ports created via transcoded-port, a BOM written or read via the transcoder appears at the beginning of the underlying data stream or file only if the binary port passed to transcoded-port is positioned at the start of the data stream or file. When the transcoder can determine this is the case, it sets a flag that causes set-port-position! to position the port beyond the BOM if an attempt is made to reposition the port to the start of the data stream or file, so that the BOM is preserved. \n\n" "When called with endianness little, utf-16-codec returns a codec that defaults to the little-endian format both for reading and for writing. For output-only streams or input/output streams that are written before read, the result is standard UTF-16, with a BOM that specifies little-endian format followed by characters in little-endian byte order. For input-only streams or input/output streams that are read before written, this codec allows programs to read from input streams that either begin with a BOM or are encoded in UTF-16LE format. This is particularly useful for handling files that might have been produced by older Windows applications that claim to produce UTF-16 files but actually produce UTF-16LE files. \n\n" "The Revised^6 Report version of utf-16-codec lacks the optional endianness argument. \n\n" "The codecs returned by utf-16le-codec and utf-16be-codec are used to read and write data in the UTF-16LE and UTF-16BE formats, i.e., UTF-16 with little-endian or big-endian byte order and no BOM. For output, these codecs are useful for controlling whether and where the BOM is emitted, since no BOM is emitted implicitly and a BOM can be emitted explicitly as an ordinary character. For input, these codecs are useful for processing files known to be in little-endian or big-endian format with no BOM. \n\n") ("io:s10" "procedure: (iconv-codec code-page)\nreturns: a codec \nlibraries: (chezscheme)  \n\n" "code-page must be a string and should identify a codec accepted by the iconv library installed on the target machine. The codec returned by this procedure can be used to convert from the non-Unicode single- and multiple-byte character sets supported by iconv. When used in the input direction, the codec converts byte sequences into Scheme strings, and when used in the output direction, it converts Scheme strings to byte sequences. \n\n" "The set of supported code pages depends on the version of iconv available; consult the iconv documentation or use the shell command iconv --list to obtain a list of supported code pages. \n\n" "While the Windows operating system does not supply an iconv library, it is possible to use iconv-codec on Windows systems by supplying an iconv dynamic-link library (named iconv.dll, libiconv.dll, or libiconv-2.dll) that provides Posix-conformant iconv_open, iconv, and iconv_close entry points either under those names or under the alternative names libiconv_open, libiconv, and libiconv_close. The dll must be located in a standard location for dlls or in the current directory of the process the first time iconv-codec is called. \n\n") ("io:s11" "thread parameter: current-transcoder \nlibraries: (chezscheme)  \n\n" "The transcoder value of the current-transcoder parameter is used whenever a textual file is opened with an implicit transcoder, e.g., by open-input-file and other convenience I/O procedures, compile-file include, load, and pretty-file. Its initial value is the value of the native-transcoder procedure.  \n\n") ("io:s12" "procedure: (transcoder? obj)\nreturns: #t if obj is a transcoder, #f otherwise \nlibraries: (chezscheme)  \n\n") ("io:s13" "thread parameter: transcoded-port-buffer-size \nlibraries: (chezscheme)  \n\n" "transcoded-port-buffer-size is a parameter that specifies the size of the string buffer that is allocated when creating a new transcoded port. The value of this parameter must be a positive fixnum. When transcoding a binary input port that implements port-position, a transcoded input port maintains an fxvector the same size as its string buffer to support port-position on the transcoded port.  \n\n") ("io:s14" "thread parameter: make-codec-buffer \nlibraries: (chezscheme)  \n\n" "The value of make-codec-buffer must be a procedure. The procedure is invoked with the binary port bp when transcoded-port is called with a buffered port bp. The procedure must return a mutable bytevector of length at least four. The behavior of transcoded-port and its callers is unspecified if a continuation captured within the make-codec-buffer procedure is invoked multiple times. \n\n") ("io:s15" "procedure: (make-input-port handler input-buffer)\nprocedure: (make-output-port handler output-buffer)\nprocedure: (make-input/output-port handler input-buffer output-buffer)\nreturns: a new textual port \nlibraries: (chezscheme)  \n\n" "handler must be a procedure, and input-buffer and output-buffer must be strings. Each procedure creates a generic port. The handler associated with the port is handler, the input buffer is input-buffer, and the output buffer is output-buffer. For make-input-port, the output buffer is undefined, and for make-output-port, the input buffer is undefined.  \n\n" "The input size of an input or input/output port is initialized to the string length of the input buffer, and the input index is set to 0. The output size and index of an output or input/output port are initialized similarly. \n\n" "The length of an input or output buffer may be zero, in which case buffering is effectively disabled. \n\n") ("io:s17" "procedure: (port-handler port)\nreturns: a procedure \nlibraries: (chezscheme)  \n\n" "For generic ports, port-handler returns the handler passed to one of the generic port creation procedures described above. For ports created by open-input-file and similar procedures, port-handler returns an internal handler that may be invoked in the same manner as any other handler. \n\n") ("io:s18" "procedure: (port-input-buffer input-port)\nprocedure: (port-input-size input-port)\nprocedure: (port-input-index input-port)\nprocedure: (textual-port-input-buffer textual-input-port)\nprocedure: (textual-port-input-size textual-input-port)\nprocedure: (textual-port-input-index textual-input-port)\nprocedure: (binary-port-input-buffer binary-input-port)\nprocedure: (binary-port-input-size binary-input-port)\nprocedure: (binary-port-input-index binary-input-port)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "These procedures return the input buffer, size, or index of the input port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts. \n\n") ("io:s19" "procedure: (set-port-input-index! input-port n)\nprocedure: (set-port-input-size! input-port n)\nprocedure: (set-port-input-buffer! input-port x)\nprocedure: (set-textual-port-input-index! textual-input-port n)\nprocedure: (set-textual-port-input-size! textual-input-port n)\nprocedure: (set-textual-port-input-buffer! textual-input-port string)\nprocedure: (set-binary-port-input-index! binary-input-port n)\nprocedure: (set-binary-port-input-size! binary-input-port n)\nprocedure: (set-binary-port-input-buffer! binary-input-port bytevector)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "The procedure set-port-input-index! sets the input index field of input-port to n, which must be a nonnegative integer less than or equal to the port's input size. \n\n" "The procedure set-port-input-size! sets the input size field of input-port to n, which must be a nonnegative integer less than or equal to the string length of the port's input buffer. It also sets the input index to 0. \n\n" "The procedure set-port-input-buffer! sets the input buffer field of input-port to x, which must be a string for textual ports and a bytevector for binary ports. It also sets the input size to the length of the string or bytevector and the input index to 0. \n\n" "The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts. \n\n") ("io:s20" "procedure: (port-input-count input-port)\nprocedure: (textual-port-input-count textual-input-port)\nprocedure: (binary-port-input-count binary-input-port)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "These procedures return an exact integer representing the number of characters or bytes left to be read from the port's input buffer, i.e., the difference between the buffer size and index. \n\n" "The variants specialized to textual or binary ports are slightly more efficient than their generic counterpart. \n\n") ("io:s21" "procedure: (port-input-empty? input-port)\nreturns: #t if the port's input buffer contains no more data, otherwise #f \nlibraries: (chezscheme)  \n\n" "This procedure determines whether the port's input count is zero without computing or returning the actual count. \n\n") ("io:s22" "procedure: (port-output-buffer output-port)\nprocedure: (port-output-size output-port)\nprocedure: (port-output-index output-port)\nprocedure: (textual-port-output-buffer output-port)\nprocedure: (textual-port-output-size output-port)\nprocedure: (textual-port-output-index output-port)\nprocedure: (binary-port-output-buffer output-port)\nprocedure: (binary-port-output-size output-port)\nprocedure: (binary-port-output-index output-port)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "These procedures return the output buffer, size, or index of the output port. The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts. \n\n") ("io:s23" "procedure: (set-port-output-index! output-port n)\nprocedure: (set-port-output-size! output-port n)\nprocedure: (set-port-output-buffer! output-port x)\nprocedure: (set-textual-port-output-index! textual-output-port n)\nprocedure: (set-textual-port-output-size! textual-output-port n)\nprocedure: (set-textual-port-output-buffer! textual-output-port string)\nprocedure: (set-binary-port-output-index! output-port n)\nprocedure: (set-binary-port-output-size! output-port n)\nprocedure: (set-binary-port-output-buffer! binary-output-port bytevector)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "The procedure set-port-output-index! sets the output index field of the output port to n, which must be a nonnegative integer less than or equal to the port's output size. \n\n" "The procedure set-port-output-size! sets the output size field of the output port to n, which must be a nonnegative integer less than or equal to the string length of the port's output buffer. It also sets the output index to 0. \n\n" "The procedure set-port-output-buffer! sets the output buffer field of output-port to x, which must be a string for textual ports and a bytevector for binary ports. It also sets the output size to the length of the string or bytevector and the output index to 0. \n\n" "The variants specialized to textual or binary ports are slightly more efficient than their generic counterparts. \n\n") ("io:s24" "procedure: (port-output-count output-port)\nprocedure: (textual-port-output-count textual-output-port)\nprocedure: (binary-port-output-count binary-output-port)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "These procedures return an exact integer representing the amount of space in characters or bytes available to be written in the port's output buffer, i.e., the difference between the buffer size and index. \n\n" "The variants specialized to textual or binary ports are slightly more efficient than their generic counterpart. \n\n") ("io:s25" "procedure: (port-output-full? output-port)\nreturns: #t if the port's input buffer has no more room, otherwise #f \nlibraries: (chezscheme)  \n\n" "This procedure determines whether the port's output count is zero without computing or returning the actual count. \n\n") ("io:s26" "procedure: (mark-port-closed! port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedure directly marks the port closed so that no further input or output operations are allowed on it. It is typically used by handlers upon receipt of a close-port message. \n\n") ("io:s27" "procedure: (port-closed? port)\nreturns: #t if port is closed, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(let ([p (open-output-string)])\n  (port-closed? p)) => #f \n\n(let ([p (open-output-string)])\n  (close-port p)\n  (port-closed? p)) => #t\n\n") ("io:s28" "procedure: (set-port-bol! output-port obj)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "When obj is #f, the port's beginning-of-line (BOL) flag is cleared; otherwise, the port's BOL flag is set. \n\n" "The BOL flag is consulted by fresh-line (page 270) to determine if it needs to emit a newline. This flag is maintained automatically for file output ports, string output ports, and transcript ports. The flag is set for newly created file and string output ports, except for file output ports created with the append option, for which the flag is reset. The BOL flag is clear for newly created generic ports and never set automatically, but may be set explicitly using set-port-bol!. The port is always flushed immediately before the flag is consulted, so it need not be maintained on a per-character basis for buffered ports. \n\n") ("io:s29" "procedure: (port-bol? port)\nreturns: #t if port's BOL flag is set, #f otherwise \nlibraries: (chezscheme)  \n\n") ("io:s30" "procedure: (set-port-eof! input-port obj)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "When obj is not #f, set-port-eof! marks input-port so that, once its buffer is empty, the port is treated as if it were at eof even if more data is available in the underlying byte or character stream. Once this artificial eof has been read, the eof mark is cleared, making any additional data in the stream available beyond the eof. This feature can be used by a generic port to simulate a stream consisting of multiple input files. \n\n" "When obj is #f, the eof mark is cleared.  \n\n" "The following example assumes /dev/zero provides an infinite stream of zero bytes. \n\n" "" "(define p\n  (parameterize ([file-buffer-size 3])\n    (open-file-input-port \"/dev/zero\")))\n(set-port-eof! p #t)\n(get-u8 p) => #!eof\n(get-u8 p) => 0\n(set-port-eof! p #t)\n(get-u8 p) => 0\n(get-u8 p) => 0\n(get-u8 p) => #!eof\n(get-u8 p) => 0\n\n") ("io:s31" "procedure: (port-name port)\nreturns: the name associated with port \nlibraries: (chezscheme)  \n\n" "The name may be any object but is usually a string or #f (denoting no name). For file ports, the name is typically a string naming the file. \n\n" "" "(let ([p (open-input-file \"myfile.ss\")])\n  (port-name p)) => \"myfile.ss\" \n\n(let ([p (open-output-string)])\n  (port-name p)) => \"string\"\n\n") ("io:s32" "procedure: (set-port-name! port obj)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedure sets port's name to obj, which should be a string or #f (denoting no name).  \n\n") ("io:s33" "procedure: (port-length port)\nprocedure: (file-length port)\nreturns: the length of the file or other object to which port refers \nprocedure: (port-has-port-length? port)\nreturns: #t if the port supports port-length, #f otherwise \nlibraries: (chezscheme)  \n\n" "A port may allow the length of the underlying stream of characters or bytes to be determined. If so, the procedure port-has-port-length? returns #t and port-length returns the current length. For binary ports, the length is always an exact nonnegative integer byte count. For textual ports, the representation of a length is unspecified; it may not be an exact nonnegative integer and, even if it is, it may not represent either a byte or character count. The length may be used at some later time to reset the length if the port supports set-port-length!. If port-length is called on a port that does not support it, an exception with condition type &assertion is raised.  \n\n" "File lengths beyond 2^32 might not be reported property for compressed files on 32-bit versions of the system. \n\n" "file-length is identical to port-length.  \n\n") ("io:s34" "procedure: (set-port-length! port len)\nreturns: unspecified \nprocedure: (port-has-set-port-length!? port)\nreturns: #t if the port supports set-port-length!, #f otherwise \nlibraries: (chezscheme)  \n\n" "A port may allow the length of the underlying stream of characters or bytes to be set, i.e., extended or truncated. If so, the procedure port-has-set-port-length!? returns #t and set-port-length! changes the length. For binary ports, the length len must be an exact nonnegative integer byte count. For textual ports, the representation of a length is unspecified, as described in the entry for port-length above, but len must be an appropriate length for the textual port, which is usually guaranteed to be the case only if it was obtained from a call to port-length on the same port. If set-port-length! is called on a port that does not support it, an exception with condition type &assertion is raised.  \n\n" "It is not possible to set the length of a port opened with compression to an arbitrary position, and the result of an attempt to set the length of a compressed file beyond 2^32 on 32-bit versions of the system is undefined. \n\n") ("io:s35" "procedure: (port-nonblocking? port)\nreturns: #t if the port is in nonblocking mode, #f otherwise \nprocedure: (port-has-port-nonblocking?? port)\nreturns: #t if the port supports port-nonblocking?, #f otherwise \nlibraries: (chezscheme)  \n\n" "A port may allow the nonblocking status of the port to be determined. If so, the procedure port-has-port-nonblocking?? returns #t and port-nonblocking? returns a boolean value reflecting whether the port is in nonblocking mode. \n\n") ("io:s36" "procedure: (set-port-nonblocking! port obj)\nreturns: unspecified \nprocedure: (port-has-set-port-nonblocking!? port)\nreturns: #t if the port supports set-port-nonblocking!, #f otherwise \nlibraries: (chezscheme)  \n\n" "A port may allow reads or writes to be performed in a \"nonblocking\" fashion. If so, the procedure port-has-set-port-nonblocking!? returns #t and set-port-nonblocking! sets the port to nonblocking mode (if obj is a true value) or blocking mode (if obj is #f). If set-port-nonblocking! is called on a port that does not support it, an exception with condition type &assertion is raised.  \n\n" "Ports created by the standard Revised^6 port opening procedures are initially set in blocking mode by default. The same is true for most of the procedures described in this document. A generic port based on a nonblocking source may be nonblocking initially. A port returned by open-fd-input-port, open-fd-output-port, or open-fd-input/output-port is initially in nonblocking mode if the file-descriptor passed in is in nonblocking mode. Similarly, a port returned by standard-input-port, standard-output-port, or standard-error-port is initially in nonblocking mode if the underlying stdin, stdout, or stderr file descriptor is in nonblocking mode. \n\n" "Although get-bytevector-some and get-string-some normally cannot return an empty bytevector or empty string, they can if the port is in nonblocking mode and no input is available. Also, get-bytevector-some! and get-string-some! may not read any data if the port is in nonblocking mode and no data is available. Similarly, put-bytevector-some and put-string-some may not write any data if the port is in nonblocking mode and no room is available. \n\n" "Nonblocking mode is not supported under Windows. \n\n") ("io:s37" "procedure: (file-position port)\nprocedure: (file-position port pos)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "When the second argument is omitted, this procedure behaves like the R6RS port-position procedure, and when present, like the R6RS set-port-position! procedure.  \n\n" "For compressed files opened with the compressed flag, file-position returns the position in the uncompressed stream of data. Changing the position of a compressed input file opened with the compressed flag generally requires rewinding and rereading the file and might thus be slow. The position of a compressed output file opened with the compressed flag can be moved forward only; this is accomplished by writing a (compressed) sequence of zeros. File positions beyond 2^32 might not be reported property for compressed files on 32-bit versions of the system. \n\n") ("io:s38" "procedure: (clear-input-port) \nprocedure: (clear-input-port input-port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "If input-port is not supplied, it defaults to the current input port. This procedure discards any data in the buffer associated with input-port. This may be necessary, for example, to clear any type-ahead from the keyboard in preparation for an urgent query. \n\n") ("io:s39" "procedure: (clear-output-port) \nprocedure: (clear-output-port output-port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "If output-port is not supplied, it defaults to the current output port. This procedure discards any data in the buffer associated with output-port. This may be necessary, for example, to clear any pending output on an interactive port in preparation for an urgent message. \n\n") ("io:s40" "procedure: (flush-output-port) \nprocedure: (flush-output-port output-port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "If output-port is not supplied, it defaults to the current output port. This procedure  forces any data in the buffer associated with output-port to be printed immediately. The console output port is automatically flushed after a newline and before input from the console input port; all ports are automatically flushed when they are closed. flush-output-port may be necessary, however, to force a message without a newline to be sent to the console output port or to force output to appear on a file without delay. \n\n") ("io:s41" "procedure: (port-file-compressed! port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "port must be an input or an output port, but not an input/output port. It must be a file port pointing to a regular file, i.e., a file on disk rather than, e.g., a socket. The port can be a binary or textual port. If the port is an output port, subsequent output sent to the port will be compressed. If the port is an input port, subsequent input will be decompressed if and only if the port is currently pointing at compressed data. The compression format for output is determined by the compress-format parameter, while the compression format on input is inferred. The compression level, which is relevant only for output, is determined by the compress-level parameter. This procedure has no effect if the port is already set for compression. \n\n") ("io:s44" "thread parameter: compress-format \nlibraries: (chezscheme)  \n\n" "compress-format determines the compression algorithm and format used for output. Currently, the possible values of the parameter are the symbols lz4 (the default) and gzip.  \n\n" "The lz4 format uses the LZ4 compression library developed by Yann Collet. It is therefore compatible with the lz4 program, which means that lz4 may be used to uncompress files produced by Chez Scheme and visa versa. \n\n" "The gzip format uses the zlib compression library developed by Jean-loup Gailly and Mark Adler. It is therefore compatible with the gzip program, which means that gzip may be used to uncompress files produced by Chez Scheme and visa versa. \n\n" "Reading lz4-compressed data tends to be much faster than reading gzip-compressed data, while gzip-compressed data tends to  be significantly smaller. \n\n") ("io:s45" "thread parameter: compress-level \nlibraries: (chezscheme)  \n\n" "compress-level determines the amount of effort spent on compression and is thus relevant only for output. It can be set to one of the symbols minimum, low, medium, high, or maximum, which are listed in order from shortest to longest expected compression time and least to greatest expected effectiveness. Its default value is medium.  \n\n") ("io:s46" "procedure: (open-input-string string)\nreturns: a new string input port \nlibraries: (chezscheme)  \n\n" "A string input port is similar to a file input port, except that characters and objects drawn from the port come from string rather than from a file. \n\n" "A string port is at \"end of file\" when the port reaches the end of the string. It is not necessary to close a string port, although it is okay to do so. \n\n" "" "(let ([p (open-input-string \"hi mom!\")])\n  (let ([x (read p)])\n    (list x (read p)))) => (hi mom!)\n\n") ("io:s48" "procedure: (with-input-from-string string thunk)\nreturns: the values returned by thunk \nlibraries: (chezscheme)  \n\n" "thunk must be a procedure and should accept zero arguments. with-input-from-string parameterizes the current input port to be the result of opening string for input during the application of thunk. \n\n" "" "(with-input-from-string \"(cons 3 4)\"\n  (lambda ()\n    (eval (read)))) => (3 . 4)\n\n") ("io:s49" "procedure: (open-output-string) \nreturns: a new string output port \nlibraries: (chezscheme)  \n\n" "A string output port is similar to a file output port, except that characters and objects written to the port are placed in a string (which grows as needed) rather than to a file. The string built by writing to a string output port may be obtained with get-output-string. See the example given for get-output-string below. It is not necessary to close a string port, although it is okay to do so. \n\n") ("io:s51" "procedure: (get-output-string string-output-port)\nreturns: the string associated with string-output-port \nlibraries: (chezscheme)  \n\n" "string-output-port must be an port returned by open-output-string.  \n\n" "As a side effect, get-output-string resets string-output-port so that subsequent output to string-output-port is placed into a fresh string. \n\n" "" "(let ([p (open-output-string)])\n  (write 'hi p)\n  (write-char #\\space p)\n  (write 'mom! p)\n  (get-output-string p)) => \"hi mom!\"\n\n" "An implementation of format (Section 9.13) might be written using string-output ports to produce string output. \n\n") ("io:s52" "procedure: (with-output-to-string thunk)\nreturns: a string containing the output \nlibraries: (chezscheme)  \n\n" "thunk must be a procedure and should accept zero arguments. with-output-to-string parameterizes the current output port to a new string output port during the application of thunk. If thunk returns, the string associated with the new string output port is returned, as with get-output-string.  \n\n" "" "(with-output-to-string\n   (lambda ()\n    (display \"Once upon a time ...\")\n    (newline))) => \"Once upon a time ...\\n\"\n\n") ("io:s53" "thread parameter: file-buffer-size \nlibraries: (chezscheme)  \n\n" "file-buffer-size is a parameter that determines the size of each buffer created when the buffer mode is not none for a port created by one of the file open operations, e.g., open-input-file or open-file-output-port. The value of this parameter must be a positive fixnum. \n\n") ("io:s54" "procedure: (file-port? port)\nreturns: #t if port is a file port, #f otherwise \nlibraries: (chezscheme)  \n\n" "A file port is any port based directly on an O/S file descriptor, e.g., one created by open-file-input-port, open-output-port, open-fd-input-port, etc., but not a string, bytevector, or custom  port. \n\n") ("io:s55" "procedure: (port-file-descriptor port)\nreturns: the file descriptor associated with port \nlibraries: (chezscheme)  \n\n" "port must be a file port, i.e., a port for which file-port? returns #t.  \n\n") ("io:s56" "thread parameter: custom-port-buffer-size \nlibraries: (chezscheme)  \n\n" "custom-port-buffer-size is a parameter that determines the sizes of the buffers associated with newly created custom ports. The value of this parameter must be a positive fixnum. \n\n") ("io:s57" "global parameter: console-input-port \nlibraries: (chezscheme)  \n\n" "console-input-port is a parameter that determines the input port used by the waiter and interactive debugger. When called with no arguments, it returns the console input port. When called with one argument, which must be a textual input port, it changes the value of the console input port. The initial value of this parameter is a port tied to the standard input (stdin) stream of the Scheme process. \n\n") ("io:s58" "thread parameter: current-input-port \nlibraries: (chezscheme)  \n\n" "current-input-port is a parameter that determines the default port argument for most input procedures, including read-char, peek-char, and read, When called with no arguments, current-input-port returns the current input port. When called with one argument, which must be a textual input port, it changes the value of the current input port. The Revised^6 Report version of current-input-port accepts only zero arguments, i.e., it cannot be used to change the current input port. The initial value of this parameter is the same port as the initial value of console-input-port.  \n\n") ("io:s59" "procedure: (open-input-file path)\nprocedure: (open-input-file path options)\nreturns: a new input port \nlibraries: (chezscheme)  \n\n" "path must be a string. open-input-file opens a textual input port for the file named by path. An exception is raised with condition type &i/o-filename if the file does not exist or cannot be opened for input. \n\n" "options, if present, is a symbolic option name or option list. Possible symbolic option names are  compressed, uncompressed, buffered, and unbuffered. An option list is a list containing zero or more symbolic option names. \n\n" "The mutually exclusive compressed and uncompressed options determine whether the input file should be decompressed if it is compressed (where the compression format is inferred). (See open-output-file.) The default is uncompressed, so the uncompressed option is useful only as documentation. \n\n" "The mutually exclusive buffered and unbuffered options determine whether input is buffered. When input is buffered, it is read in large blocks and buffered internally for efficiency to reduce the number of operating system requests. When the unbuffered option is specified, input is unbuffered, but not fully, since one character of buffering is required to support peek-char and unread-char. Input is buffered by default, so the buffered option is useful only as documentation. \n\n" "For example, the call \n\n" "" "(open-input-file \"frob\" '(compressed))\n\n" "opens the file frob with decompression enabled. \n\n" "The Revised^6 Report version of open-input-file does not support the optional options argument. \n\n") ("io:s60" "procedure: (call-with-input-file path procedure)\nprocedure: (call-with-input-file path procedure options)\nreturns: the values returned by procedure \nlibraries: (chezscheme)  \n\n" "path must be a string. procedure should accept one argument. \n\n" "call-with-input-file creates a new input port for the file named by path, as if with open-input-file, and passes this port to procedure. If procedure returns normally, call-with-input-file closes the input port and returns the values returned by procedure. \n\n" "call-with-input-file does not automatically close the input port if a continuation created outside of procedure is invoked, since it is possible that another continuation created inside of procedure will be invoked at a later time, returning control to procedure. If procedure does not return, an implementation is free to close the input port only if it can prove that the input port is no longer accessible. As shown in Section 5.6 of The Scheme Programming Language, 4th Edition, dynamic-wind may be used to ensure that the port is closed if a continuation created outside of procedure is invoked. \n\n" "See open-input-file above for a description of the optional options argument. \n\n" "The Revised^6 Report version of call-with-input-file does not support the optional input argument. \n\n") ("io:s61" "procedure: (with-input-from-file path thunk)\nprocedure: (with-input-from-file path thunk options)\nreturns: the values returned by thunk \nlibraries: (chezscheme)  \n\n" "path must be a string. thunk must be a procedure and should accept zero arguments. \n\n" "with-input-from-file temporarily changes the current input port to be the result of opening the file named by path, as if with open-input-file, during the application of thunk. If thunk returns, the port is closed and the current input port is restored to its old value. \n\n" "The behavior of with-input-from-file is unspecified if a continuation created outside of thunk is invoked before thunk returns. An implementation may close the port and restore the current input port to its old value---but it may not. \n\n" "See open-input-file above for a description of the optional options argument. \n\n" "The Revised^6 Report version of with-input-from-file does not support the optional options argument. \n\n") ("io:s62" "procedure: (open-fd-input-port fd)\nprocedure: (open-fd-input-port fd b-mode)\nprocedure: (open-fd-input-port fd b-mode ?transcoder)\nreturns: a new input port for the file descriptor fd \nlibraries: (chezscheme)  \n\n" "fd must be a nonnegative exact integer and should be a valid open file descriptor. If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual input port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary input port. See the lead-in to Section 7.2 of The Scheme Programming Language, 4th Editionfor a description of the constraints on and effects of the other arguments. \n\n" "The file descriptor is closed when the port is closed. \n\n") ("io:s63" "procedure: (standard-input-port) \nprocedure: (standard-input-port b-mode)\nprocedure: (standard-input-port b-mode ?transcoder)\nreturns: a new input port connected to the process's standard input \nlibraries: (chezscheme)  \n\n" "If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual input port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary input port. The buffer mode b-mode defaults to block.  \n\n" "The Revised^6 Report version of this procedure does not accept the optional b-mode and ?transcoder arguments, which limits it to an implementation-dependent buffering mode (block in Chez Scheme) and binary output. \n\n") ("io:s64" "procedure: (get-string-some textual-input-port)\nreturns: a nonempty string or the eof object \nlibraries: (chezscheme)  \n\n" "If textual-input-port is at end of file, the eof object is returned. Otherwise, get-string-some reads (as if with get-u8) at least one character and possibly more, and returns a string containing these characters. The port's position is advanced past the characters read. The maximum number of characters read by this operation is implementation-dependent. \n\n" "An exception to the \"at least one character\" guarantee occurs if the port is in nonblocking mode (see set-port-nonblocking!) and no input is ready. In this case, an empty string is returned. \n\n") ("io:s65" "procedure: (get-string-some! textual-input-port string start n)\nreturns: the count of characters read, as an exact nonnegative integer, or the eof object \nlibraries: (chezscheme)  \n\n" "start and n must be exact nonnegative integers, and the sum of start and n must not exceed the length of string. \n\n" "If n is 0, this procedure returns zero without attempting to read from textual-input-port and without modifying string. \n\n" "Otherwise, if textual-input-port is at end of file, this procedure returns the eof object, except it returns zero when the port is in nonblocking mode (see set-port-nonblocking!) and the port cannot be determined to be at end of file without blocking. In either case, string is not modified. \n\n" "Otherwise, this procedure reads (as if with get-char) up to n characters from the port, stores the characters in consecutive locations of string starting at start, advances the port's position just past the characters read, and returns the count of characters read. \n\n" "If the port is in nonblocking mode, this procedure reads no more than it can without blocking and thus might read zero characters; otherwise, it reads at least one character but no more than are available when the first character becomes available. \n\n") ("io:s66" "procedure: (get-bytevector-some! binary-input-port bytevector start n)\nreturns: the count of bytes read, as an exact nonnegative integer, or the eof object \nlibraries: (chezscheme)  \n\n" "start and n must be exact nonnegative integers, and the sum of start and n must not exceed the length of bytevector. \n\n" "If n is 0, this procedure returns zero without attempting to read from binary-input-port and without modifying bytevector. \n\n" "Otherwise, if binary-input-port is at end of file, this procedure returns the eof object, except it returns zero when the port is in nonblocking mode (see set-port-nonblocking!) and the port cannot be determined to be at end of file without blocking. In either case, bytevector is not modified. \n\n" "Otherwise, this procedure reads (as if with get-u8) up to n bytes from the port, stores the bytes in consecutive locations of bytevector starting at start, advances the port's position just past the bytes read, and returns the count of bytes read. \n\n" "If the port is in nonblocking mode, this procedure reads no more than it can without blocking and thus might read zero bytes; otherwise, it reads at least one byte but no more than are available when the first byte becomes available. \n\n") ("io:s67" "procedure: (unread-char char)\nprocedure: (unread-char char textual-input-port)\nprocedure: (unget-char textual-input-port char)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "For unread-char, if textual-input-port is not supplied, it defaults to the current input port. These procedures \"unread\" the last character read from textual-input-port. char may or may not be ignored, depending upon the implementation. In any case, char should be last character read from the port. A character should not be unread twice on the same port without an intervening call to read-char or get-char.  \n\n" "unread-char and unget-char are provided for applications requiring one character of lookahead and may be used in place of, or even in combination with, peek-char or lookahead-char. One character of lookahead is required in the procedure read-word, which is defined below in terms of unread-char. read-word returns the next word from a textual input port as a string, where a word is defined to be a sequence of alphabetic characters. Since it does not know until it reads one character too many that it has read the entire word, read-word uses unread-char to return the character to the input port. \n\n" "" "(define read-word\n  (lambda (p)\n    (list->string\n      (let f ([c (read-char p)])\n        (cond\n          [(eof-object? c) '()]\n          [(char-alphabetic? c)\n           (cons c (f (read-char p)))]\n          [else\n           (unread-char c p)\n           '()])))))\n\n" "In the alternate version below, peek-char is used instead of unread-char.  \n\n" "" "(define read-word\n  (lambda (p)\n    (list->string\n      (let f ([c (peek-char p)])\n        (cond\n          [(eof-object? c) '()]\n          [(char-alphabetic? c)\n           (read-char p)\n           (cons c (f (peek-char p)))]\n          [else '()])))))\n\n" "The advantage of unread-char in this situation is that only one call to unread-char per word is required, whereas one call to peek-char is required for each character in the word plus the first character beyond. In many cases, unread-char and unget-char do not enjoy this advantage, and peek-char or lookahead-char should be used instead. \n\n") ("io:s68" "procedure: (unget-u8 binary-input-port octet)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedures \"unreads\" the last byte read from binary-input-port. octet may or may not be ignored, depending upon the implementation. In any case, octet should be last byte read from the port. A byte should not be unread twice on the same port without an intervening call to get-u8.  \n\n") ("io:s69" "procedure: (input-port-ready? input-port)\nreturns: #t if data is available on input-port, #f otherwise \nlibraries: (chezscheme)  \n\n" "input-port-ready? allows a program to check to see if input is available on a textual or binary input port without hanging. If input is available or the port is at end of file, input-port-ready? returns #t. If it cannot determine from the port whether input is ready,  input-port-ready? raises an exception with condition type &i/o-read-error. Otherwise, it returns #f.  \n\n") ("io:s70" "procedure: (char-ready?) \nprocedure: (char-ready? textual-input-port)\nreturns: #t if a character is available on textual-input-port, #f otherwise \nlibraries: (chezscheme)  \n\n" "If textual-input-port is not supplied, it defaults to the current input port. char-ready? is like input-port-ready? except it is restricted to textual input ports. \n\n") ("io:s71" "procedure: (block-read textual-input-port string)\nprocedure: (block-read textual-input-port string count)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "count must be a nonnegative fixnum less than or equal to the length of string. If not provided, it defaults to the length of string. \n\n" "If textual-input-port is at end-of-file, an eof object is returned. Otherwise, string is filled with as many characters as are available for reading from textual-input-port up to count, and the number of characters placed in the string is returned. \n\n" "If textual-input-port is buffered and the buffer is nonempty, the buffered input or a portion thereof is returned; otherwise block-read bypasses the buffer entirely.  \n\n") ("io:s72" "procedure: (read-token) \nprocedure: (read-token textual-input-port)\nprocedure: (read-token textual-input-port sfd bfp)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "sfd must be a source-file descriptor. bfp must be an exact nonnegative integer and should be the character position of the next character to be read from textual-input-port. \n\n" "Parsing of a Scheme datum is conceptually performed in two steps. First, the sequence of characters that form the datum are grouped into tokens, such as symbols, numbers, left parentheses, and double quotes. During this first step, whitespace and comments are discarded. Second, these tokens are grouped into data. \n\n" "read performs both of these steps and creates an internal representation of each datum it parses. read-token may be used to perform the first step only, one token at a time. read-token is intended to be used by editors and program formatters that must be able to parse a program or datum without actually reading it. \n\n" "If textual-input-port is not supplied, it defaults to the current input port. One token is read from the input port and returned as four values: \n\n" "\ntype:\n     a symbol describing the type of token read, \n\n" "\nvalue:\n     the token value, \n\n" "\nstart:\n     the position of the first character of the token, relative to the starting position of the input port (or #f, if the position cannot be determined), and \n\n" "\nend:\n     the first position beyond the token, relative to the starting position of the input port (or #f, if the position cannot be determined). \n\n" "The input port is left pointing to the first character position beyond the token. \n\n" "When the token type fully specifies the token, read-token returns #f for the value. The token types are listed below with the corresponding value in parentheses. \n\n" "\natomic\n     (atom) an atomic value, i.e.,      a symbol, boolean, number, character, #!eof,     or #!bwp \nbox\n     (#f) box prefix, i.e.,  #& \ndot\n     (#f) dotted pair separator, i.e., . \neof\n     (#!eof) end of file \nfasl\n     (#f) fasl prefix, i.e., #@ \ninsert\n     (n) graph reference, i.e., #n#\nlbrack\n     (#f) open square bracket \nlparen\n     (#f) open parenthesis \nmark\n     (n) graph mark, i.e., #n=\nquote\n     (quote, quasiquote,     syntax, unquote, unquote-splicing,     or datum-comment)     an abbreviation mark, e.g., ' or ,@ or     datum-comment prefix \nrbrack\n     (#f) close square bracket \nrecord-brack\n     (#f) record open bracket, i.e., #[ \nrparen\n     (#f) close parenthesis \nvfxnparen\n     (n) fxvector prefix, i.e., #nvfx(\nvfxparen\n     (#f) fxvector prefix, i.e., #vfx( \nvnparen\n     (n) vector prefix, i.e., #n(\nvparen\n     (#f) vector prefix, i.e., #( \nvu8nparen\n     (n) bytevector prefix, i.e., #nvu8(\nvu8paren\n     (#f) bytevector prefix, i.e., #vu8(  \n\n" "The set of token types is likely to change in future releases of the system; check the release notes for details on such changes. \n\n" "Specifying sfd and bfp improves the quality of error messages, guarantees start and end can be determined, and eliminates the overhead of asking for a file position on each call to read-token. In most cases, bfp should be 0 for the first call to read-token at the start of a file, and it should be the fourth return value (end) of the preceding call to read-token for each subsequent call. This protocol is necessary to handle files containing multiple-byte characters, since file positions do not necessarily correspond to character positions. \n\n" "" "(define s (open-input-string \"(a b c)\"))\n(read-token s) => lparen\n                   #f\n                   0\n                   1\n(define s (open-input-string \"abc 123\"))\n(read-token s) => atomic\n                   abc\n                   0\n                   3\n(define s (open-input-string \"\"))\n(read-token s) => eof\n                   #!eof\n                   0\n                   0\n(define s (open-input-string \"#7=#7#\"))\n(read-token s) => mark\n                   7\n                   0\n                   3\n(read-token s) => insert\n                   7\n                   3\n                   6\n\n" "The information read-token returns is not always sufficient for reconstituting the exact sequence of characters that make up a token. For example, 1.0 and 1e0 both return type atomic with value 1.0. The exact sequence of characters may be obtained only by repositioning the port and reading a block of characters of the appropriate length, using the relative positions given by start and end. \n\n") ("io:s73" "global parameter: console-output-port \nlibraries: (chezscheme)  \n\n" "console-output-port is a parameter that determines the output port used by the waiter and interactive debugger. When called with no arguments, it returns the console output port. When called with one argument, which must be a textual output port, it changes the value of the console output port. The initial value of this parameter is a port tied to the standard output (stdout) stream of the Scheme process. \n\n") ("io:s74" "thread parameter: current-output-port \nlibraries: (chezscheme)  \n\n" "current-output-port is a parameter that determines the default port argument for most output procedures, including write-char, newline, write, display, and pretty-print. When called with no arguments, current-output-port returns the current output port. When called with one argument, which must be a textual output port, it changes the value of the current output port. The Revised^6 Report version of current-output-port accepts only zero arguments, i.e., it cannot be used to change the current output port. The initial value of this parameter is the same port as the initial value of console-output-port.  \n\n") ("io:s75" "thread parameter: console-error-port \nlibraries: (chezscheme)  \n\n" "console-error-port is a parameter that can be used to set or obtain the console error port, which determines the port to which conditions and other messages are printed by the default exception handler. When called with no arguments, console-error-port returns the console error port. When called with one argument, which must be a textual output port, it changes the value of the console error port. \n\n" "If the system determines that the standard output (stdout) and standard error (stderr) streams refer to the same file, socket, pipe, virtual terminal, device, etc., this parameter is initially set to the same value as the parameter console-output-port. Otherwise, this parameter is initially set to a different port tied to the standard error (stderr) stream of the Scheme process. \n\n") ("io:s76" "thread parameter: current-error-port \nlibraries: (chezscheme)  \n\n" "current-error-port is a parameter that can be used to set or obtain the current error port. When called with no arguments, current-error-port returns the current error port. When called with one argument, which must be a textual output port, it changes the value of the current error port. The Revised^6 Report version of current-error-port accepts only zero arguments, i.e., it cannot be used to change the current error port. The initial value of this parameter is the same port as the initial value of console-error-port.  \n\n") ("io:s77" "procedure: (open-output-file path)\nprocedure: (open-output-file path options)\nreturns: a new output port \nlibraries: (chezscheme)  \n\n" "path must be a string. open-output-file opens a textual output port for the file named by path. \n\n" "options, if present, is a symbolic option name or option list. Possible symbolic option names are  error, truncate, replace, append, compressed, uncompressed, buffered, unbuffered, exclusive, and nonexclusive. An option list is a list containing zero or more symbolic option names and possibly the two-element option mode mode. \n\n" "The mutually exclusive error, truncate, replace, and append options are used to direct what happens when the file to be opened already exists. \nerror:\n     An exception is raised with condition-type &i/o-filename. \nreplace:\n     The existing file is deleted before the new file is opened. \ntruncate:\n     The existing file is opened and truncated to zero length. \nappend:\n      The existing file is opened and the output port is positioned at the end of the file before each write so that output to the port is always appended to the file. The default behavior is to raise an exception. \n\n" "The mutually exclusive compressed and uncompressed options determine whether the output file is to be compressed. The compression format and level are determined by the compress-format and compress-level parameters. Files are uncompressed by default, so the uncompressed option is useful only as documentation. \n\n" "The mutually exclusive buffered and unbuffered options determine whether output is buffered. Unbuffered output is sent immediately to the file, whereas buffered output not written until the port's output buffer is filled or the port is flushed (via flush-output-port) or closed (via flush-output-port or by the storage management system when the port becomes inaccessible). Output is buffered by default for efficiency, so the buffered option is useful only as documentation.  \n\n" "The mutually exclusive exclusive and nonexclusive options determine whether access to the file is \"exclusive.\" When the exclusive option is specified, the file is locked until the port is closed to prevent access by other processes. On some systems the lock is advisory, i.e., it inhibits access by  other processes only if they also attempt to open exclusively. Nonexclusive access is the default, so the nonexclusive option is useful only as documentation. \n\n" "The mode option determines the permission bits on Unix systems when the file is created by the operation, subject to the process umask. The subsequent element in the options list must be an exact integer specifying the permissions in the manner of the Unix open function. The mode option is ignored under Windows. \n\n" "For example, the call \n\n" "" "(open-output-file \"frob\" '(compressed truncate mode #o644))\n\n" "opens the file frob with compression enabled. If frob already exists it is truncated. On Unix-based systems, if frob does not already exist, the permission bits on the newly created file are set to logical and of #o644 and the process's umask. \n\n" "The Revised^6 Report version of open-output-file does not support the optional options argument. \n\n") ("io:s80" "procedure: (call-with-output-file path procedure)\nprocedure: (call-with-output-file path procedure options)\nreturns: the values returned by procedure \nlibraries: (chezscheme)  \n\n" "path must be a string. procedure should accept one argument. \n\n" "call-with-output-file creates a new output port for the file named by path, as if with open-output-file, and passes this port to procedure. If procedure returns, call-with-output-file closes the output port and returns the values returned by procedure. \n\n" "call-with-output-file does not automatically close the output port if a continuation created outside of procedure is invoked, since it is possible that another continuation created inside of procedure will be invoked at a later time, returning control to procedure. If procedure does not return, an implementation is free to close the output port only if it can prove that the output port is no longer accessible. As shown in Section 5.6 of The Scheme Programming Language, 4th Edition, dynamic-wind may be used to ensure that the port is closed if a continuation created outside of procedure is invoked. \n\n" "See open-output-file above for a description of the optional options argument. \n\n" "The Revised^6 Report version of call-with-output-file does not support the optional options argument. \n\n") ("io:s81" "procedure: (with-output-to-file path thunk)\nprocedure: (with-output-to-file path thunk options)\nreturns: the value returned by thunk \nlibraries: (chezscheme)  \n\n" "path must be a string. thunk must be a procedure and should accept zero arguments. \n\n" "with-output-to-file temporarily rebinds the current output port to be the result of opening the file named by path, as if with open-output-file, during the application of thunk. If thunk returns, the port is closed and the current output port is restored to its old value. \n\n" "The behavior of with-output-to-file is unspecified if a continuation created outside of thunk is invoked before thunk returns. An implementation may close the port and restore the current output port to its old value---but it may not. \n\n" "See open-output-file above for a description of the optional options argument. \n\n" "The Revised^6 Report version of with-output-to-file does not support the optional options argument. \n\n") ("io:s82" "procedure: (open-fd-output-port fd)\nprocedure: (open-fd-output-port fd b-mode)\nprocedure: (open-fd-output-port fd b-mode ?transcoder)\nreturns: a new output port for the file descriptor fd \nlibraries: (chezscheme)  \n\n" "fd must be a nonnegative exact integer and should be a valid open file descriptor. If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual output port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary output port. See the lead-in to Section 7.2 of The Scheme Programming Language, 4th Editionfor a description of the constraints on and effects of the other arguments. \n\n" "The file descriptor is closed when the port is closed. \n\n") ("io:s83" "procedure: (standard-output-port) \nprocedure: (standard-output-port b-mode)\nprocedure: (standard-output-port b-mode ?transcoder)\nreturns: a new output port connected to the process's standard output \nlibraries: (chezscheme)  \n\n" "If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual output port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary output port. The buffer mode b-mode defaults to line, which differs from block in Chez Scheme only for textual output ports. \n\n" "The Revised^6 Report version of this procedure does not accept the optional b-mode and ?transcoder arguments, which limits it to an implementation-dependent buffering mode (line in Chez Scheme) and binary output. \n\n") ("io:s84" "procedure: (standard-error-port) \nprocedure: (standard-error-port b-mode)\nprocedure: (standard-error-port b-mode ?transcoder)\nreturns: a new output port connected to the process's standard error \nlibraries: (chezscheme)  \n\n" "If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual output port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary output port. The buffer mode b-mode defaults to none. See the lead-in to Section 7.2 of The Scheme Programming Language, 4th Editionfor a description of the constraints on and effects of the other arguments. \n\n" "The Revised^6 Report version of this procedure does not accept the optional b-mode and ?transcoder arguments, which limits it to an implementation-dependent buffering mode (none in Chez Scheme) and binary output. \n\n") ("io:s85" "procedure: (put-bytevector-some binary-output-port bytevector)\nprocedure: (put-bytevector-some binary-output-port bytevector start)\nprocedure: (put-bytevector-some binary-output-port bytevector start n)\nreturns: the number of bytes written \nlibraries: (chezscheme)  \n\n" "start and n must be nonnegative exact integers, and the sum of start and n must not exceed the length of bytevector. If not supplied, start defaults to zero and n defaults to the difference between the length of bytevector and start. \n\n" "This procedure normally writes the n bytes of bytevector starting at start to the port and advances the its position past the end of the bytes written. If the port is in nonblocking mode (see set-port-nonblocking!), however, the number of bytes written may be less than n, if the system would have to block to write more bytes. \n\n") ("io:s86" "procedure: (put-string-some textual-output-port string)\nprocedure: (put-string-some textual-output-port string start)\nprocedure: (put-string-some textual-output-port string start n)\nreturns: the number of characters written \nlibraries: (chezscheme)  \n\n" "start and n must be nonnegative exact integers, and the sum of start and n must not exceed the length of string. If not supplied, start defaults to zero and n defaults to the difference between the length of string and start. \n\n" "This procedure normally writes the n characters of string starting at start to the port and advances the its position past the end of the characters written. If the port is in nonblocking mode (see set-port-nonblocking!), however, the number of characters written may be less than n, if the system would have to block to write more characters. \n\n") ("io:s87" "procedure: (display-string string)\nprocedure: (display-string string textual-output-port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "display-string writes the characters contained within string to textual-output-port or to the current-output port  if textual-output-port is not specified. The enclosing string quotes are not printed, and special characters within the string are not escaped. display-string is a more efficient alternative to display for displaying strings.  \n\n") ("io:s88" "procedure: (block-write textual-output-port string)\nprocedure: (block-write textual-output-port string count)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "count must be a nonnegative fixnum less than or equal to the length of string. If not provided, it defaults to the length of string. \n\n" "block-write writes the first count characters of string to textual-output-port. If the port is buffered and the buffer is nonempty, the buffer is flushed before the contents of string are written. In any case, the contents of string are written immediately, without passing through the buffer. \n\n") ("io:s89" "procedure: (truncate-port output-port)\nprocedure: (truncate-port output-port pos)\nprocedure: (truncate-file output-port)\nprocedure: (truncate-file output-port pos)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "truncate-port and truncate-file are identical.  \n\n" "pos must be an exact nonnegative integer.  It defaults to 0. \n\n" "These procedures truncate the file or other object associated with output-port to pos and repositions the port to that position, i.e., it combines the functionality of set-port-length! and set-port-position! and can be called on a port only if port-has-set-port-length!? and port-has-set-port-position!? are both true of the port.  \n\n") ("io:s90" "procedure: (fresh-line) \nprocedure: (fresh-line textual-output-port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "If textual-output-port is not supplied, it defaults to the current output port. \n\n" "This procedure behaves like newline, i.e., sends a newline character to textual-output-port, unless it can determine that the port is already positioned at the start of a line. It does this by flushing the port and consulting the \"beginning-of-line\" (BOL) flag associated with the port. (See page 249.) \n\n") ("io:s91" "procedure: (open-input-output-file path)\nprocedure: (open-input-output-file path options)\nreturns: a new input-output port \nlibraries: (chezscheme)  \n\n" "path must be a string. open-input-output-file opens a textual input-output port for the file named by path. \n\n" "The port may be used to read from or write to the named file. The file is created if it does not already exist. \n\n" "options, if present, is a symbolic option name or option list. Possible symbolic option names are  buffered, unbuffered, exclusive, and nonexclusive. An option list is a list containing zero or more symbolic option names and possibly the two-element option mode mode. See the description of open-output-file for an explanation of these options. \n\n" "Input/output files are usually closed using close-port but may also be closed with either close-input-port or close-output-port.  \n\n") ("io:s92" "procedure: (open-fd-input/output-port fd)\nprocedure: (open-fd-input/output-port fd b-mode)\nprocedure: (open-fd-input/output-port fd b-mode ?transcoder)\nreturns: a new input/output port for the file descriptor fd \nlibraries: (chezscheme)  \n\n" "fd must be a nonnegative exact integer and should be a valid open file descriptor. If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary input/output port. See the lead-in to Section 7.2 of The Scheme Programming Language, 4th Editionfor a description of the constraints on and effects of the other arguments. \n\n" "The file descriptor is closed when the port is closed. \n\n") ("io:s94" "procedure: (multibyte->string code-page bytevector)\nreturns: a string containing the characters encoded in bytevector \nprocedure: (string->multibyte code-page string)\nreturns: a bytevector containing the encodings of the characters in string \nlibraries: (chezscheme)  \n\n" "These procedures are available only under Windows. The procedure multibyte->string is a wrapper for the Windows API MultiByteToWideChar function, and string->multibyte is a wrapper for the Windows API WideCharToMultiByte function.  \n\n" "code-page declares the encoding of the byte sequences in the input or output bytevectors. It must be an exact nonnegative integer identifying a code page or one of the symbols cp-acp, cp-maccp, cp-oemcp, cp-symbol, cp-thread-acp, cp-utf7, or cp-utf8, which have the same meanings as the API function meanings for the like-named constants. \n\n") ("io:s95" "procedure: (pretty-print obj)\nprocedure: (pretty-print obj textual-output-port)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "If textual-output-port is not supplied, it defaults to the current output port. \n\n" "pretty-print is similar to write except that it uses any number of spaces and newlines in order to print obj in a style that is pleasing to look at and which shows the nesting level via indentation. For example, \n\n" "" "(pretty-print '(define factorial (lambda (n) (let fact ((i n) (a 1))\n  (if (= i 0) a (fact (- i 1) (* a i)))))))\n\n" "might produce \n\n" "" "(define factorial\n  (lambda (n)\n    (let fact ([i n] [a 1])\n      (if (= i 0) a (fact (- i 1) (* a i))))))\n\n") ("io:s96" "procedure: (pretty-file ifn ofn)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "ifn and ofn must be strings. pretty-file reads each object in turn from the file named by ifn and pretty prints the object to the file named by ofn. Comments present in the input are discarded by the reader and so do not appear in the output file. If the file named by ofn already exists, it is replaced. \n\n") ("io:s97" "procedure: (pretty-format sym)\nreturns: see below \nprocedure: (pretty-format sym fmt)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "By default, the pretty printer uses a generic algorithm for printing each form. This procedure is used to override this default and guide the pretty-printers treatment of specific forms. The symbol sym names a syntactic form or procedure. With just one argument, pretty-format returns the current format associated with sym, or #f if no format is associated with sym. \n\n" "In the two-argument case, the format fmt is associated with sym for future invocations of the pretty printer. fmt must be in the formatting language described below. \n\n" "[table not shown]\n\n" "Some of the format forms are used for matching when there are multiple alternatives, while others are used for matching and control indentation or printing. A description of each fmt is given below. \n\n" "\n(quote symbol):\n    This matches only the symbol symbol. \n\n" "\nvar:\n    This matches any symbol. \n\n" "\nsymbol:\n    This matches any input. \n\n" "\n(read-macro string symbol):\n    This is used for read macros like quote and syntax. It matches any input of the form (symbol subform). For forms that match, the pretty printer prints string immediately followed by subform. \n\n" "\n(meta):\n    This is a special case used for the meta keyword (Section 11.8) which is used as a keyword prefix of another form. \n\n" "\n(alt fmt fmt*):\n    This compares the input against the specified formats and uses the one that is the closest match. Most often, one of the formats will match exactly, but in other cases, as when input is malformed or appears in abstract form in the template of a syntactic abstraction, none of the formats will match exactly. \n\n" "\n(bracket . fmt-tail):\n    This matches any list-structured input and prints the input enclosed in square brackets, i.e., [ and ], rather than parentheses. \n\n" "\nfmt-tail:\n    This matches any list-structured input. \n\n" "Indentation of list-structured forms is determined via the fmt-tail specifier used to the last two cases above. A description of each fmt-tail is given below. \n\n" "\n():\n    This matches an empty list tail. \n\n" "\n(tab fmt ...):\n    This matches the tail of any proper list; if the tail is nonempty and the list does not fit entirely on the current line, a line break is inserted before the first subform of the tail and tab (see below) determines the amount by which this and all subsequent subforms are indented. \n\n" "\n(fmt tab ...):\n    This matches the tail of any proper list; if the tail is nonempty and the list does not fit entirely on the current line, a line break is inserted after the first subform of the tail and tab (see below) determines the amount by which all subsequent subforms are indented. \n\n" "\n(tab fmt . fmt-tail):\n    This matches a nonempty tail if the tail of the tail matches fmt-tail. If the list does not fit entirely on the current line, a line break is inserted before the first subform of the tail and tab (see below) determines the amount by which the subform is indented. \n\n" "\n(fmt ...):\n    This matches the tail of any proper list and specified that no line breaks are to be inserted before or after the current or subsequent subforms. \n\n" "\n(fmt . fmt-tail):\n    This matches a nonempty tail if the tail of the tail matches fmt-tail and specifies that no line break is to be inserted before or after the current subform. \n\n" "\n(fill tab fmt ...):\n    This matches the tail of any proper list and invokes a fill mode in which the forms are packed with as many as will fit on each line. \n\n" "A tab determines the amount by which a list subform is indented. If tab is a nonnegative exact integer int, the subform is indented int spaces in from the character position just after the opening parenthesis or bracket of the parent form. If tab is #f, the standard indentation is used. The standard indentation can be determined or changed via the parameter pretty-standard-indent, which is described later in this section. \n\n" "In cases where a format is given that doesn't quite match, the pretty printer tries to use the given format as far as it can. For example, if a format matches a list-structured form with a specific number of subforms, but more or fewer subform are given, the pretty printer will discard or replicate subform formats as necessary. \n\n" "Here is an example showing the formatting of let might be specified. \n\n" "" "(pretty-format 'let\n  '(alt (let ([bracket var x] 0 ...) #f e #f e ...)\n        (let var ([bracket var x] 0 ...) #f e #f e ...)))\n\n" "Since let comes in two forms, named and unnamed, two alternatives are specified. In either case, the bracket fmt is used to enclose the bindings in square brackets, with all bindings after the first appearing just below the first (and just after the enclosing opening parenthesis), if they don't all fit on one line. Each body form is indented by the standard indentation. \n\n") ("io:s100" "thread parameter: pretty-line-length \nthread parameter: pretty-one-line-limit \nlibraries: (chezscheme)  \n\n" "The value of each of these parameters must be a positive fixnum. \n\n" "The parameters pretty-line-length and pretty-one-line-limit control the output produced by pretty-print. pretty-line-length determines after which character position (starting from the first) on a line the pretty printer attempts to cut off output. This is a soft limit only; if necessary, the pretty-printer will go beyond pretty-line-length.  \n\n" "pretty-one-line-limit is similar to pretty-line-length, except that it is relative to the first nonblank position on each line of output. It is also a soft limit. \n\n") ("io:s102" "thread parameter: pretty-initial-indent \nlibraries: (chezscheme)  \n\n" "The value of this parameter must be a nonnegative fixnum. \n\n" "The parameter pretty-initial-indent is used to tell pretty-print where on an output line it has been called. If pretty-initial-indent is zero (the default), pretty-print assumes that the first line of output it produces will start at the beginning of the line. If set to a nonzero value n, pretty-print assumes that the first line will appear at character position n and will adjust its printing of subsequent lines. \n\n") ("io:s104" "thread parameter: pretty-standard-indent \nlibraries: (chezscheme)  \n\n" "The value of this parameter must be a nonnegative fixnum. \n\n" "This determines the amount by which pretty-print indents subexpressions of most forms, such as let expressions, from the form's keyword or first subexpression. \n\n") ("io:s105" "thread parameter: pretty-maximum-lines \nlibraries: (chezscheme)  \n\n" "The parameter pretty-maximum-lines controls how many lines pretty-print prints when it is called. If set to #f (the default), no limit is imposed; if set to a nonnegative fixnum n, at most n lines are printed. \n\n") ("io:s106" "procedure: (format format-string obj ...)\nprocedure: (format #f format-string obj ...)\nprocedure: (format #t format-string obj ...)\nprocedure: (format textual-output-port format-string obj ...)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "When the first argument to format is a string or #f (first and second forms above), format constructs an output string from format-string and the objects obj .... Characters are copied from format-string to the output string from left to right, until format-string is exhausted. The format string may contain one or more format directives, which are multi-character sequences prefixed by a tilde ( ~ ). Each directive is replaced by some other text, often involving one or more of the obj ... arguments, as determined by the semantics of the directive. \n\n" "When the first argument is #t, output is sent to the current output port instead, as with printf. When the first argument is a port, output is sent to that port, as with fprintf. printf and fprintf are described later in this section.  \n\n" "Chez Scheme's implementation of format supports all of the Common Lisp [30] format directives except for those specific to the Common Lisp pretty printer. Please consult a Common Lisp reference or the Common Lisp Hyperspec, for complete documentation. A few of the most useful directives are described below. \n\n" "Absent any format directives, format simply displays its string argument. \n\n" "" "(format \"hi there\") => \"hi there\"\n\n" "The ~s directive is replaced by the printed representation of the next obj, which may be any object, in machine-readable format, as with write.  \n\n" "" "(format \"hi ~s\" 'mom) => \"hi mom\"\n(format \"hi ~s\" \"mom\") => \"hi \\\"mom\\\"\"\n(format \"hi ~s~s\" 'mom #\\!) => \"hi mom#\\\\!\"\n\n" "The general form of a ~s directive is actually ~mincol,colinc,minpad,padchars, and the s can be preceded by an at sign ( @ ) modifier. These additional parameters are used to control padding in the output, with at least minpad copies of padchar plus an integer multiple of colinc copies of padchar to make the total width, including the written object, mincol characters wide. The padding is placed on the left if the @ modifier is present, otherwise on the right. mincol and minpad default to 0, colinc defaults to 1, and padchar defaults to space. If specified, padchar is prefixed by a single quote mark. \n\n" "" "(format \"~10s\" 'hello) => \"hello     \"\n(format \"~10@s\" 'hello) => \"     hello\"\n(format \"~10,,,'*@s\" 'hello) => \"*****hello\"\n\n" "The ~a directive is similar, but prints the object as with display.  \n\n" "" "(format \"hi ~s~s\" \"mom\" #\\!) => \"hi \\\"mom\\\"#\\\\!\"\n(format \"hi ~a~a\" \"mom\" #\\!) => \"hi mom!\"\n\n" "A tilde may be inserted into the output with ~~, and a newline may be inserted with ~% (or embedded in the string with \\n).  \n\n" "" "(format \"~~line one,~%line two.~~\") => \"~line one,\\nline two.~\"\n(format \"~~line one,\\nline two.~~\") => \"~line one,\\nline two.~\"\n\n" "Real numbers may be printed in floating-point notation with ~f.  \n\n" "" "(format \"~f\" 3.14159) => 3.14159\n\n" "Exact numbers may printed as well as inexact numbers in this manner; they are simply converted to inexact first as if with exact->inexact.  \n\n" "" "(format \"~f\" 1/3) => \"0.3333333333333333\"\n\n" "The general form is actually ~w,d,k,overflowchar,padcharf. If specified, w determines the overall width of the output, and d the number of digits to the right of the decimal point. padchar, which defaults to space, is the pad character used if padding is needed. Padding is always inserted on the left. The number is scaled by 10^k when printed; k defaults to zero. The entire w-character field is filled with copies of overflowchar if overflowchar is specified and the number cannot be printed in w characters. k defaults to 1 If an @ modifier is present, a plus sign is printed before the number for nonnegative inputs; otherwise, a sign is printed only if the number is negative. \n\n" "" "(format \"~,3f\" 3.14159) => \"3.142\"\n(format \"~10f\" 3.14159) => \"   3.14159\"\n(format \"~10,,,'#f\" 1e20) => \"##########\"\n\n" "Real numbers may also be printed with ~e for scientific notation or with ~g, which uses either floating-point or scientific notation based on the size of the input. \n\n" "" "(format \"~e\" 1e23) => \"1.0e+23\"\n(format \"~g\" 1e23) => \"1.0e+23\"\n\n" "A real number may also be printed with ~$, which uses monetary notation defaulting to two digits to the right of the decimal point. \n\n" "" "(format \"$~$\" (* 39.95 1.06)) => \"$42.35\"\n(format \"~$USD\" 1/3) => \"0.33USD\"\n\n" "Words can be pluralized automatically using p.  \n\n" "(format \"~s bear~:p in ~s den~:p\" 10 1) => \"10 bears in 1 den\"\n\n" "Numbers may be printed out in words or roman numerals using variations on ~r.  \n\n" "" "(format \"~r\" 2599) =>  \"two thousand five hundred ninety-nine\"\n(format \"~:r\" 99) =>  \"ninety-ninth\"\n(format \"~@r\" 2599) => \"MMDXCIX\"\n\n" "Case conversions can be performed by bracketing a portion of the format string with the ~@( and ~) directives.  \n\n" "" "(format \"~@(~r~)\" 2599) =>  \"Two thousand five hundred ninety-nine\"\n(format \"~@:(~a~)\" \"Ouch!\") =>  \"OUCH!\"\n\n" "Some of the directives shown above have more options and parameters, and  there are other directives as well, including directives for conditionals, iteration, indirection, and justification. Again, please consult a Common Lisp reference for complete documentation. \n\n" "An implementation of a greatly simplified version of format appears in Section 12.6 of The Scheme Programming Language, 4th Edition. \n\n") ("io:s108" "procedure: (printf format-string obj ...)\nprocedure: (fprintf textual-output-port format-string obj ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "These procedures are simple wrappers for format. printf prints the formatted output to the current output, as with a first-argument of #t to format, and fprintf prints the formatted output to the textual-output-port, as when the first argument to format is a port.  \n\n") ("io:s109" "procedure: (char-name obj)\nreturns: see below \nprocedure: (char-name name char)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "char-name is used to associate names (symbols) with characters or to retrieve the most recently associated name or character for a  given character or name. A name can map to only one character, but more than one name can map to the same character. The name most recently associated with a character determines how that character prints, and each name associated with a character may be used after the #\\ character prefix to name that character on input. \n\n" "Character associations created by char-name are ignored by the printer unless the parameter print-char-name is set to a true value. The reader recognizes character names established by char-name except after #!r6rs, which is implied within a library or R6RS top-level program. \n\n" "In the one-argument form, obj must be a symbol or character. If it is a symbol and a character is associated with the symbol, char-name returns that character. If it is a symbol and no character is associated with the symbol, char-name returns #f. Similarly, if obj is a character, char-name returns the most recently associated symbol for the character or #f if no name is associated with the character. For example, with the default set of character names: \n\n" "" "(char-name #\\space) => space\n(char-name 'space) => #\\space\n(char-name 'nochar) => #f\n(char-name #\\a) => #f\n\n" "When passed two arguments, name is added to the set of names associated with char, and any other association for name is dropped. char may be #f, in which case any other association for name is dropped and no new association is formed. In either case, any other names associated with char remain associated with char. \n\n" "The following interactive session demonstrates the use of char-name to establish and remove associations between characters and names, including the association of more than one name with a character. \n\n" "" "(print-char-name #t)\n(char-name 'etx) => #f\n(char-name 'etx #\\x3)\n(char-name 'etx) => #\\etx\n(char-name #\\x3) => etx\n#\\etx => #\\etx\n(eq? #\\etx #\\x3) => #t\n#!r6rs #\\etx => exception: invalid character name etx\n#!chezscheme #\\etx => #\\etx\n(char-name 'etx #\\space)\n(char-name #\\x3) => #f\n(char-name 'etx) => #\\etx\n#\\space => #\\etx\n(char-name 'etx #f)\n#\\etx => exception: invalid character name etx\n#\\space => #\\space\n\n" "(When using the expression editor, it is necessary to type Control-J to force the editor to read the erroneous #\\etx input on the two inputs above that result in read errors, since typing Enter causes the expression editor to read the input only if the input is well-formed.) \n\n" "The reader does not recognize hex scalar value escapes in character names, as it does in symbols, so #\\new\\x6c;ine is not equivalent to #\\newline. In general, programmers should avoid the use of character name symbols that cannot be entered without the use of hex scalar value escapes or other symbol-name escape mechanisms, since such character names will not be readable. \n\n") ("io:s110" "thread parameter: print-char-name \nlibraries: (chezscheme)  \n\n" "When print-char-name is set to #f (the default), associations created by char-name are ignored by write, put-datum, pretty-print, and the format \"~s\" directive. Otherwise, these procedures use the names established by char-name when printing character objects.  \n\n" "" "(char-name 'etx #\\x3)\n(format \"~s\" #\\x3) => \"#\\\\x3\"\n(parameterize ([print-char-name #t])\n  (format \"~s\" #\\x3)) => \"#\\\\etx\"\n\n") ("io:s111" "thread parameter: case-sensitive \nlibraries: (chezscheme)  \n\n" "The case-sensitive parameter determines whether the reader is case-sensitive with respect to symbol and character names. When set to true (the default, as required by the Revised^6 Report) the case of alphabetic characters within symbol names is significant. When set to #f, case is insignificant. More precisely, when set to #f, symbol and character names are folded (as if by string-foldcase); otherwise, they are left as they appear in the input. \n\n" "The value of the case-sensitive matters only if neither #!fold-case nor #!no-fold-case has appeared previously in the same input stream. That is, symbol and character name are folded if #!fold-case has been seen. They are not folded if #!no-fold-case has been seen. If neither has been seen, they are folded if and only if (case-sensitive) is #f.  \n\n" "" "(case-sensitive) => #t\n(eq? 'abc 'ABC) => #f\n'ABC => ABC\n(case-sensitive #f)\n'ABC => abc\n(eq? 'abc 'ABC) => #t\n\n") ("io:s112" "thread parameter: print-graph \nlibraries: (chezscheme)  \n\n" "When print-graph is set to a true value, write and pretty-print locate and print objects with shared structure, including cycles, in a notation that may be read subsequently with read. This notation employs the syntax \"#n=obj,\" where n is a nonnegative integer and obj is the printed representation of an object, to label the first occurrence of obj in the output. The syntax \"#n#\" is used to refer to the object labeled by n thereafter in the output. print-graph is set to #f by default.  \n\n" "If graph printing is not enabled, the settings of print-length and print-level are insufficient to force finite output, and write or pretty-print detects a cycle in an object it is given to print, a warning is issued (an exception with condition type &warning is raised) and the object is printed as if print-graph were enabled.  \n\n" "Since objects printed through the ~s option in the format control strings of format, printf, and fprintf are printed as with write, the printing of such objects is also affected by print-graph.  \n\n" "" "(parameterize ([print-graph #t])\n  (let ([x (list 'a 'b)])\n    (format \"~s\" (list x x)))) => \"(#0=(a b) #0#)\" \n\n(parameterize ([print-graph #t])\n  (let ([x (list 'a 'b)])\n    (set-car! x x)\n    (set-cdr! x x)\n    (format \"~s\" x))) => \"#0=(#0# . #0#)\"\n\n" "The graph syntax is understood by the procedure read, allowing graph structures to be printed and read consistently. \n\n") ("io:s116" "thread parameter: print-level \nthread parameter: print-length \nlibraries: (chezscheme)  \n\n" "These parameters can be used to limit the extent to which nested or multiple-element structures are printed. When called without arguments, print-level returns the current print level and print-length returns the current print length. When called with one argument, which must be a nonnegative fixnum or #f, print-level sets the current print level and print-length sets the current print length to the argument.  \n\n" "When print-level is set to a nonnegative integer n, write and pretty-print traverse only n levels deep into nested structures. If a structure being printed exceeds n levels of nesting, the substructure beyond that point is replaced in the output by an ellipsis ( ... ). print-level is set to #f by default, which places no limit on the number of levels printed. \n\n" "When print-length is set to a nonnegative integer n, the procedures write and pretty-print print only n elements of a list or vector, replacing the remainder of the list or vector with an ellipsis ( ... ). print-length is set to #f by default, which places no limit on the number of elements printed. \n\n" "Since objects printed through the ~s option in the format control strings of format, printf, and fprintf are printed as with write, the printing of such objects is also affected by print-level and print-length.  \n\n" "The parameters print-level and print-length are useful for controlling the volume of output in contexts where only a small portion of the output is needed to identify the object being printed. They are also useful in situations where circular structures may be printed (see also print-graph).  \n\n" "" "(format \"~s\" '((((a) b) c) d e f g)) => \"((((a) b) c) d e f g)\" \n\n(parameterize ([print-level 2])\n  (format \"~s\" '((((a) b) c) d e f g))) => \"(((...) c) d e f g)\" \n\n(parameterize ([print-length 3])\n  (format \"~s\" '((((a) b) c) d e f g))) => \"((((a) b) c) d e ...)\" \n\n(parameterize ([print-level 2]\n               [print-length 3])\n  (format \"~s\" '((((a) b) c) d e f g))) => \"(((...) c) d e ...)\"\n\n") ("io:s121" "thread parameter: print-radix \nlibraries: (chezscheme)  \n\n" "The print-radix parameter determines the radix in which numbers are printed by write, pretty-print, and display. Its value should be an integer between 2 and 36, inclusive. Its default value is 10. \n\n" "When the value of print-radix is not 10, write and pretty-print print a radix prefix before the number (#b for radix 2, #o for radix 8, #x for radix 16, and #nr for any other radix n). \n\n" "Since objects printed through the ~s and ~a options in the format control strings of format, printf, and fprintf are printed as with write and display, the printing of such objects is also affected by print-radix.  \n\n" "" "(format \"~s\" 11242957) => \"11242957\" \n\n(parameterize ([print-radix 16])\n  (format \"~s\" 11242957)) => \"#xAB8DCD\" \n\n(parameterize ([print-radix 16])\n  (format \"~a\" 11242957)) => \"AB8DCD\"\n\n") ("io:s122" "thread parameter: print-gensym \nlibraries: (chezscheme)  \n\n" "When print-gensym is set to #t (the default) gensyms are printed with an extended symbol syntax that includes both the pretty name and the unique name of the gensym:  #{pretty-name unique-name}. When set to pretty, the pretty name only is shown, with the prefix #:. When set to pretty/suffix, the printer prints the gensym's \"pretty\" name along with a suffix based on the gensym's \"unique\" name, separated by a dot ( \".\" ). If the gensym's unique name is generated automatically during the current session, the suffix is that portion of the unique name that is not common to all gensyms created during the current session. Otherwise, the suffix is the entire unique name. When set to #f, the pretty name only is shown, with no prefix. \n\n" "Since objects printed through the ~s option in the format control strings of format, printf, errorf, etc., are printed as with write, the printing of such objects is also affected by print-gensym.  \n\n" "When printing an object that may contain more than one occurrence of a gensym and print-graph is set to pretty or #f, it is useful to set print-graph to #t so that multiple occurrences of the same gensym are marked as identical in the output. \n\n" "" "(let ([g (gensym)])\n  (format \"~s\" g)) => \"#{g0 bdids2xl6v49vgwe-a}\" \n\n(let ([g (gensym)])\n  (parameterize ([print-gensym 'pretty])\n    (format \"~s\" g))) => \"#:g1 \n\n(let ([g (gensym)])\n  (parameterize ([print-gensym #f])\n    (format \"~s\" g))) => \"g2\" \n\n(let ([g (gensym)])\n  (parameterize ([print-graph #t] [print-gensym 'pretty])\n    (format \"~s\" (list g g)))) => \"(#0=#:g3 #0#)\" \n\n(let ([g1 (gensym \"x\")]\n      [g2 (gensym \"x\")]\n      [g3 (gensym \"y\")])\n  (parameterize ([print-gensym 'pretty/suffix])\n    (format \"~s ~s ~s\" g1 g2 g3))) => \"x.1 x.2 y.3\"\n\n") ("io:s127" "thread parameter: print-brackets \nlibraries: (chezscheme)  \n\n" "When print-brackets is set to a true value, the pretty printer (see pretty-print) uses square brackets rather than parentheses around certain subexpressions of common control structures, e.g., around let bindings and cond clauses. print-brackets is set to #t by default.  \n\n" "" "(let ([p (open-output-string)])\n  (pretty-print '(let ([x 3]) x) p) => \"(let ([x 3]) x)\n  (get-output-string p))               \" \n\n(parameterize ([print-brackets #f])\n  (let ([p (open-output-string)])\n    (pretty-print '(let ([x 3]) x) p) => \"(let ((x 3)) x)\n    (get-output-string p)))              \"\n\n") ("io:s129" "thread parameter: print-extended-identifiers \nlibraries: (chezscheme)  \n\n" "Chez Scheme extends the syntax of identifiers as described in Section 1.1, except within a set of forms prefixed by #!r6rs (which is implied in a library or top-level program).  \n\n" "When this parameter is set to false (the default), identifiers in the extended set are printed with hex scalar value escapes as necessary to conform to the R6RS syntax for identifiers. When this parameter is set to a true value, identifiers in the extended set are printed without the escapes. Identifiers whose names fall outside of both syntaxes are printed with the escapes regardless of the setting of this parameter. \n\n" "For example: \n\n" "" "(parameterize ([print-extended-identifiers #f])\n  (printf \"~s\\n~s\\n\"\n    '(1+ --- { } .xyz)\n    (string->symbol \"123\")))\n\n" "prints \n\n" "" "(\\x31;+ \\x2D;-- \\x7B; \\x7D; \\x2E;xyz)\n\\x31;23\n\n" "while \n\n" "" "(parameterize ([print-extended-identifiers #t])\n  (printf \"~s\\n~s\\n\"\n    '(1+ --- { } .xyz)\n    (string->symbol \"123\")))\n\n" "prints \n\n" "" "(1+ --- { } .xyz)\n\\x31;23\n\n") ("io:s130" "thread parameter: print-vector-length \nlibraries: (chezscheme)  \n\n" "When print-vector-length is set to a true value, write, put-datum, and pretty-print include the length for all vectors, bytevectors, and fxvectors immediately after the \"#\". This parameter is set to #f by default.  \n\n" "When print-vector-length is set to a true value, write, put-datum, and pretty-print also suppress duplicated trailing elements in the vector to reduce the amount of output. This form is also recognized by the reader. \n\n" "Since objects printed through the ~s option in the format control strings of format, printf, and fprintf are printed as with write, the printing of such objects is also affected by the setting of print-vector-length.  \n\n" "" "(format \"~s\" (vector 'a 'b 'c 'c 'c)) => \"#(a b c c c)\" \n\n(parameterize ([print-vector-length #t])\n  (format \"~s\" (vector 'a 'b 'c 'c 'c))) => \"#5(a b c)\" \n\n(parameterize ([print-vector-length #t])\n  (format \"~s\" (bytevector 1 2 3 4 4 4))) => \"#6vu8(1 2 3 4)\" \n\n(parameterize ([print-vector-length #t])\n  (format \"~s\" (fxvector 1 2 3 4 4 4))) => \"#6vfx(1 2 3 4)\"\n\n") ("io:s132" "thread parameter: print-precision \nlibraries: (chezscheme)  \n\n" "When print-precision is set to #f (the default), write, put-datum, pretty-print, and the format \"~s\" directive do not include the vertical-bar \"mantissa-width\" syntax after each floating-point number---except for subnormal floating-point numbers, in which case precision printing is controlled by print-subnormal-precision. When set to a nonnegative exact integer, the mantissa width is included, as per the precision argument to number->string.  \n\n" "" "(format \"~s\" 1e-100) => \"1e-100\"\n(parameterize ([print-precision 32])\n  (format \"~s\" 1e-100)) ; => \"1e-100|53\"\n(format \"~s\" 1e-310) => \"1e-310|45\"\n\n") ("io:s133" "thread parameter: print-subnormal-precision \nlibraries: (chezscheme)  \n\n" "When print-subnormal-precision is set to a true value (the default), write, put-datum, pretty-print, and the format \"~s\" directive include the vertical-bar \"mantissa-width\" syntax after each floating-point number whose value is subnormal (roughly 4.94e-324 to 2.225e-308), regardless of the value of print-precision. When print-subnormal-precision and print-precision are both set to #f, precision is not printed for a subnormal value.  \n\n" "" "(format \"~s\" 1e-310) => \"1e-310|45\"\n(parameterize ([print-subnormal-precision #f])\n  (format \"~s\" 1e-310)) ; => \"1e-310\"\n(parameterize ([print-precision 32]\n               [print-subnormal-precision #f])\n  (format \"~s\" 1e-310)) ; => \"1e-310|45\"\n\n") ("io:s134" "thread parameter: print-positive-exponent-sign \nlibraries: (chezscheme)  \n\n" "When print-positive-exponent-sign is set to a true value, then when a flonum is printed in exponential form and the exponent is positive, a plus sign is written before the exponent. When print-positive-exponent-sign is set #f (the default), no plus sign is written before a positive exponent. \n\n") ("io:s135" "thread parameter: print-select-flonum-exponential-format \nlibraries: (chezscheme)  \n\n" "The value of print-select-flonum-exponential-format must be a procedure that accepts three arguments: a radix as an integer between 2 and 36 (inclusive), an exponent as an integer, and the number of non-zero significant digits in the flonum's printed form using the matissa (where the first digit is before the \"decimal\" point). If the procedure returns a true value, a number is printed in expotential form, otherwise it is printed in nonexponential form. \n\n" "" "(format \"~s ~s\" 1e2 1e8) => \"100.0 100000000.0\"\n(parameterize ([print-select-flonum-exponential-format\n                (lambda (radix exponent digits)\n                  (> exponent 3))])\n  (format \"~s ~s\" 1e2 1e8)) => \"100.0 1e8\"\n(parameterize ([print-select-flonum-exponential-format\n                (lambda (radix exponent digits)\n                  (< digits 3))])\n  (format \"~s ~s ~s\" 1e2 1.5e8 3.14159e-8)) => \"1e2 1.5e8 0.0000000314159\"\n\n") ("io:s136" "thread parameter: print-unicode \nlibraries: (chezscheme)  \n\n" "When print-unicode is set to #f, write, put-datum, pretty-print, and the format \"~s\" directive display Unicode characters with encodings 8016 (128) and above that appear  within character objects, symbols, and strings using hexadecimal character escapes. When set to a true value (the default), they are displayed like other printing characters, as if by put-char.  \n\n" "" "(format \"~s\" #\\x3bb) => \"#\\\\\"\n(parameterize ([print-unicode #f])\n  (format \"~s\" #\\x3bb)) => \"#\\\\x3BB\"\n\n") ("io:s138" "procedure: (fasl-write obj binary-output-port)\nprocedure: (fasl-write obj binary-output-port external-pred)\nprocedure: (fasl-write obj binary-output-port external-pred omit-rtds?)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "fasl-write writes the fasl representation of obj to binary-output-port. An exception is raised with condition-type &assertion if obj or any portion of obj has no external fasl representation, e.g., if obj is or contains a procedure. \n\n" "If externals-pred is provided and not #f, then it must be a procedure that accepts one argument.  It is applied to each distinct object  encountered in obj, including symbols, but not necessarily values of other primitive datatypes for which equal? implies eq?. If externals-pred returns true for an object, that object is not written to the fasl representation. Instead, a placeholder is written containing a position as the number of preceding calls to externals-pred that had returned true. Typically, for each object where it returns true, externals-pred saves the object through its closure. When the fasl representation is read with fasl-read, a vector with as many items as generated positions must be provided, and each placeholder is replaced with the corresponding vector element. Beware that replacing values used for system-internal data structures (which are always instances of primitive datatypes) with non-equal values at load time results in undefined behavior. \n\n" "If omit-rtds? is present and true, then any record types relevant to obj are not written to the fasl representation. When the fasl representation is read, these record types must already be declared in the loading context, and the loading context is assumed to have compatible record-type registrations using the same unique ID.  Behavior if the loading context has an incompatible record-type registration using the same (ostensibly unique) ID is undefined. \n\n" "The fasl representation of obj is compressed if the parameter fasl-compressed, described below, is set to #t, its default value. For this reason, binary-output-port generally should not be opened with the compressed option. A warning is issued (an exception with condition type &warning is raised) on the first attempt to write fasl objects to or read fasl objects from a compressed file. \n\n" "" "(define bop (open-file-output-port \"tmp.fsl\"))\n(fasl-write '(a b c) bop)\n(close-port bop) \n\n(define bip (open-file-input-port \"tmp.fsl\"))\n(fasl-read bip) => (a b c)\n(fasl-read bip) => #!eof\n(close-port bip)\n\n") ("io:s139" "procedure: (fasl-read binary-input-port)\nprocedure: (fasl-read binary-input-port situation)\nprocedure: (fasl-read binary-input-port situation externals)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "If present, situation must be one of the symbols load, visit, or revisit; it defaults to load. If present, exterrnals must be a vector; it defaults to '#().  \n\n" "fasl-read reads one object from binary-input-port, which must be positioned at the front of an object written in fasl format. fasl-read returns the eof object if the file is positioned at the end of file. If the situation is visit, fasl-read skips over  any revisit (run-time-only) objects, and if the situation is revisit, fasl-read skips over  any visit (compile-time-only) objects. It doesn't skip any if the situation is load. Similarly, objects marked as both visit and revisit (e.g., object code corresponding to source code within an eval-when form with situation load or situations visit and revisit) are never skipped. \n\n" "The externals vector must have the same length as the number of true-returning calls to external-pred during the fasl-write call that produced the fasl representation.  \n\n" "fasl-read automatically decompresses the representation of each fasl object written in compressed format by fasl-write. Thus, binary-input-port generally should not be opened with the compressed option. A warning is issued (an exception with condition type &warning is raised) on the first attempt to write fasl objects to or read fasl objects from a compressed file. \n\n" "" "(define bop (open-file-output-port \"tmp.fsl\"))\n(fasl-write '(a b c) bop)\n(close-port bop) \n\n(define bip (open-file-input-port \"tmp.fsl\"))\n(fasl-read bip) => (a b c)\n(fasl-read bip) => #!eof\n(close-port bip)\n\n") ("io:s140" "thread parameter: fasl-compressed \nlibraries: (chezscheme)  \n\n" "When this parameter is set to its default value, #t, fasl-write compresses the representation of each object as it writes it, often resulting in substantially smaller output but possibly taking more time to write and read. The compression format and level are determined by the compress-format and compress-level parameters. \n\n") ("io:s143" "procedure: (fasl-file ifn ofn)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "ifn and ofn must be strings. fasl-file may be used to convert a file in human-readable format into an equivalent file written in fasl format. fasl-file reads each object in turn from the file named by ifn and writes the fasl format for the object onto the file named by ofn. If the file named by ofn already exists, it is replaced. \n\n") ("io:s144" "global parameter: current-directory \nglobal parameter: cd \nlibraries: (chezscheme)  \n\n" "When invoked without arguments, current-directory returns a string representing the current working directory. Otherwise, the current working directory is changed to the directory specified by the argument, which must be a string representing a valid directory pathname. \n\n" "cd is bound to the same parameter.  \n\n") ("io:s145" "procedure: (directory-list path)\nreturns: a list of file names \nlibraries: (chezscheme)  \n\n" "path must be a string. The return value is a list of strings representing the names of files found in the directory named by path. directory-list raises an exception with condition type &i/o-filename if path does not name a directory or if the process cannot list the directory. \n\n") ("io:s146" "procedure: (file-exists? path)\nprocedure: (file-exists? path follow?)\nreturns: #t if the file named by path exists, #f otherwise \nlibraries: (chezscheme)  \n\n" "path must be a string. If the optional follow? argument is true (the default), file-exists? follows symbolic links; otherwise it does not. Thus, file-exists? will return #f when handed the pathname of a broken symbolic link unless follow? is provided and is #f.  \n\n" "The Revised^6 Report file-exists? does not accept the optional follow? argument. Whether it follows symbolic links is unspecified. \n\n") ("io:s147" "procedure: (file-regular? path)\nprocedure: (file-regular? path follow?)\nreturns: #t if the file named by path is a regular file, #f otherwise \nlibraries: (chezscheme)  \n\n" "path must be a string. If the optional follow? argument is true (the default), file-regular? follows symbolic links; otherwise it does not.  \n\n") ("io:s148" "procedure: (file-directory? path)\nprocedure: (file-directory? path follow?)\nreturns: #t if the file named by path is a directory, #f otherwise \nlibraries: (chezscheme)  \n\n" "path must be a string. If the optional follow? argument is true (the default), this procedure follows symbolic links; otherwise it does not. \n\n") ("io:s149" "procedure: (file-symbolic-link? path)\nreturns: #t if the file named by path is a symbolic link, #f otherwise \nlibraries: (chezscheme)  \n\n" "path must be a string. file-symbolic-link? never follows symbolic links in making its determination. \n\n") ("io:s150" "procedure: (file-access-time path/port)\nprocedure: (file-access-time path/port follow?)\nreturns: the access time of the specified file \nprocedure: (file-change-time path/port)\nprocedure: (file-change-time path/port follow?)\nreturns: the change time of the specified file \nprocedure: (file-modification-time path/port)\nprocedure: (file-modification-time path/port follow?)\nreturns: the modification time of the specified file \nlibraries: (chezscheme)  \n\n" "path/port must be a string or port. If path/port is a string, the time returned is for the file named by the string, and the optional follow? argument determines whether symbolic links are followed. If follow? is true (the default), this procedure follows symbolic links; otherwise it does not. If path/port is a port, it must be a file port, and the time returned is for the associated file. In this case, follow? is ignored. \n\n" "The returned times are represented as time objects (Section 12.10). \n\n") ("io:s151" "procedure: (mkdir path)\nprocedure: (mkdir path mode)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "path must be a string. mode must be a fixnum. \n\n" "mkdir creates a directory with the name given by path. All path path components leading up to the last must already exist. If the optional mode argument is present, it overrides the default permissions for the new directory. Under Windows, the mode argument is ignored. \n\n" "mkdir raises an exception with condition type &i/o-filename if the directory cannot be created.  \n\n") ("io:s152" "procedure: (delete-file path)\nprocedure: (delete-file path error?)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "path must be a string. delete-file removes the file named by path. If the optional error? argument is #f (the default), delete-file returns a boolean value: #t if the operation is successful and #f if it is not. Otherwise, delete-file returns an unspecified value if the operation is successful and raises an exception with condition type &i/o-filename if it is not.  \n\n" "The Revised^6 Report delete-file does not accept the optional error? argument but behaves as if error? is true. \n\n") ("io:s153" "procedure: (delete-directory path)\nprocedure: (delete-directory path error?)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "path must be a string. delete-directory removes the directory named by path. If the optional error? argument is #f (the default), delete-directory returns a boolean value: #t if the operation is successful and #f if it is not. Otherwise, delete-directory returns an unspecified value if the operation is successful and raises an exception with condition type &i/o-filename if it is not. The behavior is unspecified if the directory is not empty, but on most systems the operations will not succeed. \n\n") ("io:s154" "procedure: (rename-file old-pathname new-pathname)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "old-pathname and new-pathname must be strings. rename-file changes the name of the file named by old-pathname to new-pathname. If the file does not exist or cannot be renamed, an exception is raised with condition type &i/o-filename.  \n\n") ("io:s155" "procedure: (chmod path mode)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "path must be a string. mode must be a fixnum. \n\n" "chmod sets the permissions on the file named by path to mode. Bits 0, 1, and 2 of mode are the execute, write, and read permission bits for users other than the file's owner who are not in the file's group. Bits 3-5 are the execute, write, and read permission bits for users other than the file's owner but in the file's group. Bits 6-8 are the execute, write, and read permission bits for the file's owner. Bits 7-9 are the Unix sticky, set-group-id, and set-user-id bits. Under Windows, all but the user \"write\" bit are ignored. If the file does not exist or the permissions cannot be changed, an exception is raised with condition type &i/o-filename.  \n\n") ("io:s156" "procedure: (get-mode path)\nprocedure: (get-mode path follow?)\nreturns: the current permissions mode for path \nlibraries: (chezscheme)  \n\n" "path must be a string. get-mode retrieves the permissions on the file named by path and returns them as a fixnum in the same form as the mode argument to chmod. If the optional follow? argument is true (the default), this procedure follows symbolic links; otherwise it does not. \n\n") ("io:s157" "procedure: (directory-separator? char)\nreturns: #t if char is a directory separator, #f otherwise \nlibraries: (chezscheme)  \n\n" "The character #\\/ is a directory separator on all current machine types, and #\\\\ is a directory separator under Windows. \n\n") ("io:s158" "procedure: (directory-separator) \nreturns: the preferred directory separator \nlibraries: (chezscheme)  \n\n" "The preferred directory separator is #\\\\ for Windows and #\\/ for other systems.  \n\n") ("io:s159" "procedure: (path-build dir-path path)\nreturns: a combined path \nlibraries: (chezscheme)  \n\n" "Combines dir-path and path, adding a directory separator between them if needed. \n\n") ("io:s160" "procedure: (path-first path)\nprocedure: (path-rest path)\nprocedure: (path-last path)\nprocedure: (path-parent path)\nprocedure: (path-extension path)\nprocedure: (path-root path)\nreturns: the specified component of path \nprocedure: (path-absolute? path)\nreturns: #t if path is absolute, otherwise #f \nlibraries: (chezscheme)  \n\n" "path must be a string. The return value is also a (possibly empty) string. \n\n" "The path first component is the first directory in the path, or the empty string if the path consists only of a single filename. The path rest component is the portion of the path that does not include the path first component or the directory separator (if any) that separates it from the rest of the path. The path last component is the last (filename) portion of path. The path parent component is the portion of path that does not include the path last component, if any, or the directory separator that separates it from the rest of the path. \n\n" "If the first component of the path names a root directory (including drives and shares under Windows), home directory (e.g., ~/abc or ~user/abc),  the current directory (.), or the parent directory (..), path-first returns that component. For paths that consist only of such a directory, both path-first and path-parent act as identity procedures, while path-rest and path-last return the empty string. \n\n" "The path extension component is the portion of path that follows the last dot (period) in the last component of a path name. The path root component is the portion of path that does not include the extension, if any, or the dot that precedes it. \n\n" "If the first component names a root directory (including drives and shares under Windows) or home directory, path-absolute? returns #t. Otherwise, path-absolute? returns #f.   \n\n" "The tables below identify the components for several example paths, with underscores representing empty strings. \n\n" "[table not shown]\n\n" "The second table shows the components when Windows drives and shares are involved. \n\n" "[table not shown]\n\n" "The following procedure can be used to reproduce the tables above. \n\n" "" "(define print-table\n  (lambda path*\n    (define print-row\n      (lambda (abs? path first rest parent last root extension)\n        (printf \"~a~11t~a~17t~a~28t~a~39t~a~50t~a~61t~a~73t~a\\n\"\n          abs? path first rest parent last root extension)))\n    (print-row \"path\" \"abs\" \"first\" \"rest\" \"parent\" \"last\" \"root\" \"ext\")\n    (for-each\n      (lambda (path)\n        (define uscore (lambda (s) (if (eqv? s \"\") \"_\" s)))\n        (apply print-row path\n          (map (lambda (s) (if (eqv? s \"\") \"_\" s))\n               (list (path-absolute? path) (path-first path)\n                 (path-rest path) (path-parent path) (path-last path)\n                 (path-root path) (path-extension path)))))\n      path*)))\n\n" "For example, the first table can be produced with: \n\n" "" "(print-table \"a\" \"a/\" \"a/b\" \"a/b.c\" \"/\" \"/a/b.c\" \"~/a/b.c\"\n  \"~u/a/b.c\" \"../..\")\n\n" "while the second can be produced (under Windows) with: \n\n" "" "(print-table \"c:\" \"c:/\" \"c:a/b\" \"//s/a/b.c\" \"//s.com\")\n\n") ("numeric:s11" "procedure: (bignum? obj)\nreturns: #t if obj is a bignum, otherwise #f \nlibraries: (chezscheme)  \n\n" "" "(bignum? 0) => #f\n(bignum? (most-positive-fixnum)) => #f\n(bignum? (most-negative-fixnum)) => #f\n(bignum? (* (most-positive-fixnum) 2)) => #t\n(bignum? 3/4) => #f\n(bignum? 'a) => #f\n\n") ("numeric:s12" "procedure: (ratnum? obj)\nreturns: #t if obj is a ratnum, otherwise #f \nlibraries: (chezscheme)  \n\n" "" "(ratnum? 0) => #f\n(ratnum? (* (most-positive-fixnum) 2)) => #f\n(ratnum? 3/4) => #t\n(ratnum? -10/2) => #f\n(ratnum? -11/2) => #t\n(ratnum? 'a) => #f\n\n") ("numeric:s13" "procedure: (cflonum? obj)\nreturns: #t if obj is an inexact complexnum or flonum, otherwise #f \nlibraries: (chezscheme)  \n\n" "" "(cflonum? 0) => #f\n(cflonum? 0.0) => #t\n(cflonum? 3+4i) => #f\n(cflonum? 3.0+4i) => #t\n(cflonum? +i) => #f\n(cflonum? +1.0i) => #t\n\n") ("numeric:s14" "procedure: (most-positive-fixnum) \nreturns: the most positive fixnum supported by the system \nprocedure: (most-negative-fixnum) \nreturns: the most negative fixnum supported by the system \nlibraries: (chezscheme)  \n\n" "These procedures are identical to the Revised^6 Report greatest-fixnum and least-fixnum procedures.  \n\n") ("numeric:s15" "procedure: (fx= fixnum1 fixnum2 ...)\nprocedure: (fx< fixnum1 fixnum2 ...)\nprocedure: (fx> fixnum1 fixnum2 ...)\nprocedure: (fx<= fixnum1 fixnum2 ...)\nprocedure: (fx>= fixnum1 fixnum2 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (chezscheme)  \n\n" "The predicate fx= returns #t if its arguments are equal. The predicate fx< returns #t if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while fx> returns #t if its arguments are monotonically decreasing. The predicate fx<= returns #t if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while fx>= returns #t if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns #t.  \n\n" "These procedures are similar to the Revised^6 Report procedures fx=?, fx<?, fx>?, fx<=?, and fx>=? except that the Revised^6 Report procedures require two or more arguments, and their names have the \"?\" suffix. \n\n" "" "(fx= 0) => #t\n(fx= 0 0) => #t\n(fx< (most-negative-fixnum) 0 (most-positive-fixnum)) => #t\n(let ([x 3]) (fx<= 0 x 9)) => #t\n(fx<= 0 3 3) => #t\n(fx>= 0 0 (most-negative-fixnum)) => #t\n\n") ("numeric:s16" "procedure: (fxnonpositive? fixnum)\nreturns: #t if fixnum is not greater than zero, #f otherwise \nprocedure: (fxnonnegative? fixnum)\nreturns: #t if fixnum is not less than zero, #f otherwise \nlibraries: (chezscheme)  \n\n" "fxnonpositive? is equivalent to (lambda (x) (fx<= x 0)), and fxnonnegative? is equivalent to (lambda (x) (fx>= x 0)). \n\n" "" "(fxnonpositive? 128) => #f\n(fxnonpositive? 0) => #t\n(fxnonpositive? -1) => #t \n\n(fxnonnegative? -65) => #f\n(fxnonnegative? 0) => #t\n(fxnonnegative? 1) => #t\n\n") ("numeric:s17" "procedure: (fx+ fixnum ...)\nreturns: the sum of the arguments fixnum ...\nlibraries: (chezscheme)  \n\n" "When called with no arguments, fx+ returns 0.  \n\n" "" "(fx+) => 0\n(fx+ 1 2) => 3\n(fx+ 3 4 5) => 12\n(apply fx+ '(1 2 3 4 5)) => 15\n\n") ("numeric:s18" "procedure: (fx- fixnum1 fixnum2 ...)\nreturns: a fixnum \nlibraries: (chezscheme)  \n\n" "When called with one argument, fx- returns the negative of fixnum1. Thus, (fx- fixnum1) is an idiom for (fx- 0 fixnum1). \n\n" "When called with two or more arguments, fx- returns the result of subtracting the sum of the numbers fixnum2 ... from fixnum1. \n\n" "" "(fx- 3) => -3\n(fx- 4 3) => 1\n(fx- 4 3 2 1) => -2\n\n") ("numeric:s19" "procedure: (fx* fixnum ...)\nreturns: the product of the arguments fixnum ...\nlibraries: (chezscheme)  \n\n" "When called with no arguments, fx* returns 1.  \n\n" "" "(fx*) => 1\n(fx* 1 2) => 2\n(fx* 3 -4 5) => -60\n(apply fx* '(1 -2 3 -4 5)) => 120\n\n") ("numeric:s20" "procedure: (fx/ fixnum1 fixnum2 ...)\nreturns: see explanation \nlibraries: (chezscheme)  \n\n" "When called with one argument, fx/ returns the reciprocal of fixnum1. That is, (fx/ fixnum1) is an idiom for (fx/ 1 fixnum1). \n\n" "When called with two or more arguments, fx/ returns the result of dividing fixnum1 by the product of the remaining arguments fixnum2 .... \n\n" "" "(fx/ 1) => 1\n(fx/ -17) => 0\n(fx/ 8 -2) => -4\n(fx/ -9 2) => -4\n(fx/ 60 5 3 2) => 2\n\n") ("numeric:s21" "procedure: (fx+/wraparound fixnum ...)\nprocedure: (fx-/wraparound fixnum ...)\nprocedure: (fx*/wraparound fixnum ...)\nprocedure: (fxsll/wraparound fixnum ...)\nreturns: the arithmetic result, wrapping on overflow \nlibraries: (chezscheme)  \n\n" "These functions are like fx+, fx-, fx*, and fxsll, but when the result is too large to fit in a fixnum, as many high bits of the result as necessary are discarded to make the result representable as a fixnum. \n\n") ("numeric:s22" "procedure: (fx1+ fixnum)\nprocedure: (fx1- fixnum)\nreturns: fixnum plus 1 or fixnum minus 1 \nlibraries: (chezscheme)  \n\n" "" "(define fxplus\n  (lambda (x y)\n    (if (fxzero? x)\n        y\n        (fxplus (fx1- x) (fx1+ y))))) \n\n(fxplus 7 8) => 15\n\n" "fx1+ and fx1- can be defined as follows:  \n\n" "" "(define fx1+ (lambda (x) (fx+ x 1)))\n(define fx1- (lambda (x) (fx- x 1)))\n\n") ("numeric:s23" "procedure: (fxquotient fixnum1 fixnum2 ...)\nreturns: see explanation \nlibraries: (chezscheme)  \n\n" "fxquotient is identical to fx/. See the description of fx/ above.  \n\n") ("numeric:s24" "procedure: (fxremainder fixnum1 fixnum2)\nreturns: the fixnum remainder of fixnum1 divided by fixnum2\nlibraries: (chezscheme)  \n\n" "The result of fxremainder has the same sign as fixnum1. \n\n" "" "(fxremainder 16 4) => 0\n(fxremainder 5 2) => 1\n(fxremainder -45 7) => -3\n(fxremainder 10 -3) => 1\n(fxremainder -17 -9) => -8\n\n") ("numeric:s25" "procedure: (fxmodulo fixnum1 fixnum2)\nreturns: the fixnum modulus of fixnum1 and fixnum2\nlibraries: (chezscheme)  \n\n" "The result of fxmodulo has the same sign as fixnum2. \n\n" "" "(fxmodulo 16 4) => 0\n(fxmodulo 5 2) => 1\n(fxmodulo -45 7) => 4\n(fxmodulo 10 -3) => -2\n(fxmodulo -17 -9) => -8\n\n") ("numeric:s26" "procedure: (fxabs fixnum)\nreturns: the absolute value of fixnum \nlibraries: (chezscheme)  \n\n" "" "(fxabs 1) => 1\n(fxabs -1) => 1\n(fxabs 0) => 0\n\n") ("numeric:s27" "procedure: (flonum->fixnum flonum)\nreturns: the fixnum representation of flonum, truncated \nlibraries: (chezscheme)  \n\n" "The truncated value of flonum must fall within the fixnum range. flonum->fixnum is a restricted version of exact, which converts any numeric representation to its exact equivalent. \n\n" "" "(flonum->fixnum 0.0) => 0\n(flonum->fixnum 3.9) => 3\n(flonum->fixnum -2.2) => -2\n\n") ("numeric:s29" "procedure: (fl= flonum1 flonum2 ...)\nprocedure: (fl< flonum1 flonum2 ...)\nprocedure: (fl> flonum1 flonum2 ...)\nprocedure: (fl<= flonum1 flonum2 ...)\nprocedure: (fl>= flonum1 flonum2 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (chezscheme)  \n\n" "The predicate fl= returns #t if its arguments are equal. The predicate fl< returns #t if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while fl> returns #t if its arguments are monotonically decreasing. The predicate fl<= returns #t if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while fl>= returns #t if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns #t.  \n\n" "IEEE NANs are not comparable, i.e., comparisons involving NANs always return #f.  \n\n" "These procedures are similar to the Revised^6 Report procedures fl=?, fl<?, fl>?, fl<=?, and fl>=? except that the Revised^6 Report procedures require two or more arguments, and their names have the \"?\" suffix. \n\n" "" "(fl= 0.0) => #t\n(fl= 0.0 0.0) => #t\n(fl< -1.0 0.0 1.0) => #t\n(fl> -1.0 0.0 1.0) => #f\n(fl<= 0.0 3.0 3.0) => #t\n(fl>= 4.0 3.0 3.0) => #t\n(fl< 7.0 +inf.0) => #t\n(fl= +nan.0 0.0) => #f\n(fl= +nan.0 +nan.0) => #f\n(fl< +nan.0 +nan.0) => #f\n(fl> +nan.0 +nan.0) => #f\n\n") ("numeric:s30" "procedure: (flnonpositive? fl)\nreturns: #t if fl is not greater than zero, #f otherwise \nprocedure: (flnonnegative? fl)\nreturns: #t if fl is not less than zero, #f otherwise \nlibraries: (chezscheme)  \n\n" "flnonpositive? is equivalent to (lambda (x) (fl<= x 0.0)), and flnonnegative? is equivalent to (lambda (x) (fl>= x 0.0)). \n\n" "Even if the flonum representation distinguishes -0.0 from +0.0, both are considered nonpositive and nonnegative. \n\n" "" "(flnonpositive? 128.0) => #f\n(flnonpositive? 0.0) => #t\n(flnonpositive? -0.0) => #t\n(flnonpositive? -1.0) => #t \n\n(flnonnegative? -65.0) => #f\n(flnonnegative? 0.0) => #t\n(flnonnegative? -0.0) => #t\n(flnonnegative? 1.0) => #t \n\n(flnonnegative? +nan.0) => #f\n(flnonpositive? +nan.0) => #f \n\n(flnonnegative? +inf.0) => #t\n(flnonnegative? -inf.0) => #f\n\n") ("numeric:s31" "procedure: (flsingle fl)\nreturns: a possibly less precise variant of fl \nlibraries: (chezscheme)  \n\n" "Potentially discards precision from fl so that the result is representable as a 32-bit IEEE floating-point number. \n\n") ("numeric:s32" "procedure: (decode-float x)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "x must be a flonum. decode-float returns a vector with three integer elements, m, e, and s, such that x = sm2^e. It is useful primarily in the printing of floating-point numbers. \n\n" "" "(decode-float 1.0) => #(4503599627370496 -52 1)\n(decode-float -1.0) => #(4503599627370496 -52 -1) \n\n(define slow-identity\n  (lambda (x)\n    (inexact\n      (let ([v (decode-float x)])\n        (let ([m (vector-ref v 0)]\n              [e (vector-ref v 1)]\n              [s (vector-ref v 2)])\n          (* s m (expt 2 e))))))) \n\n(slow-identity 1.0) => 1.0\n(slow-identity -1e20) => -1e20\n\n") ("numeric:s33" "procedure: (fllp flonum)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "fllp returns the 12-bit integer consisting of the exponent plus highest order represented bit of a flonum (ieee 64-bit floating-point number). It can be used to compute a fast approximation of the logarithm of the number. \n\n" "" "(fllp 0.0) => 0\n(fllp 1.0) => 2046\n(fllp -1.0) => 2046 \n\n(fllp 1.5) => 2047 \n\n(fllp +inf.0) => 4094\n(fllp -inf.0) => 4094 \n\n(fllp #b1.0e-1111111111) => 1\n(fllp #b1.0e-10000000000) => 0\n\n") ("numeric:s37" "procedure: (fl-make-rectangular flonum1 flonum2)\nreturns: an inexact complexnum  \nlibraries: (chezscheme)  \n\n" "The inexact complexnum produced by fl-make-rectangular has real part equal to flonum1 and imaginary part equal to flonum2. \n\n" "" "(fl-make-rectangular 2.0 -3.0) => 2.0-3.0i\n(fl-make-rectangular 2.0 0.0) => 2.0+0.0i\n(fl-make-rectangular 2.0 -0.0) => 2.0-0.0i\n\n") ("numeric:s38" "procedure: (cfl-real-part cflonum)\nreturns: the real part of cflonum \nprocedure: (cfl-imag-part cflonum)\nreturns: the imaginary part of cflonum \nlibraries: (chezscheme)  \n\n" "" "(cfl-real-part 2.0-3.0i) => 2.0\n(cfl-imag-part 2.0-3.0i) => -3.0\n(cfl-imag-part 2.0-0.0i) => -0.0\n(cfl-imag-part 2.0-inf.0i) => -inf.0\n\n") ("numeric:s39" "procedure: (cfl= cflonum ...)\nreturns: #t if its arguments are equal, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(cfl= 7.0+0.0i 7.0) => #t\n(cfl= 1.0+2.0i 1.0+2.0i) => #t\n(cfl= 1.0+2.0i 1.0-2.0i) => #f\n\n") ("numeric:s40" "procedure: (cfl+ cflonum ...)\nprocedure: (cfl* cflonum ...)\nprocedure: (cfl- cflonum1 cflonum2 ...)\nprocedure: (cfl/ cflonum1 cflonum2 ...)\nreturns: a cflonum \nlibraries: (chezscheme)  \n\n" "These procedures compute the sum, difference, product, or quotient of inexact complex quantities, whether these quantities are represented by flonums or inexact complexnums. For example, if cfl+ receives two flonum arguments a and b, it returns the sum a + b; in this case, it behaves the same as fl+. With two inexact complexnum arguments a + bi and c + di, it returns the sum (a + c) + (b + d)i. If one argument is a flonum a and the other an inexact complexnum c + di, cfl+ returns (a + c) + di. \n\n" "When passed zero arguments, cfl+ returns 0.0 and cfl* returns 1.0. When passed one argument, cfl- returns the additive inverse of the argument, and cfl/ returns the multiplicative inverse of the argument. When passed three or more arguments, cfl- returns the difference between its first and the sum of its remaining arguments, and cfl/ returns the quotient of its first and the product of its remaining arguments. \n\n" "" "(cfl+) => 0.0\n(cfl*) => 1.0\n(cfl- 5.0+1.0i) => -5.0-1.0i\n(cfl/ 2.0+2.0i) => 0.25-0.25i \n\n(cfl+ 1.0+2.2i -3.7+5.3i) => -2.7+7.5i\n(cfl+ 1.0 -5.3) => -4.3\n(cfl+ 1.0 2.0 -5.3i) => 3.0-5.3i\n(cfl- 1.0+2.5i -3.7) => 4.7+2.5i\n(cfl* 1.0+2.0i 3.0+4.0i) => -5.0+10.0i\n(cfl/ -5.0+10.0i 1.0+2.0i 2.0) => 1.5+2.0i\n\n") ("numeric:s41" "procedure: (cfl-conjugate cflonum)\nreturns: complex conjugate of cflonum \nlibraries: (chezscheme)  \n\n" "The procedure cfl-conjugate, when passed an inexact complex argument a + bi, returns its complex conjugate a + (-b)i. \n\n" "See also conjugate, which is a generic version of this operator that returns the complex conjugate of any valid representation for a complex number. \n\n" "" "(cfl-conjugate 3.0) => 3.0\n(cfl-conjugate 3.0+4.0i) => 3.0-4.0i\n(cfl-conjugate 1e-20-2e-30i) => 1e-20+2e-30i\n\n") ("numeric:s43" "procedure: (cfl-magnitude-squared cflonum)\nreturns: magnitude of cflonum squared \nlibraries: (chezscheme)  \n\n" "The procedure cfl-magnitude-squared, when passed an inexact complex argument a + bi returns a flonum representing the magnitude of the argument squared, i.e., a^2 + b^2. \n\n" "See also magnitude-squared, which is a generic version of this operator that returns the magnitude squared of any valid representation for a complex number. Both operations are similar to the magnitude procedure, which returns the magnitude, sqrt(a^2 + b^2), of its generic complex argument. \n\n" "" "(cfl-magnitude-squared 3.0) => 9.0\n(cfl-magnitude-squared 3.0-4.0i) => 25.0\n\n") ("numeric:s46" "procedure: (logand int ...)\nreturns: the logical \"and\" of the arguments int ...\nlibraries: (chezscheme)  \n\n" "The arguments must be exact integers (fixnums or bignums) and are treated as two's complement integers, regardless of the underlying representation. With no arguments, logand returns -1, i.e., all bits set.  \n\n" "" "(logand) => -1\n(logand 15) => 15\n(logand -1 -1) => -1\n(logand -1 0) => 0\n(logand 5 3) => 1\n(logand #x173C8D95 7) => 5\n(logand #x173C8D95 -8) => #x173C8D90\n(logand #b1100 #b1111 #b1101) => #b1100\n\n") ("numeric:s47" "procedure: (logior int ...)\nprocedure: (logor int ...)\nreturns: the logical \"or\" of the arguments int ...\nlibraries: (chezscheme)  \n\n" "The arguments must be exact integers (fixnums or bignums) and are treated as two's complement integers, regardless of the underlying representation. With no arguments, logior returns 0, i.e., all bits reset.  \n\n" "" "(logior) => 0\n(logior 15) => 15\n(logior -1 -1) => -1\n(logior -1 0) => -1\n(logior 5 3) => 7\n(logior #b111000 #b101010) => #b111010\n(logior #b1000 #b0100 #b0010) => #b1110\n(apply logior '(1 2 4 8 16)) => 31\n\n") ("numeric:s48" "procedure: (logxor int ...)\nreturns: the logical \"exclusive or\" of the arguments int ...\nlibraries: (chezscheme)  \n\n" "The arguments must be exact integers (fixnums or bignums) and are treated as two's complement integers, regardless of the underlying representation. With no arguments, logxor returns 0, i.e., all bits reset.  \n\n" "" "(logxor) => 0\n(logxor 15) => 15\n(logxor -1 -1) => 0\n(logxor -1 0) => -1\n(logxor 5 3) => 6\n(logxor #b111000 #b101010) => #b010010\n(logxor #b1100 #b0100 #b0110) => #b1110\n\n") ("numeric:s49" "procedure: (lognot int)\nreturns: the logical \"not\" of int \nlibraries: (chezscheme)  \n\n" "The argument must be an exact integer (fixnum or bignum) and is treated as a two's complement integer, regardless of the underlying representation. \n\n" "" "(lognot -1) => 0\n(lognot 0) => -1\n(lognot 7) => -8\n(lognot -8) => 7\n\n") ("numeric:s50" "procedure: (logbit? index int)\nreturns: #t if the specified bit is set, otherwise #f \nlibraries: (chezscheme)  \n\n" "index must be a nonnegative exact integer. int must be an exact integer (fixnum or bignum) and is treated as a two's complement integer, regardless of the underlying representation. \n\n" "logbit? returns #t if the bit at index index of int is set (one) and #f otherwise. The index is zero-based, counting from the lowest-order toward higher-order bits. There is no upper limit on the index; for nonnegative values of int, the bits above the highest order set bit are all considered to be zero, and for negative values, the bits above the highest order reset bit are all considered to be one. \n\n" "logbit? is equivalent to  \n\n" "" "(lambda (k n) (not (zero? (logand n (ash 1 k)))))\n\n" "but more efficient. \n\n" "" "(logbit? 0 #b1110) => #f\n(logbit? 1 #b1110) => #t\n(logbit? 2 #b1110) => #t\n(logbit? 3 #b1110) => #t\n(logbit? 4 #b1110) => #f\n(logbit? 100 #b1110) => #f \n\n(logbit? 0 -6) => #f  ; the two's complement of -6 is 1...1010\n(logbit? 1 -6) => #t\n(logbit? 2 -6) => #f\n(logbit? 3 -6) => #t\n(logbit? 100 -6) => #t \n\n(logbit? (random 1000000) 0) => #f\n(logbit? (random 1000000) -1) => #t \n\n(logbit? 20000 (ash 1 20000)) => #t\n\n") ("numeric:s51" "procedure: (logtest int1 int2)\nreturns: #t if any common bits are set, otherwise #f \nlibraries: (chezscheme)  \n\n" "The arguments must be exact integers (fixnums or bignums) and are treated as two's complement integers, regardless of the underlying representation. \n\n" "logtest returns #t if any bit set in one argument is also set in the other. It returns #f if the two arguments have no set bits in common.  \n\n" "logtest is equivalent to  \n\n" "" "(lambda (n1 n2) (not (zero? (logand n1 n2))))\n\n" "but more efficient. \n\n" "" "(logtest #b10001 #b1110) => #f\n(logtest #b10101 #b1110) => #t\n(logtest #b111000 #b110111) => #t \n\n(logtest #b101 -6) => #f  ; the two's complement of -6 is 1...1010\n(logtest #b1000 -6) => #t\n(logtest 100 -6) => #t \n\n(logtest (+ (random 1000000) 1) 0) => #f\n(logtest (+ (random 1000000) 1) -1) => #t \n\n(logtest (ash #b101 20000) (ash #b111 20000)) => #t\n\n") ("numeric:s52" "procedure: (logbit0 index int)\nreturns: the result of clearing bit index of int \nlibraries: (chezscheme)  \n\n" "index must be a nonnegative exact integer. int must be an exact integer (fixnum or bignum) and is treated as a two's complement integer, regardless of the underlying representation. \n\n" "The index is zero-based, counting from the lowest-order toward higher-order bits. As with logbit?, there is no upper limit on the index.  \n\n" "logbit0 is equivalent to  \n\n" "" "(lambda (i n) (logand (lognot (ash 1 i)) n))\n\n" "but more efficient. \n\n" "" "(logbit0 3 #b10101010) => #b10100010\n(logbit0 4 #b10101010) => #b10101010\n(logbit0 0 -1) => -2\n\n") ("numeric:s53" "procedure: (logbit1 index int)\nreturns: the result of setting bit index of int \nlibraries: (chezscheme)  \n\n" "index must be a nonnegative exact integer. int must be an exact integer (fixnum or bignum) and is treated as a two's complement integer, regardless of the underlying representation. \n\n" "The index is zero-based, counting from the lowest-order toward higher-order bits. As with logbit?, there is no upper limit on the index.  \n\n" "logbit1 is equivalent to  \n\n" "" "(lambda (i n) (logor (ash 1 i) n))\n\n" "but more efficient. \n\n" "" "(logbit1 3 #b10101010) => #b10101010\n(logbit1 4 #b10101010) => #b10111010\n(logbit1 4 0) => #b10000\n(logbit1 0 -2) => -1\n\n") ("numeric:s54" "procedure: (ash int count)\nreturns: int shifted left arithmetically by count. \nlibraries: (chezscheme)  \n\n" "Both arguments must be exact integers. The first argument is treated as a two's complement integer, regardless of the underlying representation. If count is negative, int is shifted right by -count bits. \n\n" "" "(ash 8 0) => 8\n(ash 8 2) => 32\n(ash 8 -2) => 2\n(ash -1 2) => -4\n(ash -1 -2) => -1\n\n") ("numeric:s55" "procedure: (fxlogand fixnum ...)\nreturns: the logical \"and\" of the arguments fixnum ...\nlibraries: (chezscheme)  \n\n" "The arguments are treated as two's complement integers, regardless of the underlying representation. With no arguments, fxlogand returns -1, i.e., all bits set.  \n\n" "" "(fxlogand) => -1\n(fxlogand 15) => 15\n(fxlogand -1 -1) => -1\n(fxlogand -1 0) => 0\n(fxlogand 5 3) => 1\n(fxlogand #b111000 #b101010) => #b101000\n(fxlogand #b1100 #b1111 #b1101) => #b1100\n\n") ("numeric:s56" "procedure: (fxlogior fixnum ...)\nprocedure: (fxlogor fixnum ...)\nreturns: the logical \"or\" of the arguments fixnum ...\nlibraries: (chezscheme)  \n\n" "The arguments are treated as two's complement integers, regardless of the underlying representation. With no arguments, fxlogior returns 0, i.e., all bits reset.  \n\n" "" "(fxlogior) => 0\n(fxlogior 15) => 15\n(fxlogior -1 -1) => -1\n(fxlogior -1 0) => -1\n(fxlogior #b111000 #b101010) => #b111010\n(fxlogior #b1000 #b0100 #b0010) => #b1110\n(apply fxlogior '(1 2 4 8 16)) => 31\n\n") ("numeric:s57" "procedure: (fxlogxor fixnum ...)\nreturns: the logical \"exclusive or\" of the arguments fixnum ...\nlibraries: (chezscheme)  \n\n" "The arguments are treated as two's complement integers, regardless of the underlying representation. With no arguments, fxlogxor returns 0, i.e., all bits reset.  \n\n" "" "(fxlogxor) => 0\n(fxlogxor 15) => 15\n(fxlogxor -1 -1) => 0\n(fxlogxor -1 0) => -1\n(fxlogxor 5 3) => 6\n(fxlogxor #b111000 #b101010) => #b010010\n(fxlogxor #b1100 #b0100 #b0110) => #b1110\n\n") ("numeric:s58" "procedure: (fxlognot fixnum)\nreturns: the logical \"not\" of fixnum \nlibraries: (chezscheme)  \n\n" "The argument is treated as a two's complement integer, regardless of the underlying representation. \n\n" "" "(fxlognot -1) => 0\n(fxlognot 0) => -1\n(fxlognot 1) => -2\n(fxlognot -2) => 1\n\n") ("numeric:s59" "procedure: (fxlogbit? index fixnum)\nreturns: #t if the specified bit is set, otherwise #f \nlibraries: (chezscheme)  \n\n" "index must be a nonnegative fixnum. fixnum is treated as a two's complement integer, regardless of the underlying representation. \n\n" "fxlogbit? returns #t if the bit at index index of fixnum is set (one) and #f otherwise. The index is zero-based, counting from the lowest-order toward higher-order bits. The index is limited only by the fixnum range; for nonnegative values of fixnum, the bits above the highest order set bit are all considered to be zero, and for negative values, the bits above the highest order reset bit are all considered to be one. \n\n" "" "(fxlogbit? 0 #b1110) => #f\n(fxlogbit? 1 #b1110) => #t\n(fxlogbit? 2 #b1110) => #t\n(fxlogbit? 3 #b1110) => #t\n(fxlogbit? 4 #b1110) => #f\n(fxlogbit? 100 #b1110) => #f \n\n(fxlogbit? 0 -6) => #f  ; the two's complement of -6 is 1...1010\n(fxlogbit? 1 -6) => #t\n(fxlogbit? 2 -6) => #f\n(fxlogbit? 3 -6) => #t\n(fxlogbit? 100 -6) => #t \n\n(fxlogbit? (random 1000000) 0) => #f\n(fxlogbit? (random 1000000) -1) => #t\n\n") ("numeric:s60" "procedure: (fxlogtest fixnum1 fixnum2)\nreturns: #t if any common bits are set, otherwise #f \nlibraries: (chezscheme)  \n\n" "The arguments are treated as two's complement integers, regardless of the underlying representation. \n\n" "fxlogtest returns #t if any bit set in one argument is also set in the other. It returns #f if the two arguments have no set bits in common.  \n\n" "" "(fxlogtest #b10001 #b1110) => #f\n(fxlogtest #b10101 #b1110) => #t\n(fxlogtest #b111000 #b110111) => #t \n\n(fxlogtest #b101 -6) => #f  ; the two's complement of -6 is 1...1010\n(fxlogtest #b1000 -6) => #t\n(fxlogtest 100 -6) => #t \n\n(fxlogtest (+ (random 1000000) 1) 0) => #f\n(fxlogtest (+ (random 1000000) 1) -1) => #t\n\n") ("numeric:s61" "procedure: (fxlogbit0 index fixnum)\nreturns: the result of clearing bit index of fixnum \nlibraries: (chezscheme)  \n\n" "fixnum is treated as a two's complement integer, regardless of the underlying representation. index must be nonnegative and less than the number of bits in a fixnum, excluding the sign bit, i.e., less than (integer-length (most-positive-fixnum)). The index is zero-based, counting from the lowest-order toward higher-order bits. \n\n" "fxlogbit0 is equivalent to  \n\n" "" "(lambda (i n) (fxlogand (fxlognot (fxsll 1 i)) n))\n\n" "but more efficient. \n\n" "" "(fxlogbit0 3 #b10101010) => #b10100010\n(fxlogbit0 4 #b10101010) => #b10101010\n(fxlogbit0 0 -1) => -2\n\n") ("numeric:s62" "procedure: (fxlogbit1 index fixnum)\nreturns: the result of setting bit index of fixnum \nlibraries: (chezscheme)  \n\n" "fixnum is treated as a two's complement integer, regardless of the underlying representation. index must be nonnegative and less than the number of bits in a fixnum, excluding the sign bit, i.e., less than (integer-length (most-positive-fixnum)). The index is zero-based, counting from the lowest-order toward higher-order bits. \n\n" "fxlogbit1 is equivalent to  \n\n" "" "(lambda (i n) (fxlogor (fxsll 1 i) n))\n\n" "but more efficient. \n\n" "" "(fxlogbit1 3 #b10101010) => #b10101010\n(fxlogbit1 4 #b10101010) => #b10111010\n(fxlogbit1 4 0) => #b10000\n(fxlogbit1 0 -2) => -1\n\n") ("numeric:s63" "procedure: (fxsll fixnum count)\nreturns: fixnum shifted left by count \nlibraries: (chezscheme)  \n\n" "fixnum is treated as a two's complement integer, regardless of the underlying representation. count must be nonnegative and not more than the number of bits in a fixnum, i.e., (+ (integer-length (most-positive-fixnum)) 1). An exception is raised with condition-type &implementation-restriction if the result cannot be represented as a fixnum. \n\n" "" "(fxsll 1 2) => 4\n(fxsll -1 2) => -4\n\n") ("numeric:s64" "procedure: (fxsrl fixnum count)\nreturns: fixnum logically shifted right by count \nlibraries: (chezscheme)  \n\n" "fixnum is treated as a two's complement integer, regardless of the underlying representation. count must be nonnegative and not more than the number of bits in a fixnum, i.e., (+ (integer-length (most-positive-fixnum)) 1). \n\n" "" "(fxsrl 4 2) => 1\n(= (fxsrl -1 1) (most-positive-fixnum)) => #t\n\n") ("numeric:s65" "procedure: (fxsra fixnum count)\nreturns: fixnum arithmetically shifted right by count \nlibraries: (chezscheme)  \n\n" "fixnum is treated as a two's complement integer, regardless of the underlying representation. count must be nonnegative and not more than the number of bits in a fixnum, i.e., (+ (integer-length (most-positive-fixnum)) 1). \n\n" "" "(fxsra 64 3) => 8\n(fxsra -1 1) => -1\n(fxsra -64 3) => -8\n\n") ("numeric:s66" "procedure: (fxpopcount fixnum)\nprocedure: (fxpopcount32 fixnum)\nprocedure: (fxpopcount16 fixnum)\nreturns: number of bits set in fixnum \nlibraries: (chezscheme)  \n\n" "fixnum must be non-negative, and it must have a width of no more than 32 for fxpopcount32 or no more than 16 for fxpopcount16. fixnum is treated as a two's complement integer, regardless of the underlying representation. \n\n" "See also fxbit-count, which produces the same result as fxpopcount for the domain of fxpopcount. Because fxbit-count also handles negative arguments, however, it does not map as simply to certain processor instructions. \n\n") ("numeric:s67" "procedure: (random real)\nreturns: a nonnegative pseudo-random number less than real \nlibraries: (chezscheme)  \n\n" "real must be a positive integer or positive inexact real number. \n\n" "" "(random 1) => 0\n(random 1029384535235) => 1029384535001, every now and then\n(random 1.0) => 0.5, every now and then\n\n") ("numeric:s68" "thread parameter: random-seed \nlibraries: (chezscheme)  \n\n" "The random number generator allows the current random seed to be obtained and modified via the parameter random-seed.  \n\n" "When called without arguments, random-seed returns the current random seed. When called with one argument, which must be a nonnegative exact integer ranging from 1 through 2^32 - 1, random-seed sets the current random seed to the argument. \n\n" "" "(let ([s (random-seed)])\n  (let ([r1 (random 1.0)])\n    (random-seed s)\n    (eqv? (random 1.0) r1))) => #t\n\n") ("numeric:s70" "procedure: (make-pseudo-random-generator) \nreturns: a fresh pseudo-random generator \nlibraries: (chezscheme)  \n\n" "Creates a pseudo-random generator state for use with pseudo-random-generator-next!. This generator uses a more modern algorithm than random and generates number sequences that better approximate true randomness. \n\n" "The initial state of the pseudo-random generator is based on the current time, which is good enough for generating variability in most programs but not good enough for security purposes. \n\n") ("numeric:s71" "procedure: (pseudo-random-generator? val)\nreturns: a boolean \nlibraries: (chezscheme)  \n\n" "Checks whether val is a pseudo-random generator state. \n\n") ("numeric:s72" "procedure: (pseudo-random-generator-next! prgen)\nprocedure: (pseudo-random-generator-next! prgen below-int)\nreturns: a pseudo-random number \nlibraries: (chezscheme)  \n\n" "prgen must be a pseudo-random generator state. If below-int is provided, it must be a positive, exact integer. \n\n" "Steps a pseudo-random generator to produce a number. The result is an inexact number between 0.0 and 1.0 (both exclusive) if below-int is not provided. If below-int is provided, the result is an exact integer between 0 (inclusive) and below-int (exclusive).  \n\n") ("numeric:s73" "procedure: (pseudo-random-generator-seed! prgen seed-int)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "prgen must be a pseudo-random generator state, and seed-int must be a nonnegative, exact integer. \n\n" "Sets the state of a pseudo-random generator using only 31 or so bits of seed-int. This procedure is useful for initializing the state of a pseudo-random generator to one of a small number of known states for triggering predictable output, but it is not a good way to put a generator into an unpredictable state. \n\n") ("numeric:s74" "procedure: (pseudo-random-generator->vector prgen)\nreturns: a vector \nlibraries: (chezscheme) \nprocedure: (vector->pseudo-random-generator vec)\nprocedure: (vector->pseudo-random-generator! prgen vec)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "prgen must be a pseudo-random generator state, and vec must be a vector previously produced by pseudo-random-generator->vector.  \n\n" "pseudo-random-generator->vector converts the current state of a pseudo-random generator to a vector of numbers, vector->pseudo-random-generator creates a fresh pseudo-random generator with the same state, and vector->pseudo-random-generator! changes an existing pseudo-random generator to have the same state. \n\n") ("numeric:s75" "procedure: (= num1 num2 num3 ...)\nprocedure: (< real1 real2 real3 ...)\nprocedure: (> real1 real2 real3 ...)\nprocedure: (<= real1 real2 real3 ...)\nprocedure: (>= real1 real2 real3 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (chezscheme)  \n\n" "These predicates are identical to the Revised^6 Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns #t.  \n\n" "" "(> 3/4) => #t\n(< 3/4) => #t\n(= 3/4) => #t\n\n") ("numeric:s76" "procedure: (1+ num)\nprocedure: (add1 num)\nprocedure: (1- num)\nprocedure: (-1+ num)\nprocedure: (sub1 num)\nreturns: num plus 1 or num minus 1 \nlibraries: (chezscheme)  \n\n" "1+ and add1 are equivalent to (lambda (x) (+ x 1)); 1-, -1+, and sub1 are equivalent to (lambda (x) (- x 1)). \n\n" "" "(define plus\n ; x should be a nonnegative integer\n  (lambda (x y)\n    (if (zero? x)\n        y\n        (plus (1- x) (1+ y))))) \n\n(plus 7 8) => 15 \n\n(define double\n ; x should be a nonnegative integer\n  (lambda (x)\n    (if (zero? x)\n        0\n        (add1 (add1 (double (sub1 x))))))) \n\n(double 7) => 14\n\n") ("numeric:s77" "procedure: (expt-mod int1 int2 int3)\nreturns: int1 raised to the int2 power, modulo int3\nlibraries: (chezscheme)  \n\n" "int1, int2 and int3must be nonnegative integers. expt-mod performs its computation in such a way that the intermediate results are never much larger than int3. This means that when int2 is large, expt-mod is more efficient than the equivalent procedure (lambda (x y z) (modulo (expt x y) z)). \n\n" "" "(expt-mod 2 4 3) => 1\n(expt-mod 2 76543 76543) => 2\n\n") ("numeric:s78" "procedure: (isqrt n)\nreturns: the integer square root of n \nlibraries: (chezscheme)  \n\n" "n must be a nonnegative integer. The integer square root of n is defined to be [image not available]. \n\n" "" "(isqrt 0) => 0\n(isqrt 16) => 4\n(isqrt 16.0) => 4.0\n(isqrt 20) => 4\n(isqrt 20.0) => 4.0\n(isqrt (* 2 (expt 10 20))) => 14142135623\n\n") ("numeric:s79" "procedure: (integer-length n)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "The procedure integer-length returns the length in bits of the smallest two's complement representation for n, with an assumed leading 1 (sign) bit for negative numbers. For zero, integer-length returns 0.  \n\n" "" "(integer-length 0) => 0\n(integer-length 1) => 1\n(integer-length 2) => 2\n(integer-length 3) => 2\n(integer-length 4) => 3\n(integer-length #b10000000) => 8\n(integer-length #b11111111) => 8\n(integer-length -1) => 0\n(integer-length -2) => 1\n(integer-length -3) => 2\n(integer-length -4) => 2\n\n") ("numeric:s80" "procedure: (nonpositive? real)\nreturns: #t if real is not greater than zero, #f otherwise \nlibraries: (chezscheme)  \n\n" "nonpositive? is equivalent to (lambda (x) (<= x 0)). \n\n" "" "(nonpositive? 128) => #f\n(nonpositive? 0.0) => #t\n(nonpositive? 1.8e-15) => #f\n(nonpositive? -2/3) => #t\n\n") ("numeric:s81" "procedure: (nonnegative? real)\nreturns: #t if real is not less than zero, #f otherwise \nlibraries: (chezscheme)  \n\n" "nonnegative? is equivalent to (lambda (x) (>= x 0)). \n\n" "" "(nonnegative? -65) => #f\n(nonnegative? 0) => #t\n(nonnegative? -0.0121) => #f\n(nonnegative? 15/16) => #t\n\n") ("numeric:s82" "procedure: (conjugate num)\nreturns: complex conjugate of num \nlibraries: (chezscheme)  \n\n" "The procedure conjugate, when passed a complex argument a + bi, returns its complex conjugate a + (-b)i. \n\n" "" "(conjugate 3.0+4.0i) => 3.0-4.0i\n(conjugate 1e-20-2e-30i) => 1e-20+2e-30i\n(conjugate 3) => 3\n\n") ("numeric:s83" "procedure: (magnitude-squared num)\nreturns: magnitude of num squared \nlibraries: (chezscheme)  \n\n" "The procedure magnitude-squared, when passed a complex argument a + bi returns its magnitude squared, i.e., a^2 + b^2. \n\n" "" "(magnitude-squared 3.0-4.0i) => 25.0\n(magnitude-squared 3.0) => 9.0\n\n") ("numeric:s84" "procedure: (sinh num)\nprocedure: (cosh num)\nprocedure: (tanh num)\nreturns: the hyperbolic sine, cosine, or tangent of num \nlibraries: (chezscheme)  \n\n" "" "(sinh 0.0) => 0.0\n(cosh 0.0) => 1.0\n(tanh -0.0) => -0.0\n\n") ("numeric:s85" "procedure: (asinh num)\nprocedure: (acosh num)\nprocedure: (atanh num)\nreturns: the hyperbolic arc sine, arc cosine, or arc tangent of num \nlibraries: (chezscheme)  \n\n" "" "(acosh 0.0) => 0.0+1.5707963267948966i\n(acosh 1.0) => 0.0\n(atanh -1.0) => -inf.0\n\n") ("numeric:s86" "procedure: (string->number string)\nprocedure: (string->number string radix)\nreturns: the number represented by string, or #f \nlibraries: (chezscheme)  \n\n" "This procedure is identical to the Revised^6 Report version except that radix may be any exact integer between 2 and 36, inclusive. The Revised^6 Report version requires radix to be in the set {2,8,10,16}. \n\n" "" "(string->number \"211012\" 3) => 559\n(string->number \"tobeornottobe\" 36) => 140613689159812836698\n\n") ("numeric:s87" "procedure: (number->string num)\nprocedure: (number->string num radix)\nprocedure: (number->string num radix precision)\nreturns: an external representation of num as a string \nlibraries: (chezscheme)  \n\n" "This procedure is identical to the Revised^6 Report version except that radix may be any exact integer between 2 and 36, inclusive. The Revised^6 Report version requires radix to be in the set {2,8,10,16}. \n\n" "" "(number->string 10000 4) => \"2130100\"\n(number->string 10000 27) => \"DJA\"\n\n" "") ("objects:s0" "procedure: (enum-set? obj)\nreturns: #t if obj is an enum set, #f otherwise \nlibraries: (chezscheme)  \n\n" "This predicate is not defined by the Revised^6 Report, but should be. \n\n") ("objects:s1" "procedure: (record-constructor-descriptor? obj)\nreturns: #t if obj is a record constructor descriptor, #f otherwise \nlibraries: (chezscheme)  \n\n" "This predicate is not defined by the Revised^6 Report, but should be. \n\n") ("objects:s2" "procedure: (atom? obj)\nreturns: #t if obj is not a pair, #f otherwise \nlibraries: (chezscheme)  \n\n" "atom? is equivalent to (lambda (x) (not (pair? x))). \n\n" "" "(atom? '(a b c)) => #f\n(atom? '(3 . 4)) => #f\n(atom? '()) => #t\n(atom? 3) => #t\n\n") ("objects:s3" "procedure: (list-head list n)\nreturns: a list of the first n elements of list \nlibraries: (chezscheme)  \n\n" "n must be an exact nonnegative integer less than or equal to the length of list. \n\n" "list-head and the standard Scheme procedure list-tail  may be used together to split a list into two separate lists. While list-tail performs no allocation but instead returns a sublist of the original list, list-head always returns a copy of the first portion of the list. \n\n" "list-head may be defined as follows.  \n\n" "" "(define list-head\n  (lambda (ls n)\n    (if (= n 0)\n        '()\n        (cons (car ls) (list-head (cdr ls) (- n 1)))))) \n\n(list-head '(a b c) 0) => ()\n(list-head '(a b c) 2) => (a b)\n(list-head '(a b c) 3) => (a b c)\n(list-head '(a b c . d) 2) => (a b)\n(list-head '(a b c . d) 3) => (a b c)\n(list-head '#1=(a . #1#) 5) => (a a a a a)\n\n") ("objects:s4" "procedure: (last-pair list)\nreturns: the last pair of a list \nlibraries: (chezscheme)  \n\n" "list must not be empty. last-pair returns the last pair (not the last element) of list. list may be an improper list, in which case the last pair is the pair containing the last element and the terminating object. \n\n" "" "(last-pair '(a b c d)) => (d)\n(last-pair '(a b c . d)) => (c . d)\n\n") ("objects:s5" "procedure: (list-assuming-immutable? v)\nreturns: a boolean \nlibraries: (chezscheme)  \n\n" "Like list?, but on the assumption that any pairs traversed while computing the result are never mutated further, the result is produced in amoritized constant time. \n\n" "" "(list-assuming-immutable? '(a b c d)) => #t\n(list-assuming-immutable? '(a b c . d)) => #f\n\n") ("objects:s6" "procedure: (list-copy list)\nreturns: a copy of list \nlibraries: (chezscheme)  \n\n" "list-copy returns a list equal? to list, using new pairs to reform the top-level list structure. \n\n" "" "(list-copy '(a b c)) => (a b c) \n\n(let ([ls '(a b c)])\n  (equal? ls (list-copy ls))) => #t \n\n(let ([ls '(a b c)])\n  (let ([ls-copy (list-copy ls)])\n    (or (eq? ls-copy ls)\n        (eq? (cdr ls-copy) (cdr ls))\n        (eq? (cddr ls-copy) (cddr ls))))) => #f\n\n") ("objects:s7" "procedure: (list* obj ... final-obj)\nreturns: a list of obj ... terminated by final-obj \nlibraries: (chezscheme)  \n\n" "list* is identical to the Revised^6 Report cons*.  \n\n") ("objects:s8" "procedure: (make-list n)\nprocedure: (make-list n obj)\nreturns: a list of n objs \nlibraries: (chezscheme)  \n\n" "n must be a nonnegative integer. If obj is omitted, the elements of the list are unspecified. \n\n" "" "(make-list 0 '()) => ()\n(make-list 3 0) => (0 0 0)\n(make-list 2 \"hi\") => (\"hi\" \"hi\")\n\n") ("objects:s9" "procedure: (iota n)\nreturns: a list of integers from 0 (inclusive) to n (exclusive) \nlibraries: (chezscheme)  \n\n" "n must be an exact nonnegative integer. \n\n" "" "(iota 0) => ()\n(iota 5) => (0 1 2 3 4)\n\n") ("objects:s10" "procedure: (enumerate ls)\nreturns: a list of integers from 0 (inclusive) to the length of ls (exclusive) \nlibraries: (chezscheme)  \n\n" "" "(enumerate '()) => ()\n(enumerate '(a b c)) => (0 1 2)\n(let ([ls '(a b c)])\n  (map cons ls (enumerate ls))) => ((a . 0) (b . 1) (c . 2))\n\n") ("objects:s11" "procedure: (remq! obj list)\nprocedure: (remv! obj list)\nprocedure: (remove! obj list)\nreturns: a list containing the elements of list with all occurrences of obj removed \nlibraries: (chezscheme)  \n\n" "These procedures are similar to the Revised^6 Report remq, remv, and remove procedures, except remq!, remv! and remove! use pairs from the input list to build the output list. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately. \n\n" "" "(remq! 'a '(a b a c a d)) => (b c d) \n\n(remv! #\\a '(#\\a #\\b #\\c)) => (#\\b #\\c) \n\n(remove! '(c) '((a) (b) (c))) => ((a) (b))\n\n") ("objects:s12" "procedure: (substq new old tree)\nprocedure: (substv new old tree)\nprocedure: (subst new old tree)\nprocedure: (substq! new old tree)\nprocedure: (substv! new old tree)\nprocedure: (subst! new old tree)\nreturns: a tree with new substituted for occurrences of old in tree \nlibraries: (chezscheme)  \n\n" "These procedures traverse tree, replacing all objects equivalent to the object old with the object new. \n\n" "The equivalence test for substq and substq! is eq?, for substv and substv! is eqv?, and for subst and subst! is equal?.  \n\n" "substq!, substv!, and subst! perform the substitutions destructively. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately. \n\n" "" "(substq 'a 'b '((b c) b a)) => ((a c) a a) \n\n(substv 2 1 '((1 . 2) (1 . 4) . 1)) => ((2 . 2) (2 . 4) . 2) \n\n(subst 'a\n       '(a . b)\n       '((a . b) (c a . b) . c)) => (a (c . a) . c) \n\n(let ([tr '((b c) b a)])\n  (substq! 'a 'b tr)\n  tr) => ((a c) a a)\n\n") ("objects:s13" "procedure: (reverse! list)\nreturns: a list containing the elements of list in reverse order \nlibraries: (chezscheme)  \n\n" "reverse! destructively reverses list by reversing its links. Using reverse! in place of reverse reduces allocation but is not necessarily faster than reverse. Its use can easily lead to confusing or incorrect results if used indiscriminately. \n\n" "" "(reverse! '()) => ()\n(reverse! '(a b c)) => (c b a) \n\n(let ([x '(a b c)])\n    (reverse! x)\n    x) => (a) \n\n(let ([x '(a b c)])\n    (set! x (reverse! x))\n    x) => (c b a)\n\n") ("objects:s14" "procedure: (append! list ...)\nreturns: the concatenation of the input lists \nlibraries: (chezscheme)  \n\n" "Like append, append! returns a new list consisting of the elements of the first list followed by the elements of the second list, the elements of the third list, and so on. Unlike append, append! reuses the pairs in all of the arguments in forming the new list. That is, the last cdr of each list argument but the last is changed to point to the next list argument. If any argument but the last is the empty list, it is essentially ignored. The final argument (which need not be a list) is not altered. \n\n" "append! performs less allocation than append but is not necessarily faster. Its use can easily lead to confusing or incorrect results if used indiscriminately. \n\n" "" "(append! '(a b) '(c d)) => (a b c d) \n\n(let ([x '(a b)])\n    (append! x '(c d))\n    x) => (a b c d)\n\n") ("objects:s16" "procedure: (char=? char1 char2 ...)\nprocedure: (char<? char1 char2 ...)\nprocedure: (char>? char1 char2 ...)\nprocedure: (char<=? char1 char2 ...)\nprocedure: (char>=? char1 char2 ...)\nprocedure: (char-ci=? char1 char2 ...)\nprocedure: (char-ci<? char1 char2 ...)\nprocedure: (char-ci>? char1 char2 ...)\nprocedure: (char-ci<=? char1 char2 ...)\nprocedure: (char-ci>=? char1 char2 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (chezscheme)  \n\n" "These predicates are identical to the Revised^6 Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns #t.  \n\n" "" "(char>? #\\a) => #t\n(char<? #\\a) => #t\n(char-ci=? #\\a) => #t\n\n") ("objects:s17" "procedure: (char- char1 char2)\nreturns: the integer difference between char1 and char2\nlibraries: (chezscheme)  \n\n" "char- subtracts the integer value of char2 from the integer value of char1 and returns the difference. The following examples assume that the integer representation is the ASCII code for the character. \n\n" "" "(char- #\\f #\\e) => 1 \n\n(define digit-value\n ; returns the digit value of the base-r digit c, or #f if c\n ; is not a valid digit\n  (lambda (c r)\n    (let ([v (cond\n               [(char<=? #\\0 c #\\9) (char- c #\\0)]\n               [(char<=? #\\A c #\\Z) (char- c #\\7)]\n               [(char<=? #\\a c #\\z) (char- c #\\W)]\n               [else 36])])\n      (and (fx< v r) v))))\n(digit-value #\\8 10) => 8\n(digit-value #\\z 10) => #f\n(digit-value #\\z 36) => 35\n\n" "char- might be defined as follows.  \n\n" "" "(define char-\n  (lambda (c1 c2)\n    (- (char->integer c1) (char->integer c2))))\n\n") ("objects:s18" "procedure: (char-grapheme-step char state)\nreturns: two values: a boolean indicating whether a cluster terminated and a new state \nlibraries: (chezscheme)  \n\n" "char must be a character, and state must be a fixnum. \n\n" "char-grapheme-step encodes a state machine for Unicode's grapheme specification on a sequence of code points. It accepts a character for the next code point in a sequence, and it returns two values: whether a (single) grapheme cluster has terminated since the most recently reported termination (or the start of the stream), and a new state to be used with char-grapheme-step and the next character.  \n\n" "A state is represented by a fixnum. A value of 0 for state represents the initial state or a state where no characters are pending toward a new boundary. Thus, if a sequence of characters is exhausted and state is not 0, then the end of the stream creates one last grapheme boundary. \n\n" "char-grapheme-step will produce a result for any fixnum state, but the meaning of a non-0 state is specified only in that providing such a state produced by char-grapheme-step in another call to char-grapheme-step continues detecting grapheme boundaries in the sequence. \n\n") ("objects:s19" "procedure: (char-grapheme-break-property char)\nreturns: a symbol \nlibraries: (chezscheme)  \n\n" "char-grapheme-break-property reports the grapheme-break property of char, one of Other, CR, LF, Control, Extend, ZWJ, Regional_Indicator, Prepend, SpacingMark, L, V, T, LV, or LVT. This function is used in the implementation of char-grapheme-step.  \n\n" "" "(char-grapheme-break-property #\\a)    => Other\n(char-grapheme-break-property #\\x300) => Extend\n\n") ("objects:s20" "procedure: (char-extended-pictographic? char)\nreturns: a boolean \nlibraries: (chezscheme)  \n\n" "char-extended-pictographic? reports whether char has the Unicode Extended_Pictographic property. This function is used in the implementation of char-grapheme-step.  \n\n" "" "(char-extended-pictographic? #\\a)   => #f\n(char-extended-pictographic? #\\xA9) => #t\n\n") ("objects:s25" "procedure: (string=? string1 string2 string3 ...)\nprocedure: (string<? string1 string2 string3 ...)\nprocedure: (string>? string1 string2 string3 ...)\nprocedure: (string<=? string1 string2 string3 ...)\nprocedure: (string>=? string1 string2 string3 ...)\nprocedure: (string-ci=? string1 string2 string3 ...)\nprocedure: (string-ci<? string1 string2 string3 ...)\nprocedure: (string-ci>? string1 string2 string3 ...)\nprocedure: (string-ci<=? string1 string2 string3 ...)\nprocedure: (string-ci>=? string1 string2 string3 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (chezscheme)  \n\n" "These predicates are identical to the Revised^6 Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns #t.  \n\n" "" "(string>? \"a\") => #t\n(string<? \"a\") => #t\n(string-ci=? \"a\") => #t\n\n") ("objects:s26" "procedure: (string-copy! src src-start dst dst-start n)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "src and dst must be strings, and dst must be mutable. src-start, dst-start, and n must be exact nonnegative integers. The sum of src-start and n must not exceed the length of src, and the sum of dst-start and n must not exceed the length of dst. \n\n" "string-copy! overwrites the n bytes of dst starting at dst-start with the n bytes of dst starting at src-start. This works even if dst is the same string as src and the source and destination locations overlap. That is, the destination is filled with the characters that appeared at the source before the operation began. \n\n" "" "(define s1 \"to boldly go\")\n(define s2 (make-string 10 #\\-)) \n\n(string-copy! s1 3 s2 1 3)\ns2 => \"-bol------\"\n \n(string-copy! s1 7 s2 4 2)\ns2 => \"-bolly----\"\n \n(string-copy! s2 2 s2 5 4)\ns2 => \"-bollolly-\"\n\n") ("objects:s27" "procedure: (substring-fill! string start end char)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "string must be mutable. The characters of string from start (inclusive) to end (exclusive) are set to char. start and end must be nonnegative integers; start must be strictly less than the length of string, while end may be less than or equal to the length of string. If end <= start, the string is left unchanged. \n\n" "" "(let ([str (string-copy \"a tpyo typo\")])\n  (substring-fill! str 2 6 #\\X)\n  str) => \"a XXXX typo\"\n\n") ("objects:s28" "procedure: (string-truncate! string n)\nreturns: string or the empty string \nlibraries: (chezscheme)  \n\n" "string must be mutable. n must be an exact nonnegative fixnum not greater than the length of string. If n is zero, string-truncate! returns the empty string. Otherwise, string-truncate! destructively truncates string to its first n characters and returns string. \n\n" "" "(define s (make-string 7 #\\$))\n(string-truncate! s 0) => \"\"\ns => \"$$$$$$$\"\n(string-truncate! s 3) => \"$$$\"\ns => \"$$$\"\n\n") ("objects:s29" "procedure: (mutable-string? obj)\nreturns: #t if obj is a mutable string, #f otherwise \nprocedure: (immutable-string? obj)\nreturns: #t if obj is an immutable string, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(mutable-string? (string #\\a #\\b #\\c)) => #t\n(mutable-string? (string->immutable-string \"abc\")) => #f\n(immutable-string? (string #\\a #\\b #\\c)) => #f\n(immutable-string? (string->immutable-string \"abc\")) => #t\n(immutable-string? (cons 3 4)) => #f\n\n") ("objects:s30" "procedure: (string->immutable-string string)\nreturns: an immutable string equal to string \nlibraries: (chezscheme)  \n\n" "The result is string itself if string is immutable; otherwise, the result is an immutable string with the same content as string. \n\n" "" "(define s (string->immutable-string (string #\\x #\\y #\\z)))\n(string-set! s 0 #\\a) => exception: not mutable\n\n") ("objects:s33" "procedure: (string-append-immutable string ...)\nreturns: an immutable string that appends the argument strings \nlibraries: (chezscheme)  \n\n" "Like string-append, but produces an immutable string.  \n\n") ("objects:s34" "procedure: (string-grapheme-span string start)\nprocedure: (string-grapheme-span string start end)\nreturns: the number of characters in a grapheme cluster at the given start \nlibraries: (chezscheme)  \n\n" "start and end must indicate a valid range in the string as for substring, where the length of the string is used if end is not supplied. \n\n" "The result is the number of characters (i.e., code points) in the string that form a Unicode grapheme cluster starting at start, assuming that start is the start of a grapheme cluster and extending no further than the character before end. The result is 0 if start equals end. \n\n" "" "(string-grapheme-span (string #\\a) 0)              => 1\n(string-grapheme-span (string #\\a #\\x300) 0)       => 2\n(string-grapheme-span (string #\\a #\\x300 #\\a) 0)   => 2\n(string-grapheme-span (string #\\a #\\x300 #\\a) 0 1) => 1\n\n") ("objects:s35" "procedure: (string-grapheme-count string)\nprocedure: (string-grapheme-count string start)\nprocedure: (string-grapheme-count string start end)\nreturns: the number of Unicode grapheme clusters (see below) \nlibraries: (chezscheme)  \n\n" "start and end must indicate a valid range in the string as for substring, where 0 is used if start is not provided, and the length of the string is used if end is not supplied. \n\n" "The result is the number of Unicode grapheme clusters in the substring of string selected by start and end. \n\n" "" "(string-grapheme-count (string #\\a) 0)              => 1\n(string-grapheme-count (string #\\a #\\x300) 0)       => 1\n(string-grapheme-count (string #\\a #\\x300 #\\a) 0)   => 2\n(string-grapheme-count (string #\\a #\\x300 #\\a) 0 1) => 1\n\n") ("objects:s42" "procedure: (vector-copy vector)\nprocedure: (vector-copy vector start n)\nreturns: a new vector \nlibraries: (chezscheme)  \n\n" "vector must be a vector. start and n must be exact nonnegative integers. The sum of start and n must not exceed the length of vector. When start and n are not supplied, 0 and (vector-length vector) are used. \n\n" "vector-copy creates a new vector that contains n consecutive elements of vector from position start. When start and n are not supplied, the result is a copy of vector. The vector elements themselves are not copied. \n\n" "" "(vector-copy '#(a b c)) => #(a b c)\n(vector-copy '#(a b c d) 1 2) => #(b c) \n\n(let ([v '#(a b c)])\n  (eq? v (vector-copy v))) => #f\n\n") ("objects:s43" "procedure: (vector-append vector ...)\nreturns: a new vector \nlibraries: (chezscheme)  \n\n" "vector-append creates a new vector whose content is the concatenation of the given vectors in order. \n\n" "" "(vector-append '#(a b c)) => #(a b c)\n(vector-append '#(a b c) '#(d e) '#(f)) => #(a b c d e f)\n(vector-append) => #()\n\n") ("objects:s44" "procedure: (vector-set/copy vector n val)\nreturns: a new vector with val at index n \nlibraries: (chezscheme)  \n\n" "vector must be a vector. n must be exact nonnegative integer that is a valid element index for the vector. \n\n" "vector-set/copy creates a new vector whose content is the same as vector, except that the element at index n is changed to val. \n\n" "" "(vector-set/copy '#(a b c) 0 'x) => #(x b c)\n(vector-set/copy '#(a b c) 2 'x) => #(a b x)\n\n") ("objects:s45" "procedure: (vector-set-fixnum! vector n fixnum)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "vector must be mutable. vector-set-fixnum! changes the nth element of vector to fixnum. n must be an exact nonnegative integer strictly less than the length of vector. \n\n" "It is faster to store a fixnum than an arbitrary value, since for arbitrary values, the system has to record potential assignments from older to younger objects to support generational garbage collection. Care must be taken to ensure that the argument is indeed a fixnum, however; otherwise, the collector may not properly track the assignment. The primitive performs a fixnum check on the argument except at optimization level 3. \n\n" "See also the description of fixnum-only vectors (fxvectors) below. \n\n" "" "(let ([v (vector 1 2 3 4 5)])\n  (vector-set-fixnum! v 2 73)\n  v) => #(1 2 73 4 5)\n\n") ("objects:s46" "procedure: (vector-cas! vector n old-obj new-obj)\nreturns: #t if vector is changed, #f otherwise \nlibraries: (chezscheme)  \n\n" "vector must be mutable. vector-cas! atomically changes the nth element of vector to new-obj if the replaced nth element is eq? to old-obj. If the nth element of vector that would be replaced is not eq? to old-obj, then vector is unchanged. \n\n" "On an architecture with a weak memory model, vector-cas! can spuriously fail, leaving vector unchanged and returning #f even if the current value of element n is old-obj. On success, no memory ordering is implied, which means that memory-order-acquire and/or memory-order-release may be needed to complete an intended synchronization. \n\n" "" "(define v (vector 'old0 'old1 'old2))\n(vector-cas! v 1 'old1 'new1) => #t, assuming no spurious failure\n(vector-ref v 1) => 'new1\n(vector-cas! v 2 'old1 'new2) => #f\n(vector-ref v 2) => 'old2\n\n") ("objects:s47" "procedure: (mutable-vector? obj)\nreturns: #t if obj is a mutable vector, #f otherwise \nprocedure: (immutable-vector? obj)\nreturns: #t if obj is an immutable vector, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(mutable-vector? (vector 1 2 3)) => #t\n(mutable-vector? (vector->immutable-vector (vector 1 2 3))) => #f\n(immutable-vector? (vector 1 2 3)) => #f\n(immutable-vector? (vector->immutable-vector (vector 1 2 3))) => #t\n(immutable-vector? (cons 3 4)) => #f\n\n") ("objects:s48" "procedure: (vector->immutable-vector vector)\nreturns: an immutable vector equal to vector \nlibraries: (chezscheme)  \n\n" "The result is vector itself if vector is immutable; otherwise, the result is an immutable vector with the same content as vector. \n\n" "" "(define v (vector->immutable-vector (vector 1 2 3)))\n(vector-set! v 0 0) => exception: not mutable\n\n") ("objects:s51" "procedure: (immutable-vector obj ...)\nprocedure: (immutable-vector-copy vector)\nprocedure: (immutable-vector-copy vector start n)\nprocedure: (immutable-vector-append vector ...)\nprocedure: (vector-set/copy vector n val)\nlibraries: (chezscheme)  \n\n" "Like vector, vector-copy,  vector-append, and vector-set/copy, but these procedures return an immutable vector instead of a mutable one, and they may return an existing object instead of allocating a new one. In the case of immutable-vector-copy, immutable-vector-append, or immutable-vector-set/copy, an argument vector can be mutable or immutable.  \n\n") ("objects:s52" "thread parameter: self-evaluating-vectors \nlibraries: (chezscheme)  \n\n" "The default value of this parameter is #f, meaning that vector literals must be quoted, as required by the Revised^6 Report. Setting self-evaluating-vectors to a true value may be useful to provide compatibility with R^7RS, as the latter states that vectors are self-evaluating. \n\n" "" "#(a b c) => exception: invalid syntax\n\n(self-evaluating-vectors #t)\n#(a b c) => #(a b c)\n\n") ("objects:s56" "procedure: (fxvector? obj)\nreturns: #t if obj is an fxvector, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(fxvector? #vfx()) => #t\n(fxvector? #vfx(1 2 3)) => #t\n(fxvector? (fxvector 1 2 3)) => #t\n(fxvector? '#(a b c)) => #f\n(fxvector? '(a b c)) => #f\n(fxvector? \"abc\") => #f\n\n") ("objects:s57" "procedure: (fxvector fixnum ...)\nreturns: an fxvector of the fixnums fixnum ...\nlibraries: (chezscheme)  \n\n" "" "(fxvector) => #vfx()\n(fxvector 1 3 5) => #vfx(1 3 5)\n\n") ("objects:s58" "procedure: (make-fxvector n)\nprocedure: (make-fxvector n fixnum)\nreturns: an fxvector of length n \nlibraries: (chezscheme)  \n\n" "n must be a fixnum. If fixnum is supplied, each element of the fxvector is initialized to fixnum; otherwise, the elements are unspecified. \n\n" "" "(make-fxvector 0) => #vfx()\n(make-fxvector 0 7) => #vfx()\n(make-fxvector 5 7) => #vfx(7 7 7 7 7)\n\n") ("objects:s59" "procedure: (fxvector-length fxvector)\nreturns: the number of elements in fxvector \nlibraries: (chezscheme)  \n\n" "" "(fxvector-length #vfx()) => 0\n(fxvector-length #vfx(1 2 3)) => 3\n(fxvector-length #10vfx(1 2 3)) => 10\n(fxvector-length (fxvector 1 2 3 4)) => 4\n(fxvector-length (make-fxvector 300)) => 300\n\n") ("objects:s60" "procedure: (fxvector-ref fxvector n)\nreturns: the nth element (zero-based) of fxvector \nlibraries: (chezscheme)  \n\n" "n must be a nonnegative fixnum strictly less than the length of fxvector. \n\n" "" "(fxvector-ref #vfx(-1 2 4 7) 0) => -1\n(fxvector-ref #vfx(-1 2 4 7) 1) => 2\n(fxvector-ref #vfx(-1 2 4 7) 3) => 7\n\n") ("objects:s61" "procedure: (fxvector-set! fxvector n fixnum)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "n must be a nonnegative fixnum strictly less than the length of fxvector. fxvector-set! changes the nth element of fxvector to fixnum. \n\n" "" "(let ([v (fxvector 1 2 3 4 5)])\n  (fxvector-set! v 2 (fx- (fxvector-ref v 2)))\n  v) => #vfx(1 2 -3 4 5)\n\n") ("objects:s62" "procedure: (fxvector-fill! fxvector fixnum)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "fxvector-fill! replaces each element of fxvector with fixnum. \n\n" "" "(let ([v (fxvector 1 2 3)])\n  (fxvector-fill! v 0)\n  v) => #vfx(0 0 0)\n\n") ("objects:s63" "procedure: (fxvector->list fxvector)\nreturns: a list of the elements of fxvector \nlibraries: (chezscheme)  \n\n" "" "(fxvector->list (fxvector)) => ()\n(fxvector->list #vfx(7 5 2)) => (7 5 2) \n\n(let ([v #vfx(1 2 3 4 5)])\n  (apply fx* (fxvector->list v))) => 120\n\n") ("objects:s64" "procedure: (list->fxvector list)\nreturns: an fxvector of the elements of list \nlibraries: (chezscheme)  \n\n" "list must consist entirely of fixnums. \n\n" "" "(list->fxvector '()) => #vfx()\n(list->fxvector '(3 5 7)) => #vfx(3 5 7) \n\n(let ([v #vfx(1 2 3 4 5)])\n  (let ([ls (fxvector->list v)])\n    (list->fxvector (map fx* ls ls)))) => #vfx(1 4 9 16 25)\n\n") ("objects:s65" "procedure: (fxvector-copy fxvector)\nreturns: a copy of fxvector \nlibraries: (chezscheme)  \n\n" "fxvector-copy creates a new fxvector with the same length and contents as fxvector. \n\n" "" "(fxvector-copy #vfx(3 4 5)) => #vfx(3 4 5) \n\n(let ([v #vfx(3 4 5)])\n  (eq? v (fxvector-copy v))) => #f\n\n") ("objects:s69" "procedure: (flvector? obj)\nreturns: #t if obj is an flvector, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(flvector? #vfl()) => #t\n(flvector? #vfl(1.0 2.0 3.0)) => #t\n(flvector? (flvector 1.0 2.0 3.0)) => #t\n(flvector? '#(a b c)) => #f\n(flvector? '(a b c)) => #f\n(flvector? \"abc\") => #f\n\n") ("objects:s70" "procedure: (flvector flonum ...)\nreturns: an flvector of the flonums flonum ...\nlibraries: (chezscheme)  \n\n" "" "(flvector) => #vfl()\n(flvector 1.0 3.0 5.0) => #vfl(1.0 3.0 5.0)\n\n") ("objects:s71" "procedure: (make-flvector n)\nprocedure: (make-flvector n flonum)\nreturns: an flvector of length n \nlibraries: (chezscheme)  \n\n" "n must be a fixnum. If flonum is supplied, each element of the flvector is initialized to flonum; otherwise, the elements are unspecified. \n\n" "" "(make-flvector 0) => #vfl()\n(make-flvector 0 7.0) => #vfl()\n(make-flvector 5 7.0) => #vfl(7.0 7.0 7.0 7.0 7.0)\n\n") ("objects:s72" "procedure: (flvector-length flvector)\nreturns: the number of elements in flvector \nlibraries: (chezscheme)  \n\n" "" "(flvector-length #vfl()) => 0\n(flvector-length #vfl(1.0 2.0 3.0)) => 3\n(flvector-length #10vfl(1.0 2.0 3.0)) => 10\n(flvector-length (flvector 1.0 2.0 3.0 4.0)) => 4\n(flvector-length (make-flvector 300)) => 300\n\n") ("objects:s73" "procedure: (flvector-ref flvector n)\nreturns: the nth element (zero-based) of flvector \nlibraries: (chezscheme)  \n\n" "n must be a nonnegative fixnum strictly less than the length of flvector. \n\n" "" "(flvector-ref #vfl(-1.0 2.0 4.0 7.0) 0) => -1.0\n(flvector-ref #vfl(-1.0 2.0 4.0 7.0) 1) => 2.0\n(flvector-ref #vfl(-1.0 2.0 4.0 7.0) 3) => 7.0\n\n") ("objects:s74" "procedure: (flvector-set! flvector n flonum)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "n must be a nonnegative fixnum strictly less than the length of flvector. flvector-set! changes the nth element of flvector to flonum. \n\n" "" "(let ([v (flvector 1.0 2.0 3.0 4.0 5.0)])\n  (flvector-set! v 2 (fx- (flvector-ref v 2)))\n  v) => #vfl(1.0 2.0 -3.0 4.0 5.0)\n\n") ("objects:s75" "procedure: (flvector-fill! flvector flonum)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "flvector-fill! replaces each element of flvector with flonum. \n\n" "" "(let ([v (flvector 1.0 2.0 3.0)])\n  (flvector-fill! v 0.0)\n  v) => #vfl(0.0 0.0 0.0)\n\n") ("objects:s76" "procedure: (flvector->list flvector)\nreturns: a list of the elements of flvector \nlibraries: (chezscheme)  \n\n" "" "(flvector->list (flvector)) => ()\n(flvector->list #vfl(7.0 5.0 2.0)) => (7.0 5.0 2.0) \n\n(let ([v #vfl(1.0 2.0 3.0 4.0 5.0)])\n  (apply fl* (flvector->list v))) => 120.0\n\n") ("objects:s77" "procedure: (list->flvector list)\nreturns: an flvector of the elements of list \nlibraries: (chezscheme)  \n\n" "list must consist entirely of flonums. \n\n" "" "(list->flvector '()) => #vfl()\n(list->flvector '(3.0 5.0 7.0)) => #vfl(3.0 5.0 7.0) \n\n(let ([v #vfl(1.0 2.0 3.0 4.0 5.0)])\n  (let ([ls (flvector->list v)])\n    (list->flvector (map fx* ls ls)))) => #vfl(1.0 4.0 9.0 16.0 25.0)\n\n") ("objects:s78" "procedure: (flvector-copy flvector)\nreturns: a copy of flvector \nlibraries: (chezscheme)  \n\n" "flvector-copy creates a new flvector with the same length and contents as flvector. \n\n" "" "(flvector-copy #vfl(3.0 4.0 5.0)) => #vfl(3.0 4.0 5.0) \n\n(let ([v #vfl(3.0 4.0 5.0)])\n  (eq? v (flvector-copy v))) => #f\n\n") ("objects:s82" "procedure: (bytevector fill ...)\nreturns: a new bytevector containing fill ...\nlibraries: (chezscheme)  \n\n" "Each fill value must be an exact integer representing a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent. \n\n" "" "(bytevector) => #vu8()\n(bytevector 1 3 5) => #vu8(1 3 5)\n(bytevector -1 -3 -5) => #vu8(255 253 251)\n\n") ("objects:s83" "procedure: (bytevector->s8-list bytevector)\nreturns: a new list of the 8-bit signed elements of bytevector \nlibraries: (chezscheme)  \n\n" "The values in the returned list are exact eight-bit signed integers, i.e., values in the range -128 to 127 inclusive. bytevector->s8-list is similar to the Revised^6 Report  bytevector->u8-list except the values in the returned list are signed rather than unsigned. \n\n" "" "(bytevector->s8-list (make-bytevector 0)) => ()\n(bytevector->s8-list #vu8(1 127 128 255)) => (1 127 -128 -1) \n\n(let ([v #vu8(1 2 3 255)])\n  (apply * (bytevector->s8-list v))) => -6\n\n") ("objects:s84" "procedure: (s8-list->bytevector list)\nreturns: a new bytevector of the elements of list \nlibraries: (chezscheme)  \n\n" "list must consist entirely of exact eight-bit signed integers, i.e., values in the range -128 to 127 inclusive. s8-list->bytevector is similar to the Revised^6 Report  procedure u8-list->bytevector, except the elements of the input list are signed rather than unsigned. \n\n" "" "(s8-list->bytevector '()) => #vu8()\n(s8-list->bytevector '(1 127 -128 -1)) => #vu8(1 127 128 255) \n\n(let ([v #vu8(1 2 3 4 5)])\n  (let ([ls (bytevector->s8-list v)])\n    (s8-list->bytevector (map - ls)))) => #vu8(255 254 253 252 251)\n\n") ("objects:s85" "procedure: (bytevector-truncate! bytevector n)\nreturns: bytevector or the empty bytevector \nlibraries: (chezscheme)  \n\n" "bytevector must be mutable. n must be an exact nonnegative fixnum not greater than the length of bytevector. If n is zero, bytevector-truncate! returns the empty bytevector. Otherwise, bytevector-truncate! destructively truncates bytevector to its first n bytes and returns bytevector. \n\n" "" "(define bv (make-bytevector 7 19))\n(bytevector-truncate! bv 0) => #vu8()\nbv => #vu8(19 19 19 19 19 19 19)\n(bytevector-truncate! bv 3) => #vu8(19 19 19)\nbv => #vu8(19 19 19)\n\n") ("objects:s86" "procedure: (bytevector-u24-ref bytevector n eness)\nreturns: the 24-bit unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-s24-ref bytevector n eness)\nreturns: the 24-bit signed integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-u40-ref bytevector n eness)\nreturns: the 40-bit unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-s40-ref bytevector n eness)\nreturns: the 40-bit signed integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-u48-ref bytevector n eness)\nreturns: the 48-bit unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-s48-ref bytevector n eness)\nreturns: the 48-bit signed integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-u56-ref bytevector n eness)\nreturns: the 56-bit unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-s56-ref bytevector n eness)\nreturns: the 56-bit signed integer at index n (zero-based) of bytevector  \nlibraries: (chezscheme)  \n\n" "n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of bytevector. eness must be a valid endianness symbol naming the endianness. \n\n" "The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value. \n\n") ("objects:s87" "procedure: (bytevector-u24-set! bytevector n u24 eness)\nprocedure: (bytevector-s24-set! bytevector n s24 eness)\nprocedure: (bytevector-u40-set! bytevector n u40 eness)\nprocedure: (bytevector-s40-set! bytevector n s40 eness)\nprocedure: (bytevector-u48-set! bytevector n u48 eness)\nprocedure: (bytevector-s48-set! bytevector n s48 eness)\nprocedure: (bytevector-u56-set! bytevector n u56 eness)\nprocedure: (bytevector-s56-set! bytevector n s56 eness)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "bytevector must be mutable. n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value must not exceed the length of bytevector. u24 must be a 24-bit unsigned value, i.e., a value in the range 0 to 2^24 - 1 inclusive; s24 must be a 24-bit signed value, i.e., a value in the range -2^23 to 2^23 - 1 inclusive; u40 must be a 40-bit unsigned value, i.e., a value in the range 0 to 2^40 - 1 inclusive; s40 must be a 40-bit signed value, i.e., a value in the range -2^39 to 2^39 - 1 inclusive; u48 must be a 48-bit unsigned value, i.e., a value in the range 0 to 2^48 - 1 inclusive; s48 must be a 48-bit signed value, i.e., a value in the range -2^47 to 2^47 - 1 inclusive; u56 must be a 56-bit unsigned value, i.e., a value in the range 0 to 2^56 - 1 inclusive; and s56 must be a 56-bit signed value, i.e., a value in the range -2^55 to 2^55 - 1 inclusive. eness must be a valid endianness symbol naming the endianness. \n\n" "These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index n (zero-based) of bytevector. Negative values are stored as their two's complement equivalent. \n\n") ("objects:s88" "procedure: (mutable-bytevector? obj)\nreturns: #t if obj is a mutable bytevector, #f otherwise \nprocedure: (immutable-bytevector? obj)\nreturns: #t if obj is an immutable bytevector, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(mutable-bytevector? (bytevector 1 2 3)) => #t\n(mutable-bytevector?\n  (bytevector->immutable-bytevector (bytevector 1 2 3))) => #f\n(immutable-bytevector? (bytevector 1 2 3)) => #f\n(immutable-bytevector?\n  (bytevector->immutable-bytevector (bytevector 1 2 3))) => #t\n(immutable-bytevector? (cons 3 4)) => #f\n\n") ("objects:s89" "procedure: (bytevector->immutable-bytevector bytevector)\nreturns: an immutable bytevector equal to bytevector \nlibraries: (chezscheme)  \n\n" "The result is bytevector itself if bytevector is immutable; otherwise, the result is an immutable bytevector with the same content as bytevector. \n\n" "" "(define bv (bytevector->immutable-bytevector (bytevector 1 2 3)))\n(bytevector-u8-set! bv 0 0) => exception: not mutable\n\n") ("objects:s92" "procedure: (bytevector-compress bytevector)\nreturns: a new bytevector containing compressed content of bytevector \nlibraries: (chezscheme)  \n\n" "The result is the raw compressed data with a minimal header to record the uncompressed size and the compression mode. The result does not include the header that is written by port-based compression using the compressed option. The compression format is determined by the compress-format parameter, and the compression level is determined by the compress-level parameter. \n\n") ("objects:s95" "procedure: (bytevector-uncompress bytevector)\nreturns: a bytevector containing uncompressed content of bytevector \nlibraries: (chezscheme)  \n\n" "Uncompresses a bytevector produced by bytevector-compress to a new bytevector with the same content as the original given to bytevector-compress.  \n\n") ("objects:s98" "procedure: (stencil-vector-mask-width) \nreturns: a fixnum: the number of bits in a stencil vector mask \nlibraries: (chezscheme)  \n\n" "The result is always less than (fixnum-width).  \n\n") ("objects:s99" "procedure: (stencil-vector? obj)\nreturns: #t if obj is a stencil vector, #f otherwise \nlibraries: (chezscheme)  \n\n" "" "(stencil-vector? (stencil-vector #b11 'x 'y)) => #t\n(stencil-vector? '#3vs(x y)) => #t\n(stencil-vector? '#2(x y)) => #f\n\n") ("objects:s100" "procedure: (stencil-vector mask obj ...)\nreturns: a stencil vector with the given mask and content \nlibraries: (chezscheme)  \n\n" "mask must be a nonnegative fixnum less than (fxsll 1 (stencil-vector-mask-width)), and the number of supplied objs must be the same as (fxpopcount mask). \n\n" "" "(stencil-vector #b11 'x 'y) => #3vs(x y)\n(stencil-vector #b10101 'x 'y 'z) => #21vs(x y z)\n\n") ("objects:s101" "procedure: (stencil-vector-mask stencil-vector)\nreturns: the mask of stencil-vector \nlibraries: (chezscheme)  \n\n") ("objects:s102" "procedure: (stencil-vector-length stencil-vector)\nreturns: the length of stencil-vector \nlibraries: (chezscheme)  \n\n" "A stencil vector's length is determined by its mask.  (I.e., this is equivalent to (fxpopcount (stencil-vector-mask stencil-vector)).) \n\n" "" "(stencil-vector-mask '#0vs()) ;= 0\n(stencil-vector-length '#0vs()) ;= 0\n(stencil-vector-mask '#21vs(x y z)) ;= 21\n(stencil-vector-length '#21vs(x y z)) ;= 3\n\n") ("objects:s103" "procedure: (stencil-vector-ref stencil-vector n)\nreturns: the object at position n in stencil-vector \nlibraries: (chezscheme)  \n\n" "n must be a nonnegative fixnum that is less than the length of stencil-vector. \n\n" "Stencil vector elements are accessed by position, unrelated to the stencil vector's mask (except insofar as the number of valid positions is determined by the mask). \n\n" "Conceptually, each stensil vector element corresponds to a bit in the stencil vector's mask (and vice-versa). To convert a (0-based) bit position bit to an index, where the lowest set bit corresponds to the first element of the stencil vector, use the following calculation: \n\n" "(fxpopcount (fxand (stencil-vector-mask stencil-vector) (fx- (fxsll 1 bit) 1)))\n\n" "" "(stencil-vector-ref '#21vs(x y z) 0) ;= x\n(stencil-vector-ref '#21vs(x y z) 2) ;= z\n\n") ("objects:s104" "procedure: (stencil-vector-set! stencil-vector n obj)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "n must be a nonnegative fixnum that is less than the length of stencil-vector. \n\n" "Installs obj at position n within stencil-vector. See stencil-vector-ref for more information about positions in stencil vectors. \n\n" "" "(define sv (stencil-vector #b10101 'x 'y 'z))\n(stencil-vector-set! sv 1 'why)\nsv => #21vs(x why z)\n\n") ("objects:s105" "procedure: (stencil-vector-update stencil-vector remove-bits add-bits obj ...)\nreturns: a new stencil vector adapted from stencil-vector \nlibraries: (chezscheme)  \n\n" "remove-bits and add-bits must be nonnegative fixnums less than \n (fxsll 1 (stencil-vector-mask-width)). Furthermore, all of the following must be true: \n\n" " \n\n") ("objects:s106" "\n* remove-bits        must be a subset of the bits in the mask of stencil-vector.        In other words,        (logand (stencil-vector-mask stencil-vector) remove-bits)       must be equal to remove-bits.   \n* add-bits must have a set of bits that do not overlap the         subtraction of remove-bits from the mask of         stencil-vector.  In other words                  (logand\n          (logand (stencil-vector-mask stencil-vector) (lognot remove-bits))\n          add-bits)\n                must be 0.           \n* The number of supplied objs must match (fxpopcount add-bits). Returns a new stencil vector that has all of the elements of stencil-vector, except the ones identified by the bits in remove-bits. The new stencil vector also has the given objs at positions determined by add-bits. Elements copied from stencil-vector to the new vector retain their relative positions corresponding to their bits in the stencil-vector mask. Individual bits in the mask, remove-bits, and add-bits are mapped to element positions as described in the documentation of stencil-vector-ref. The mask of the new stencil vector is the mask of stencil-vector minus remove-bits plus add-bits. (define st-vec (stencil-vector #b101 'a 'b))\n(stencil-vector-update st-vec #b0 #b10 'c) => #7vs(a c b)\n(stencil-vector-update st-vec #b0 #b1000 'c) => #13vs(a b c)\nst-vec => #5vs(a b)\n(stencil-vector-update st-vec #b1 #b1 'c) => #5vs(c b)\n(stencil-vector-update st-vec #b100 #b100 'c) => #5vs(a c)\n(stencil-vector-update st-vec #b100 #b0) => #1vs(a)procedure: (stencil-vector-truncate! stencil-vector mask)\nreturns: unspecified \nlibraries: (chezscheme)  mask must be a nonnegative fixnum that does not have more bits set than bits set in the current mask of stencil-vector. Changes the mask of stencil-vector to mask, discarding any elements of the vector beyond the first (fxpopcount mask) elements. There is no requirement that mask has any bits in common with the current mask of stencil-vector. Section 7.10. BoxesBoxes are single-cell objects that are primarily useful for providing an \"extra level of indirection.\" This extra level of indirection is typically used to allow more than one body of code or data structure to share a reference, or pointer, to an object. For example, boxes may be used to implement call-by-reference semantics in an interpreter for a language employing this parameter passing discipline. Boxes are written with the prefix #& (pronounced \"hash-ampersand\"). For example, #&(a b c) is a box holding the list (a b c). The box syntax is disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently. All boxes are mutable by default, including constants. A program can create immutable boxes via box-immutable. Any attempt to modify an immutable box causes an exception to be raised. procedure: (box? obj)\nreturns: #t if obj is a box, #f otherwise \nlibraries: (chezscheme)  (box? '#&a) => #t\n(box? 'a) => #f\n(box? (box 3)) => #tprocedure: (box obj)\nreturns: a new box containing obj \nlibraries: (chezscheme)  (box 'a) => #&a\n(box (box '(a b c))) => #&#&(a b c)procedure: (unbox box)\nreturns: contents of box \nlibraries: (chezscheme)  (unbox #&a) => a\n(unbox #&#&(a b c)) => #&(a b c) \n\n(let ([b (box \"hi\")])\n  (unbox b)) => \"hi\"procedure: (set-box! box obj)\nreturns: unspecified \nlibraries: (chezscheme)  box must be mutable. set-box! sets the contents of box to obj. (let ([b (box 'x)])\n  (set-box! b 'y)\n  b) => #&y \n\n(let ([incr!\n       (lambda (x)\n         (set-box! x (+ (unbox x) 1)))])\n  (let ([b (box 3)])\n    (incr! b)\n    (unbox b))) => 4procedure: (box-cas! box old-obj new-obj)\nreturns: #t if box is changed, #f otherwise \nlibraries: (chezscheme)  box must be mutable. box-cas! atomically changes the content of box to new-obj if the replaced content is eq? to old-obj. If the content of box that would be replaced is not eq? to old-obj, then box is unchanged. On an architecture with a weak memory model, box-cas! can spuriously fail, leaving box unchanged and returning #f even if the current value in box is old-obj. On success, no memory ordering is implied, which means that memory-order-acquire and/or memory-order-release may be needed to complete an intended synchronization. (define b (box 'old))\n(box-cas! b 'old 'new) => #t, assuming no spurious failure\n(unbox b) => 'new\n(box-cas! b 'other 'wrong) => #f\n(unbox b) => 'newprocedure: (mutable-box? obj)\nreturns: #t if obj is a mutable box, #f otherwise \nprocedure: (immutable-box? obj)\nreturns: #t if obj is an immutable box, #f otherwise \nlibraries: (chezscheme)  (mutable-box? (box 1)) => #t\n(mutable-box? (box-immutable 1)) => #f\n(immutable-box? (box 1)) => #f\n(immutable-box? (box-immutable 1)) => #t\n(mutable-box? (cons 3 4)) => #fprocedure: (box-immutable obj)\nreturns: a new immutable box containing obj \nlibraries: (chezscheme)  Boxes are typically intended to support shared, mutable structure, so immutable boxes are not often useful. (define b (box-immutable 1))\n(set-box! b 0) => exception: not mutableSection 7.11. SymbolsChez Scheme extends the standard symbol syntax in several ways: \n* Symbol names may begin with @, but ,@abc is parsed as (unquote-splicing abc); to produce (unquote @abc)one can type , @abc, \\x40;abc, or ,|@abc|.  \n* The single-character sequences { and } are read as symbols. \n* A symbol's name may begin with any character that might normally start a number, including a digit, ., +, -, as long as the delimited sequence of characters starting with that character cannot be parsed as a number. \n* A symbol whose name contains arbitrary characters may be written by escaping them with \\ or with |. \\ is used to escape a single character (except 'x', since \\x marks the start of a hex scalar value), whereas | is used to escape the group of characters that follow it up through the matching |.  The printer always prints symbols using the standard R6RS syntax, so that, e.g., @abc prints as \\x40;abc and 1- prints as \\x31;-.  '  Gensyms are printed #{ and } brackets that enclose both the \"pretty\" and \"unique\" names, e.g., #{g1426 e5g1c94g642dssw-a}. They may also be printed using the pretty name only with the prefix #:, e.g., #:g1426.  These extensions are disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently. procedure: (gensym) \nprocedure: (gensym pretty-name)\nprocedure: (gensym pretty-name unique-name)\nreturns: a unique generated symbol \nlibraries: (chezscheme)  Each call to gensym returns a unique generated symbol, or gensym. Each generated symbol has two names: a \"pretty\" name and a \"unique\" name. In the first form above, the pretty name is formed (lazily---see below) by combining an internal prefix with the value of an internal counter. After each name is formed, the internal counter is incremented. The parameters gensym-prefix and gensym-count, described below, may be used to access and set the internal prefix and counter. By default, the prefix is the single-character string \"g\". In the second and third forms, the pretty name of the new gensym is pretty-name, which must be a string. The pretty name of a gensym is returned by the procedure symbol->string.  In both the first and second forms, the unique name is an automatically generated globally unique name. Globally unique names are constructed (lazily---see below) from the combination of a universally unique identifier and an internal counter. In the third form of gensym, the unique name of the new gensym is unique-name, which must be a string. The unique name of a gensym may be obtained via the procedure gensym->unique-string.  The unique name allows gensyms to be written in such a way that they can be read back and reliably commonized on input. The syntax for gensyms includes both the pretty name and the unique name, as shown in the example below: (gensym) => #{g0 bcsfg5eq4e9b3h9o-a}When the parameter print-gensym is set to pretty, the printer prints the pretty name only, with a #: syntax, so  (parameterize ([print-gensym 'pretty])\n  (write (gensym)))prints #:g0.  When the reader sees the #: syntax, it produces a gensym with the given pretty name, but the original unique name is lost. When the parameter is set to #f, the printer prints just the pretty name, so (parameterize ([print-gensym #f])\n  (write (gensym)))prints g0. This is useful only when gensyms do not need to be read back in as gensyms. In order to reduce construction and (when threaded) synchronization overhead when gensyms are frequently created but rarely printed or stored in an object file, generated pretty and unique names are created lazily, i.e., not until first requested, either by the printer, fasl writer, or explicitly by one of the procedures symbol->string or gensym->unique-string. In addition, a gensym is not placed into the system's internal symbol table (the oblist; see page 175) until the unique name is requested. This allows a gensym to be reclaimed by the storage manager if no references to the gensym exist and no unique name exists by which to access it, even if it has a top-level binding or a nonempty property list. (define x (gensym))\nx                         => #{g2 bcsfg5eq4e9b3h9o-c}\n(symbol->string x)        => \"g2\"\n(gensym->unique-string x) => \"bcsfg5eq4e9b3h9o-c\"Gensyms subsume the notion of uninterned symbols supported by earlier versions of Chez Scheme. For most purposes, the predicate uninterned-symbol? has been replaced by gensym?.  thread parameter: gensym-prefix \nthread parameter: gensym-count \nlibraries: (chezscheme)  The parameters gensym-prefix and gensym-count are used to access and set the internal prefix and counter from which the pretty name of a gensym is generated when gensym is not given an explicit string argument. gensym-prefix defaults to the string \"g\" and may be set to any object. gensym-count starts at 0 and may be set to any nonnegative integer. As described above, Chez Scheme delays the creation of the pretty name until the name is first requested by the printer or by an explicit call to symbol->string. These parameters are not consulted until that time; setting them when gensym is called thus has no effect on the generated name.  (let ([x (parameterize ([gensym-prefix \"genny\"]\n                        [gensym-count 17]\n                        [print-gensym 'pretty])\n           (gensym))])\n  (format \"~s\" x))                       => \"#{g4 bcsfg5eq4e9b3h9o-e}\"\n(let ([x (gensym)])\n  (parameterize ([gensym-prefix \"genny\"]\n                 [gensym-count 17]\n                 [print-gensym #f])\n    (format \"~s\" (gensym))))             => \"genny17\"procedure: (gensym->unique-string gensym)\nreturns: the unique name of gensym \nlibraries: (chezscheme)  (gensym->unique-string (gensym)) => \"bd3kufa7ypjcuvut-g\"procedure: (gensym? obj)\nreturns: #t if obj is a gensym, #f otherwise \nlibraries: (chezscheme)  (gensym? (string->symbol \"z\")) => #f\n(gensym? (gensym \"z\")) => #t\n(gensym? 'a) => #f\n(gensym? 3) => #f\n(gensym? (gensym)) => #t\n(gensym? '#{g2 bcsfg5eq4e9b3h9o-c}) => #tprocedure: (string->uninterned-symbol str)\nreturns: a fresh uninterned symbol \nlibraries: (chezscheme)  str must be a string. Returns an uninterned symbol that prints the same as a symbol constructed from str, but which is not eq? to any other symbol. When an uninterned symbol is converted by the fasl writer, the fasl reader will allocate a fresh uninterned symbol each time the fasl stream is read. Multiple occurrences of the same uninterned symbol in the fasl writer's argument will become multiple occurrences of the same new uninterned symbol in the fasl reader's result for the stream. (string->uninterned-symbol \"z\") => z\n(uninterned-symbol? (string->uninterned-symbol \"z\")) => #t\n(symbol? (string->uninterned-symbol \"z\")) => #t\n(gensym? (string->uninterned-symbol \"z\")) => #fprocedure: (uninterned-symbol? obj)\nreturns: #t if obj is an uninterned symbol, #f otherwise \nlibraries: (chezscheme)  (uninterned-symbol? (string->symbol \"z\")) => #f\n(uninterned-symbol? (gensym \"z\")) => #f\n(uninterned-symbol? (string->uninterned-symbol \"z\")) => #tprocedure: (putprop symbol key value)\nreturns: unspecified \nlibraries: (chezscheme)  Chez Scheme associates a property list with each symbol, allowing multiple key-value pairs to be stored directly with the symbol. New key-value pairs may be placed in the property list or retrieved in a manner analogous to the use of association lists, using the procedures putprop and getprop. Property lists are often used to store information related to the symbol itself. For example, a natural language program might use symbols to represent words, using their property lists to store information about use and meaning. putprop associates value with key on the property list of symbol. key and value may be any types of object, although key is typically a symbol. putprop may be used to establish a new property or to change an existing property. See the examples under getprop below.  procedure: (getprop symbol key)\nprocedure: (getprop symbol key default)\nreturns: the value associated with key on the property list of symbol \nlibraries: (chezscheme)  getprop searches the property list of symbol for a key identical to key (in the sense of eq?), and returns the value associated with this key, if any. If no value is associated with key on the property list of symbol, getprop returns default, or #f if the default argument is not supplied. (putprop 'fred 'species 'snurd)\n(putprop 'fred 'age 4)  \n(putprop 'fred 'colors '(black white)) \n\n(getprop 'fred 'species) => snurd\n(getprop 'fred 'colors) => (black white)\n(getprop 'fred 'nonkey) => #f\n(getprop 'fred 'nonkey 'unknown) => unknown\n \n(putprop 'fred 'species #f)\n(getprop 'fred 'species 'unknown) => #fprocedure: (remprop symbol key)\nreturns: unspecified \nlibraries: (chezscheme)  remprop removes the property with key key from the property list of symbol, if such a property exists. (putprop 'fred 'species 'snurd)\n(getprop 'fred 'species) => snurd \n\n(remprop 'fred 'species)\n(getprop 'fred 'species 'unknown) => unknownprocedure: (property-list symbol)\nreturns: a copy of the internal property list for symbol \nlibraries: (chezscheme)  A property list is a list of alternating keys and values, i.e., (key value ...). (putprop 'fred 'species 'snurd)\n(putprop 'fred 'colors '(black white))\n(property-list 'fred) => (colors (black white) species snurd)procedure: (oblist) \nreturns: a list of interned symbols \nlibraries: (chezscheme)  The system maintains an internal symbol table used to insure that any two occurrences of the same symbol name resolve to the same symbol object. The oblist procedure returns a list of the symbols currently in this symbol table. The list of interned symbols grows when a new symbol is introduced into the system or when the unique name of a gensym (see page 171) is requested. It shrinks when the garbage collector determines that it is safe to discard a symbol. It is safe to discard a symbol only if the symbol is not accessible except through the oblist, has no top-level binding, and has no properties on its property list. (if (memq 'tiger (oblist)) 'yes 'no) => yes\n(equal? (oblist) (oblist)) => #t\n(= (length (oblist)) (length (oblist))) => #t or #fThe first example above follows from the property that all interned symbols are in the oblist from the time they are read, which happens prior to evaluation. The second example follows from the fact that no symbols can be removed from the oblist while references to those symbols exist, in this case, within the list returned by the first call to oblist (whichever call is performed first). The expression in the third example can return #f only if a garbage collection occurs sometime between the two calls to oblist, and only if one or more symbols are removed from the oblist by that collection. Section 7.12. VoidMany Scheme operations return an unspecified result. Chez Scheme typically returns a special void object when the value returned by an operation is unspecified. The Chez Scheme void object is not meant to be used as a datum, and consequently does not have a reader syntax. As for other objects without a reader syntax, such as procedures and ports, Chez Scheme output procedures print the void object using a nonreadable representation, i.e., #<void>. Since the void object should be returned only by operations that do not have \"interesting\" values, the default waiter printer (see waiter-write) suppresses the printing of the void object. set!, set-car!, load, and write are examples of Chez Schemeoperations that return the void object. procedure: (void) \nreturns: the void object \nlibraries: (chezscheme)  void is a procedure of no arguments that returns the void object. It can be used to force expressions that are used for effect or whose values are otherwise unspecified to evaluate to a consistent, trivial value. Since most Chez Scheme operations that are used for effect return the void object, however, it is rarely necessary to explicitly invoke the void procedure.  Since the void object is used explicitly as an \"unspecified\" value, it is a bad idea to use it for any other purpose or to count on any given expression evaluating to the void object. The default waiter printer suppresses the void object; that is, nothing is printed for expressions that evaluate to the void object. (eq? (void) #f) => #f\n(eq? (void) #t) => #f\n(eq? (void) '()) => #fSection 7.13. Sortingprocedure: (sort predicate list)\nprocedure: (sort! predicate list)\nreturns: a list containing the elements of list sorted according to predicate \nlibraries: (chezscheme)  sort is identical to the Revised^6 Report list-sort, and sort! is a destructive version of sort, i.e., it reuses pairs from the input list to form the output list. (sort < '(3 4 2 1 2 5)) => (1 2 2 3 4 5)\n(sort! < '(3 4 2 1 2 5)) => (1 2 2 3 4 5)procedure: (merge predicate list1 list2)\nprocedure: (merge! predicate list1 list2)\nreturns: list1 merged with list2 in the order specified by predicate \nlibraries: (chezscheme)  predicate should be a procedure that expects two arguments and returns #t if its first argument must precede its second in the merged list. It should not have any side effects. That is, if predicate is applied to two objects x and y, where x is taken from the second list and y is taken from the first list, it should return true only if x should appear before y in the output list. If this constraint is met, merge and merge! are stable, in that items from list1 are placed in front of equivalent items from list2 in the output list. Duplicate elements are included in the merged list. merge! combines the lists destructively, using pairs from the input lists to form the output list. (merge char<?\n       '(#\\a #\\c)\n       '(#\\b #\\c #\\d)) => (#\\a #\\b #\\c #\\c #\\d)\n(merge <\n       '(1/2 2/3 3/4)\n       '(0.5 0.6 0.7)) => (1/2 0.5 0.6 2/3 0.7 3/4)Section 7.14. HashtablesChez Scheme provides several extensions to the hashtable mechanism, including a mechanism for directly accessing a key, value pair in a hashtable, support for weak eq and eqv hashtables, and a set of procedures specialized to eq and symbol hashtables. procedure: (hashtable-cell hashtable key default)\nreturns: a pair (see below) \nlibraries: (chezscheme)  hashtable must be a mutable hashtable. key and default may be any Scheme values. If no value is associated with key in hashtable, hashtable-cell modifies hashtable to associate key with default. It returns a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key in the car field should not be changed. The advantage of this procedure over the Revised^6 Report procedures for manipulating hashtable entries is that the value associated with a key may be read or written many times with only a single hashtable lookup. (define ht (make-eq-hashtable))\n(define v (vector 'a 'b 'c))\n(define cell (hashtable-cell ht v 3))\ncell => (#(a b c) . 3)\n(hashtable-ref ht v 0) => 3\n(set-cdr! cell 4)\n(hashtable-ref ht v 0) => 4procedure: (hashtable-ref-cell hashtable key)\nreturns: a pair if key is in hashtable, #f otherwise \nlibraries: (chezscheme)  hashtable must be a mutable hashtable. key may be any Scheme value. If key is associated with a value in hashtable, then hashtable-ref-cell returns a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key in the car field should not be changed. If key is not in hashtable, then #f is returned.  (define ht (make-eq-hashtable))\n(define v (vector 'a 'b 'c))\n(hashtable-ref-cell ht v) => #f\n(hashtable-set! ht v 3)\n(define cell (hashtable-ref-cell ht v))\ncell => ((#a b c) . 3)\n(hashtable-ref ht v 0) => 3\n(set-cdr! cell 4)\n(hashtable-ref ht v 0) => 4procedure: (hashtable-keys hashtable)\nprocedure: (hashtable-keys hashtable size)\nreturns: a vector containing the keys in hashtable \nlibraries: (chezscheme)  Identical to the Revised^6 Report counterpart, but allowing an optional size argument. If size is specified, then it must be an exact, nonnegative integer; the result vector will contain (min size (hashtable-size hashtable)) elements. Different calls to hashtable-keys with a size less than (hashtable-size hashtable)may return different subsets of hashtable's keys. (define ht (make-eq-hashtable))\n(hashtable-set! ht 'a \"one\")\n(hashtable-set! ht 'b \"two\")\n(hashtable-set! ht 'c \"three\")\n(hashtable-keys ht) => #(a b c) or any permutation\n(hashtable-keys ht 1) => #(a) or #(b) or #(c)procedure: (hashtable-values hashtable)\nprocedure: (hashtable-values hashtable size)\nreturns: a vector containing the values in hashtable \nlibraries: (chezscheme)  Each value is the value of one of the keys in hashtable. Duplicate values are not removed. The values may appear in any order in the returned vector. If size is specified, then it must be an exact, nonnegative integer; the result vector will contain (min size (hashtable-size hashtable)) elements. Different calls to hashtable-values with a size less than (hashtable-size hashtable)may return different subsets of hashtable's values. (define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 \"one\")\n(hashtable-set! ht p2 \"two\")\n(hashtable-set! ht 'q \"two\")\n(hashtable-values ht) => #(\"one\" \"two\" \"two\") or any permutation\n(hashtable-values ht 1) => #(\"one\") or #(\"two\")This procedure is equivalent to calling hashtable-entries and returning only the second result, but it is more efficient since the separate vector of keys need not be created. procedure: (hashtable-entries hashtable)\nprocedure: (hashtable-entries hashtable size)\nreturns: two vectors containing the keys and values in hashtable \nlibraries: (chezscheme)  Identical to the Revised^6 Report counterpart, but allowing an optional size argument. If size is specified, then it must be an exact, nonnegative integer; the result vectors will each contain (min size (hashtable-size hashtable)) elements. Different calls to hashtable-entries with a size less than (hashtable-size hashtable)may return different subsets of hashtable's entries. (define ht (make-eq-hashtable))\n(hashtable-set! ht 'a \"one\")\n(hashtable-set! ht 'b \"two\")\n(hashtable-entries ht) => #(a b) #(\"one\" \"two\") or the other permutation\n(hashtable-entries ht 1) => #(a) #(\"one\") or #(b) #(\"two\") procedure: (hashtable-cells hashtable)\nprocedure: (hashtable-cells hashtable size)\nreturns: a vector of up to size elements containing the cells of hashtable \nlibraries: (chezscheme)  hashtable must be a mutable hashtable. Each element of the result vector is the value of one of the cells in hashtable. The cells may appear in any order in the returned vector. If size is specified, then it must be an exact, nonnegative integer; the result vector will contain (min size (hashtable-size hashtable)) elements. If size is not specified, then the result vector has (hashtable-size hashtable) elements. Different calls to hashtable-cells with a size less than (hashtable-size hashtable)may return different subsets of hashtable's cells. Changing the cdr of a pair in the result vector effectively updates the table to associate car of the pair with a new value. The car of a pair in the result vector should not be changed. (define ht (make-eqv-hashtable))\n(hashtable-set! ht 1 'one)\n(hashtable-set! ht 2 'two)\n(hashtable-cells ht) => #((1 . one) (2 . two)) or #((2 . two) (1 . one))\n(hashtable-cells ht 1) => #((1 . one)) or #((2 . two))\n(hashtable-cells ht 0) => #()procedure: (make-weak-eq-hashtable) \nprocedure: (make-weak-eq-hashtable size)\nprocedure: (make-weak-eqv-hashtable) \nprocedure: (make-weak-eqv-hashtable size)\nprocedure: (make-weak-hashtable hash equiv?)\nprocedure: (make-weak-hashtable hash equiv? size)\nreturns: a new weak hashtable \nlibraries: (chezscheme)  Like the Revised^6 Report procedures make-eq-hashtable, make-eqv-hashtable, and make-hashtable, except the keys of the hashtable are held weakly, i.e., they are not protected from the garbage collector. Keys reclaimed by the garbage collector are removed from the table, and their associated values are dropped the next time the table is modified, if not sooner. Values in the hashtable are referenced normally as long as the key is not reclaimed, since keys are paired values using weak pairs. Consequently, if a value in the hashtable refers to its own key, then garbage collection is prevented from reclaiming the key. See make-ephemeron-hashtable and related functions.  A copy of a weak hashtable created by hashtable-copy is also weak. If the copy is immutable, inaccessible keys may still be dropped from the hashtable, even though the contents of the table is otherwise unchanging. The effect of this can be observed via hashtable-keys and hashtable-entries.  (define ht1 (make-weak-eq-hashtable))\n(define ht2 (make-weak-eq-hashtable 32))procedure: (make-ephemeron-eq-hashtable) \nprocedure: (make-ephemeron-eq-hashtable size)\nprocedure: (make-ephemeron-eqv-hashtable) \nprocedure: (make-ephemeron-eqv-hashtable size)\nprocedure: (make-ephemeron-hashtable hash equiv?)\nprocedure: (make-ephemeron-hashtable hash equiv? size)\nreturns: a new ephemeron hashtable \nlibraries: (chezscheme)  Like make-weak-eq-hashtable, make-weak-eqv-hashtable, and make-weak-hashtable, but a value in the hashtable can refer to a key in the hashtable (directly or indirectly) without preventing garbage collection from reclaiming the key, because keys are paired with values using ephemeron pairs. A copy of an ephemeron hashtable created by hashtable-copy is also an ephemeron table, and an inaccessible key can be dropped from an immutable ephemeron hashtable in the same way as for an immutable weak hashtable. (define ht1 (make-ephemeron-eq-hashtable))\n(define ht2 (make-ephemeron-eq-hashtable 32))procedure: (hashtable-weak? obj)\nreturns: #t if obj is a weak hashtable, #f otherwise \nlibraries: (chezscheme)  (define ht1 (make-weak-eq-hashtable))\n(define ht2 (hashtable-copy ht1))\n(hashtable-weak? ht2) => #tprocedure: (hashtable-ephemeron? obj)\nreturns: #t if obj is an ephemeron hashtable, #f otherwise \nlibraries: (chezscheme)  (define ht1 (make-ephemeron-eq-hashtable))\n(define ht2 (hashtable-copy ht1))\n(hashtable-ephemeron? ht2) => #tprocedure: (eq-hashtable? obj)\nreturns: #t if obj is an eq hashtable, #f otherwise \nlibraries: (chezscheme)  (eq-hashtable? (make-eq-hashtable)) => #t\n(eq-hashtable? '(not a hash table)) => #fprocedure: (eq-hashtable-weak? hashtable)\nreturns: #t if hashtable is weak, #f otherwise \nlibraries: (chezscheme)  hashtable must be an eq hashtable. (eq-hashtable-weak? (make-eq-hashtable)) => #f\n(eq-hashtable-weak? (make-weak-eq-hashtable)) => #tprocedure: (eq-hashtable-ephemeron? hashtable)\nreturns: #t if hashtable uses ephemeron pairs, #f otherwise \nlibraries: (chezscheme)  hashtable must be an eq hashtable. (eq-hashtable-ephemeron? (make-eq-hashtable)) => #f\n(eq-hashtable-ephemeron? (make-ephemeron-eq-hashtable)) => #tprocedure: (eq-hashtable-set! hashtable key value)\nreturns: unspecified \nlibraries: (chezscheme)  hashtable must be a mutable eq hashtable. key and value may be any Scheme values. eq-hashtable-set! associates the value value with the key key in hashtable. (define ht (make-eq-hashtable))\n(eq-hashtable-set! ht 'a 73)procedure: (eq-hashtable-ref hashtable key default)\nreturns: see below \nlibraries: (chezscheme)  hashtable must be an eq hashtable. key and default may be any Scheme values. eq-hashtable-ref returns the value associated with key in hashtable. If no value is associated with key in hashtable, eq-hashtable-ref returns default. (define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(eq-hashtable-set! ht p1 73)\n(eq-hashtable-ref ht p1 55) => 73\n(eq-hashtable-ref ht p2 55) => 55procedure: (eq-hashtable-contains? hashtable key)\nreturns: #t if an association for key exists in hashtable, #f otherwise \nlibraries: (chezscheme)  hashtable must be an eq hashtable. key may be any Scheme value. (define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(eq-hashtable-set! ht p1 73)\n(eq-hashtable-contains? ht p1) => #t\n(eq-hashtable-contains? ht p2) => #fprocedure: (eq-hashtable-update! hashtable key procedure default)\nreturns: unspecified \nlibraries: (chezscheme)  hashtable must be a mutable eq hashtable. key and default may be any Scheme values. procedure should accept one argument, should return one value, and should not modify hashtable. eq-hashtable-update! applies procedure to the value associated with key in hashtable, or to default if no value is associated with key in hashtable. If procedure returns, eq-hashtable-update! associates key with the value returned by procedure, replacing the old association, if any. A version of eq-hashtable-update! that does not verify that it receives arguments of the proper type might be defined as follows. (define eq-hashtable-update!\n  (lambda (ht key proc value)\n    (eq-hashtable-set! ht key\n      (proc (eq-hashtable-ref ht key value)))))An implementation may, however, be able to implement eq-hashtable-update! more efficiently by avoiding multiple hash computations and hashtable lookups. (define ht (make-eq-hashtable))\n(eq-hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  55)\n(eq-hashtable-ref ht 'a 0) => 110\n(eq-hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  0)\n(eq-hashtable-ref ht 'a 0) => 220procedure: (eq-hashtable-cell hashtable key default)\nreturns: a pair (see below) \nlibraries: (chezscheme)  hashtable must be a mutable eq hashtable. key and default may be any Scheme values. If no value is associated with key in hashtable, eq-hashtable-cell modifies hashtable to associate key with default. It returns a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key should not be changed. (define ht (make-eq-hashtable))\n(define v (vector 'a 'b 'c))\n(define cell (eq-hashtable-cell ht v 3))\ncell => (#(a b c) . 3)\n(eq-hashtable-ref ht v 0) => 3\n(set-cdr! cell 4)\n(eq-hashtable-ref ht v 0) => 4procedure: (eq-hashtable-try-atomic-cell hashtable key default)\nreturns: a pair or #f (see below) \nlibraries: (chezscheme)  Like eq-hashtable-cell, but safe for use from multiple threads at the same time as long as only this function, eq-hashtable-ref, eq-hashtable-ref-cell, and eq-hashtable-contains? are used on a particular hash table by any thread. To handle certain forms of contention, the result may be #f, in which case the operation might be retried. An even more significant constraint is that the hash table will not be resized interally as needed to provide constant-time behavior. Use eq-hashtable-set! or a similar operation from a single thread (e.g., during a collect-reqest handler) to allow the opportunity of resizing. procedure: (eq-hashtable-ref-cell hashtable key)\nreturns: a pair if key is in hashtable, #f otherwise \nlibraries: (chezscheme)  hashtable must be a mutable eq hashtable. key may be any Scheme value. If key is associated with a value in hashtable, then eq-hashtable-ref-cell returns a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key in the car field should not be changed. If key is not in hashtable, then #f is returned.  (define ht (make-eq-hashtable))\n(define v (vector 'a 'b 'c))\n(eq-hashtable-ref-cell ht v) => #f\n(eq-hashtable-set! ht v 3)\n(define cell (eq-hashtable-ref-cell ht v))\ncell => ((#a b c) . 3)\n(eq-hashtable-ref ht v 0) => 3\n(set-cdr! cell 4)\n(eq-hashtable-ref ht v 0) => 4procedure: (eq-hashtable-delete! hashtable key)\nreturns: unspecified \nlibraries: (chezscheme)  hashtable must be a mutable eq hashtable. key may be any Scheme value. eq-hashtable-delete! drops any association for key from hashtable. (define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(eq-hashtable-set! ht p1 73)\n(eq-hashtable-contains? ht p1) => #t\n(eq-hashtable-delete! ht p1)\n(eq-hashtable-contains? ht p1) => #f\n(eq-hashtable-contains? ht p2) => #f\n(eq-hashtable-delete! ht p2)procedure: (symbol-hashtable? obj)\nreturns: #t if obj is a symbol hashtable, #f otherwise \nlibraries: (chezscheme)  A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.  (symbol-hashtable? (make-hashtable symbol-hash eq?)) => #t\n(symbol-hashtable? (make-eq-hashtable)) => #fprocedure: (symbol-hashtable-set! hashtable key value)\nreturns: unspecified \nlibraries: (chezscheme)  hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and value may be any Scheme value. symbol-hashtable-set! associates the value value with the key key in hashtable. (define ht (make-hashtable symbol-hash eq?))\n(symbol-hashtable-ref ht 'a #f) => #f\n(symbol-hashtable-set! ht 'a 73)\n(symbol-hashtable-ref ht 'a #f) => 73procedure: (symbol-hashtable-ref hashtable key default)\nreturns: see below \nlibraries: (chezscheme)  hashtable must be a symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and default may be any Scheme value. symbol-hashtable-ref returns the value associated with key in hashtable. If no value is associated with key in hashtable, symbol-hashtable-ref returns default. (define ht (make-hashtable symbol-hash eq?))\n(define k1 'abcd)\n(define k2 'not-abcd)\n(symbol-hashtable-set! ht k1 \"hi\")\n(symbol-hashtable-ref ht k1 \"bye\") => \"hi\"\n(symbol-hashtable-ref ht k2 \"bye\") => \"bye\"procedure: (symbol-hashtable-contains? hashtable key)\nreturns: #t if an association for key exists in hashtable, #f otherwise \nlibraries: (chezscheme)  hashtable must be a symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol. (define ht (make-hashtable symbol-hash eq?))\n(define k1 'abcd)\n(define k2 'not-abcd)\n(symbol-hashtable-set! ht k1 \"hi\")\n(symbol-hashtable-contains? ht k1) => #t\n(symbol-hashtable-contains? ht k2 ) => #fprocedure: (symbol-hashtable-update! hashtable key procedure default)\nreturns: unspecified \nlibraries: (chezscheme)  hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and default may be any Scheme value. procedure should accept one argument, should return one value, and should not modify hashtable. symbol-hashtable-update! applies procedure to the value associated with key in hashtable, or to default if no value is associated with key in hashtable. If procedure returns, symbol-hashtable-update! associates key with the value returned by procedure, replacing the old association, if any. A version of symbol-hashtable-update! that does not verify that it receives arguments of the proper type might be defined as follows. (define symbol-hashtable-update!\n  (lambda (ht key proc value)\n    (symbol-hashtable-set! ht key\n      (proc (symbol-hashtable-ref ht key value)))))An implementation may, however, be able to implement symbol-hashtable-update! more efficiently by avoiding multiple hash computations and hashtable lookups. (define ht (make-hashtable symbol-hash eq?))\n(symbol-hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  55)\n(symbol-hashtable-ref ht 'a 0) => 110\n(symbol-hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  0)\n(symbol-hashtable-ref ht 'a 0) => 220procedure: (symbol-hashtable-cell hashtable key default)\nreturns: a pair (see below) \nlibraries: (chezscheme)  hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol, and default may be any Scheme value. If no value is associated with key in hashtable, symbol-hashtable-cell modifies hashtable to associate key with default. It returns a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key should not be changed. (define ht (make-hashtable symbol-hash eq?))\n(define k 'a-key)\n(define cell (symbol-hashtable-cell ht k 3))\ncell => (a-key . 3)\n(symbol-hashtable-ref ht k 0) => 3\n(set-cdr! cell 4)\n(symbol-hashtable-ref ht k 0) => 4procedure: (symbol-hashtable-ref-cell hashtable key)\nreturns: a pair if key is in hashtable, #f otherwise \nlibraries: (chezscheme)  hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol. If key is associated with a value in hashtable, then it returns a pair whose car is key and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate key with a new value. The key in the car field should not be changed. If key is not in hashtable, then #f is returned.  (define ht (make-hashtable symbol-hash eq?))\n(define k 'a-key)\n(symbol-hashtable-ref-cell ht k) => #f\n(symbol-hashtable-set! ht k 3)\n(define cell (symbol-hashtable-ref-cell ht k))\ncell => (a-key . 3)\n(symbol-hashtable-ref ht k 0) => 3\n(set-cdr! cell 4)\n(symbol-hashtable-ref ht k 0) => 4procedure: (symbol-hashtable-delete! hashtable key)\nreturns: unspecified \nlibraries: (chezscheme)  hashtable must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function symbol-hash and equivalence function eq?, eqv?, equal?, or symbol=?.) key must be a symbol. symbol-hashtable-delete! drops any association for key from hashtable. (define ht (make-hashtable symbol-hash eq?))\n(define k1 (gensym))\n(define k2 (gensym))\n(symbol-hashtable-set! ht k1 73)\n(symbol-hashtable-contains? ht k1) => #t\n(symbol-hashtable-delete! ht k1)\n(symbol-hashtable-contains? ht k1) => #f\n(symbol-hashtable-contains? ht k2) => #f\n(symbol-hashtable-delete! ht k2)Section 7.15. Record TypesChez Scheme extends the Revised^6 Report's define-record-type syntax in one way, which is that it allows a generative record type to be declared explicitly as such (in a double-negative sort of way) by including a nongenerative clause with #f as the uid, i.e.: (nongenerative #f)This can be used in conjunction with the parameter require-nongenerative-clause to catch the accidental use of generative record types while avoiding spurious errors for record types that must be generative. Generative record types are rarely needed and are generally less efficient since a run-time representation of the type is created each time the define-record-clause is evaluated, rather than once at compile (expansion) time. thread parameter: require-nongenerative-clause \nlibraries: (chezscheme)  This parameter holds a boolean value that determines whether define-record-type requires a nongenerative clause. The default value is #f. The lead-in above describes why one might want to set this to #t.  Section 7.16. Record Equality and HashingBy default, the equal? primitive compares record instances using eq?, i.e., it distinguishes non-eq? instances even if they are of the same type and have equal contents. A program can override this behavior for instances of a record type (and its subtypes that do not have their own equality procedures) by using record-type-equal-procedure to associate an equality procedure with the record-type descriptor (rtd) that describes the record type. When comparing two eq? instances, equal? always returns #t. When comparing two non-eq? instances that share an equality procedure equal-proc, equal? uses equal-proc to compare the instances. Two instances x and y share an equality procedure if they inherit an equality procedure from the same point in the inheritance chain, i.e., if (record-equal-procedure x y)returns a procedure (equal-proc) rather than #f. equal? passes equal-proc three arguments: the two instances plus a eql? procedure that should be used for recursive comparison of values within the two instances. Use of eql? for recursive comparison is necessary to allow comparison of potentially cyclic structure. When comparing two non-eq? instances that do not share an equality procedure, equal? returns #f.  A default equality procedure to be used for all record types (including opaque types) can be specified via the parameter default-record-equal-procedure. The default equality procedure is used only if neither instance's type has or inherits a type-specific record equality procedure. Similarly, when the equal-hash primitive hashes a record instance, it defaults to a value that is independent of the record type and contents of the instance. A program can override this behavior for instances of a record type by using record-type-hash-procedure to associate a hash procedure with the record-type descriptor (rtd) that describes the record type. The procedure record-hash-procedure can be used to find the hash procedure for a given record instance, following the inheritance chain. equal-hash passes the hash procedure two arguments: the instance plus a hash procedure that should be used for recursive hashing of values within the instance. Use of hash for recursive hashing is necessary to allow hashing of potentially cyclic structure and to make the hashing of shared structure more efficient. A default hash procedure to be used for all record types (including opaque types) can be specified via the parameter default-record-hash-procedure. The default hash procedure is used only if an instance's type does not have or inherit a type-specific hash procedure. The following example illustrates the setting of equality and hash procedures. (define-record-type marble\n  (nongenerative)\n  (fields color quality)) \n\n(record-type-equal-procedure (record-type-descriptor marble)) => #f\n(equal? (make-marble 'blue 'medium) (make-marble 'blue 'medium)) => #f\n(equal? (make-marble 'blue 'medium) (make-marble 'blue 'high)) => #f \n\n; Treat marbles as equal when they have the same color\n(record-type-equal-procedure (record-type-descriptor marble)\n  (lambda (m1 m2 eql?)\n    (eql? (marble-color m1) (marble-color m2))))\n(record-type-hash-procedure (record-type-descriptor marble)\n  (lambda (m hash)\n    (hash (marble-color m)))) \n\n(equal? (make-marble 'blue 'medium) (make-marble 'blue 'high)) => #t\n(equal? (make-marble 'red 'high) (make-marble 'blue 'high)) => #f \n\n(define ht (make-hashtable equal-hash equal?))\n(hashtable-set! ht (make-marble 'blue 'medium) \"glass\")\n(hashtable-ref ht (make-marble 'blue 'high) #f) => \"glass\" \n\n(define-record-type shooter\n  (nongenerative)\n  (parent marble)\n  (fields size)) \n\n(equal? (make-marble 'blue 'medium) (make-shooter 'blue 'large 17)) => #t\n(equal? (make-shooter 'blue 'large 17) (make-marble 'blue 'medium)) => #t\n(hashtable-ref ht (make-shooter 'blue 'high 17) #f) => \"glass\"This example illustrates the application of equality and hash procedures to cyclic record structures. (define-record-type node\n  (nongenerative)\n  (fields (mutable left) (mutable right))) \n\n(record-type-equal-procedure (record-type-descriptor node)\n  (lambda (x y e?)\n    (and\n      (e? (node-left x) (node-left y))\n      (e? (node-right x) (node-right y)))))\n(record-type-hash-procedure (record-type-descriptor node)\n  (lambda (x hash)\n    (+ (hash (node-left x)) (hash (node-right x)) 23))) \n\n(define graph1\n  (let ([x (make-node \"a\" (make-node #f \"b\"))])\n    (node-left-set! (node-right x) x)\n    x))\n(define graph2\n  (let ([x (make-node \"a\" (make-node (make-node \"a\" #f) \"b\"))])\n    (node-right-set! (node-left (node-right x)) (node-right x))\n    x))\n(define graph3\n  (let ([x (make-node \"a\" (make-node #f \"c\"))])\n    (node-left-set! (node-right x) x)\n    x)) \n\n(equal? graph1 graph2) => #t\n(equal? graph1 graph3) => #f\n(equal? graph2 graph3) => #f \n\n(define h (make-hashtable equal-hash equal?))\n(hashtable-set! h graph1 #t)\n(hashtable-ref h graph1 #f) => #t\n(hashtable-ref h graph2 #f) => #t\n(hashtable-ref h graph3 #f) => #fprocedure: (record-type-equal-procedure rtd equal-proc)\nreturns: unspecified \nprocedure: (record-type-equal-procedure rtd)\nreturns: equality procedure associated with rtd, if any, otherwise #f \nlibraries: (chezscheme)  In the first form, equal-proc must be a procedure or #f. If equal-proc is a procedure, a new association between rtd and equal-proc is established, replacing any existing such association. If equal-proc is #f, any existing association between rtd and an equality procedure is dropped. In the second form, record-type-equal-procedure returns the equality procedure associated with rtd, if any, otherwise #f.  When changing a record type's equality procedure, the record type's hash procedure, if any, should be updated if necessary to maintain the property that it produces the same hash value for any two instances the equality procedure considers equal. procedure: (record-equal-procedure record1 record2)\nreturns: the shared equality procedure for record1 and record2, if there is one, otherwise #f \nlibraries: (chezscheme)  record-equal-procedure traverses the inheritance chains for both record instances in an attempt to find the most specific type for each that is associated with an equality procedure, if any. If such type is found and is the same for both instances, the equality procedure associated with the type is returned. Otherwise, #f is returned.  procedure: (record-type-hash-procedure rtd hash-proc)\nreturns: unspecified \nprocedure: (record-type-hash-procedure rtd)\nreturns: hash procedure associated with rtd, if any, otherwise #f \nlibraries: (chezscheme)  In the first form, hash-proc must be a procedure or #f. If hash-proc is a procedure, a new association between rtd and hash-proc is established, replacing any existing such association. If hash-proc is #f, any existing association between rtd and a hash procedure is dropped. In the second form, record-type-hash-procedure returns the hash procedure associated with rtd, if any, otherwise #f.  The procedure hash-proc should accept two arguments, the instance for which it should compute a hash value and a hash procedure to use to compute hash values for arbitrary fields of the instance, and it returns a nonnegative exact integer. A record type's hash procedure should produce the same hash value for any two instances the record type's equality procedure considers equal. procedure: (record-hash-procedure record)\nreturns: the hash procedure for record, if there is one, otherwise #f \nlibraries: (chezscheme)  record-hash-procedure traverses the inheritance chain for the record instance in an attempt to find the most specific type that is associated with a hash procedure, if any. If such type is found, the hash procedure associated with the type is returned. Otherwise, #f is returned.  thread parameter: default-record-equal-procedure \nlibraries: (chezscheme)  This parameter determines how two record instances are compared by equal? if neither has a type-specific equality procedure. When the parameter has the value #f (the default), equal? compares the instances with eq?, i.e., there is no attempt at determining structural equivalence. Otherwise, the parameter's value must be a procedure, and equal? invokes that procedure to compare the instances, passing it three arguments: the two instances and a procedure that should be used to recursively compare arbitrary values within the instances. thread parameter: default-record-hash-procedure \nlibraries: (chezscheme)  This parameter determines the hash procedure used when equal-hash is called on a record instance and the instance does not have a type-specific hash procedure. When the parameter has the value #f (the default), equal-hash returns a value that is independent of the record type and contents of the instance. Otherwise, the parameter's value must be a procedure, and equal-hash invokes the procedure to compute the instance's hash value, passing it the record instance and a procedure to invoke to recursively compute hash values for arbitrary values contained within the record. The procedure should return a nonnegative exact integer, and the return value should be the same for any two instances the default equal procedure considers equivalent. Section 7.17. Legacy Record TypesIn addition to the Revised^6 Report record-type creation and definition mechanisms, which are described in Chapter 9 of The Scheme Programming Language, 4th Edition, Chez Scheme continues to support pre-R6RS mechanisms for creating new data types, or record types, with fixed sets of named fields. Many of the procedures described in this section are available only when imported from the (chezscheme csv7) library. Code intended to be portable should use the R6RS mechanism instead. Records may be defined via the define-record syntactic form or via the make-record-type procedure. The underlying representation of records and record-type descriptors is the same for the Revised^6 Report mechanism and the alternative mechanism. Record types created by one can be used as parent record types for the other via the procedural mechanisms, though not via the syntactic mechanisms. The syntactic (define-record) interface is the most commonly used interface. Each define-record form defines a constructor procedure for records of the new type, a type predicate that returns true only for records of the new type, an access procedure for each field, and an assignment procedure for each mutable field. For example, (define-record point (x y))creates a new point record type with two fields, x and y, and defines the following procedures:  (make-point x y)  constructor(point? obj)  predicate(point-x p)  accessor for field x(point-y p)  accessor for field y(set-point-x! p obj)  mutator for field x(set-point-y! p obj)  mutator for field y  The names of these procedures follow a regular naming convention by default, but the programmer can override the defaults if desired. define-record allows the programmer to control which fields are arguments to the generated constructor procedure and which  are explicitly initialized by the constructor procedure. Fields are mutable by default, but may be declared immutable. Fields can generally contain any Scheme value, but the internal representation of each field may be specified, which places implicit constraints on the type of value that may be stored there. These customization options are covered in the formal description of define-record later in this section.  The procedural (make-record-type) interface may be used to implement interpreters that must handle define-record forms. Each call to make-record-type returns a record-type descriptor representing the record type. Using this record-type descriptor, programs may generate constructors, type predicates, field accessors, and field mutators dynamically. The following code demonstrates how the procedural interface might be used to create a similar point record type and associated definitions. (define point (make-record-type \"point\" '(x y)))\n(define make-point (record-constructor point))\n(define point? (record-predicate point))\n(define point-x (record-field-accessor point 'x))\n(define point-y (record-field-accessor point 'y))\n(define set-point-x! (record-field-mutator point 'x))\n(define set-point-y! (record-field-mutator point 'y))The procedural interface is more flexible than the syntactic interface, but this flexibility can lead to less readable programs and compromises the compiler's ability to generate efficient code. Programmers should use the syntactic interface whenever it suffices. A record-type descriptor may also be extracted from an instance of a record type, whether the record type was produced by define-record or make-record-type, and the extracted descriptor may also be used to produce constructors, predicates, accessors, and mutators, with a few limitations noted in the description of record-type-descriptor below. This is a powerful feature that permits the coding of portable printers and object inspectors. For example, the printer employs this feature in its default record printer, and the inspector uses it to allow inspection and mutation of system- and user-defined records during debugging. A parent record may be specified in the define-record syntax or as an optional argument to make-record-type. A new record inherits the parent record's fields, and each instance of the new record type is considered to be an instance of the parent type as well, so that accessors and mutators for the parent type may be used on instances of the new type. Record type definitions may be classified as either generative or nongenerative. A new type results for each generative record definition, while only one type results for all occurrences of a given nongenerative record definition. This distinction is important semantically since record accessors and setters are applicable only to objects with the same type. Syntactic (define-record) record definitions are expand-time generative by default, which means that a new record is created when the code is expanded. Expansion happens once for each form prior to compilation or interpretation, as when it is entered interactively, loaded from source, or compiled by compile-file. As a result, multiple evaluations of a single define-record form, e.g., in the body of a procedure called multiple times, always produce the same record type. Separate define-record forms usually produce different types, even if the forms are textually identical. The only exception occurs when the name of a record is specified as a generated symbol, or gensym (page 171). Multiple copies of a record definition whose name is given by a gensym always produce the same record type; i.e., such definitions are nongenerative. Each copy of the record definition must contain the same fields and field modifiers in the same order; an exception is raised with condition-type &assertion when two differing record types with the same generated name are loaded into the same Scheme process. Procedural (make-record-type) record definitions are run-time generative by default. That is, each call to make-record-type usually produces a new record type. As with the syntactic interface, the only exception occurs when the name of the record is specified as a gensym, in which case the record type is fully nongenerative. By default, a record is printed with the syntax #[type-name field ...]where field ... are the printed representations of the contents of the fields of the record, and type-name is a generated symbol, or gensym(page 171), that uniquely identifies the record type. For nongenerative records, type-name is the gensym provided by the program. Otherwise, it is a gensym whose \"pretty\" name (page 171) is the name given to the record by define-record or make-record-type.  The default printing of records of a given type may be overridden with record-writer.  The default syntax may be used as input to the reader as well, as long as the corresponding record type has already been defined in the Scheme session in which the read occurs. The parameter record-reader may be used to specify a different name to be recognized by the reader in place of the generated name. Specifying a different name in this manner also changes the name used when the record is printed. This reader extension is disabled in an input stream after #!r6rs has been seen by the reader, unless #!chezscheme has been seen more recently. The mark (#n=) and reference (#n#) syntaxes may be used within the record syntax, with the result of creating shared or cyclic structure as desired. All cycles must be resolvable, however, without mutation of an immutable record field. That is, any cycle must contain at least one pointer through a mutable field, whether it is a mutable record field or a mutable field of a built-in object type such as a pair or vector. When the parameter print-record is set to #f, records are printed using the simpler syntax #<record of type name>where name is the \"pretty\" name of the record (not the full gensym) or the reader name first assigned to the record type. syntax: (define-record name (fld1 ...) ((fld2 init) ...) (opt ...))\nsyntax: (define-record name parent (fld1 ...) ((fld2 init) ...) (opt ...))\nreturns: unspecified \nlibraries: (chezscheme)  A define-record form is a definition and may appear anywhere and only where other definitions may appear. define-record creates a new record type containing a specified set of named fields and defines a set of procedures for creating and manipulating instances of the record type. name must be an identifier. If name is a generated symbol (gensym), the record definition is nongenerative, otherwise it is expand-time generative. (See the discussion of generativity earlier in this section.) Each fld must be an identifier field-name, or it must take the form (class type field-name)where class and type are optional and field-name is an identifier. class, if present, must be the keyword immutable or the keyword mutable. If the immutable class specifier is present, the field is immutable; otherwise, the field is mutable. type, if present, specifies how the field is represented, as described below.   ptr             any Scheme objectscheme-object   same as ptrint             a C intunsigned        a C unsigned intshort           a C shortunsigned-short  a C unsigned shortlong            a C longunsigned-long   a C unsigned longiptr            a signed integer the size of a ptruptr            an unsigned integer the size of a ptrfloat           a C floatdouble          a C doubleinteger-8       an eight-bit signed integerunsigned-8      an eight-bit unsigned integerinteger-16      a 16-bit signed integerunsigned-16     a 16-bit unsigned integerinteger-32      a 32-bit signed integerunsigned-32     a 32-bit unsigned integerinteger-64      a 64-bit signed integerunsigned-64     a 64-bit unsigned integersingle-float    a 32-bit single floating point numberdouble-float    a 64-bit double floating point number If a type is specified, the field can contain objects only of the specified type. If no type is specified, the field is of type ptr, meaning that it can contain any Scheme object. The field identifiers name the fields of the record. The values of the n fields described by fld1 ... are specified by the n arguments to the generated constructor procedure. The values of the remaining fields, fld2 ..., are given by the corresponding expressions, init .... Each init is evaluated within the scope of the set of field names given by fld1 ... and each field in fld2 ... that precedes it, as if within a let* expression. Each of these field names is bound to the value of the corresponding field during initialization. If parent is present, the record type named by parent is the parent of the record. The new record type inherits each of the parent record's fields, and records of the new type are considered records of the parent type. If parent is not present, the parent record type is a base record type with no fields. The following procedures are defined by define-record:  \n* a constructor procedure whose name is make-name, \n* a type predicate whose name is name?, \n* an access procedure whose name is name-fieldnamefor each noninherited field, and \n* an assignment procedure whose name is set-name-fieldname!for each noninherited mutable field. If no parent record type is specified, the constructor behaves as if defined as (define make-name\n  (lambda (id1 ...)\n    (let* ([id2 init] ...)\n      body)))where id1 ... are the names of the fields defined by fld1 ..., id2 ... are the names of the fields defined by fld2 ..., and body builds the record from the values of the identifiers id1 ... and id2 .... If a parent record type is specified, the parent arguments appear first, and the parent fields are inserted into the record before the child fields. The options opt ... control the selection of names of the generated constructor, predicate, accessors, and mutators. (constructor id)\n(predicate id)\n(prefix string)The option (constructor id) causes the generated constructor's name to be id rather than make-name. The option (predicate id) likewise causes the generated predicate's name to be id rather than name?. The option (prefix string) determines the prefix to be used in the generated accessor and mutator names in place of name-. If no options are needed, the third subexpression, (opt ...), may be omitted. If no options and no fields other than those initialized by the arguments to the constructor procedure are needed, both the second and third subexpressions may be omitted. If options are specified, the second subexpression must be present, even if it contains no field specifiers. Here is a simple example with no inheritance and no options. (define-record marble (color quality))\n(define x (make-marble 'blue 'medium))\n(marble? x) => #t\n(pair? x) => #f\n(vector? x) => #f\n(marble-color x) => blue\n(marble-quality x) => medium\n(set-marble-quality! x 'low)\n(marble-quality x) => low \n\n(define-record marble ((immutable color) (mutable quality))\n  (((mutable shape) (if (eq? quality 'high) 'round 'unknown))))\n(marble-shape (make-marble 'blue 'high)) => round\n(marble-shape (make-marble 'blue 'low)) => unknown\n(define x (make-marble 'blue 'high))\n(set-marble-quality! x 'low)\n(marble-shape x) => round\n(set-marble-shape! x 'half-round)\n(marble-shape x) => half-roundThe following example illustrates inheritance. (define-record shape (x y))\n(define-record point shape ())\n(define-record circle shape (radius)) \n\n(define a (make-point 7 -3))\n(shape? a) => #t\n(point? a) => #t\n(circle? a) => #f \n\n(shape-x a) => 7\n(set-shape-y! a (- (shape-y a) 1))\n(shape-y a) => -4 \n\n(define b (make-circle 7 -3 1))\n(shape? b) => #t\n(point? b) => #f\n(circle? b) => #t \n\n(circle-radius b) => 1\n(circle-radius a) => exception: not of type circle\n\n(define c (make-shape 0 0))\n(shape? c) => #t\n(point? c) => #f\n(circle? c) => #fThis example demonstrates the use of options: (define-record pair (car cdr)\n  ()\n  ((constructor cons)\n   (prefix \"\"))) \n\n(define x (cons 'a 'b))\n(car x) => a\n(cdr x) => b\n(pair? x) => #t \n\n(pair? '(a b c)) => #f\nx => #[#{pair bdhavk1bwafxyss1-a} a b]This example illustrates the use a specified reader name, immutable fields, and the graph mark and reference syntax. (define-record triple ((immutable x1) (mutable x2) (immutable x3)))\n(record-reader 'triple (type-descriptor triple)) \n\n(let ([t '#[triple #1=(1 2) (3 4) #1#]])\n  (eq? (triple-x1 t) (triple-x3 t))) => #t\n(let ([x '(#1=(1 2) . #[triple #1# b c])])\n  (eq? (car x) (triple-x1 (cdr x)))) => #t\n(let ([t #[triple #1# (3 4) #1=(1 2)]])\n  (eq? (triple-x1 t) (triple-x3 t))) => #t\n(let ([t '#1=#[triple a #1# c]])\n  (eq? t (triple-x2 t))) => #t\n(let ([t '#1=(#[triple #1# b #1#])])\n  (and (eq? t (triple-x1 (car t)))\n       (eq? t (triple-x1 (car t))))) => #tCycles established with the mark and reference syntax can be resolved only if a mutable record field or mutable location of some other object is involved the cycle, as in the last two examples above. An exception is raised with condition type &lexical if only immutable fields are involved. '#1=#[triple #1# (3 4) #1#] => exceptionThe following example demonstrates the use of nongenerative record definitions. (module A (point-disp)\n  (define-record #{point bdhavk1bwafxyss1-b} (x y))\n  (define square (lambda (x) (* x x)))\n  (define point-disp\n    (lambda (p1 p2)\n      (sqrt (+ (square (- (point-x p1) (point-x p2)))\n               (square (- (point-y p1) (point-y p2)))))))) \n\n(module B (base-disp)\n  (define-record #{point bdhavk1bwafxyss1-b} (x y))\n  (import A)\n  (define base-disp\n    (lambda (p)\n      (point-disp (make-point 0 0) p)))) \n\n(let ()\n  (import B)\n  (define-record #{point bdhavk1bwafxyss1-b} (x y))\n  (base-disp (make-point 3 4))) => 5This works even if the different program components are loaded from different source files or are compiled separately and loaded from different object files. syntax: predicate \nsyntax: prefix \nsyntax: constructor \nlibraries: (chezscheme)  These identifiers are auxiliary keywords for define-record. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords. mutable and immutable are also auxiliary keywords for define-record, shared with the Revised^6 Report define-record-type.  syntax: (type-descriptor name)\nreturns: the record-type descriptor associated with name \nlibraries: (chezscheme)  name must name a record type defined by define-record or define-record-type.  This form is equivalent to the Revised^6 Report record-type-descriptor form.  The record-type descriptor is useful for overriding the default read and write syntax using record-reader and record-writer and may also be used with the procedural interface routines described later in this section. (define-record frob ())\n(type-descriptor frob) => #<record type frob>procedure: (record-reader name)\nreturns: the record-type descriptor associated with name \nprocedure: (record-reader rtd)\nreturns: the first name associated with rtd \nprocedure: (record-reader name rtd)\nreturns: unspecified \nprocedure: (record-reader name #f)\nreturns: unspecified \nprocedure: (record-reader rtd #f)\nreturns: unspecified \nlibraries: (chezscheme)  name must be a symbol, and rtd must be a record-type descriptor. With one argument, record-reader is used to retrieve the record type associated with a name or name associated with a record type. If no association has been created, record-reader returns #f  With arguments name and rtd, record-reader registers rtd as the record-type descriptor to be used whenever the read procedure encounters a record named by name and printed in the default record syntax. With arguments name and #f, record-reader removes any association for name to a record-type descriptor. Similarly, with arguments rtd and #f, record-reader removes any association for rtd to a name. (define-record marble (color quality))\n(define m (make-marble 'blue 'perfect))\nm => #[#{marble bdhavk1bwafxyss1-c} blue perfect] \n\n(record-reader (type-descriptor marble)) => #f\n(record-reader 'marble) => #f \n\n(record-reader 'marble (type-descriptor marble))\n(marble-color '#[marble red miserable]) => red \n\n(record-reader (type-descriptor marble)) => marble\n(record-reader 'marble) => #<record type marble> \n\n(record-reader (type-descriptor marble) #f)\n(record-reader (type-descriptor marble)) => #f\n(record-reader 'marble) => #f \n\n(record-reader 'marble (type-descriptor marble))\n(record-reader 'marble #f)\n(record-reader (type-descriptor marble)) => #f\n(record-reader 'marble) => #fThe introduction of a record reader also changes the default printing of records. The printer always chooses the reader name first assigned to the record, if any, in place of the unique record name, as this continuation of the example above demonstrates. (record-reader 'marble (type-descriptor marble))\n(make-marble 'pink 'splendid) => #[marble pink splendid]procedure: (record-writer rtd)\nreturns: the record writer associated with rtd \nprocedure: (record-writer rtd procedure)\nreturns: unspecified \nlibraries: (chezscheme)  rtd must be a record-type descriptor, and procedure should accept three arguments, as described below. When passed only one argument, record-writer returns the record writer associated with rtd, which is initially the default record writer for all records. The default print method prints all records in a uniform syntax that includes the generated name for the record  and the values of each of the fields, as described in the introduction to this section. When passed two arguments, record-writer establishes a new association between rtd and procedure so that procedure will be used by the printer in place of the default printer for records of the given type. The printer passes procedure three arguments: the record r, a port p, and a procedure wr that should be used to write out the values of arbitrary Scheme objects that the print method chooses to include in the printed representation of the record, e.g., values of the record's fields. (define-record marble (color quality))\n(define m (make-marble 'blue 'medium)) \n\nm => #[#{marble bdhavk1bwafxyss1-d} blue medium] \n\n(record-writer (type-descriptor marble)\n  (lambda (r p wr)\n    (display \"#<\" p)\n    (wr (marble-quality r) p)\n    (display \" quality \" p)\n    (wr (marble-color r) p)\n    (display \" marble>\" p))) \n\nm => #<medium quality blue marble>The record writer is used only when print-record is true (the default). When the parameter print-record is set to #f, records are printed using a compressed syntax that identifies only the type of record. (parameterize ([print-record #f])\n  (format \"~s\" m)) => \"#<record of type marble>\"A print method may be called more than once during the printing of a single record to support cycle detection and graph printing (see print-graph), so print methods that perform side effects other than printing to the given port are discouraged. Whenever a print method is called more than once during the printing of a single record, in all but one call, a generic \"bit sink\" port is used to suppress output automatically so that only one copy of the object appears on the actual port. In order to avoid confusing the cycle detection and graph printing algorithms, a print method should always produce the same printed representation for each object. Furthermore, a print method should normally use the supplied procedure wr to print subobjects, though atomic values, such as strings or numbers, may be printed by direct calls to display or write or by other means.  (let ()\n  (define-record ref () ((contents 'nothing)))\n  (record-writer (type-descriptor ref)\n    (lambda (r p wr)\n      (display \"<\" p)\n      (wr (ref-contents r) p)\n      (display \">\" p)))\n  (let ([ref-lexive (make-ref)])\n    (set-ref-contents! ref-lexive ref-lexive)\n    ref-lexive)) => #0=<#0#>Print methods need not be concerned with handling nonfalse values of the parameters print-level. The printer handles print-level automatically even when user-defined print procedures are used. Since records typically contain a small, fixed number of fields, it is usually possible to ignore nonfalse values of print-length as well.  (print-level 3)\n(let ()\n  (define-record ref () ((contents 'nothing)))\n  (record-writer (type-descriptor ref)\n    (lambda (r p wr)\n      (display \"<\" p)\n      (wr (ref-contents r) p)\n      (display \">\" p)))\n  (let ([ref-lexive (make-ref)])\n    (set-ref-contents! ref-lexive ref-lexive)\n    ref-lexive)) => <<<<#[...]>>>>thread parameter: print-record \nlibraries: (chezscheme)  This parameter controls the printing of records. If set to true (the default) the record writer associated with a record type is used to print records of that type. If set to false, all records are printed with the syntax #<record of type name>, where name is the name of the record type as returned by record-type-name.  procedure: (make-record-type type-name fields)\nprocedure: (make-record-type parent-rtd type-name fields)\nreturns: a record-type descriptor for a new record type \nlibraries: (chezscheme)  make-record-type creates a new data type and returns a record-type descriptor, a value representing the new data type. The new type is disjoint from all others. If present, parent-rtd must be a record-type descriptor. type-name must be a string or gensym. If type-name is a string, a new record type is generated. If type-name is a gensym, a new record type is generated only if one with the same gensym has not already been defined. If one has already been defined, the parent and fields must be identical to those of the existing record type, and the existing record type is used. If the parent and fields are not identical, an exception is raised with condition-type &assertion.  fields must be a list of field descriptors, each of which describes one field of instances of the new record type. A field descriptor is either a symbol or a list in the following form: (class type field-name)where class and type are optional. field-name must be a symbol. class, if present, must be the symbol immutable or the symbol mutable. If the immutable class-specifier is present, the field is immutable; otherwise, the field is mutable. type, if present, specifies how the field is represented. The types are the same as those given in the description of define-record on page 196. If a type is specified, the field can contain objects only of the specified type. If no type is specified, the field is of type ptr, meaning that it can contain any Scheme object. The behavior of a program that modifies the string type-name or the list fields or any of its sublists is unspecified. The record-type descriptor may be passed as an argument to any of the Revised^6 Report procedures \n* record-constructor, \n* record-predicate, \n* record-accessor, and \n* record-mutator,  or to the Chez Scheme variants \n* record-constructor, \n* record-field-accessor, and \n* record-field-mutator  to obtain procedures for creating and manipulating records of the new type. (define marble\n  (make-record-type \"marble\"\n    '(color quality)\n    (lambda (r p wr)\n      (display \"#<\" p)\n      (wr (marble-quality r) p)\n      (display \" quality \" p)\n      (wr (marble-color r) p)\n      (display \" marble>\" p))))\n(define make-marble\n  (record-constructor marble))\n(define marble?\n  (record-predicate marble))\n(define marble-color\n  (record-field-accessor marble 'color))\n(define marble-quality\n  (record-field-accessor marble 'quality))\n(define set-marble-quality!\n  (record-field-mutator marble 'quality))\n(define x (make-marble 'blue 'high))\n(marble? x) => #t\n(marble-quality x) => high\n(set-marble-quality! x 'low)\n(marble-quality x) => low\nx => #<low quality blue marble>The order in which the fields appear in fields is important. While field names are generally distinct, it is permissible for one field name to be the same as another in the list of fields or the same as an inherited name. In this case, field ordinals must be used to select fields in calls to record-field-accessor and record-field-mutator. Ordinals range from zero through one less than the number of fields. Parent fields come first, if any, followed by the fields in fields, in the order given. (define r1 (make-record-type \"r1\" '(t t)))\n(define r2 (make-record-type r1 \"r2\" '(t)))\n(define r3 (make-record-type r2 \"r3\" '(t t t))) \n\n(define x ((record-constructor r3) 'a 'b 'c 'd 'e 'f))\n((record-field-accessor r3 0) x) => a\n((record-field-accessor r3 2) x) => c\n((record-field-accessor r3 4) x) => e\n((record-field-accessor r3 't) x) => unspecifiedprocedure: (record-constructor rcd)\nprocedure: (record-constructor rtd)\nreturns: a constructor for records of the type represented by rtd \nlibraries: (chezscheme)  Like the Revised^6 Report version of this procedure, this procedure may be passed a record-constructor descriptor, rcd, which determines the behavior of the constructor. It may also be passed a record-type descriptor, rtd, in which case the constructor accepts as many arguments as there are fields in the record; these arguments are the initial values of the fields in the order given when the record-type descriptor was created. procedure: (record-field-accessor rtd field-id)\nreturns: an accessor for the identified field \nlibraries: (chezscheme csv7)rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The specified field must be accessible. The generated accessor expects one argument, which must be a record of the type represented by rtd. It returns the contents of the specified field of the record. procedure: (record-field-accessible? rtd field-id)\nreturns: #t if the specified field is accessible, otherwise #f \nlibraries: (chezscheme csv7)rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The compiler is free to eliminate a record field if it can prove that the field is not accessed. In making this determination, the compiler is free to ignore the possibility that an accessor might be created from a record-type descriptor obtained by calling record-type-descriptor on an instance of the record type. procedure: (record-field-mutator rtd field-id)\nreturns: a mutator for the identified field \nlibraries: (chezscheme csv7)rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The specified field must be mutable. The mutator expects two arguments, r and obj. r must be a record of the type represented by rtd. obj must be a value that is compatible with the type declared for the specified field when the record-type descriptor was created. obj is stored in the specified field of the record. procedure: (record-field-mutable? rtd field-id)\nreturns: #t if the specified field is mutable, otherwise #f \nlibraries: (chezscheme csv7)rtd must be a record-type descriptor, field-id must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. Any field declared immutable is immutable. In addition, the compiler is free to treat a field as immutable if it can prove that the field is never assigned. In making this determination, the compiler is free to ignore the possibility that a mutator might be created from a record-type descriptor obtained by calling record-type-descriptor on an instance of the record type. procedure: (record-type-name rtd)\nreturns: the name of the record-type represented by rtd \nlibraries: (chezscheme csv7)rtd must be a record-type descriptor. The name is a always a string. If a gensym is provided as the record-type name in a define-record form or make-record-type call, the result is the \"pretty\" name of the gensym (see 7.11). (record-type-name (make-record-type \"empty\" '())) => \"empty\" \n\n(define-record #{point bdhavk1bwafxyss1-b} (x y))\n(define p (type-descriptor #{point bdhavk1bwafxyss1-b}))\n(record-type-name p) => \"point\"procedure: (record-type-symbol rtd)\nreturns: the generated symbol associated with rtd \nlibraries: (chezscheme csv7)rtd must be a record-type descriptor. (define e (make-record-type \"empty\" '()))\n(record-type-symbol e) => #{empty bdhavk1bwafxyss1-e} \n\n(define-record #{point bdhavk1bwafxyss1-b} (x y))\n(define p (type-descriptor #{point bdhavk1bwafxyss1-b}))\n(record-type-symbol p) => #{point bdhavk1bwafxyss1-b}procedure: (record-type-field-names rtd)\nreturns: a list of field names of the type represented by rtd \nlibraries: (chezscheme csv7)rtd must be a record-type descriptor. The field names are symbols. See also the Revised^6 Report version of this prodecure (exported from the (chezscheme) library) which returns a vector.  (define-record triple ((immutable x1) (mutable x2) (immutable x3)))\n(record-type-field-names (type-descriptor triple)) => (x1 x2 x3)procedure: (record-type-field-decls rtd)\nreturns: a list of field declarations of the type represented by rtd \nlibraries: (chezscheme csv7)rtd must be a record-type descriptor. Each field declaration has the following form: (class type field-name)where class, type, and field-name are as described under make-record-type.  (define-record shape (x y))\n(define-record circle shape (radius)) \n\n(record-type-field-decls\n  (type-descriptor circle)) => ((mutable ptr x)\n                                (mutable ptr y)\n                                (mutable ptr radius))procedure: (record? obj)\nreturns: #t if obj is a record, otherwise #f \nprocedure: (record? obj rtd)\nreturns: #t if obj is a record of the given type, otherwise #f \nlibraries: (chezscheme)  If present, rtd must be a record-type descriptor. A record is \"of the given type\" if it is an instance of the record type or one of its ancestors. The predicate generated by record-predicate for a record-type descriptor rtd is equivalent to the following. (lambda (x) (record? x rtd))procedure: (record-instance? obj rtd)\nreturns: #t if obj is a record of the given type, otherwise #f \nlibraries: (chezscheme)  obj must be a record, and rtd must be a record-type descriptor. The result is the same as for a two-argument record? call, but obj is constrained to be a record. In unsafe mode, record-instance? might be faster than record?.  procedure: (record-type-descriptor rec)\nreturns: the record-type descriptor of rec \nlibraries: (chezscheme csv7)rec must be a record. This procedure is intended for use in the definition of portable printers and debuggers. For records created with make-record-type, it may not be the same as the descriptor returned by make-record-type. See the comments about field accessibility and mutability under record-field-accessible? and record-field-mutable? above.  This procedure is equivalent to the Revised^6 Report record-rtd procedure. (define rtd (make-record-type \"frob\" '(blit blat)))\nrtd => #<record type frob>\n(define x ((record-constructor rtd) 1 2))\n(record-type-descriptor x) => #<record type frob>\n(eq? (record-type-descriptor x) rtd) => unspecifiedprocedure: (make-record-type-descriptor name parent uid s? o? fields)\nreturns: a record-type descriptor for a new record type \nlibraries: (chezscheme)  Like the Revised^6 Report version of this procedure, but fields is also allowed to be a pair of non-negative integers, in which case the new record type has anonymous fields. The car of fields is a field count, and it is added to any fields present in parent to determine the record type's total number of fields. The cdr of fields must be an exact non-negative integer that is treated as a bit array; a 1 bit indicates the the corresponding field among new fields is mutable. The total number of fields in a record type must be a fixnum. If parent is a record type descriptor, it must also have anonymous fields. The resulting anonymous-field record type can only be the parent of a record type with anonymous fields. When a function like record-type-field-names is applied to an anonymous-field record type, the field names are all reported as field.  procedure: (record-type-has-named-fields? rtd)\nreturns: a boolean indicating whether rtd has named fields \nlibraries: (chezscheme)  rtd must be a record-type descriptor. Section 7.18. Proceduresprocedure: (procedure-arity-mask proc)\nreturns: an exact integer bitmask identifying the accepted argument counts of proc \nlibraries: (chezscheme)  The bitmask is represented as two's complement number with the bit at each index n set if and only if proc accepts n arguments. The two's complement encoding implies that if proc accepts n or more arguments, the encoding is a negative number, since all the bits from n and up are set. For example, if proc accepts any number of arguments, the two's complement encoding of all bits set is -1.  (procedure-arity-mask (lambda () 'none)) => 1\n(procedure-arity-mask car) => 2\n(procedure-arity-mask (case-lambda [() 'none] [(x) x])) => 3\n(procedure-arity-mask (lambda x x)) => -1\n(procedure-arity-mask (case-lambda [() 'none] [(x y . z) x])) => -3\n(procedure-arity-mask (case-lambda)) => 0\n(logbit? 1 (procedure-arity-mask pair?)) => #t\n(logbit? 2 (procedure-arity-mask pair?)) => #f\n(logbit? 2 (procedure-arity-mask cons)) => #tprocedure: (make-wrapper-procedure proc arity-mask data)\nprocedure: (make-arity-wrapper-procedure proc arity-mask data)\nreturns: a procedure that behaves like proc, but with the given arity-mask \nlibraries: (chezscheme)  proc must be a procedure, and arity-mask must be an exact integer representing an arity mask in the sense of procedure-arity-mask.  The resulting procedure behaves the same as proc, except that procedure-arity-mask on the result procedure returns arity-mask. When the result of make-arity-wrapper-procedure is called, the given arguments are compared to the given arity mask, and an error is reported if the argument count does not match. The result of make-wrapper-procedure, in contrast, does not enforce the given arity mask. The data argument can be any value, and it can be retrieved from the result procedure with wrapper-procedure-data.  (define vector3 (make-wrapper-procedure vector 8 #f))\n(procedure-arity-mask vector) ; => -1\n(procedure-arity-mask vector3) ; => 8\n(vector3 1 2 3) => #(1 2 3)\n(vector3 1 2) => #(1 2)\n(define vector3/check (make-arity-wrapper-procedure vector 8 #f))\n(vector3/check 1 2 3) =>  #(1 2 3)\n(vector3/check 1 2) => exceptionprocedure: (wrapper-procedure? obj)\nreturns: #t if obj is a wrapper procedure, #f otherwise \nlibraries: (chezscheme)  Determines whether obj is a wrapper procedure produced by either make-wrapper-procedure or make-arity-wrapper-procedure.  (wrapper-procedure? vector) ; => #f\n(define vector3 (make-wrapper-procedure vector 8 #f))\n(wrapper-procedure? vector3) ; => #tprocedure: (wrapper-procedure-procedure w-proc)\nreturns: the procedure wrapped by the wrapper procedure proc \nlibraries: (chezscheme)  w-proc must be a wrapper procedure produced by either make-wrapper-procedure or make-arity-wrapper-procedure.  (define vector3 (make-wrapper-procedure vector 8 'my-data))\n(wrapper-procedure-procedure vector3) ; => #<procedure vector>procedure: (wrapper-procedure-data w-proc)\nreturns: the data stored with the wrapper procedure proc \nlibraries: (chezscheme)  w-proc must be a wrapper procedure produced by either make-wrapper-procedure or make-arity-wrapper-procedure.  (define vector3 (make-wrapper-procedure vector 8 'my-data))\n(wrapper-procedure-data vector3) ; => 'my-dataprocedure: (set-wrapper-procedure-data! w-proc data)\nreturns: unspecified \nlibraries: (chezscheme)  w-proc must be a wrapper procedure produced by either make-wrapper-procedure or make-arity-wrapper-procedure.  Changes the data stored in w-proc to data. (define vector3 (make-wrapper-procedure vector 8 'my-data))\n(wrapper-procedure-data vector3) ; => 'my-data\n(set-wrapper-procedure-data! vector3 'my-new-data)\n(wrapper-procedure-data vector3) ; => 'my-new-dataprocedure: (set-wrapper-procedure-procedure! w-proc proc)\nreturns: unspecified \nlibraries: (chezscheme)  w-proc must be a wrapper procedure produced by either make-wrapper-procedure or make-arity-wrapper-procedure, and proc must be a procedure. Changes w-proc so that it behaves the same as proc, leaving the results of \n (procedure-arity-mask w-proc) and (wrapper-procedure-data w-proc) unchanged. (define vector3 (make-wrapper-procedure vector 8 'my-data))\n(vector3 1 2 3) ; => #(1 2 3)\n(set-wrapper-procedure-procedure! vector3 list)\n(vector3 1 2 3) ; => (1 2 3)procedure: (procedure-known-single-valued? proc)\nreturns: a boolean indicating whether proc is known to always produce a single value \nlibraries: (chezscheme)  Returns an approximate classification of proc as always having a single result value or not. The result may be #f for a procedure that always returns a single value, but with an implementation that was too complex for the compiler to prove that fact. The result is #t only for a procedure that always produces a single result value. Chez Scheme Version 10 User's Guide\nCopyright  2024 Cisco Systems, Inc.\nLicensed under the Apache License Version 2.0(full copyright notice.).Revised February 2024 for Chez Scheme Version 10.0.0\nabout this book\n\n") ("control:s0" "syntax: (exclusive-cond clause1 clause2 ...)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "exclusive-cond is a version of cond (Section 5.3 of TSPLFOUR) that differs from cond in that the tests embedded within the clauses are assumed to be exclusive in the sense that if one of the tests is true, the others are not. This allows the implementation to reorder clauses when profiling information is available at expansion time (Section 12.7). \n\n" "The (test) form of clause is not supported. The order chosen when profiling information is available is based on the relative numbers of times the RHS of each clause is executed, and (test) has no RHS. (test => values) is equivalent, albeit less concise. \n\n") ("control:s1" "syntax: (case expr0 clause1 clause2 ...)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "Each clause but the last must take one of the forms: \n\n" "" "((key ...) expr1 expr2 ...)\n(key expr1 expr2 ...)\n\n" "where each key is a datum distinct from the other keys. The last clause may be in the above form or it may be an else clause of the form  \n\n" "" "(else expr1 expr2 ...)\n\n" "expr0 is evaluated and the result is compared (using equal?) against the keys of each clause in order. If a clause containing a matching key is found, the expressions expr1 expr2 ... are evaluated in sequence and the values of the last expression are returned. \n\n" "If none of the clauses contains a matching key and an else clause is present, the expressions expr1 expr2 ... of the else clause are evaluated in sequence and the values of the last expression are returned. \n\n" "If none of the clauses contains a matching key and no else clause is present, the value or values are unspecified. \n\n" "The Revised^6 Report version of case does not support singleton keys (the second of the first two clause forms above) and uses eqv? rather than equal? as the comparison procedure. Both versions are defined in terms of exclusive-cond so that if profiling information is available at expansion time, the clauses will be reordered to put those that are most frequently executed first. \n\n" "" "(let ([ls '(ii iv)])\n  (case (car ls)\n    [i 1]\n    [ii 2]\n    [iii 3]\n    [(iiii iv) 4]\n    [else 'out-of-range])) => 2 \n\n(define p\n  (lambda (x)\n    (case x\n      [(\"abc\" \"def\") 'one]\n      [((a b c)) 'two]\n      [else #f]))) \n\n(p (string #\\d #\\e #\\f)) => one\n(p '(a b c)) => two\n\n") ("control:s3" "syntax: (record-case expr clause1 clause2 ...)\nreturns: see explanation \nlibraries: (chezscheme)  \n\n" "record-case is a restricted form of case that supports the destructuring of records, or tagged lists. A record has as its first element a tag that determines what \"type\" of record it is; the remaining elements are the fields of the record. \n\n" "Each clause but the last must take the form \n\n" "" "((key ...) formals body1 body2 ...)\n\n" "where each key is a datum distinct from the other keys. The last clause may be in the above form or it may be an else clause of the form  \n\n" "" "(else body1 body2 ...)\n\n" "expr must evaluate to a pair. expr is evaluated and the car of its value is compared (using eqv?) against the keys of each clause in order. If a clause containing a matching key is found, the variables in formals are bound to the remaining elements of the list and the expressions body1 body2 ... are evaluated in sequence. The value of the last expression is returned. The effect is identical to the application of \n\n" "" "(lambda formals body1 body2 ...)\n\n" "to the cdr of the list. \n\n" "If none of the clauses contains a matching key and an else clause is present, the expressions body1 body2 ... of the else clause are evaluated in sequence and the value of the last expression is returned. \n\n" "If none of the clauses contains a matching key and no else clause is present, the value is unspecified. \n\n" "" "(define calc\n  (lambda (x)\n    (record-case x\n      [(add) (x y) (+ x y)]\n      [(sub) (x y) (- x y)]\n      [(mul) (x y) (* x y)]\n      [(div) (x y) (/ x y)]\n      [else (assertion-violationf 'calc \"invalid expression ~s\" x)]))) \n\n(calc '(add 3 4)) => 7\n(calc '(div 3 4)) => 3/4\n\n") ("control:s7" "procedure: (ormap procedure list1 list2 ...)\nreturns: see explanation \nlibraries: (chezscheme)  \n\n" "ormap is identical to the Revised^6 Report exists.  \n\n") ("control:s8" "procedure: (andmap procedure list1 list2 ...)\nreturns: see explanation \nlibraries: (chezscheme)  \n\n" "andmap is identical to the Revised^6 Report for-all.  \n\n") ("control:s9" "procedure: (call/1cc procedure)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "call/1cc obtains its continuation and passes it to procedure, which should accept one argument. The continuation itself is represented by a procedure. This procedure normally takes one argument but may take an arbitrary number of arguments depending upon whether the context of the call to call/1cc expects multiple return values or not. When this procedure is applied to a value or values, it returns the values to the continuation of the call/1cc application.  \n\n" "The continuation obtained by call/1cc is a \"one-shot continuation.\" A one-shot continuation should not be returned to multiple times, either by invoking the continuation or returning normally from procedure more than once. A one-shot continuation is \"promoted\" into a normal (multishot) continuation, however, if it is  still active when a normal continuation is obtained by call/cc. After a one-shot continuation is promoted into a multishot continuation, it behaves exactly as if it had been obtained via call/cc. This allows call/cc and call/1cc to be used together transparently in many applications. \n\n" "One-shot continuations may be more efficient for some applications than multishot continuations. See the paper \"Representing control in the presence of one-shot continuations\" [3] for more information about one-shot continuations, including how they are implemented in Chez Scheme. \n\n" "The following examples highlight the similarities and differences between one-shot and normal continuations. \n\n" "" "(define prod\n ; compute the product of the elements of ls, bugging out\n ; with no multiplications if a zero element is found\n  (lambda (ls)\n    (lambda (k)\n      (if (null? ls)\n          1\n          (if (= (car ls) 0)\n              (k 0)\n              (* (car ls) ((prod (cdr ls)) k))))))) \n\n(call/cc (prod '(1 2 3 4))) => 24\n(call/1cc (prod '(1 2 3 4))) => 24 \n\n(call/cc (prod '(1 2 3 4 0))) => 0\n(call/1cc (prod '(1 2 3 4 0))) => 0 \n\n(let ([k (call/cc (lambda (x) x))])\n  (k (lambda (x) 0))) => 0 \n\n(let ([k (call/1cc (lambda (x) x))])\n  (k (lambda (x) 0))) => exception\n\n") ("control:s11" "procedure: (dynamic-wind in body out)\nprocedure: (dynamic-wind critical? in body out)\nreturns: values resulting from the application of body \nlibraries: (chezscheme)  \n\n" "The first form is identical to the Revised^6 Report dynamic-wind. When the optional critical? argument is present and non-false, the in thunk is invoked in a critical section along with the code that records that the body has been entered, and the out thunk is invoked in a critical section along with the code that records that the body has been exited. Extreme caution must be taken with this form of dynamic-wind, since an error or long-running computation can leave interrupts and automatic garbage collection disabled. \n\n") ("control:s12" "syntax: (with-continuation-mark key val body)\nreturns: the value of the body expression \nlibraries: (chezscheme)  \n\n" "with-continuation-mark updates the table of marks on the current continuation to map the result of the key expression to the result of the val expression. If the current continuation's table of marks already has a mapping for key (based on eq? comparison), then the mark's value is replaced with val, otherwise a mapping from key to val is added to the table. \n\n" "" "(with-continuation-mark\n  'key \"val\"\n \"hello\") ; => \"hello\" \n\n(with-continuation-mark\n 'key \"val\"\n (continuation-marks-first (current-continuation-marks)\n                           'key)) ; => \"val\" \n\n(with-continuation-mark\n 'key \"val\"\n (continuation-marks-first (current-continuation-marks)\n                           'other-key)) ; => #f \n\n(with-continuation-mark\n 'key \"val\"\n (with-continuation-mark\n  'key \"val2\"\n  (continuation-marks-first (current-continuation-marks)\n                            'key))) ; => \"val2\" \n\n(with-continuation-mark\n 'key \"val\"\n (with-continuation-mark\n  'key \"val2\"\n  (continuation-marks->list (current-continuation-marks)\n                            'key))) ; => (\"val2\") \n\n(with-continuation-mark\n 'key \"val\"\n (values\n  (with-continuation-mark\n   'key \"val2\"\n   (continuation-marks->list (current-continuation-marks)\n                             'key)))) ; => (\"val2\" \"val\")\n\n") ("control:s13" "procedure: (continuation-marks? obj)\nreturns: boolean \nlibraries: (chezscheme)  \n\n" "A predicate that recognizes a continuation mark sequence, which can be produced by the functions current-continuation-marks and continuation-next-marks.  \n\n") ("control:s14" "procedure: (current-continuation-marks) \nprocedure: (continuation-next-marks cont)\nreturns: a continuation mark sequence \nlibraries: (chezscheme)  \n\n" "Returns a captured sequence of mark tables, either the current continuation's marks in the case of current-continuation-marks or the marks of the rest of cont in the case of continuation-next-marks. In the latter case, cont must be a continuation. \n\n" "This function takes constant time. The size of the resulting mark sequence is proportional to the number of distinct key-value mappings in the overall mark-table sequence; that size is bounded by the length of the continuation times the number of distinct values used as keys, but since many continuations have no keys or fewer than all possible keys in their tables, the size tends to be much less than the bound. \n\n" "" "(continuation-marks? (current-continuation-marks)) ; => #t\n(continuation-marks? (continuation-next-marks\n                      (call/cc (lambda (k) k)))) ; => #t\n\n") ("control:s15" "procedure: (continuation-marks-first marks key)\nprocedure: (continuation-marks-first marks key none-val)\nreturns: the value for key in marks or none-val \nlibraries: (chezscheme)  \n\n" "Extracts the first value found for key in marks, checking the mark table of a continuation before checking the table of the continuation that it extends (if any). Keys are compared using eq?. If no mark for key is found, none-val is returned; if none-val is not provided, it defaults to #f.  \n\n" "This function takes amortized time proportional to the number of distinct values used as keys in marks. Typically the number of keys used in an application is bounded, which makes the computation amortized constant-time for those applications. \n\n" "" "(with-continuation-mark\n  'key \"val\"\n (values\n  (with-continuation-mark\n   'key \"val2\"\n   (continuation-marks-first (current-continuation-marks)\n                             'key)))) ; => \"val2\" \n\n(with-continuation-mark\n 'key \"val\"\n (continuation-marks-first (current-continuation-marks)\n                           'other\n                           \"nope\")) ; => \"nope\"\n\n") ("control:s16" "procedure: (continuation-marks->list marks key)\nreturns: a list \nlibraries: (chezscheme)  \n\n" "Returns the list of all values associated with key in marks, with the value from a continuation's mark table appearing before the values from the mark tables of any other continuation that it extends.  Keys are compared using eq?.  \n\n" "This function takes time proportional to the size of the captured mark sequence. \n\n" "" "(with-continuation-mark\n  'key \"val\"\n (values\n  (with-continuation-mark\n   'key \"val2\"\n   (continuation-marks->list (current-continuation-marks)\n                             'key)))) ; => (\"val2\" \"val\") \n\n(with-continuation-mark\n 'key \"val\"\n (continuation-marks->list (current-continuation-marks)\n                           'other)) ; => ()\n\n") ("control:s17" "procedure: (continuation-marks->iterator marks key-vector)\nprocedure: (continuation-marks->iterator marks key-vector none-val)\nreturns: a procedure \nlibraries: (chezscheme)  \n\n" "Generalizes the mark sequence traversal of continuation-marks->list to a functional iterator. The marks argument must be a continuation mark sequence, and the key-vector argument must be a vector of values to be used as keys. The result is an iterator procedure of zero arguments. \n\n" "Calling the result iterator procedure (with no arguments) returns two values: \n\n" "") ("control:s18" "\n* The first result is either a vector of values, one for each key in   key-vector (in the order given in key-vector) and drawn from   a single continuation's mark table, or #f if no more values for   any keys are available. The given none-val, which defaults to   #f, is used for each key that has no value in the table. Only   mark tables with mappings for at least one of the keys in   key-vector are represented in the iteration, so a result vector   will never consist solely of none-val values (unless one or more of the keys   is explicitly mapped to none-val). \n* The second result is a new iterator procedure to obtain the next vector of values, and so on. When the first result is #f, the second result is an iterator procedure that will still return #f as its first result (and a procedure functionally equivalent to itself as the second result). Obtaining an iterator from continuation-marks->iterator takes constant time. Each call to an iterator takes time proportional to the size of continuation mark tables that are traversed to find one of the keys in key-vector. (with-continuation-mark\n  'key \"val\"\n (with-continuation-mark\n  'other \"also\"\n  (values\n   (with-continuation-mark\n    'key \"val2\"\n    (let loop ([iter (continuation-marks->iterator\n                      (current-continuation-marks)\n                      '#(key other))])\n      (let-values ([(vec iter) (iter)])\n         (if vec\n             (cons vec (loop iter))\n             '()))))))) ; => (#(\"val2\" #f) #(\"val\" \"also\"))procedure: (call-with-immediate-continuation-mark key proc)\nprocedure: (call-with-immediate-continuation-mark key none-val proc)\nreturns: the value produced by calling proc \nlibraries: (chezscheme)  Similar to  (continuation-marks-first (current-continuation-marks) key none-val)but only the immediate continuation's mark table is checked, and the result is delivered to proc instead of returned. The proc, which must be a procedure that accepts one argument, is called in tail position, so its continuation is the same as the one whose table is checked. (with-continuation-mark\n  'key \"val\"\n (call-with-immediate-continuation-mark 'key list)) ; => (\"val\") \n\n(with-continuation-mark\n 'key \"val\"\n (vector (call-with-immediate-continuation-mark 'key list))) ; => #((#f))\n(with-continuation-mark\n 'key \"val\"\n (vector (call-with-immediate-continuation-mark 'key 'no list))) ; => #((no))procedure: (call-in-continuation continuation procedure)\nprocedure: (call-in-continuation continuation marks procedure)\nreturns: does not return \nlibraries: (chezscheme)  continuation must be a continuation, procedure must be a procedure that accepts zero arguments, and marks (if provided) must be a continuation mark sequence. Applies procedure to zero arguments with continuation as the continuation of the call, escaping from the current continuation. This operation is similar to applying continuation to values, except that the values delivered to the continuation are the ones produced by procedure as it runs within the applied continuation. If marks is not provided, then procedure starts with no immediate mark table. Otherwise, marks must be consistent with the result of continuation-next-marks on continuation: either the same content or one additional mark table, and the additional mark table becomes the immediate mark table when calling procedure. Section 6.4. EnginesEngines are a high-level process abstraction supporting timed preemption [15,24]. Engines may be used to simulate multiprocessing, implement operating system kernels, and perform nondeterministic computations. procedure: (make-engine thunk)\nreturns: an engine \nlibraries: (chezscheme)  An engine is created by passing a thunk (no argument procedure) to make-engine. The body of the thunk is the computation to be performed by the engine. An engine itself is a procedure of three arguments: \nticks:\n    a positive integer that specifies the amount of fuel to be given to the engine. An engine executes until this fuel runs out or until its computation finishes. \ncomplete:\n    a procedure of one or more arguments that specifies what to do if the computation finishes. Its arguments are the amount of fuel left over and the values produced by the computation. \nexpire:\n    a procedure of one argument that specifies what to do if the fuel runs out before the computation finishes. Its argument is a new engine capable of continuing the computation from the point of interruption. When an engine is applied to its arguments, it sets up a timer to fire in ticks time units. (See set-timer on page 359.) If the engine computation completes before the timer expires, the system invokes complete, passing  it the number of ticks left over and the values produced by the computation. If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the interrupted computation and passes this engine to expire. complete and expire are invoked in the continuation of the engine invocation. An implementation of engines is given in Section 12.11. of The Scheme Programming Language, 4th Edition. Do not use the timer interrupt (see set-timer) and engines at the same time, since engines are implemented in terms of the timer. The following example creates an engine from a trivial computation, 3, and gives the engine 10 ticks. (define eng\n  (make-engine\n    (lambda () 3))) \n\n(eng 10\n     (lambda (ticks value) value)\n     (lambda (x) x)) => 3It is often useful to pass list as the complete procedure to an engine, causing an engine that completes to return a list whose first element is the ticks remaining and whose remaining elements are the values returned by the computation. (define eng\n  (make-engine\n    (lambda () 3))) \n\n(eng 10\n     list\n     (lambda (x) x)) => (9 3)In the example above, the value is 3 and there are 9 ticks left over, i.e., it takes one unit of fuel to evaluate 3. (The fuel amounts given here are for illustration only. Your mileage may vary.) Typically, the engine computation does not finish in one try. The following example displays the use of an engine to compute the 10th Fibonacci number in steps. (define fibonacci\n  (lambda (n)\n    (let fib ([i n])\n      (cond\n        [(= i 0) 0]\n        [(= i 1) 1]\n        [else (+ (fib (- i 1))\n                 (fib (- i 2)))])))) \n\n(define eng\n  (make-engine\n    (lambda ()\n      (fibonacci 10)))) \n\n(eng 50\n     list\n     (lambda (new-eng)\n       (set! eng new-eng)\n       \"expired\")) => \"expired\" \n\n(eng 50\n     list\n     (lambda (new-eng)\n       (set! eng new-eng)\n       \"expired\")) => \"expired\" \n\n(eng 50\n     list\n     (lambda (new-eng)\n       (set! eng new-eng)\n       \"expired\")) => \"expired\" \n\n(eng 50\n     list\n     (lambda (new-eng)\n       (set! eng new-eng)\n       \"expired\")) => (21 55)Each time the engine's fuel runs out, the expire procedure assigns eng to the new engine. The entire computation requires four blocks of 50 ticks to complete; of the last 50 it uses all but 21. Thus, the total amount of fuel used is 179 ticks. This leads to the following procedure, mileage, which \"times\" a computation using engines: (define mileage\n  (lambda (thunk)\n    (let loop ([eng (make-engine thunk)] [total-ticks 0])\n      (eng 50\n           (lambda (ticks . values)\n             (+ total-ticks (- 50 ticks)))\n           (lambda (new-eng)\n             (loop new-eng\n                   (+ total-ticks 50))))))) \n\n(mileage (lambda () (fibonacci 10))) => 179The choice of 50 for the number of ticks to use each time is arbitrary, of course. It might make more sense to pass a much larger number, say 10000, in order to reduce the number of times the computation is interrupted. The next procedure is similar to mileage, but it returns a list of engines, one for each tick it takes to complete the computation. Each of the engines in the list represents a \"snapshot\" of the computation, analogous to a single frame of a moving picture. snapshot might be useful for \"single stepping\" a computation.  (define snapshot\n  (lambda (thunk)\n    (let again ([eng (make-engine thunk)])\n      (cons eng\n            (eng 1 (lambda (t . v) '()) again)))))The recursion embedded in this procedure is rather strange. The complete procedure performs the base case, returning the empty list, and the expire procedure performs the recursion. The next procedure, round-robin, could be the basis for a simple time-sharing operating system. round-robin maintains a queue of processes (a list of engines), cycling through the queue in a round-robin fashion, allowing each process to run for a set amount of time. round-robin returns a list of the values returned by the engine computations in the order that the computations complete. Each computation is assumed to produce exactly one value. (define round-robin\n  (lambda (engs)\n    (if (null? engs)\n        '()\n        ((car engs)\n         1\n         (lambda (ticks value)\n           (cons value (round-robin (cdr engs))))\n         (lambda (eng)\n           (round-robin\n             (append (cdr engs) (list eng))))))))Since the amount of fuel supplied each time, one tick, is constant, the effect of round-robin is to return a list of the values sorted from the quickest to complete to the slowest to complete. Thus, when we call round-robin on a list of engines, each computing one of the Fibonacci numbers, the output list is sorted with the earlier Fibonacci numbers first, regardless of the order of the input list. (round-robin\n   (map (lambda (x)\n         (make-engine\n           (lambda ()\n             (fibonacci x))))\n       '(4 5 2 8 3 7 6 2))) => (1 1 2 3 5 8 13 21)More interesting things can happen if the amount of fuel varies each time through the loop. In this case, the computation would be nondeterministic, i.e., the results would vary from call to call. The following syntactic form, por (parallel-or), returns the first of its expressions to complete with a true value. por is implemented with the procedure first-true, which is similar to round-robin but quits when any of the engines completes with a true value. If all of the engines complete, but none with a true value, first-true (and hence por) returns #f. Also, although first-true passes a fixed amount of fuel to each engine, it chooses the next engine to run at random, and is thus nondeterministic. (define-syntax por\n  (syntax-rules ()\n    [(_ x ...)\n     (first-true\n       (list (make-engine (lambda () x)) ...))])) \n\n(define first-true\n  (let ([pick\n         (lambda (ls)\n           (list-ref ls (random (length ls))))])\n    (lambda (engs)\n      (if (null? engs)\n          #f\n          (let ([eng (pick engs)])\n            (eng 1\n                 (lambda (ticks value)\n                   (or value\n                       (first-true\n                         (remq eng engs))))\n                 (lambda (new-eng)\n                   (first-true\n                     (cons new-eng\n                           (remq eng engs))))))))))The list of engines is maintained with pick, which randomly chooses an element of the list, and remq, which removes the chosen engine from the list. Since por is nondeterministic, subsequent uses with the same expressions may not return the same values. (por 1 2 3) => 2\n(por 1 2 3) => 3\n(por 1 2 3) => 2\n(por 1 2 3) => 1Furthermore, even if one of the expressions is an infinite loop, por still finishes as long as one of the other expressions completes and returns a true value. (por (let loop () (loop)) 2) => 2With engine-return and engine-block, it is possible to terminate an engine explicitly. engine-return causes the engine to complete, as if the computation had finished. Its arguments are passed to the complete procedure along with the number of ticks remaining. It is essentially a nonlocal exit from the engine. Similarly, engine-block causes the engine to expire, as if the timer had run out. A new engine is made from the continuation of the call to engine-block and passed to the expire procedure. procedure: (engine-block) \nreturns: does not return \nlibraries: (chezscheme)  This causes a running engine to stop, create a new engine capable of continuing the computation, and pass the new engine to the original engine's third argument (the expire procedure). Any remaining fuel is forfeited. (define eng\n  (make-engine\n    (lambda ()\n      (engine-block)\n      \"completed\"))) \n\n(eng 100\n     (lambda (ticks value) value)\n     (lambda (x)\n        (set! eng x)\n        \"expired\")) => \"expired\" \n\n(eng 100\n     (lambda (ticks value) value)\n     (lambda (x)\n        (set! eng x)\n        \"expired\")) => \"completed\"procedure: (engine-return obj ...)\nreturns: does not return \nlibraries: (chezscheme)  This causes a running engine to stop and pass control to the engine's complete argument. The first argument passed to the complete procedure is the amount of fuel remaining, as usual, and the remaining arguments are the objects obj ...passed to engine-return.  (define eng\n  (make-engine\n    (lambda ()\n      (reverse (engine-return 'a 'b 'c))))) \n\n(eng 100\n     (lambda (ticks . values) values)\n     (lambda (new-eng) \"expired\")) => (a b c)Chez Scheme Version 10 User's Guide\nCopyright  2024 Cisco Systems, Inc.\nLicensed under the Apache License Version 2.0(full copyright notice.).Revised February 2024 for Chez Scheme Version 10.0.0\nabout this book\n\n") ("binding:s15" "thread parameter: internal-defines-as-letrec* \nlibraries: (chezscheme)  \n\n" "When this parameter is set to #t (the default), internal variable definitions are evaluated using letrec* semantics. It may be set to #f to revert to the letrec semantics for internal variable definitions, for backward compatibility. \n\n") ("binding:s16" "syntax: (define-values formals expr)\nlibraries: (chezscheme)  \n\n" "A define-values form is a definition and can appear anywhere other definitions can appear. It is like a define form but permits an arbitrary formals list (like lambda) on the left-hand side. It evaluates expr and binds the variables appearing in formals to the resulting values, in the same manner as the formal parameters of a procedure are bound to its arguments. \n\n" "" "(let ()\n  (define-values (x y) (values 1 2))\n  (list x y)) => (1 2)\n(let ()\n  (define-values (x y . z) (values 1 2 3 4))\n  (list x y z)) => (1 2 (3 4))\n\n" "A define-values form expands into a sequence of definitions, the first for a hidden temporary bound to a data structure holding the values returned by expr and the remainder binding each of the formals to the corresponding value or list of values, extracted from the data structure via a reference to the temporary. Because the temporary must be defined before the other variables are defined, this works for internal define-values forms only if internal-defines-as-letrec* is set to the default value #t.  \n\n") ("binding:s17" "syntax: (rec var expr)\nreturns: value of expr \nlibraries: (chezscheme)  \n\n" "The syntactic form rec creates a recursive object from expr by establishing a binding of var within expr to the value of expr. In essence, it is a special case of letrec for self-recursive objects.  \n\n" "This form is useful for creating recursive objects (especially procedures) that do not depend on external variables for the recursion, which are sometimes undesirable because the external bindings can change. For example, a recursive procedure defined at top level depends on the value of the top-level variable given as its name. If the value of this variable should change, the meaning of the procedure itself would change. If the procedure is defined instead with rec, its meaning is independent of the variable to which it is bound. \n\n" "" "(map (rec sum\n       (lambda (x)\n         (if (= x 0)\n             0\n             (+ x (sum (- x 1))))))\n     '(0 1 2 3 4 5)) => (0 1 3 6 10 15) \n\n(define cycle\n  (rec self\n    (list (lambda () self)))) \n\n(eq? ((car cycle)) cycle) => #t\n\n" "The definition below expands rec in terms of letrec.  \n\n" "" "(define-syntax rec\n  (syntax-rules ()\n    [(_ x e) (letrec ((x e)) x)]))\n\n") ("binding:s19" "syntax: (fluid-let ((var expr) ...) body1 body2 ...)\nreturns: the values of the body body1 body2 ...\nlibraries: (chezscheme)  \n\n" "The syntactic form fluid-let provides a way to temporarily assign values to a set of variables. The new values are in effect only during the evaluation of the body of the fluid-let expression. The scopes of the variables are not determined by fluid-let; as with set!, the variables must be bound at top level or by an enclosing lambda or other binding form. It is possible, therefore, to control the scope of a variable with lambda or let while establishing a temporary value with fluid-let.  \n\n" "Although it is similar in appearance to let, its operation is more like that of set!. Each var is assigned, as with set!, to the value of the corresponding expr within the body body1 body2 .... Should the body exit normally or by invoking a continuation made outside of the body (see call/cc), the values in effect before the bindings were changed are restored. Should control return back to the body by the invocation of a continuation created within the body, the bindings are changed once again to the values in effect when the body last exited. \n\n" "Fluid bindings are most useful for maintaining variables that must be shared by a group of procedures. Upon entry to the group of procedures, the shared variables are fluidly bound to a new set of initial values so that on exit the original values are restored automatically. In this way, the group of procedures itself can be reentrant; it may call itself directly or indirectly without affecting the values of its shared variables. \n\n" "Fluid bindings are similar to special bindings in Common Lisp [30], except that (1) there is a single namespace for both lexical and fluid bindings, and (2) the scope of a fluidly bound variable is not necessarily global. \n\n" "" "(let ([x 3])\n  (+ (fluid-let ([x 5])\n       x)\n     x)) => 8 \n\n(let ([x 'a])\n  (letrec ([f (lambda (y) (cons x y))])\n    (fluid-let ([x 'b])\n      (f 'c)))) => (b . c) \n\n(let ([x 'a])\n  (call/cc\n    (lambda (k)\n       (fluid-let ([x 'b])\n         (letrec ([f (lambda (y) (k '*))])\n           (f '*)))))\n  x) => a\n\n" "fluid-let may be defined in terms of dynamic-wind as follows.  \n\n" "" "(define-syntax fluid-let\n  (lambda (x)\n    (syntax-case x ()\n      [(_ () b1 b2 ...) #'(let () b1 b2 ...)]\n      [(_ ((x e) ...) b1 b2 ...)\n       (andmap identifier? #'(x ...))\n       (with-syntax ([(y ...) (generate-temporaries #'(x ...))])\n         #'(let ([y e] ...)\n             (let ([swap (lambda ()\n                           (let ([t x]) (set! x y) (set! y t))\n                           ...)])\n               (dynamic-wind swap (lambda () b1 b2 ...) swap))))])))\n\n") ("binding:s24" "procedure: (define-top-level-value symbol obj)\nprocedure: (define-top-level-value symbol obj env)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "define-top-level-value is used to establish a binding for the variable named by symbol to the value obj in the environment env. If env is not provided, it defaults to the value of interaction-environment, i.e., the top-level evaluation environment (Section 12.3). \n\n" "An exception is raised with condition type &assertion if env is not mutable. \n\n" "A call to define-top-level-value is similar to a top-level define form, except that a call to define-top-level-value need not occur at top-level and the variable for which the binding is to be established can be determined at run time, as can the environment. \n\n" "" "(begin\n   (define-top-level-value 'xyz \"hi\")\n  xyz) => \"hi\" \n\n(let ([var 'xyz])\n  (define-top-level-value var \"mom\")\n  (list var xyz)) => (xyz \"mom\")\n\n") ("binding:s26" "procedure: (set-top-level-value! symbol obj)\nprocedure: (set-top-level-value! symbol obj env)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "set-top-level-value! assigns  the variable named by symbol to the value obj in the environment env. If env is not provided, it defaults to the value of interaction-environment, i.e., the top-level evaluation environment (Section 12.3). \n\n" "An exception is raised with condition type &assertion if the identifier named by symbol is not defined as a variable in env or if the variable or environment is not mutable. \n\n" "set-top-level-value! is similar to set! when set! is used on top-level variables except that the variable to be assigned can be determined at run time, as can the environment. \n\n" "" "(let ([v (let ([cons list])\n           (set-top-level-value! 'cons +)\n           (cons 3 4))])\n  (list v (cons 3 4))) => ((3 4) 7)\n\n") ("binding:s29" "procedure: (top-level-value symbol)\nprocedure: (top-level-value symbol env)\nreturns: the top-level value of the variable named by symbol in env \nlibraries: (chezscheme)  \n\n" "If env is not provided, it defaults to the value of interaction-environment, i.e., the top-level evaluation environment (Section 12.3). \n\n" "An exception is raised with condition type &assertion if the identifier named by symbol is not defined as a variable in env. \n\n" "top-level-value is similar to a top-level variable reference except that the variable to be referenced can be determined at run time, as can the environment. \n\n" "" "(let ([cons +])\n  (list (cons 3 4)\n        ((top-level-value 'cons) 3 4))) => (7 (3 . 4)) \n\n(define e (copy-environment (scheme-environment)))\n(define-top-level-value 'pi 3.14 e)\n(top-level-value 'pi e) => 3.14\n(set-top-level-value! 'pi 3.1416 e)\n(top-level-value 'pi e) => 3.1416\n\n") ("binding:s30" "procedure: (top-level-bound? symbol)\nprocedure: (top-level-bound? symbol env)\nreturns: #t if symbol is defined as a variable in env, #f otherwise \nlibraries: (chezscheme)  \n\n" "If env is not provided, it defaults to the value of interaction-environment, i.e., the top-level evaluation environment (Section 12.3). \n\n" "This predicate is useful in an interpreter to check for the existence of a top-level binding before requesting the value with top-level-value.  \n\n" "" "(top-level-bound? 'xyz) => #f \n\n(begin\n  (define-top-level-value 'xyz 3)\n  (top-level-bound? 'xyz)) => #t \n\n(define e (copy-environment (interaction-environment)))\n(define-top-level-value 'pi 3.14 e)\n(top-level-bound? 'pi) => #f\n(top-level-bound? 'pi e) => #t\n\n") ("binding:s31" "procedure: (top-level-mutable? symbol)\nprocedure: (top-level-mutable? symbol env)\nreturns: #t if symbol is mutable in env, #f otherwise \nlibraries: (chezscheme)  \n\n" "If env is not provided, it defaults to the value of interaction-environment, i.e., the top-level evaluation environment (Section 12.3). \n\n" "This predicate is useful in an interpreter to check whether a variable can be assigned before assigning it with set-top-level-value!.  \n\n" "" "(define xyz 3)\n(top-level-mutable? 'xyz) => #t\n(set-top-level-value! 'xyz 4)\n(top-level-value 'xyz) => 4 \n\n(define e (copy-environment (interaction-environment) #f))\n(top-level-mutable? 'xyz e) => #f\n(set-top-level-value! 'xyz e) => exception: xyz is immutable\n\n") ("binding:s32" "procedure: (define-top-level-syntax symbol obj)\nprocedure: (define-top-level-syntax symbol obj env)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "define-top-level-syntax is used to establish a top-level binding for the identifier named by symbol to the value of obj in the environment env. The value must be a procedure, the result of a call to make-variable-transformer, or the result of a call to top-level-syntax. If env is not provided, it defaults to the value of interaction-environment, i.e., the top-level evaluation environment (Section 12.3). \n\n" "An exception is raised with condition type &assertion if env is not mutable. \n\n" "A call to define-top-level-syntax is similar to a top-level define-syntax form, except that a call to define-top-level-syntax need not occur at top-level and the identifier for which the binding is to be established can be determined at run time, as can the environment. \n\n" "" "(define-top-level-syntax 'let1\n  (syntax-rules ()\n    [(_ x e b1 b2 ...) (let ([x e]) b1 b2 ...)]))\n(let1 a 3 (+ a 1)) => 4\n\n" "define-top-level-syntax can also be used to attach to an identifier arbitrary compile-time bindings obtained  via top-level-syntax.  \n\n") ("binding:s34" "procedure: (top-level-syntax symbol)\nprocedure: (top-level-syntax symbol env)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "top-level-syntax is used to retrieve the transformer, compile-time value, or other compile-time binding to which the identifier named by symbol is bound in the environment env. If env is not provided, it defaults to the value of interaction-environment, i.e., the top-level evaluation environment (Section 12.3). All identifiers bound in an environment have compile-time bindings, including variables. \n\n" "An exception is raised with condition type &assertion if the identifier named by symbol is not defined as a keyword in env. \n\n" "" "(define-top-level-syntax 'also-let (top-level-syntax 'let))\n(also-let ([x 3] [y 4]) (+ x y)) => 7 \n\n(define foo 17)\n(define-top-level-syntax 'also-foo (top-level-syntax 'foo))\nalso-foo => 17\n(set! also-foo 23)\nalso-foo => 23\nfoo => 23\n\n" "The effect of the last example can be had more clearly with alias:  \n\n" "" "(define foo 17)\n(alias also-foo foo)\nalso-foo => 17\n(set! also-foo 23)\nalso-foo => 23\nfoo => 23\n\n") ("binding:s35" "procedure: (top-level-syntax? symbol)\nprocedure: (top-level-syntax? symbol env)\nreturns: #t if symbol is bound as a keyword in env, #f otherwise \nlibraries: (chezscheme)  \n\n" "If env is not provided, it defaults to the value of interaction-environment, i.e., the top-level evaluation environment (Section 12.3). \n\n" "All identifiers bound in an environment have compile-time bindings, including variables, so this predicate amounts to a bound check, but is more general than top-level-bound?, which returns true only for bound variables.  \n\n" "" "(define xyz 'hello)\n(top-level-syntax? 'cons) => #t\n(top-level-syntax? 'lambda) => #t\n(top-level-syntax? 'hello) => #t \n\n(top-level-syntax? 'cons (scheme-environment)) => #t\n(top-level-syntax? 'lambda (scheme-environment)) => #t\n(top-level-syntax? 'hello (scheme-environment)) => #f\n\n" "") ("foreign:s4" "procedure: (system command)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "command must be a string. \n\n" "The system procedure creates a subprocess to perform the operation specified by command. The subprocess may communicate with the user through the same console input and console output files used by the Scheme process. After creating the subprocess, system waits for the process to exit before returning. \n\n" "When the subprocess exits, system returns the exit code for the subprocess, unless (on Unix-based systems) a signal caused the subprocess to terminate, in which case system returns the negation of the signal that caused the termination, e.g., -1 for SIGHUP.  \n\n") ("foreign:s5" "procedure: (open-process-ports command)\nprocedure: (open-process-ports command b-mode)\nprocedure: (open-process-ports command b-mode ?transcoder)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "command must be a string. If ?transcoder is present and not #f, it must be a transcoder, and this procedure creates textual ports, each of whose transcoder is ?transcoder. Otherwise, this procedure returns binary ports. b-mode specifies the buffer mode used by each of the ports returned by this procedure and defaults to block. Buffer modes are described in Section 7.2 of The Scheme Programming Language, 4th Edition. \n\n" "open-process-ports creates a subprocess to perform the operation specified by command. Unlike system, process returns immediately after creating the subprocess, i.e., without waiting for the subprocess to terminate. It returns four values: \n\n" "\n* to-stdin is an output port to which Scheme can send output to the subprocess through the subprocess's standard input file. \n* from-stdout is an input port from which Scheme can read input from the subprocess through the subprocess's standard output file. \n* from-stderr is an input port from which Scheme can read input from the subprocess through the subprocess's standard error file. \n* process-id is an integer identifying the created subprocess provided by the host operating system. \n\n" "" "If the process exits or closes its standard output file descriptor, any procedure that reads input from from-stdout will return an end-of-file object. Similarly, if the process exits or closes its standard error file descriptor, any procedure that reads input from from-stderr will return an end-of-file object. \n\n" "The predicate input-port-ready? may be used to detect whether input has been sent by the subprocess to Scheme. \n\n" "It is sometimes necessary to force output to be sent immediately to the subprocess by invoking flush-output-port on to-stdin, since Chez Scheme buffers the output for efficiency. \n\n" "On UNIX systems, the process-id is the process identifier for the shell created to execute command. If command is used to invoke an executable file rather than a shell command, it may be useful to prepend command with the string \"exec \", which causes the shell to load and execute the named executable directly, without forking a new process---the shell equivalent of a tail call. This will reduce by one the number of subprocesses created and cause process-id to reflect the process identifier for the  executable once the shell has transferred control. \n\n") ("foreign:s7" "procedure: (process command)\nreturns: see explanation \nlibraries: (chezscheme)  \n\n" "command must be a string. \n\n" "process is similar to open-process-ports, but less general. It does not return a port from which the subprocess's standard error output can be read, and it always creates textual ports. It returns a list of three values rather than the four separate values of open-process-ports. The returned list contains, in order: from-stdout, to-stdin, and process-id, which correspond to the second, first, and fourth return values of open-process-ports.  \n\n" "") ("foreign:s10" "syntax: (foreign-procedure conv ... entry-exp (param-type ...) res-type)\nreturns: a procedure \nlibraries: (chezscheme)  \n\n" "entry-exp must evaluate to a string representing a valid foreign procedure entry point or an integer representing the address of the foreign procedure. The param-types and res-type must be symbols or structured forms as described below. When a foreign-procedure expression is evaluated, a Scheme procedure is created that will invoke the foreign procedure specified by entry-exp. When the procedure is called each argument is checked and converted according to the specified param-type before it is passed to the foreign procedure. The result of the foreign procedure call is converted as specified by the res-type. Multiple procedures may be created for the same foreign entry. \n\n" "Each conv adjusts the calling convention to be used. A #f is allowed as conv to indicate the default calling convention on the target machine (so the #f has no effect). Three other conventions are currently supported under Windows: __stdcall, __cdecl, and __com (32-bit only). Since __cdecl is the default, specifying __cdecl is equivalent to specifying #f or no convention. Additionally, conv can be __collect_safe to indicate that garbage collection is allowed concurrently with a call of the foreign procedure, or it can be __varargs or (__varargs_after n) to indicate that the procedure uses a convention that works with a variable number of arguments after the first n (which may differ from the convention used for the fixed-argument variant on some platforms and conventions). __varargs is a shorthand for (__varargs_after 1). \n\n" "Use __stdcall to access most Windows API procedures. Use __cdecl for Windows API varargs procedures, for C library procedures, and for most other procedures. Use __com to invoke COM interface methods; COM uses the __stdcall convention but additionally performs the indirections necessary to obtain the correct method from a COM instance. The address of the COM instance must be passed as the first argument, which should normally be declared as iptr. For the __com interface only, entry-exp must evaluate to the byte offset of the method in the COM vtable. For example, \n\n" "" "(foreign-procedure __com 12 (iptr double-float) integer-32)\n\n" "creates an interface to a COM method at offset 12 in the vtable encapsulated within the COM instance passed as the first argument, with the second argument being a double float and the return value being an integer. \n\n" "Use __collect_safe to declare that garbage collection is allowed concurrently with the foreign procedure. The __collect_safe declaration allows concurrent collection by deactivating the current thread (see fork-thread) when the foreign procedure is called, and the thread is activated again when the foreign procedure returns. The __collect_safe declaration is useful, for example, when calling a blocking I/O call to allow other Scheme threads to run normally. Refrain from passing collectable memory to a __collect_safe foreign procedure, or use lock-object to lock the memory in place; see also Sdeactivate_thread. The __collect_safe declaration has no effect on a non-threaded version of the system. \n\n" "For example, calling the C sleep function with the default convention will block other Scheme threads from performing a garbage collection, but adding the __collect_safe declaration avoids that problem: \n\n" "" "(define c-sleep\n  (foreign-procedure __collect_safe \"sleep\" (unsigned) unsigned))\n(c-sleep 10) ; sleeps for 10 seconds without blocking other threads\n\n" "If a foreign procedure that is called with __collect_safe can invoke callables, then each callable should also be declared with __collect_safe so that the callable reactivates the thread.  \n\n" "Complete type checking and conversion is performed on the parameters to a foreign procedure. The types scheme-object, string, wstring, u8*, u16*, u32*, utf-8, utf-16, utf-16le, utf-16be, utf-32, utf-32le, and utf-32be, must be used with caution, however, since they allow allocated Scheme objects to be used in places the Scheme memory management system cannot control. No problems will arise as long as such objects are not retained in foreign variables or data structures while Scheme code is running, and as long as they are not passed as arguments to a __collect_safe procedure, since garbage collection can occur only while Scheme code is running or when concurrent garbage collection is enabled. Other parameter types are converted to equivalent foreign representations and consequently they can be retained indefinitely in foreign variables and data structures. \n\n" "For argument types string, wstring, utf-8, utf-16, utf-16le, utf-16be, utf-32, utf-32le, and utf-32be, an argument is converted to a fresh object that is passed to the foreign procedure. Since the fresh object is not accessible for locking before the call, it can never be treated correctly for a __collect_safe foreign procedure, so those types are disallowed as argument types for a __collect_safe foreign procedure. For analogous reasons, those types are disallowed as the result of a __collect_safe foreign callable. \n\n" "Following are the valid parameter types: \n\n" "" "integer-8: Exact integers from -2^7 through 2^8 - 1 are valid. Integers in the range 2^7 through 2^8 - 1 are treated as two's complement representations of negative numbers, e.g., #xff is treated as -1. The argument is passed to C as an integer of the appropriate size (usually signed char). \n\n" "" "unsigned-8: Exact integers from -2^7 to 2^8 - 1 are valid. Integers in the range -2^7 through -1 are treated as the positive equivalents of their two's complement representation, e.g., -1 is treated as #xff. The argument is passed to C as an unsigned integer of the appropriate size (usually unsigned char). \n\n" "" "integer-16: Exact integers from -2^15 through 2^16 - 1 are valid. Integers in the range 2^15 through 2^16 - 1 are treated as two's complement representations of negative numbers, e.g., #xffff is treated as -1. The argument is passed to C as an integer of the appropriate size (usually short).  \n\n" "" "unsigned-16: Exact integers from -2^15 to 2^16 - 1 are valid. Integers in the range -2^15 through -1 are treated as the positive equivalents of their two's complement representation, e.g., -1 is treated as #xffff. The argument is passed to C as an unsigned integer of the appropriate size (usually unsigned short). \n\n" "" "integer-32: Exact integers from -2^31 through 2^32 - 1 are valid. Integers in the range 2^31 through 2^32 - 1 are treated as two's complement representations of negative numbers, e.g., #xffffffff is treated as -1. The argument is passed to C as an integer of the appropriate size (usually int).  \n\n" "" "unsigned-32: Exact integers from -2^31 to 2^32 - 1 are valid. Integers in the range -2^31 through -1 are treated as the positive equivalents of their two's complement representation, e.g., -1 is treated as #xffffffff. The argument is passed to C as an unsigned integer of the appropriate size (usually unsigned int). \n\n" "" "integer-64: Exact integers from -2^63 through 2^64 - 1 are valid. Integers in the range 2^63 through 2^64 - 1 are treated as two's complement representations of negative numbers. The argument is passed to C as an integer of the appropriate size (usually long long or, on many 64-bit platforms, long).  \n\n" "" "unsigned-64: Exact integers from -2^63 through 2^64 - 1 are valid. Integers in the range -2^63 through -1 are treated as the positive equivalents of their two's complement representation, The argument is passed to C as an integer of the appropriate size (usually unsigned long long or, on many 64-bit platforms, long).  \n\n" "" "double-float: Only Scheme flonums are valid---other Scheme numeric types are not automatically converted. The argument is passed to C as a double float. \n\n" "" "single-float: Only Scheme flonums are valid---other Scheme numeric types are not automatically converted. The argument is passed to C as a single float. Since Chez Scheme represents flonums in double-float format, the parameter is first converted into single-float format. \n\n" "" "short: This type is an alias for the appropriate fixed-size type above, depending on the size of a C short.  \n\n" "" "unsigned-short: This type is an alias for the appropriate fixed-size type above, depending on the size of a C unsigned short. \n\n" "" "int: This type is an alias for the appropriate fixed-size type above, depending on the size of a C int.  \n\n" "" "unsigned: This type is an alias for the appropriate fixed-size type above, depending on the size of a C unsigned.  \n\n" "" "unsigned-int: This type is an alias unsigned. fixed-size type above, depending on the size of a C unsigned.  \n\n" "" "long: This type is an alias for the appropriate fixed-size type above, depending on the size of a C long.  \n\n" "" "unsigned-long: This type is an alias for the appropriate fixed-size type above, depending on the size of a C unsigned long. \n\n" "" "long-long: This type is an alias for the appropriate fixed-size type above, depending on the size of the nonstandard C type long long. \n\n" "" "unsigned-long-long: This type is an alias for the appropriate fixed-size type above, depending on the size of the nonstandard C type unsigned long long. \n\n" "" "ptrdiff_t: This type is an alias for the appropriate fixed-size type above, depending on its definition in the host machine's stddef.h include file.  \n\n" "" "size_t: This type is an alias for the appropriate unsigned fixed-size type above, depending on its definition in the host machine's stddef.h include file.  \n\n" "" "ssize_t: This type is an alias for the appropriate signed fixed-size type above, depending on its definition in the host machine's stddef.h include file.  \n\n" "" "iptr: This type is an alias for the appropriate fixed-size type above, depending on the size of a C pointer. \n\n" "" "uptr: This type is an alias for the appropriate (unsigned) fixed-size type above, depending on the size of a C pointer. \n\n" "" "void*: This type is an alias for uptr.  \n\n" "" "fixnum: This type is equivalent to iptr, except only values in the fixnum range are valid. Transmission of fixnums is slightly faster than transmission of iptr values, but the fixnum range is smaller, so some iptr values do not have a fixnum representation.  \n\n" "" "boolean: Any Scheme object may be passed as a boolean. #f is converted to 0; all other objects are converted to 1. The argument is passed to C as an int.  \n\n" "" "char: Only Scheme characters with Unicode scalar values in the range 0 through 255 are valid char parameters. The character is converted to its Unicode scalar value, as with char->integer, and passed to C as an unsigned char. \n\n" "" "wchar_t: Only Scheme characters are valid wchar_t parameters. Under Windows and any other system where wchar_t holds only 16-bit values rather than full Unicode scalar values, only characters with 16-bit Unicode scalar values are valid. On systems where wchar_t is a full 32-bit value, any Scheme character is valid. The character is converted to its Unicode scalar value, as with char->integer, and passed to C as a wchar_t.  \n\n" "" "wchar: This type is an alias for wchar_t.  \n\n" "" "double: This type is an alias for double-float.  \n\n" "" "float: This type is an alias for single-float.  \n\n" "" "scheme-object: The argument is passed directly to the foreign procedure; no conversion or type checking is performed. This form of parameter passing should be used with discretion. Scheme objects should not be preserved in foreign variables or data structures since the memory management system may relocate them between foreign procedure calls. \n\n" "" "ptr: This type is an alias for scheme-object.  \n\n" "" "u8*: The argument must be a Scheme bytevector or #f. For #f, the null pointer (0) is passed to the foreign procedure. For a bytevector, a pointer to the first byte of the bytevector's data is passed. If the C routine to which the data is passed requires the input to be null-terminated, a null (0) byte must be included explicitly in the bytevector. The bytevector should not be retained in foreign variables or data structures, since the memory management system may relocate or discard them between foreign procedure calls, and use their storage for some other purpose. \n\n" "" "u16*: Arguments of this type are treated just like arguments of type u8*. If the C routine to which the data is passed requires the input to be null-terminated, two null (0) bytes must be included explicitly in the bytevector, aligned on a 16-bit boundary. \n\n" "" "u32*: Arguments of this type are treated just like arguments of type u8*. If the C routine to which the data is passed requires the input to be null-terminated, four null (0) bytes must be included explicitly in the bytevector, aligned on a 32-bit boundary. \n\n" "" "utf-8: The argument must be a Scheme string or #f. For #f, the null pointer (0) is passed to the foreign procedure. A string is converted into a bytevector, as if via string->utf8, with an added null byte, and the address of the first byte of the bytevector is passed to C. The bytevector should not be retained in foreign variables or data structures, since the memory management system may relocate or discard them between foreign procedure calls and use their storage for some other purpose. The utf-8 argument type is not allowed for a __collect_safe foreign procedure.  \n\n" "" "utf-16: Arguments of this type are treated like arguments of type utf-8, except they are converted as if via string->utf16 with endianness (native-endianness), and they are extended by two null bytes rather than one. \n\n" "" "utf-16le: Arguments of this type are treated like arguments of type utf-8, except they are converted as if via string->utf16 with endianness little, and they are extended by two null bytes rather than one. \n\n" "" "utf-16be: Arguments of this type are treated like arguments of type utf-8, except they are converted as if via string->utf16 with endianness big, and they are extended by two null bytes rather than one. \n\n" "" "utf-32: Arguments of this type are treated like arguments of type utf-8, except they are converted as if via string->utf32 with endianness (native-endianness), and they are extended by four null bytes rather than one. \n\n" "" "utf-32le: Arguments of this type are treated like arguments of type utf-8, except they are converted as if via string->utf32 with endianness little, and they are extended by four null bytes rather than one. \n\n" "" "utf-32be: Arguments of this type are treated like arguments of type utf-8, except they are converted as if via string->utf32 with endianness big, and they are extended by four null bytes rather than one. \n\n" "" "string: This type is an alias for utf-8.  \n\n" "" "wstring: This type is an alias for utf-16 or utf-32 as appropriate depending on the size of a C wchar_t. For example, wstring is equivalent to utf-16 under Windows running on Intel hardware. \n\n" "" "(* ftype-name): This type allows a pointer to a foreign type (ftype) to be passed. The argument must be an ftype pointer of the type identified by ftype-name, and the actual argument is the address encapsulated in the ftype pointer. See Section 4.5 for a description of foreign types. \n\n" "" "(& ftype-name): This type allows a foreign type (ftype) to be passed as a value, but represented on the Scheme side as a pointer to the foreign-type data. That is, a (& ftype-name) argument is represented on the Scheme side the same as a (* ftype-name) argument, but a (& ftype-name) argument is passed to the foreign procedure as the content at the foreign pointer's address instead of as the address. For example, if ftype-name identifies a struct type, then (& ftype-name) passes a struct argument instead of a struct-pointer argument. The ftype-name cannot refer to an array type. \n\n" "" "The result types are similar to the parameter types with the addition of a void type. In general, the type conversions are the inverse of the parameter type conversions. No error checking is performed on return, since the system cannot determine whether a foreign result is actually of the indicated type. Particular caution should be exercised with the result types scheme-object, double-float, double, single-float, float, and the types that result in the construction of bytevectors or strings, since invalid return values may lead to invalid memory references as well as incorrect computations. Following are the valid result types: \n\n" "" "void: The result of the foreign procedure call is ignored and an unspecified Scheme object is returned. void should be used when foreign procedures are called for effect only.  \n\n" "" "integer-8: The result is interpreted as a signed 8-bit integer and is converted to a Scheme exact integer. \n\n" "" "unsigned-8: The result is interpreted as an unsigned 8-bit integer and is converted to a Scheme nonnegative exact integer. \n\n" "" "integer-16: The result is interpreted as a signed 16-bit integer and is converted to a Scheme exact integer. \n\n" "" "unsigned-16: The result is interpreted as an unsigned 16-bit integer and is converted to a Scheme nonnegative exact integer. \n\n" "" "integer-32: The result is interpreted as a signed 32-bit integer and is converted to a Scheme exact integer. \n\n" "" "unsigned-32: The result is interpreted as an unsigned 32-bit integer and is converted to a Scheme nonnegative exact integer. \n\n" "" "integer-64: The result is interpreted as a signed 64-bit integer and is converted to a Scheme exact integer. \n\n" "" "unsigned-64: The result is interpreted as an unsigned 64-bit integer and is converted to a Scheme nonnegative exact integer. \n\n" "" "double-float: The result is interpreted as a double float and is translated into a Chez Scheme flonum. \n\n" "" "single-float: The result is interpreted as a single float and is translated into a Chez Scheme flonum. Since Chez Scheme represents flonums in double-float format, the result is first converted into double-float format. \n\n" "" "short: This type is an alias for the appropriate fixed-size type above, depending on the size of a C short.  \n\n" "" "unsigned-short: This type is an alias for the appropriate fixed-size type above, depending on the size of a C unsigned short. \n\n" "" "int: This type is an alias for the appropriate fixed-size type above, depending on the size of a C int.  \n\n" "" "unsigned: This type is an alias for the appropriate fixed-size type above, depending on the size of a C unsigned.  \n\n" "" "unsigned-int: This type is an alias unsigned. fixed-size type above, depending on the size of a C unsigned.  \n\n" "" "long: This type is an alias for the appropriate fixed-size type above, depending on the size of a C long.  \n\n" "" "unsigned-long: This type is an alias for the appropriate fixed-size type above, depending on the size of a C unsigned long. \n\n" "" "long-long: This type is an alias for the appropriate fixed-size type above, depending on the size of the nonstandard C type long long. \n\n" "" "unsigned-long-long: This type is an alias for the appropriate fixed-size type above, depending on the size of the nonstandard C type unsigned long long. \n\n" "" "ptrdiff_t: This type is an alias for the appropriate fixed-size type above, depending on its definition in the host machine's stddef.h include file.  \n\n" "" "size_t: This type is an alias for the appropriate unsigned fixed-size type above, depending on its definition in the host machine's stddef.h include file.  \n\n" "" "ssize_t: This type is an alias for the appropriate signed fixed-size type above, depending on its definition in the host machine's stddef.h include file.  \n\n" "" "iptr: This type is an alias for the appropriate fixed-size type above, depending on the size of a C pointer. \n\n" "" "uptr: This type is an alias for the appropriate (unsigned) fixed-size type above, depending on the size of a C pointer. \n\n" "" "void*: This type is an alias for uptr.  \n\n" "" "boolean: This type converts a C int return value into a Scheme boolean. 0 is converted to #f; all other values are converted to #t.  \n\n" "" "char: This type converts a C unsigned char return value into a Scheme character, as if via integer->char.  \n\n" "" "wchar_t: This type converts a C wchar_t return value into a Scheme character, as if via integer->char. The wchar_t value must be a valid Unicode scalar value.  \n\n" "" "wchar: This type is an alias for wchar_t.  \n\n" "" "double: This type is an alias for double-float.  \n\n" "" "float: This type is an alias for single-float.  \n\n" "" "scheme-object: The result is assumed to be a valid Scheme object, and no conversion is performed. This type is inherently dangerous, since an invalid Scheme object can corrupt the memory management system with unpredictable (but always unpleasant) results. Since Scheme objects are actually typed pointers, even integers cannot safely be returned as type scheme-object unless they were created by the Scheme system. \n\n" "" "ptr: This type is an alias for scheme-object.  \n\n" "" "u8*: The result is interpreted as a pointer to a null-terminated sequence of 8-bit unsigned integers (bytes). If the result is a null pointer, #f is returned. Otherwise, the sequence of bytes is stored in a freshly allocated bytevector of the appropriate length, and the bytevector is returned to Scheme. \n\n" "" "u16*: The result is interpreted as a pointer to a null-terminated sequence of 16-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of 16-bit integers is stored in a freshly allocated bytevector of the appropriate length, and the bytevector is returned to Scheme. The null terminator must be a properly aligned 16-bit word, i.e., two bytes of zero aligned on a 16-bit boundary. \n\n" "" "u32*: The result is interpreted as a pointer to a null-terminated sequence of 32-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of 16-bit integers is stored in a freshly allocated bytevector of the appropriate length, and the bytevector is returned to Scheme. The null terminator must be a properly aligned 32-bit word, i.e., four bytes of zero aligned on a 32-bit boundary. \n\n" "" "utf-8: The result is interpreted as a pointer to a null-terminated sequence of 8-bit unsigned character values. If the result is a null pointer, #f is returned. Otherwise, the sequence of bytes is converted into a Scheme string, as if via utf8->string, and the string is returned to Scheme.  \n\n" "" "utf-16: The result is interpreted as a pointer to a null-terminated sequence of 16-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of integers is converted into a Scheme string, as if via utf16->string with endianness (native-endianness), and the string is returned to Scheme. A byte-order mark in the sequence of integers is treated as an ordinary character value and does not affect the byte ordering. \n\n" "" "utf-16le: The result is interpreted as a pointer to a null-terminated sequence of 16-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of integers is converted into a Scheme string, as if via utf16->string with endianness little, and the string is returned to Scheme. A byte-order mark in the sequence of integers is treated as an ordinary character value and does not affect the byte ordering. \n\n" "" "utf-16be: The result is interpreted as a pointer to a null-terminated sequence of 16-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of integers is converted into a Scheme string, as if via utf16->string with endianness big, and the string is returned to Scheme. A byte-order mark in the sequence of integers is treated as an ordinary character value and does not affect the byte ordering. \n\n" "" "utf-32: The result is interpreted as a pointer to a null-terminated sequence of 32-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of integers is converted into a Scheme string, as if via utf32->string with endianness (native-endianness), and the string is returned to Scheme. A byte-order mark in the sequence of integers is treated as an ordinary character value and does not affect the byte ordering. \n\n" "" "utf-32le: The result is interpreted as a pointer to a null-terminated sequence of 32-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of integers is converted into a Scheme string, as if via utf32->string with endianness little, and the string is returned to Scheme. A byte-order mark in the sequence of integers is treated as an ordinary character value and does not affect the byte ordering. \n\n" "" "utf-32be: The result is interpreted as a pointer to a null-terminated sequence of 32-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of integers is converted into a Scheme string, as if via utf32->string with endianness big, and the string is returned to Scheme. A byte-order mark in the sequence of integers is treated as an ordinary character value and does not affect the byte ordering. \n\n" "" "string: This type is an alias for utf-8.  \n\n" "" "wstring: This type is an alias for utf-16 or utf-32 as appropriate depending on the size of a C wchar_t. For example, wstring is equivalent to utf-16 under Windows running on Intel hardware. \n\n" "" "(* ftype-name): The result is interpreted as the address of a foreign object whose structure is described by the ftype identified by ftype-name, and a freshly allocated ftype pointer encapsulating the address is returned. See Section 4.5 for a description of foreign types. \n\n" "" "(& ftype-name): The result is interpreted as a foreign object whose structure is described by the ftype identified by ftype-name, where the foreign procedure returns a ftype-name result, but the caller must provide an extra (* ftype-name) argument before all other arguments to receive the result. An unspecified Scheme object is returned when the foreign procedure is called, since the result is instead written into storage referenced by the extra argument.  The ftype-name cannot refer to an array type. \n\n" "" "Consider a C identity procedure: \n\n" "int id(x) int x; { return x; }\n\n" "After a file containing this procedure has been compiled and loaded (see Section 4.7) it can be accessed as follows: \n\n" "" "(foreign-procedure \"id\"\n  (int) int) => #<procedure>\n((foreign-procedure \"id\"\n   (int) int)\n 1) => 1\n(define int-id\n  (foreign-procedure \"id\"\n    (int) int))\n(int-id 1) => 1\n\n" "The \"id\" entry can also be interpreted as accepting and returning a boolean: \n\n" "" "(define bool-id\n  (foreign-procedure \"id\"\n    (boolean) boolean))\n(bool-id #f) => #f\n(bool-id #t) => #t\n(bool-id 1) => #t\n\n" "As the last example reveals, bool-id is actually a conversion procedure. When a Scheme object is passed as type boolean it is converted to 0 or 1, and when it is returned it is converted to #f or #t. As a result objects are converted to normalized boolean values. The \"id\" entry can be used to create other conversion procedures by varying the type specifications: \n\n" "" "(define int->bool\n  (foreign-procedure \"id\"\n    (int) boolean))\n(int->bool 0) => #f\n(int->bool 5) => #t\n(map (foreign-procedure \"id\"\n       (boolean) int)\n     '(#t #f)) => (1 0)\n(define void\n  (foreign-procedure \"id\"\n    (int) void))\n(void 10) => unspecified\n\n" "There are, of course, simpler and more efficient ways of accomplishing these conversions directly in Scheme. \n\n" "A foreign entry is resolved when a foreign-procedure expression is evaluated, rather than either when the code is loaded or each time the procedure is invoked. Thus, the following definition is always valid since the foreign-procedure expression is not immediately evaluated:  \n\n" "" "(define doit\n  (lambda ()\n    ((foreign-procedure \"doit\" () void))))\n\n" "doit should not be invoked, however, before an entry for \"doit\" has been provided. Similarly, an entry for \"doit\" must exist before the following code is evaluated: \n\n" "" "(define doit\n  (foreign-procedure \"doit\" () void))\n\n" "Although the second definition is more constraining on the load order of foreign files, it is more efficient since the entry resolution need be done only once. \n\n" "It is often useful to define a template to be used in the creation of several foreign procedures with similar argument types and return values. For example, the following code creates two foreign procedures from a single foreign procedure expression, by abstracting out the foreign procedure name: \n\n" "" "(define double->double\n  (lambda (proc-name)\n    (foreign-procedure proc-name\n      (double)\n      double))) \n\n(define log10 (double->double \"log10\"))\n(define gamma (double->double \"gamma\"))\n\n" "Both \"log10\" and \"gamma\" must be available as foreign entries (see Section 4.7) before the corresponding definitions. The use of foreign procedure templates can simplify the coding process and reduce the amount of code generated when a large number of foreign procedures are involved, e.g., when an entire library of foreign procedures is imported into Scheme. \n\n") ("foreign:s135" "syntax: (foreign-callable conv ... proc-exp (param-type ...) res-type)\nreturns: a code object \nlibraries: (chezscheme)  \n\n" "proc-exp must evaluate to a procedure, the Scheme procedure that is to be invoked by foreign code. The parameter and result types are as described for foreign-procedure in Section 4.2, except that the requirements and conversions are effectively reversed, e.g., the conversions described for foreign-procedure arguments are performed for foreign-callable return values. A (& ftype) argument to the callable refers to an address that is valid only during the dynamic extent of the callback invocation. A (& ftype) result type for a callable causes the Scheme procedure to receive an extra (& ftype) argument before all others; the Scheme procedure should write a result into the extra argument, and the direct result of the Scheme procedure is ignored. Type checking is performed for result values but not argument values, since the parameter values are provided by the foreign code and must be assumed to be correct. \n\n" "Each conv adjusts the calling convention to be used. foreign-callable supports the same conventions as foreign-procedure with the exception of __com. The __collect_safe convention for a callable activates a calling thread if the thread is not already activated, and the thread's activation state is reverted when the callable returns. If a calling thread is not currently registered with the Scheme system, then reverting the thread's activation state implies destroying the thread's registration (see Sdestroy_thread).  \n\n" "The value produced by foreign-callable is a Scheme code object, which contains some header information as well as code that performs the call to the encapsulated Scheme procedure. The code object may be converted into a foreign-callable address via foreign-callable-entry-point, which returns an integer representing the address of the entry point within the code object. (The C-callable library function Sforeign_callable_entry_point, described in Section 4.9, may be used to obtain the entry point as well.)   This is an implicit pointer into an immobile Scheme object, so it will not be relocated by the storage management system, but it may be reclaimed if the code object becomes unreachable on the Scheme side; lock the code object (using lock-object) or otherwise retain it if the entry point is, for example, registered as a callback and retained in the \"C\" side indefinitely. \n\n" "The following code creates a foreign-callable code object, locks the code object, and returns the entry point. \n\n" "" "(let ([x (foreign-callable\n           (lambda (x y) (pretty-print (cons x (* y 2))))\n           (string integer-32)\n           void)])\n  (lock-object x)\n  (foreign-callable-entry-point x))\n\n" "Unless the entry point is intended to be permanent, however, a pointer to the code object returned by foreign-callable should be retained (in which case locking is unnecessary, since the storage management system will not move the code object as long as it remains reachable on the Scheme side). \n\n" "Mixed use of foreign-callable and foreign-procedure may result in nesting of foreign and Scheme calls, and this results in some interesting considerations when continuations are involved, directly or indirectly (as via the default exception handler). See Section 4.4 for a discussion of the interaction between foreign calls and continuations. \n\n" "The following example demonstrates how the \"callback\" functions required by many windowing systems might be defined in Scheme with the use of foreign-callable. Assume that the following C code has been compiled and loaded (see Section 4.7). \n\n" "" "#include <stdio.h> \n\ntypedef void (*CB)(char); \n\nCB callbacks[256]; \n\nvoid cb_init(void) {\n   int i; \n\n   for (i = 0; i < 256; i += 1)\n       callbacks[i] = (CB)0;\n} \n\nvoid register_callback(char c, CB cb) {\n    callbacks[c] = cb;\n} \n\nvoid event_loop(void) {\n    CB f; char c; \n\n    for (;;) {\n        c = getchar();\n        if (c == EOF) break;\n        f = callbacks[c];\n        if (f != (CB)0) f(c);\n    }\n}\n\n" "Interfaces to these functions may be defined in Scheme as follows. \n\n" "" "(define cb-init\n  (foreign-procedure \"cb_init\" () void))\n(define register-callback\n  (foreign-procedure \"register_callback\" (char void*) void))\n(define event-loop\n  (foreign-procedure __collect_safe \"event_loop\" () void))\n\n" "A callback for selected characters can then be defined. \n\n" "" "(define callback\n  (lambda (p)\n    (let ([code (foreign-callable __collect_safe p (char) void)])\n      (lock-object code)\n      (foreign-callable-entry-point code))))\n(define ouch\n  (callback\n    (lambda (c)\n      (printf \"Ouch! Hit by '~c'~%\" c))))\n(define rats\n  (callback\n    (lambda (c)\n      (printf \"Rats! Received '~c'~%\" c)))) \n\n(cb-init)\n(register-callback #\\a ouch)\n(register-callback #\\c rats)\n(register-callback #\\e ouch)\n\n" "This sets up the following interaction. \n\n" "" "> (event-loop)\na\nOuch! Hit by 'a'\nb\nc\nRats! Received 'c'\nd\ne\nOuch! Hit by 'e'\n\n" "The __collect_safe declarations in this example ensure that other threads can continue working while event-loop blocks waiting for input. A more well-behaved version of the example would save each code object returned by foreign-callable and unlock it when it is no longer registered as a callback. \n\n") ("foreign:s138" "procedure: (foreign-callable-entry-point code)\nreturns: the address of the foreign-callable entry point in code \nlibraries: (chezscheme)  \n\n" "code should be a code object produced by foreign-callable.  \n\n") ("foreign:s139" "procedure: (foreign-callable-code-object address)\nreturns: the code object corresponding to the foreign-callable entry point address \nlibraries: (chezscheme)  \n\n" "address must be an exact integer and should be the address of the entry point of a code object produced by foreign-callable.  \n\n") ("foreign:s140" "procedure: (foreign-alloc n)\nreturns: the address of a freshly allocated block of foreign data n bytes long \nlibraries: (chezscheme)  \n\n" "n must be a positive fixnum. The returned value is an exact integer and is guaranteed to be properly aligned for any type of value according to the requirements of the underlying hardware. An exception is raised with condition type &assertion if the block of foreign data cannot be allocated. \n\n") ("foreign:s141" "procedure: (foreign-free address)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "This procedure frees the block of storage to which address points. address must be an exact integer in the range -2^w-1 through 2^w - 1, where w is the width in bits of a pointer, e.g., 64 for a 64-bit machine. It should be an address returned by an earlier call to foreign-alloc and not subsequently passed to foreign-free.  \n\n") ("foreign:s142" "procedure: (foreign-ref type address offset)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "foreign-ref extracts the value of type type from the memory location at offset bytes offset from address. \n\n" "type must be a symbol identifying the type of value to be extracted. The following types have machine-dependent sizes and correspond to the like-named C types: \n\n" "\n* short, \n* unsigned-short, \n* int, \n* unsigned, \n* unsigned-int, \n* long, \n* unsigned-long, \n* long-long, \n* unsigned-long-long, \n* ptrdiff_t, \n* size_t, \n* ssize_t, \n* char, \n* wchar_t, \n* float, \n* double, and \n* void*.  \n\n" "" "The types long-long and unsigned-long-long correspond to the C types long long  and unsigned long long. A value of type char is referenced as a single byte and converted (as if via integer->char) into a Scheme character. A value of type wchar_t is converted (as if via integer->char) into a Scheme character. The value must be a valid Unicode scalar value. \n\n" "wchar is an alias for wchar_t.  \n\n" "Several additional machine-dependent types are recognized: \n\n" "\n* iptr, \n* uptr, \n* fixnum, and \n* boolean.  \n\n" "" "uptr is equivalent to void*; both are treated as unsigned integers the size of a pointer. iptr is treated as a signed integer the size of a pointer. fixnum is treated as an iptr, but with a range limited to the fixnum range. boolean is treated as an int, with zero converted to the Scheme value #f and all other values converted to #t.  \n\n" "Finally, several fixed-sized types are also supported: \n\n" "\n* integer-8, \n* unsigned-8, \n* integer-16, \n* unsigned-16, \n* integer-32, \n* unsigned-32, \n* integer-64, \n* unsigned-64, \n* single-float, and \n* double-float.  \n\n" "" "address must be an exact integer in the range -2^w-1 through 2^w - 1, where w is the width in bits of a pointer, e.g., 64 for a 64-bit machine. offset must be an exact fixnum. The sum of address and offset should address a readable block of memory large enough to hold a value of type type, within a block of storage previously returned by foreign-alloc and not subsequently freed by foreign-free or within a block of storage obtained via some other mechanism, e.g., a foreign call. For multiple-byte values, the native endianness of the machine is assumed. \n\n") ("foreign:s143" "procedure: (foreign-set! type address offset value)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "foreign-set! stores a representation of value as type type offset bytes into the block of foreign data addressed by address. \n\n" "type must be a symbol identifying the type of value to be stored, one of those listed in the description of foreign-ref above. Scheme characters are converted to type char or wchar_t as if via char->integer. For type boolean, Scheme #f is converted to the int 0, and any other Scheme object is converted to 1.  \n\n" "address must be an exact integer in the range -2^w-1 through 2^w - 1, where w is the width in bits of a pointer, e.g., 64 for a 64-bit machine. offset must be an exact fixnum. The sum of address and offset should address a writable block of memory large enough to hold a value of type type, within a block of storage previously returned by foreign-alloc and not subsequently freed by foreign-free or within a block of storage obtained via some other mechanism, e.g., a foreign call. value must be an appropriate value for type, e.g., a floating-point number for the float types or an exact integer within the appropriate range for the integer types. For multiple-byte values, the native endianness of the machine is assumed. \n\n") ("foreign:s144" "procedure: (foreign-sizeof type)\nreturns: the size in bytes of type \nlibraries: (chezscheme)  \n\n" "type must be one of the symbols listed in the description of foreign-ref above.  \n\n") ("foreign:s145" "procedure: (foreign-alignof type)\nreturns: the alignment in bytes of type \nlibraries: (chezscheme)  \n\n" "type must be one of the symbols listed in the description of foreign-ref above.  \n\n") ("foreign:s146" "syntax: (define-ftype ftype-name ftype)\nsyntax: (define-ftype (ftype-name ftype) ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "A define-ftype form is a definition and can appear anywhere other definitions can appear. It establishes one or more foreign-type (ftype) bindings for the identifier ftype-name or identifiers ftype-name ...to the foreign type represented ftype or the foreign types represented by ftype .... Each ftype-name can be used to access foreign objects with the declared shape, and each can be used in the formation of other ftypes. \n\n" "An ftype must take one of the following forms: \n\n" "" "ftype-name\n(struct (field-name ftype) ...)\n(union (field-name ftype) ...)\n(array length ftype)\n(* ftype)\n(bits (field-name signedness bits) ...)\n(function conv ... (ftype ...) ftype)\n(packed ftype)\n(unpacked ftype)\n(endian endianness ftype)\n\n" "where length is an exact nonnegative integer, bits is an exact positive integer, field-name is an identifier, conv is #f or a string naming a valid convention as described on page 4.2, signedness is either signed or unsigned, and endianness is one of native, swapped, big, or little.  \n\n" "A restriction not reflected above is that  function ftypes cannot be used as the types of field names or array elements. That is, function ftypes are valid only at the top level of an ftype, e.g,: \n\n" "" "(define-ftype bvcopy_t (function (u8* u8* size_t) void))\n\n" "or as the immediate sub-type of a pointer (*) ftype, as in the following definitions, which are equivalent assuming the definition of bvcopy_t above.  \n\n" "" "(define-ftype A\n  (struct\n    [x int]\n    [f (* (function (u8* u8* size_t) void))])) \n\n(define-ftype A\n  (struct\n    [x int]\n    [f (* bvcopy_t)]))\n\n" "That is, a function cannot be embedded within a struct, union, or array, but a pointer to a function can be so embedded. \n\n" "The following definitions establish ftype bindings for F, A, and E.  \n\n" "" "(define-ftype F (function (wchar_t int) int)) \n\n(define-ftype A (array 10 wchar_t)) \n\n(define-ftype E\n  (struct\n    [a int]\n    [b double]\n    [c (array 25\n         (struct\n           [a short]\n           [_ long]\n           [b A]))]\n    [d (endian big\n         (union\n           [v1 unsigned-32]\n           [v2 (bits\n                 [hi unsigned 12]\n                 [lo unsigned 20])]))]\n    [e (* A)]\n    [f (* F)]))\n\n" "The ftype F describes the type of a foreign function that takes two arguments, a wide character and an integer, and returns an integer. The ftype A is simply an array of 10 wchar_t values, and its size will be 10 times the size of a single wchar_t. The ftype E is a structure with six fields: an integer a, a double-float b, an array c, a union d, a pointer e, and a pointer f. The array c is an array of 25 structs, each of which contains a short integer, a long integer, and a A array. The size of the c array will be 25 times the size of a single A array, plus 25 times the space needed to store each of the short and long integers. The union d is either a 32-bit unsigned integer or a 32-bit unsigned integer split into high (12 bits) and low (20 bits) components. The fields of a union overlap so that writing to one effectively overlaps the other. Thus, one can use the d union type to split apart an unsigned integer by writing the integer into v1 and reading the pieces from hi and lo. The pointer e points to an A array; it is not itself an array, and its size is just the size of a single pointer. Similarly, f points to a function, and its size is also that of a single pointer. \n\n" "An underscore ( _ ) can be used as the field name for one or more fields of a struct, union, or bits ftype. Such fields are included in the layout but are considered unnamed and cannot be accessed via the ftype operators described below. Thus, in the example above, the long field within the c array is inaccessible.  \n\n" "Non-underscore field names are handled symbolically, i.e., they are treated as symbols rather than identifiers. Each symbol must be unique (as a symbol) with respect to the other field names within a single struct, union, or bits ftype but need not be unique with respect to field names in other struct, union, or bits ftypes within the same ftype. \n\n" "Each ftype-name in an ftype must either (a) have been defined previously by define-ftype, (b) be defined by the current define-ftype, or (c) be a base-type name, i.e., one of the type names supported by foreign-ref and foreign-set!. In case (b), any reference within one ftype to the ftype-name of one of the earlier bindings is permissible, but a reference to the ftype-name of the current or a subsequent binding can appear only within a pointer field. \n\n" "For example, in: \n\n" "" "(define-ftype\n   [Qlist (struct\n           [head int]\n           [tail (* Qlist)])])\n\n" "the reference to Qlist is permissible since it appears within a pointer field. Similarly, in: \n\n" "" "(define-ftype\n   [Qfrob (struct\n           [head int]\n           [tail (* Qsnark)])]\n  [Qsnark (struct\n            [head int]\n            [xtra Qfrob]\n            [tail (* Qfrob)])])\n\n" "the mutually recursive references to Qsnark and Qfrob are permissible. In the following, however: \n\n" "" "(define-ftype\n   [Qfrob (struct\n           [head int]\n           [xtra Qfrob]\n           [tail (* Qsnark)])]\n  [Qsnark (struct\n            [head int]\n            [tail (* Qfrob)])])\n\n" "the reference to Qfrob within the ftype for Qfrob is invalid, and in: \n\n" "" "(define-ftype\n   [Qfrob (struct\n           [head int]\n           [xtra Qsnark]\n           [tail (* Qsnark)])]\n  [Qsnark (struct\n            [head int]\n            [tail (* Qfrob)])])\n\n" "the reference to Qsnark is similarly invalid.  \n\n" "By default, padding is inserted where appropriate to maintain proper alignment of multiple-byte scalar values in an attempt to mirror the target machine's C struct layout conventions, where such layouts are adequately documented. For packed ftypes (ftypes wrapped in a packed form with no closer enclosing unpacked form), this padding is not inserted. \n\n" "Multiple-byte scalar values are stored in memory using the target machine's native \"endianness,\" e.g., little on X86 and X86_64-based platforms and big on Sparc-based platforms. Big-endian or little-endian representation can be forced via the endian ftype with a big or little endianness specifier. The native specifier can be used to force a return back to native representation. The swapped specifier can be used to swap the representation relative to the default or enclosing representation. Each endian form affects only ftypes nested syntactically within it and not nested within a closer endian form. The endianness of an ftype is fixed once it is defined. \n\n" "The total size n of the fields within an ftype bits form must be 8, 16, 24, 32, 40, 48, 56, or 64.  Padding must be added manually, if needed. In little-endian representation, the first field occupies the low-order bits of the containing 8, 16, 24, 32, 40, 48, 56, or 64-bit word, with each subsequent field just above the preceding field. In big-endian representation, the first field occupies the high-order bits, with each subsequent field just below the preceding field. For a machine type where endianness is not known at compile time (such as the portable bytecode virtual machine), a bit field must be specified explicitly as big or little endian by an enclosing declaration. \n\n" "Two ftypes are considered equivalent only if defined by the same ftype binding. If two ftype definitions look identical but appear in two parts of the same program, the ftypes are not identical, and attempts to access one using the name of the other via the operators described below will fail with a run-time exception. \n\n" "Array bounds must always be constant. If an array's length cannot be known until run time, the array can be placed at the end of the ftype (and any containing ftype) and declared to have size zero, as illustrated by the example below. \n\n" "" "(define-ftype Vec\n  (struct\n    [len int]\n    [data (array 0 double)]))\n(define make-Vec\n  (lambda (n)\n    (let ([fptr (make-ftype-pointer Vec\n                  (foreign-alloc\n                    (+ (ftype-sizeof Vec)\n                       (* (ftype-sizeof double) n))))])\n      (ftype-set! Vec (len) fptr n)\n      fptr)))\n(define x (make-Vec 100))\n(/ (- (ftype-pointer-address (ftype-&ref Vec (data 10) x))\n      (ftype-pointer-address x)                            => 10\n      (ftype-sizeof int))\n   (ftype-sizeof double))\n(foreign-free (ftype-pointer-address x))\n\n" "No array bounds checks are performed for zero-length arrays. Only one variable-sized array can appear in a single foreign object, but one can work around this by treating the object as multiple individual objects. \n\n" "To avoid specifying the constant length of an array in more than one place, a macro that binds both a variable to the size as well as an ftype name to the ftype can be used. For example, \n\n" "" "(define-syntax define-array\n  (syntax-rules ()\n    [(_ array-name type size-name size)\n     (begin\n       (define size-name size)\n       (define-ftype array-name\n         (array size type)))]))\n(define-array A int A-size 100)\nA-size => 100\n(ftype-pointer-ftype\n  (make-ftype-pointer A\n    (foreign-alloc (ftype-sizeof A)))) => (array 100 int)\n\n" "This technique can be used to define arbitrary ftypes with arbitrary numbers of array fields. \n\n" "A struct ftype is an implicit subtype of the type of the first field of the struct. Similarly, an array ftype is an implicit subtype of the type of its elements. Thus, the struct or array extends the type of first field or element with additional fields or elements. This allows an instance of the struct or array to be treated as an instance of the type of its first field or element, without the need to use ftype-&ref to allocate a new pointer to the field or element.  \n\n") ("foreign:s151" "syntax: (ftype-sizeof ftype-name)\nreturns: the size in bytes of the ftype identified by ftype-name \nlibraries: (chezscheme)  \n\n" "The size includes the sizes of any ftypes directly embedded within the identified ftype but excludes those indirectly embedded via a pointer ftype. In the latter case, the size of the pointer is included. \n\n" "ftype-name must not be defined as a function ftype, since the size of a function cannot generally be determined. \n\n" "" "(define-ftype B\n  (struct\n    [b1 integer-32]\n    [b2 (array 10 integer-32)]))\n(ftype-sizeof B) => 44 \n\n(define-ftype C (* B))\n(ftype-sizeof C) => 4  ; on 32-bit machines\n(ftype-sizeof C) => 8  ; on 64-bit machines\n\n(define-ftype BB\n  (struct\n    [bb1 B]\n    [bb2 (* B)]))\n(- (ftype-sizeof BB) (ftype-sizeof void*)) => 44\n\n") ("foreign:s152" "syntax: (make-ftype-pointer ftype-name expr)\nreturns: an ftype-pointer object \nlibraries: (chezscheme)  \n\n" "If ftype-name does not describe a function ftype, expr must evaluate to an address represented as an exact integer in the appropriate range for the target machine. \n\n" "The ftype-pointer object returned by this procedure encapsulates the address and is tagged with a representation of the type identified by ftype-name to enable various forms of checking to be done by the access routines described below. \n\n" "" "(make-ftype-pointer E #x80000000) => #<ftype-pointer #x80000000>\n\n" "The address will not typically be a constant, as shown. Instead, it might instead come from a call to foreign-alloc, e.g.:  \n\n" "" "(make-ftype-pointer E (foreign-alloc (ftype-sizeof E)))\n\n" "It might also come from source outside of Scheme such as from a C routine called from Scheme via the foreign-procedure interface. \n\n" "If ftype-name describes a function ftype, expr must evaluate to an address, procedure, or string. If it evaluates to address, the call behaves like any other call to make-ftype-pointer with an address argument.  \n\n" "If it evaluates to a procedure, a foreign-callable code object is created for the procedure, as if via foreign-callable (Section 4.3). The address encapsulated in the resulting ftype-pointer object is the address of the procedure's entry point. \n\n" "" "(define fact\n  (lambda (n)\n    (if (= n 0) 1 (fact (- n 1)))))\n(define-ftype fact_t (function (int) int))\n(define fact-fptr (make-ftype-pointer fact_t fact))\n\n" "The resulting ftype pointer can be passed to a C routine, if the argument is declared to be a pointer to the same ftype, and the C routine can invoke the function pointer it receives as it would any other function pointer. Thus, make-ftype-pointer with a function ftype is an alternative to foreign-callable for creating C-callable wrappers for Scheme procedures. \n\n" "Since the foreign-callable code object can be reclaimed by the garbage collector if it is not otherwise referenced, the implicit foreign-callable's code object is automatically locked, as if via lock-object, before it is embedded in the ftype pointer. The code object should be unlocked after its last use from C, since locked objects take up space, cause fragmentation, and increase the cost of collection. Since the system cannot determine automatically when the last use from C occurs, the program must explicitly unlock the code object, which it can do by extracting the address from the ftype-pointer converting the address (back) into a code object, and passing it to unlock-object:  \n\n" "" "(unlock-object\n   (foreign-callable-code-object\n    (ftype-pointer-address fact-fptr)))\n\n" "Even after the code object is unlocked, the code object will remain immobile as long as a result of foreign-callable-code-object is retained. However, if only the ftype pointer object is retained, then the ftype pointer should not be used again unless it is relocked, e.g., via: \n\n" "" "(lock-object\n   (foreign-callable-code-object\n    (ftype-pointer-address fact-fptr)))\n\n" "A program can determine whether an object is already locked via the locked-object? predicate.  \n\n" "A function ftype can be also used with make-ftype-pointer to create an ftype-pointer to a C function, either by providing the address of the C function or its name, represented as a string. For example, with the following definition of bvcopy_t,  \n\n" "" "(define-ftype bvcopy_t (function (u8* u8* size_t) void))\n\n" "the two definitions of bvcopy-ftpr below are equivalent.  \n\n" "" "(define bvcopy-fptr (make-ftype-pointer bvcopy_t \"memcpy\"))\n(define bvcopy-fptr (make-ftype-pointer bvcopy_t (foreign-entry \"memcpy\")))\n\n" "A library that defines memcpy must be loaded first via load-shared-object, or memcpy must be registered via one of the methods described in Section  4.7. \n\n") ("foreign:s156" "syntax: (ftype-pointer? obj)\nreturns: #t if obj is an ftype pointer, otherwise #f \nsyntax: (ftype-pointer? ftype-name obj)\nreturns: #t if obj is an ftype-name, otherwise #f \nlibraries: (chezscheme)  \n\n" "" "(define-ftype Widget1 (struct [x int] [y int]))\n(define-ftype Widget2 (struct [w Widget1] [b boolean])) \n\n(define x1 (make-ftype-pointer Widget1 #x80000000))\n(define x2 (make-ftype-pointer Widget2 #x80000000)) \n\n(ftype-pointer? x1) => #t\n(ftype-pointer? x2) => #t \n\n(ftype-pointer? Widget1 x1) => #t\n(ftype-pointer? Widget1 x2) => #t \n\n(ftype-pointer? Widget2 x1) => #f\n(ftype-pointer? Widget2 x2) => #t \n\n(ftype-pointer? #x80000000) => #f\n(ftype-pointer? Widget1 #x80000000) => #f\n\n") ("foreign:s157" "procedure: (ftype-pointer-address fptr)\nreturns: the address encapsulated within fptr \nlibraries: (chezscheme)  \n\n" "fptr must be an ftype-pointer object. \n\n" "" "(define x (make-ftype-pointer E #x80000000))\n(ftype-pointer-address x) => #x80000000\n\n") ("foreign:s158" "syntax: (ftype-pointer=? fptr1 fptr2)\nreturns: #t if fptr1 and fptr2 have the same address, otherwise #f \nlibraries: (chezscheme)  \n\n" "fptr1 and fptr2 must be ftype-pointer objects. \n\n" "ftype-pointer=? might be defined as follows:  \n\n" "" "(define ftype-pointer=?\n  (lambda (fptr1 fptr2)\n    (= (ftype-pointer-address fptr1) (ftype-pointer-address fptr2))))\n\n" "It is, however, guaranteed not to allocate bignums for the addresses even if the addresses do not fit in fixnum range. \n\n") ("foreign:s159" "syntax: (ftype-pointer-null? fptr)\nreturns: #t if the address of fptr is 0, otherwise #f \nlibraries: (chezscheme)  \n\n" "fptr must be an ftype-pointer object. \n\n" "ftype-pointer-null? might be defined as follows:  \n\n" "" "(define ftype-pointer-null?\n  (lambda (fptr)\n    (= (ftype-pointer-address fptr) 0)))\n\n" "It is, however, guaranteed not to allocate a bignum for the address even if the address does not fit in fixnum range. \n\n") ("foreign:s160" "syntax: (ftype-&ref ftype-name (a ...) fptr-expr)\nsyntax: (ftype-&ref ftype-name (a ...) fptr-expr index)\nreturns: an ftype-pointer object \nlibraries: (chezscheme)  \n\n" "The ftype-pointer object returned by ftype-&ref encapsulates the address of some object embedded directly or indirectly within the foreign object pointed to by the value of fptr-expr, offset by index, if present. The value of fptr-expr must be an ftype pointer (fptr) of the ftype identified by ftype-name, and index must either be the identifier * or evaluate to a fixnum, possibly negative. The index is automatically scaled by the size of the ftype identified by ftype-name, which allows the fptr to be treated as an array of ftype-name objects and index as an index into that array. An index of * or 0 is the same as no index.  \n\n" "The sequence of accessors a ... must specify a valid path through the identified ftype. For struct, union, and bits ftypes, an accessor must be a valid field name for the ftype, while for pointer and array ftypes, an accessor must be the identifier * or evaluate to a fixnum index. For array ftypes, an index must be nonnegative, and for array ftypes with nonzero length, an index must also be less than the length. \n\n" "The examples below assume the definitions of B and BB shown above in the description of ftype-sizeof. Fixed addresses are shown for illustrative purposes and are assumed to be valid, although addresses are generally determined at run time via foreign-alloc or some other mechanism.  \n\n" "" "(define x (make-ftype-pointer B #x80000000))\n(ftype-&ref B () x) => #<ftype-pointer #x80000000>\n(let ([idx 1])             => #<ftype-pointer #x8000002C>\n  (ftype-&ref B () x idx))\n(let ([idx -1])            => #<ftype-pointer #x7FFFFFD4>\n  (ftype-&ref B () x idx))\n(ftype-&ref B (b1) x) => #<ftype-pointer #x80000000>\n(ftype-&ref B (b2) x) => #<ftype-pointer #x80000004>\n(ftype-&ref B (b2 5) x) => #<ftype-pointer #x80000018>\n(let ([n 5]) (ftype-&ref B (b2 n) x)) => #<ftype-pointer #x80000018> \n\n(ftype-&ref B (b1 b2) x) => syntax error\n(ftype-&ref B (b2 15) x) => run-time exception\n\n(define y (make-ftype-pointer BB #x90000000))\n(ftype-set! BB (bb2) y x)\n(ftype-&ref BB (bb1 b2) y) => #<ftype-pointer #x90000004>\n(ftype-&ref BB (bb2 * b2) y) => #<ftype-pointer #x80000004>\n(let ([idx 1])                    => #<ftype-pointer #x80000030>\n  (ftype-&ref BB (bb2 idx b2) y))\n\n" "With no accessors and no index, as in the first use of ftype-&ref above, the returned ftype-pointer might be eq? to the input. Otherwise, the ftype-pointer is freshly allocated.  \n\n") ("foreign:s161" "syntax: (ftype-set! ftype-name (a ...) fptr-expr val-expr)\nsyntax: (ftype-set! ftype-name (a ...) fptr-expr index val-expr)\nreturns: unspecified \nsyntax: (ftype-ref ftype-name (a ...) fptr-expr)\nsyntax: (ftype-ref ftype-name (a ...) fptr-expr index)\nreturns: an ftype-pointer object \nlibraries: (chezscheme)  \n\n" "These forms are used to store values into or retrieve values from the object pointed to by the value of fptr-expr, offset by index, if present. The value of fptr-expr must be an ftype pointer (fptr) of the ftype identified by ftype-name, and index must either be the identifier * or evaluate to a fixnum, possibly negative. The index is automatically scaled by the size of the ftype identified by ftype-name, which allows the fptr to be treated as an array of ftype-name objects and index as an index into that array. An index of * or 0 is the same as no index.  \n\n" "The sequence of accessors a ... must specify a valid path through the identified ftype. For struct, union, and bits ftypes, an accessor must be a valid field name for the ftype, while for pointer and array ftypes, an accessor must be the identifier * or evaluate to a fixnum index. For array ftypes, an index must be nonnegative, and for array ftypes with nonzero length, an index must also be less than the length. The field or element specified by the sequence of accessors must be a scalar field, e.g., a pointer field or a field containing a base type such as an int, char, or double.  \n\n" "For ftype-set!, val-expr must evaluate to a value of the appropriate type for the specified field, e.g., an ftype pointer of the appropriate type or an appropriate base-type value. \n\n" "For both signed and unsigned integer fields, values in the range -2^w-1 through 2^w - 1 are accepted, where w is the width in bits of the integer field. For signed integer fields, values in the range 2^w-1 through 2^w - 1 are treated as two's complement representations of the corresponding negative numbers. For unsigned integer fields, values in the range -2^w-1 through -1 are similarly treated as two's complement representations of the corresponding positive numbers. \n\n" "char and wchar_t (wchar) field values are converted from (ftype-set!) or to (ftype-ref) Scheme characters, as if with char->integer and integer->char. Characters stored by ftype-set! into a char field must have Unicode scalar values in the range 0 through 255. Under Windows and any other system where wchar_t (wchar) is a 16-bit value, characters stored by ftype-set! into a whar_t (wchar) field must have Unicode scalar values in the range 0 through 2^16 - 1. On systems where wchar_t is a 32-bit value, any character can be stored in a wchar_t (wchar) field. \n\n" "The examples below assume that B and C have been defined as shown in the description of ftype-sizeof above.  \n\n" "" "(define b\n  (make-ftype-pointer B\n    (foreign-alloc\n      (* (ftype-sizeof B) 3))))\n(define c\n  (make-ftype-pointer C\n    (foreign-alloc (ftype-sizeof C)))) \n\n(ftype-set! B (b1) b 5)\n(ftype-set! B (b1) b 1 6)\n(ftype-set! B (b1) c 5) => exception: ftype mismatch\n(ftype-set! B (b2) b 0) => exception: not a scalar\n(ftype-set! B (b2 -1) b 0) => exception: invalid index\n(ftype-set! B (b2 0) b 50)\n(ftype-set! B (b2 4) b 55)\n(ftype-set! B (b2 10) b 55) => exception: invalid index\n\n(ftype-set! C () c (ftype-&ref B () b 1)) \n\n(= (ftype-pointer-address (ftype-ref C () c))      => #t\n   (+ (ftype-pointer-address b) (ftype-sizeof B)))\n(= (ftype-pointer-address (ftype-&ref C (*) c)) => #t\n   (+ (ftype-pointer-address b) (ftype-sizeof B)))\n(= (ftype-pointer-address (ftype-&ref C (-1) c)) => #t\n   (ftype-pointer-address b)) \n\n(ftype-ref C (-1 b1) c) => 5\n(ftype-ref C (* b1) c) => 6\n(ftype-ref C (-1 b2 0) c) => 50\n(let ([i 4]) (ftype-ref C (-1 b2 i) c)) => 55 \n\n(ftype-set! C (-1 b2 0) c 75)\n(ftype-ref B (b2 0) b) => 75\n(foreign-free (ftype-pointer-address c))\n(foreign-free (ftype-pointer-address b))\n\n" "A function ftype pointer can be converted into a Scheme-callable procedure via ftype-ref. Assuming that a library defining memcpy has been loaded via load-shared-object or memcpy has been registered via one of the methods described in Section  4.7, A Scheme-callable memcpy can be defined as follows.  \n\n" "" "(define-ftype bvcopy_t (function (u8* u8* size_t) void))\n(define bvcopy-fptr (make-ftype-pointer bvcopy_t \"memcpy\"))\n(define bvcopy (ftype-ref bvcopy_t () bvcopy-fptr)) \n\n(define bv1 (make-bytevector 8 0))\n(define bv2 (make-bytevector 8 57))\nbv1 => #vu8(0 0 0 0 0 0 0 0)\nbv2 => #vu8(57 57 57 57 57 57 57 57)\n(bvcopy bv1 bv2 5)\nbv1 => #vu8(57 57 57 57 57 0 0 0)\n\n" "An ftype pointer can also be obtained as a return value from a C function declared to return a pointer to a function ftype. \n\n" "Thus, ftype-ref with a function ftype is an alternative to foreign-procedure (Section 4.2) for creating Scheme-callable wrappers for C functions. \n\n") ("foreign:s164" "procedure: (ftype-pointer-ftype fptr)\nreturns: fptr's ftype, represented as an s-expression \nlibraries: (chezscheme)  \n\n" "fptr must be an ftype-pointer object. \n\n" "" "(define-ftype Q0\n  (struct\n    [x int]\n    [y int]))\n(define-ftype Q1\n  (struct\n    [x double]\n    [y char]\n    [z (endian big\n         (bits\n           [_ unsigned 3]\n           [a unsigned 9]\n           [b unsigned 4]))]\n    [w (* Q0)]))\n(define q1 (make-ftype-pointer Q1 0))\n(ftype-pointer-ftype q1) => (struct \n                              [x double]\n                              [y char]\n                              [z (endian big\n                                   (bits\n                                     [_ unsigned 3]\n                                     [a unsigned 9]\n                                     [b unsigned 4]))]\n                              [w (* Q0)])\n\n") ("foreign:s165" "procedure: (ftype-pointer->sexpr fptr)\nreturns: an s-expression representation of the object to which fptr points \nlibraries: (chezscheme)  \n\n" "fptr must be an ftype-pointer object. \n\n" "For each unnamed field, i.e., each whose field name is an underscore, the corresponding field value in the resulting s-expression is also an underscore. Similarly, if a field is inaccessible, i.e., if its address is invalid, the value is the symbol invalid.  \n\n" "" "(define-ftype Frob\n  (struct\n    [p boolean]\n    [q char]))\n(define-ftype Snurk\n  (struct\n    [a Frob]\n    [b (* Frob)]\n    [c (* Frob)]\n    [d (bits\n         [_ unsigned 15]\n         [dx signed 17])]\n    [e (array 5 double)]))\n(define x\n  (make-ftype-pointer Snurk\n    (foreign-alloc (ftype-sizeof Snurk))))\n(ftype-set! Snurk (b) x\n  (make-ftype-pointer Frob\n    (foreign-alloc (ftype-sizeof Frob))))\n(ftype-set! Snurk (c) x\n  (make-ftype-pointer Frob 0))\n(ftype-set! Snurk (a p) x #t)\n(ftype-set! Snurk (a q) x #\\A)\n(ftype-set! Snurk (b * p) x #f)\n(ftype-set! Snurk (b * q) x #\\B)\n(ftype-set! Snurk (d dx) x -2500)\n(do ([i 0 (fx+ i 1)])\n    ((fx= i 5))\n  (ftype-set! Snurk (e i) x (+ (* i 5.0) 3.0)))\n(ftype-pointer->sexpr x) => (struct\n                              [a (struct [p #t] [q #\\A])]\n                              [b (* (struct [p #f] [q #\\B]))]\n                              [c (* (struct [p invalid] [q invalid]))]\n                              [d (bits [_ _] [dx -2500])]\n                              [e (array 5 3.0 8.0 13.0 18.0 23.0)])\n\n") ("foreign:s166" "procedure: (make-reference-bytevector n)\nreturns: a reference bytevector of length n \nlibraries: (chezscheme)  \n\n" "Like make-bytevector, but the result is a reference bytevector that is initialized with all bytes being 0 (i.e., all referenced objects being #f and any trailing bytes after an even multiple of the current machine's pointer size being 0). \n\n") ("foreign:s167" "procedure: (make-immobile-reference-bytevector n)\nreturns: a reference bytevector of length n \nlibraries: (chezscheme)  \n\n" "Like make-reference-bytevector, but creates a reference bytevector that will not be relocated in memory by the storage management system until it is reclaimed. \n\n") ("foreign:s168" "procedure: (reference-bytevector? obj)\nreturns: #t if obj is an reference bytevector, #f otherwise \nlibraries: (chezscheme)  \n\n" "Note that every reference bytevector is also a bytevector that is recognized by bytevector?, and equal? considers two bytevectors independent of whether either is a reference bytevector. \n\n") ("foreign:s169" "procedure: (bytevector-reference-set! bytevector n obj)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "bytevector must be a reference bytevector, and n must be a nonnegative fixnum.  The sum of n and the size of a pointer (i.e., (ftype-sizeof uptr)) must not be greater than the length of bytevector. \n\n" "Installs a reference to obj at byte offset n within bytevector. In the case that obj is a bytevector or flvector, the reference is represented as the starting address of the bytevector or flvector's content.  If obj is #f then the reference is represented as 0.  The reference occupies (ftype-sizeof uptr) bytes. \n\n") ("foreign:s170" "procedure: (bytevector-reference-ref bytevector n)\nreturns: a Scheme object \nlibraries: (chezscheme)  \n\n" "bytevector must be a reference bytevector, and n must be a nonnegative fixnum.  The sum of n and the size of a pointer (i.e., (ftype-sizeof uptr)) must not be greater than the length of bytevector. \n\n" "Returns the object that is referenced in bytevector at byte offset n.  If the (ftype-sizeof uptr) bytes at offset n do not represent a reference to a valid Scheme object then behavior is undefined. \n\n") ("foreign:s171" "procedure: (bytevector-reference*-ref bytevector n)\nreturns: an allocated Scheme object or a positive exact integer \nlibraries: (chezscheme)  \n\n" "Like bytevector-reference-ref, but if bytevector at byte offset n holds a non-0 foreign address, bytevector-reference*-ref returns an integer. The representation of a reference to a Scheme object can overlap with the representation of a foreign address; see reference*-address->object.  \n\n") ("foreign:s172" "procedure: (object->reference-address obj)\nreturns: a nonnegative exact integer \nlibraries: (chezscheme)  \n\n" "The result is 0 if obj is #f, and it is the address of objs's content in the case that obj is a bytevector or flvector---at least, at the point where object->reference-address was called. Unless obj is a locked or immobile bytevector or flvector, its address can change at any time that a garbage collection is possible (i.e., when interrupts are enabled). For other kinds of objs, the representation of the returned address is not specified, except that it is a nonnegative exact integer that is distinct from any other object's representation. \n\n") ("foreign:s173" "procedure: (reference-address->object addr)\nreturns: a Scheme object \nlibraries: (chezscheme)  \n\n" "addr must be a nonnegative exact integer that is a valid reference to a Scheme object, and the result is the referenced Scheme object.  If addr is not a valid reference to a Scheme object then behavior is undefined. \n\n") ("foreign:s174" "procedure: (reference*-address->object addr)\nreturns: a Scheme object, possibly addr itself \nlibraries: (chezscheme)  \n\n" "addr must be a nonnegative exact integer that is a valid reference to a Scheme object, or it must be an foreign address that is outside the range that belongs to the storage manager. \n\n" "When addr is 0, the result is #f. Otherwise, if addr is a foreign address, then addr itself is returned. \n\n" "The representation of a reference to a bytevector or flvector is guaranteed to be distinct from any foreign address, but other values may have a representation that overlaps with foreign addresses, in which case addr is returned (i.e., the foreign-address interpretation takes precedence). Thus, reference*-address->object and bytevector-reference*-ref are mainly useful for an address that is known to be either a bytevector reference, an flvector reference, or a foreign address. \n\n" "If addr is not a foreign address and does not reference a valid Scheme object then behavior is undefined. \n\n") ("foreign:s175" "procedure: (foreign-entry? entry-name)\nreturns: #t if entry-name is an existing foreign procedure entry point, #f otherwise \nlibraries: (chezscheme)  \n\n" "entry-name must be a string. foreign-entry? may be used to determine if an entry exists for a foreign procedure. \n\n" "The following examples assume that  a library that defines strlen has been loaded via load-shared-object or that strlen has been registered via one of the other methods described in this section. \n\n" "" "(foreign-entry? \"strlen\") => #t\n((foreign-procedure \"strlen\"\n    (string) size_t)\n \"hey!\") => 4\n\n") ("foreign:s176" "procedure: (foreign-entry entry-name)\nreturns: the address of entry-name as an exact integer \nlibraries: (chezscheme)  \n\n" "entry-name must be a string naming an existing foreign entry point. \n\n" "The following examples assume that  a library that defines strlen has been loaded via load-shared-object or that strlen has been registered via one of the other methods described in this section. \n\n" "" "(let ([addr (foreign-entry \"strlen\")])\n  (and (integer? addr) (exact? addr))) => #t \n\n(define-ftype strlen-type (function (string) size_t))\n(define strlen\n  (ftype-ref strlen-type ()\n    (make-ftype-pointer strlen-type \"strlen\")))\n(strlen \"hey!\") => 4\n\n") ("foreign:s177" "procedure: (foreign-address-name address)\nreturns: the entry name corresponding to address, if known, otherwise #f \nlibraries: (chezscheme)  \n\n" "The following examples assume that  a library that defines strlen has been loaded via load-shared-object or that strlen has been registered via one of the other methods described in this section. \n\n" "" "(foreign-address-name (foreign-entry \"strlen\")) => \"strlen\"\n\n") ("foreign:s178" "procedure: (load-shared-object path)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "path must be a string or #f. If path is a string, load-shared-object loads the shared object named by path. Shared objects may be system libraries or files created from ordinary C programs. All external symbols in the shared object, along with external symbols available in other shared objects linked with the shared object, are made available as foreign entries.  \n\n" "This procedure is supported for most platforms upon which Chez Schemeruns. \n\n" "If path does not begin with a \".\" or \"/\", the shared object is searched for in a default set of directories determined by the system. \n\n" "If path is #f, external symbols in the executable itself (if any), as well as those found in dependent shared objects, are also made available as foreign entries. Usually, executables do not export symbols, but can be instructed to do so with proper compilation flags. One may thus create an executable based on Chez Scheme, and have Scheme code access exported symbols from it and also from any shared object dynamically linked to it. \n\n" "Because Chez Scheme is usually dynamically linked to the operating system's C library, all built-in C library functions are also accessible after evaluation of (load-shared-object #f). This provides a simple way to gain access to standard C functions (such as memcpy or getenv), which may be very convenient for Scheme programs intended to be portable across different systems. If Chez Scheme is statically linked however, the standard C functions may only be accessible in this manner if they are present in the executable and exported, otherwise the shared object containing the C library must be explicitly named; see below for examples for some platforms. \n\n" "On most Unix systems, load-shared-object is based on the system routine dlopen. Under Windows, load-shared-object is based on LoadLibrary. Refer to the documentation for these routines and for the C compiler and loader for precise rules for locating and building shared objects. \n\n" "load-shared-object can be used to access built-in C library functions, such as getenv. The name of the shared object varies from one system to another. \n\n" "On Linux systems: \n\n" "" "(load-shared-object \"libc.so.6\")\n\n" "On Solaris, OpenSolaris, FreeBSD, NetBSD, and OpenBSD systems: \n\n" "" "(load-shared-object \"libc.so\")\n\n" "On MacOS X systems: \n\n" "" "(load-shared-object \"libc.dylib\")\n\n" "On Windows: \n\n" "" "(load-shared-object \"msvcrt.dll\")\n\n" "Once the C library has been loaded, getenv should be available as a foreign entry. \n\n" "" "(foreign-entry? \"getenv\") => #t\n\n" "An equivalent Scheme procedure may be defined and invoked as follows. \n\n" "" "(define getenv\n  (foreign-procedure \"getenv\"\n    (string)\n    string))\n(getenv \"HOME\") => \"/home/elmer/fudd\"\n(getenv \"home\") => #f\n\n" "load-shared-object can be used to access user-created libraries as well. Suppose the C file \"even.c\" contains \n\n" "" "int even(n) int n; { return n == 0 || odd(n - 1); }\n\n" "and the C file \"odd.c\" contains  \n\n" "" "int odd(n) int n; { return n != 0 && even(n - 1); }\n\n" "The files must be compiled and linked into a shared object before they can be loaded. How this is done depends upon the host system. On Linux, FreeBSD, OpenBSD, and OpenSolaris systems: \n\n" "" "(system \"cc -fPIC -shared -o evenodd.so even.c odd.c\")\n\n" "Depending on the host configuration, the -m32 or -m64 option might be needed to specify 32-bit or 64-bit compilation as appropriate. \n\n" "On MacOS X (Intel or PowerPC) systems: \n\n" "" "(system \"cc -dynamiclib -o evenodd.so even.c odd.c\")\n\n" "Depending on the host configuration, the -m32 or -m64 option might be needed to specify 32-bit or 64-bit compilation as appropriate. \n\n" "On 32-bit Sparc Solaris: \n\n" "" "(system \"cc -KPIC -G -o evenodd.so even.c odd.c\")\n\n" "On 64-bit Sparc Solaris: \n\n" "" "(system \"cc -xarch=v9 -KPIC -G -o evenodd.so even.c odd.c\")\n\n" "On Windows, we build a DLL (dynamic link library) file. In order to make the compiler generate the appropriate entry points, we alter even.c to read  \n\n" "" "#ifdef WIN32\n#define EXPORT extern __declspec (dllexport)\n#else\n#define EXPORT extern\n#endif \n\nEXPORT int even(n) int n; { return n == 0 || odd(n - 1); }\n\n" "and odd.c to read  \n\n" "" "#ifdef WIN32\n#define EXPORT extern __declspec (dllexport)\n#else\n#define EXPORT extern\n#endif \n\nEXPORT int odd(n) int n; { return n != 0 && even(n - 1); }\n\n" "We can then build the DLL as follows, giving it the extension \".so\" rather than \".dll\" for consistency with the other systems. \n\n" "" "(system \"cl -c -DWIN32 even.c\")\n(system \"cl -c -DWIN32 odd.c\")\n(system \"link -dll -out:evenodd.so even.obj odd.obj\")\n\n" "" "The resulting \".so\" file can be loaded into Scheme and even and odd made available as foreign procedures:  \n\n" "" "(load-shared-object \"./evenodd.so\")\n(let ([odd (foreign-procedure \"odd\"\n             (integer-32) boolean)]\n      [even (foreign-procedure \"even\"\n              (integer-32) boolean)])\n  (list (even 100) (odd 100))) => (#t #f)\n\n" "The filename is given as \"./evenodd.so\" rather than simply \"evenodd.so\", because some systems look for shared libraries in a standard set of system directories that does not include the current directory. \n\n") ("foreign:s180" "procedure: (remove-foreign-entry entry-name)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "remove-foreign-entry blocks further access to the entry specified by the string entry-name. An exception is raised with condition type &assertion if the entry does not exist. Since access previously established by foreign-procedure is not affected, remove-foreign-entry may be used to clean up after the desired interface to a group of foreign procedures has been established. \n\n" "remove-foreign-entry can be used to remove entries registered using Sforeign_symbol and Sregister_symbol but not entries created as a result of a call to load-shared-object.  \n\n") ("debug:s0" "syntax: (trace-lambda name formals body1 body2 ...)\nreturns: a traced procedure \nlibraries: (chezscheme)  \n\n" "A trace-lambda expression is equivalent to a lambda expression with the same formals and body except that trace information is printed to the trace output port whenever the procedure is invoked, using name to identify the procedure. The trace information shows the value of the arguments passed to the procedure and the values returned by the procedure, with indentation to show the nesting of calls. \n\n" "The traced procedure half defined below returns the integer quotient of its argument and 2. \n\n" "" "(define half\n  (trace-lambda half (x)\n    (cond\n      [(zero? x) 0]\n      [(odd? x) (half (- x 1))]\n      [(even? x) (+ (half (- x 1)) 1)])))\n\n" "A trace of the call (half 5), which returns 2, is shown below. \n\n" "" "|(half 5)\n|(half 4)\n| (half 3)\n| (half 2)\n| |(half 1)\n| |(half 0)\n| |0\n| 1\n|2\n\n" "This example highlights the proper treatment of tail and nontail calls by the trace package. Since half tail calls itself when its argument is odd, the call (half 4) appears at the same level of indentation as the call (half 5). Furthermore, since the return values of (half 5) and (half 4) are necessarily the same, only one return value is shown for both calls. \n\n") ("debug:s3" "syntax: (trace-case-lambda name clause ...)\nreturns: a traced procedure \nlibraries: (chezscheme)  \n\n" "A trace-case-lambda expression is equivalent to a case-lambda expression with the same clauses except that trace information is printed to the trace output port whenever the procedure is invoked, using name to identify the procedure. The trace information shows the value of the arguments passed to the procedure and the values returned by the procedure, with indentation to show the nesting of calls. \n\n") ("debug:s5" "syntax: (trace-let name ((var expr) ...) body1 body2 ...)\nreturns: the values of the body body1 body2 ...\nlibraries: (chezscheme)  \n\n" "A trace-let expression is equivalent to a named let expression with the same name, bindings, and body except that trace information is printed to the trace output port on entry or reentry (via invocation of the procedure bound to name) into the trace-let expression.  \n\n" "A trace-let expression of the form  \n\n" "" "(trace-let name ([var expr] ...)\n  body1 body2 ...)\n\n" "can be rewritten in terms of trace-lambda as follows:  \n\n" "" "((letrec ([name\n           (trace-lambda name (var ...)\n             body1 body2 ...)])\n   name)\n expr ...)\n\n" "trace-let may be used to trace ordinary let expressions as well as let expressions as long as the name inserted along with the trace-let keyword in place of let does not appear free within the body of the let expression. It is also sometimes useful to insert a trace-let expression into a program simply to display the value of an arbitrary expression at the current trace indentation. For example, a call to the following variant of half  \n\n" "" "(define half\n  (trace-lambda half (x)\n    (cond\n      [(zero? x) 0]\n      [(odd? x) (half (trace-let decr-value () (- x 1)))]\n      [(even? x) (+ (half (- x 1)) 1)])))\n\n" "with argument 5 results in the trace: \n\n" "" "|(half 5)\n| (decr-value)\n| 4\n|(half 4)\n| (half 3)\n| |(decr-value)\n| |2\n| (half 2)\n| |(half 1)\n| | (decr-value)\n| | 0\n| |(half 0)\n| 1\n|2\n\n") ("debug:s7" "syntax: (trace-do ((var init update) ...) (test result ...) expr ...)\nreturns: the values of the last result expression \nlibraries: (chezscheme)  \n\n" "A trace-do expression is equivalent to a do expression with the same subforms, except that trace information is printed to the trace output port, showing the values of var ... and each iteration and the final value of the loop on termination. For example, the expression \n\n" "" "(trace-do ([old '(a b c) (cdr old)]\n           [new '() (cons (car old) new)])\n  ((null? old) new))\n\n" "produces the trace \n\n" "" "|(do (a b c) ())\n|(do (b c) (a))\n|(do (c) (b a))\n|(do () (c b a))\n|(c b a)\n\n" "and returns (c b a). \n\n") ("debug:s9" "syntax: (trace var1 var2 ...)\nreturns: a list of var1 var2 ...\nsyntax: (trace) \nreturns: a list of all currently traced top-level variables \nlibraries: (chezscheme)  \n\n" "In the first form, trace reassigns the top-level values of var1 var2 ..., whose values must be procedures, to equivalent procedures that display trace information in the manner of trace-lambda.  \n\n" "trace works by encapsulating the old value of each var in a traced procedure. It could be defined approximately as follows.  (The actual version records and returns information about traced variables.) \n\n" "" "(define-syntax trace\n  (syntax-rules ()\n    [(_ var ...)\n     (begin\n       (set-top-level-value! 'var\n         (let ([p (top-level-value 'var)])\n           (trace-lambda var args (apply p args))))\n       ...)]))\n\n" "Tracing for a procedure traced in this manner may be disabled via untrace (see below), an assignment of the corresponding variable to a different, untraced value, or a subsequent use of trace for the same variable. Because the value is traced and not the binding, however, a traced value obtained before tracing is disabled and retained after tracing is disabled will remain traced. \n\n" "trace without subexpressions evaluates to a list of all currently traced variables. A variable is currently traced if it has been traced and not subsequently untraced or assigned to a different value. \n\n" "The following transcript demonstrates the use of trace in an interactive session. \n\n" "" "> (define half\n    (lambda (x)\n      (cond\n        [(zero? x) 0]\n        [(odd? x) (half (- x 1))]\n        [(even? x) (+ (half (- x 1)) 1)])))\n> (half 5)\n2\n> (trace half)\n(half)\n> (half 5)\n|(half 5)\n|(half 4)\n| (half 3)\n| (half 2)\n| |(half 1)\n| |(half 0)\n| |0\n| 1\n|2\n2\n> (define traced-half half)\n> (untrace half)\n(half)\n> (half 2)\n1\n> (traced-half 2)\n|(half 2)\n|1\n1\n\n") ("debug:s10" "syntax: (untrace var1 var2 ...)\nsyntax: (untrace) \nreturns: a list of untraced variables \nlibraries: (chezscheme)  \n\n" "untrace restores the original (pre-trace) top-level values of each currently traced variable in var1 var2 ..., effectively disabling the tracing of the values of these variables. Any variable in var1 var2 ... that is not currently traced is ignored. If untrace is called without arguments, the values of all currently traced variables are restored. \n\n" "The following transcript demonstrates the use of trace and untrace in an interactive session to debug an incorrect procedure definition. \n\n" "" "> (define square-minus-one\n    (lambda (x)\n      (- (* x x) 2)))\n> (square-minus-one 3)\n7\n> (trace square-minus-one * -)\n(square-minus-one * -)\n> (square-minus-one 3)\n|(square-minus-one 3)\n| (* 3 3)\n| 9\n|(- 9 2)\n|7\n7\n> (define square-minus-one\n    (lambda (x)\n      (- (* x x) 1))) ; change the 2 to 1\n> (trace)\n(- *)\n> (square-minus-one 3)\n|(* 3 3)\n|9\n|(- 9 1)\n|8\n8\n> (untrace square-minus-one)\n()\n> (untrace * -)\n(- *)\n> (square-minus-one 3)\n8\n\n" "The first call to square-minus-one indicates there is an error, the second (traced) call indicates the step at which the error occurs, the third call demonstrates that the fix works, and the fourth call demonstrates that untrace does not wipe out the fix.  \n\n") ("debug:s11" "thread parameter: trace-output-port \nlibraries: (chezscheme)  \n\n" "trace-output-port is a parameter that determines the output port to which tracing information is sent. When called with no arguments, trace-output-port returns the current trace output port. When called with one argument, which must be a textual output port, trace-output-port changes the value of the current trace output port. \n\n") ("debug:s12" "thread parameter: trace-print \nlibraries: (chezscheme)  \n\n" "The value of trace-print must be a procedure of two arguments, an object and an output port. The trace package uses the value of trace-print to print the arguments and return values for each call to a traced procedure. trace-print is set to pretty-print by default.  \n\n" "The trace package sets pretty-initial-indent to an appropriate value for the current nesting level before calling the value of trace-print so that multiline output can be indented properly. \n\n") ("debug:s14" "syntax: (trace-define var expr)\nsyntax: (trace-define (var . idspec) body1 body2 ...)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "trace-define is a convenient shorthand for defining variables bound to traced procedures of the same name. The first form is equivalent to \n\n" "" "(define var\n  (let ([x expr])\n    (trace-lambda var args\n      (apply x args))))\n\n" "and the second is equivalent to \n\n" "" "(define var\n  (trace-lambda var idspec\n    body1 body2 ...))\n\n" "In the former case, expr must evaluate to a procedure. \n\n" "" "> (let ()\n    (trace-define plus\n      (lambda (x y) \n        (+ x y)))\n    (list (plus 3 4) (+ 5 6)))\n|(plus 3 4)\n|7\n(7 11)\n\n") ("debug:s15" "syntax: (trace-define-syntax keyword expr)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "trace-define-syntax traces the input and output to the transformer value of expr, stripped of the contextual information used by the expander to maintain lexical scoping. \n\n" "" "> (trace-define-syntax let*\n    (syntax-rules ()\n      [(_ () b1 b2 ...)\n       (let () b1 b2 ...)]\n      [(_ ((x e) m ...) b1 b2 ...)\n       (let ((x e))\n         (let* (m ...) b1 b2 ...))]))\n> (let* ([x 3] [y (+ x x)]) (list x y))\n|(let* (let* [(x 3) (y (+ x x))] [list x y]))\n|(let ([x 3]) (let* ([y (+ x x)]) (list x y)))\n|(let* (let* [(y (+ x x))] [list x y]))\n|(let ([y (+ x x)]) (let* () (list x y)))\n|(let* (let* () [list x y]))\n|(let () (list x y))\n(3 6)\n\n" "Without contextual information, the displayed forms are more readable but less precise, since different identifiers with the same name are indistinguishable, as shown in the example below. \n\n" "" "> (let ([x 0])\n    (trace-define-syntax a\n      (syntax-rules ()\n        [(_ y) (eq? x y)]))\n    (let ([x 1])\n      (a x)))\n|(a (a x))\n|(eq? x x)\n#f\n\n") ("debug:s16" "procedure: (debug) \nreturns: does not return \nlibraries: (chezscheme)  \n\n" "When the default exception handler receives a serious or non-warning condition, it displays the condition and resets to the current caf. Before it resets, it saves the condition in the parameter debug-condition. The debug procedure may be used to inspect the condition. Whenever one of the built-in error-reporting mechanisms is used to raise an exception, the continuation at the point where the exception was raised can be inspected as well. More generally, debug allows the continuation contained within any continuation condition created by make-continuation-condition to be inspected.  \n\n" "If the parameter debug-on-exception is set to #t, the default exception handler enters the debugger directly for all serious and non-warning conditions, delaying its reset until after the debugger exits. The --debug-on-exception command-line option may be used to set debug-on-exception to #t from the command line, which is particularly useful when debugging scripts or top-level programs run via the --script or --program command-line options. \n\n") ("debug:s22" "procedure: (inspect obj)\nreturns: unspecified \nlibraries: (chezscheme)  \n\n" "Invokes the inspector on obj, as described above. The commands recognized by the inspector are listed below, categorized by the type of the current object. \n\n" "" "" "Generally applicable commands\n\n" "" "help or h displays a brief description of how to use the inspector. \n\n" "" "? displays commands applicable to the current type of object. \n\n" "" "?? displays the generally applicable commands.  \n\n" "" "print or p prints the current object (using pretty-print).  \n\n" "" "write or w writes the current object (using write).  \n\n" "" "size writes the size in bytes occupied by the current object (determined via compute-size), including any objects accessible from the current object except those for which the size was previously requested during the same interactive inspector session. \n\n" "" "find expr [ g ] evaluates expr, which should evaluate to a procedure of one argument, and searches (via make-object-finder) for the first occurrence of an object within the current object for which the predicate returns a true value, treating immediate values (e.g., fixnums), values in generations older than g, and values already visited during the search as leaves. If g is not unspecified, it defaults to the current maximum generation, i.e., the value of collect-maximum-generation. If specified, g must be an exact nonnegative integer less than or equal to the current maximum generation or the symbol static representing the static generation. If such an object is found, the inspector's focus moves to that object as if through a series of steps that lead from the current object to the located object, so that the up command can be used to determine where the object was found relative to the original object. \n\n" "" "find-next repeats the last find, locating an occurrence not previously found, if any. \n\n" "" "up or u n returns to the nth previous level. Used to move outwards in the structure of the inspected object. n defaults to 1. \n\n" "" "top or t returns to the outermost level of the inspected object. \n\n" "" "forward or f moves to the nth next expression. Used to move from one element to another of an object containing a sequence of elements, such as a list, vector, record, frame, or closure. n defaults to 1. \n\n" "" "back or b moves to the nth previous expression. Used to move from one element to another of an object containing a sequence of elements, such as a list, vector, record, frame, or closure. n defaults to 1. \n\n" "" "=> expr sends the current object to the procedure value of expr. expr may begin on the current or following line and may span multiple lines. \n\n" "" "file path opens the source file at the specified path for listing. The parameter source-directories (Section 12.5) determines the set of directories searched for source files. \n\n" "" "list line count lists count lines of the current source file (see file) starting at line. line defaults to the end of the previous set of lines listed and count defaults to ten or the number of lines previously listed. If line is negative, listing begins line lines before the previous set of lines listed. \n\n" "" "files shows the currently open source files.  \n\n" "" "mark or m m marks the current location with the symbolic mark m. If m is not specified, the current location is marked with a unique default mark. \n\n" "" "goto or g m returns to the location marked m. If m is not specified, the inspector returns to the location marked with the default mark. \n\n" "" "new-cafe or n enters a new read-eval-print loop (caf), giving access to the normal top-level environment. \n\n" "" "quit or q exits from the inspector.  \n\n" "" "reset or r resets to the current caf. \n\n" "" "abort or a x aborts from Scheme with exit status x, which defaults to -1. \n\n" "" "Continuation commands\n\n" "" "show-frames or sf shows the next n frames. If n is not specified, all frames are displayed. \n\n" "" "depth displays the number of frames in the continuation.  \n\n" "" "down or d n move to the nth frame down in the continuation. n defaults to 1. \n\n" "" "show or s shows the continuation (next frame) and, if available, the calling procedure source, the pending call source, the closure, and the frame and free-variable values. Source is available only if generation of inspector information was enabled during compilation of the corresponding lambda expression. \n\n" "" "show-local or sl is like show or s except that free variable values are not shown.  (If present, free variable values can be found by inspecting the closure.) \n\n" "" "length or l displays the number of elements in the topmost frame of the continuation. \n\n" "" "ref or r moves to the nth or named frame element.  n defaults to 0. If multiple elements have the same name, only one is accessible by name, and the others must be accessed by number. \n\n" "" "code or c moves to the source for the calling procedure.  \n\n" "" "call moves to the source for the pending call.  \n\n" "" "file opens the source file containing the pending call, if known. The parameter source-directories (Section 12.5) determines the list of source directories searched for source files identified by relative path names. \n\n" "For absolute pathnames starting with a / (or \\ or a directory specifier under Windows), the inspector tries the absolute pathname first, then looks for the last (filename) component of the path in the list of source directories.  For pathnames starting with ./ (or .\\ under Windows) or ../ (or ..\\ under Windows), the inspector looks in \".\" or \"..\" first, as appropriate, then for the entire .- or ..-prefixed pathname in the source directories, then for the last (filename) component in the source directories. For other (relative) pathnames, the inspector looks for the entire relative pathname in the list of source directories, then the last (filename) component in the list of source directories.  \n\n" "If a file by the same name as but different contents from the original source file is found during this process, it will be skipped over. This typically happens because the file has been modified since it was compiled. Pass an explicit filename argument to force opening of a particular file (see the generally applicable commands above). \n\n" "" "eval or e expr evaluates the expression expr in an environment containing bindings for the elements of the frame.  Within the evaluated expression, the value of each frame element n is accessible via the variable %n. Named elements are accessible via their names as well.  Names are available only if generation of inspector information was enabled during compilation of the corresponding lambda expression. \n\n" "" "set! or ! n e sets the value of the nth frame element to e, if the frame element corresponds to an assignable variable. n defaults to 0. \n\n" "" "Procedure commands\n\n" "" "show or s shows the source and free variables of the procedure. Source is available only if generation of inspector information was enabled during compilation of the corresponding lambda expression. \n\n" "" "code or c moves to the source for the procedure.  \n\n" "" "file opens the file containing the procedure's source code, if known. See the description of the continuation file entry above for more information. \n\n" "" "length or l displays the number of free variables whose values are recorded in the procedure object. \n\n" "" "ref or r moves to the nth or named free variable.  n defaults to 0. If multiple free variables have the same name, only one is accessible by name, and the others must be accessed by number. \n\n" "" "set! or ! n e sets the value of the nth free variable to e, if the variable is assignable. n defaults to 0. \n\n" "" "eval or e expr evaluates the expression expr in an environment containing bindings for the free variables of the procedure. Within the evaluated expression, the value of each free variable n is accessible via the variable %n. Named free variables are accessible via their names as well. Names are available only if generation of inspector information was enabled during compilation of the corresponding lambda expression. \n\n" "" "Pair (list) commands\n\n" "" "show or s n shows the first n elements of the list. If n is not specified, all elements are displayed. \n\n" "" "length or l displays the list length.  \n\n" "" "car moves to the object in the car of the current object.  \n\n" "" "cdr moves to the object in the cdr.  \n\n" "" "ref or r n moves to the nth element of the list. n defaults to 0. \n\n" "" "tail n moves to the nth cdr of the list. n defaults to 1. \n\n" "" "Vector, Bytevector, and Fxvector commands\n\n" "" "show or s n shows the first n elements of the vector. If n is not specified, all elements are displayed. \n\n" "" "length or l displays the vector length.  \n\n" "" "ref or r n moves to the nth element of the vector. n defaults to 0. \n\n" "" "String commands\n\n" "" "show or s n shows the first n elements of the string. If n is not specified, all elements are displayed. \n\n" "" "length or l displays the string length.  \n\n" "" "ref or r n moves to the nth element of the string. n defaults to 0. \n\n" "" "unicode n displays the first n elements of the string as hexadecimal Unicode scalar values. \n\n" "" "ascii n displays the first n elements of the string as hexadecimal ASCII values, using -- to denote characters whose Unicode scalar values are not in the ASCII range. \n\n" "" "Symbol commands\n\n" "" "show or s shows the fields of the symbol.  \n\n" "" "value or v moves to the top-level value of the symbol.  \n\n" "" "name or n moves to the name of the symbol.  \n\n" "" "property-list or pl moves to the property list of the symbol. \n\n" "" "ref or r n moves to the nth field of the symbol. Field 0 is the top-level value of the symbol, field 1  is the symbol's name, and field 2 is its property list. n defaults to 0. \n\n" "" "Character commands\n\n" "" "unicode displays the hexadecimal Unicode scalar value for the character. \n\n" "" "ascii displays the hexadecimal ASCII code for the character, using -- to denote characters whose Unicode scalar values are not in the ASCII range. \n\n" "" "Box commands\n\n" "" "show or s shows the contents of the box.  \n\n" "" "unbox or ref or r moves to the boxed object.  \n\n" "" "Port commands\n\n" "" "show or s shows the fields of the port, including the input and output size, index, and buffer fields. \n\n" "" "name moves to the port's name.  \n\n" "" "handler moves to the port's handler.  \n\n" "" "output-buffer or ob moves to the port's output buffer.  \n\n" "" "input-buffer or ib moves to the port's input buffer.  \n\n" "" "Record commands\n\n" "" "show or s shows the contents of the record.  \n\n" "" "fields moves to the list of field names of the record. \n\n" "" "name moves to the name of the record.  \n\n" "" "rtd moves to the record-type descriptor of the record.  \n\n" "" "ref or r name moves to the named field of the record, if accessible. \n\n" "" "set! or ! name value sets the value of the named field of the record, if mutable. \n\n" "" "Transport Link Cell (TLC) commands\n\n" "" "show or s shows the fields of the TLC.  \n\n" "" "keyval moves to the keyval of the TLC.  \n\n" "" "tconc moves to the tconc of the TLC.  \n\n" "" "next moves to the next link of the TLC.  \n\n" "" "ref or r n moves to the nth field of the symbol. Field 0 is the keyval, field 1 the tconc, and field 2 the next link. n defaults to 0. \n\n") ("debug:s25" "procedure: (inspect/object object)\nreturns: an inspector object procedure \nlibraries: (chezscheme)  \n\n" "inspect/object is used to turn an ordinary Scheme object into an inspector object. All inspector objects accept the messages type, print, write, and size. The type message returns a symbolic representation of the type of the object. The print and write messages must be accompanied by a port parameter. They cause a representation of the object to be written to the port, using the Scheme procedures pretty-print and write. The size message returns a fixnum representing the size in bytes occupied by the object, including any objects accessible from the current object except those for which the size was already requested via an inspector object derived from the argument of the same inspect/object call.  \n\n" "All inspector objects except for variable inspector objects accept the message value, which returns the actual object encapsulated in the inspector object. \n\n" "" "(define x (inspect/object '(1 2 3)))\n(x 'type) => pair\n(define p (open-output-string))\n(x 'write p)\n(get-output-string p) => \"(1 2 3)\"\n(x 'length) => (proper 3)\n(define y (x 'car))\n(y 'type) => simple\n(y 'value) => 1\n\n" "" "" "" "Pair inspector objects.Pair inspector objects contain Scheme pairs. \n\n" "" "(pair-object 'type) returns the symbol pair.  \n\n" "" "(pair-object 'car) returns an inspector object containing the \"car\" field of the pair. \n\n" "" "(pair-object 'cdr) returns an inspector object containing the \"cdr\" field of the pair. \n\n" "" "(pair-object 'length) returns a list of the form (type count). The type field contains the symbol proper, the symbol improper, or the symbol circular, depending on the structure of the list. The count field contains the number of distinct pairs in the list. \n\n" "" "Box inspector objects.Box inspector objects contain Chez Scheme boxes. \n\n" "" "(box-object 'type) returns the symbol box.  \n\n" "" "(box-object 'unbox) returns an inspector object containing the contents of the box. \n\n" "" "TLC inspector objects.TLC inspector objects contain Chez Scheme transport link cells. \n\n" "" "(tlc-object 'type) returns the symbol tlc.  \n\n" "" "(tlc-object 'keyval) returns an inspector object containing the TLC's keyval. \n\n" "" "(tlc-object 'tconc) returns an inspector object containing the TLC's tconc. \n\n" "" "(tlc-object 'next) returns an inspector object containing the TLC's next link. \n\n" "" "Vector, String, Bytevector, and Fxvector inspector objects.Vector (bytevector, string, fxvector) inspector objects contain Scheme vectors (bytevectors, strings, fxvectors). \n\n" "" "(vector-object 'type) returns the symbol vector (string, bytevector, fxvector).  \n\n" "" "(vector-object 'length) returns the number of elements in the vector or string. \n\n" "" "(vector-object 'ref n) returns an inspector object containing the nth element of the vector or string. \n\n" "" "Simple inspector objects.Simple inspector objects contain unstructured, unmodifiable objects. These include numbers, booleans, the empty list, the end-of-file object, and the void object. They may be examined directly by asking for the value of the object.  \n\n" "" "(simple-object 'type) returns the symbol simple.  \n\n" "" "Unbound inspector objects.Although unbound objects are not normally accessible to Scheme programs, they may be encountered when inspecting variables. \n\n" "" "(unbound-object 'type) returns the symbol unbound.  \n\n" "" "Procedure inspector objects.Procedure inspector objects contain Scheme procedures. \n\n" "" "(procedure-object 'type) returns the symbol procedure.  \n\n" "" "(procedure-object 'length) returns the number of free variables. \n\n" "" "(procedure-object 'ref n) returns an inspector object containing the nth free variable of the procedure. See the description below of variable inspector objects. n must be nonnegative and less than the length of the procedure. \n\n" "" "(procedure-object 'eval expr) evaluates expr and returns its value. The values of the procedure's free variables are bound within the evaluated expression to identifiers of the form %n, where n is the location number displayed by the inspector. The values of named variables are also bound to their names. \n\n" "" "(procedure-object 'code) returns an inspector object containing the procedure's code object. See the description below of code inspector objects. \n\n" "" "Continuation inspector objects.Continuations created by call/cc are actually procedures. However, when inspecting such a procedure the underlying data structure that embodies the continuation may be exposed. A continuation structure contains the location at which computation is to resume, the variable values necessary to perform the computation, and a link to the next continuation. \n\n" "" "(continuation-object 'type) returns the symbol continuation.  \n\n" "" "(continuation-object 'length) returns the number of free variables. \n\n" "" "(continuation-object 'ref n) returns an inspector object containing the nth free variable of the continuation. See the description below of variable inspector objects. n must be nonnegative and less than the length of the continuation. \n\n" "" "(continuation-object 'eval expr) evaluates expr and returns its value. The values of frame locations are bound within the evaluated expression to identifiers of the form %n, where n is the location number displayed by the inspector. The values of named locations are also bound to their names. \n\n" "" "(continuation-object 'code) returns an inspector object containing the code object for the procedure that was active when the current continuation frame was created. See the description below of code inspector objects. \n\n" "" "(continuation-object 'depth) returns the number of frames in the continuation. \n\n" "" "(continuation-object 'link) returns an inspector object containing the next continuation frame. The depth must be greater than 1. \n\n" "" "(continuation-object 'link* n) returns an inspector object containing the nth continuation link. n must be less than the depth. \n\n" "" "(continuation-object 'source) returns an inspector object containing the source information attached to the continuation (representing the source for the application that resulted in the formation of the continuation) or #f if no source information is attached.  \n\n" "" "(continuation-object 'source-object) returns an inspector object containing the source object for the procedure application that resulted in the formation of the continuation or #f if no source object is attached.  \n\n" "" "(continuation-object 'source-path) attempts to find the pathname of the file containing the source for the procedure application that resulted in the formation of the continuation. If successful, three values are returned to identify the file and position of the application within the file: path, line, and char. Two values, a file name and an absolute character position, are returned if the file name is known but the named file cannot be found. The search may be unsuccessful even if a file by the expected name is found in the path if the file has been modified since the source code was compiled. If no file name is known, no values are returned. The parameter source-directories (Section 12.5) determines the set of directories searched for source files identified by relative path names. \n\n" "" "Code inspector objects.Code inspector objects contain Chez Scheme code objects. \n\n" "" "(code-object 'type) returns the symbol code.  \n\n" "" "(code-object 'name) returns a string or #f. The name associated with a code inspector object is the name of the variable to which the procedure was originally bound or assigned. Since the binding of a variable can be changed, this name association may not always be accurate. #f is returned if the inspector cannot determine a name for the procedure. \n\n" "" "(code-object 'realm) returns a symbol or #f. The realm of a code object is determined by the compile-procedure-realm parameter at the time that the code object is compiled. \n\n" "" "(code-object 'source) returns an inspector object containing the source information attached to the code object or #f if no source information is attached.  \n\n" "" "(continuation-object 'source-object) returns an inspector object containing the source object for the code object or #f if no source object is attached.  \n\n" "" "(code-object 'source-path) attempts to find the pathname of the file containing the source for the lambda expression that produced the code object. If successful, three values are returned to identify the file and position of the application within the file: path, line, and char. Two values, a file name and an absolute character position, are returned if the file name is known but the named file cannot be found. The search may be unsuccessful even if a file by the expected name is found in the path if the file has been modified since the source code was compiled. If no file name is known, no values are returned. The parameter source-directories (Section 12.5) determines the set of directories searched for source files identified by relative path names. \n\n" "" "(code-object 'free-count) returns the number of free variables in any procedure for which this is the corresponding code. \n\n" "" "Variable inspector objects.Variable inspector objects encapsulate variable bindings. Although the actual underlying representation varies, the variable inspector object provides a uniform interface. \n\n" "" "(variable-object 'type) returns the symbol variable.  \n\n" "" "(variable-object 'name) returns a symbol or #f. #f is returned if the name is not available or if the variable is a compiler-generated temporary variable. Variable names are not retained when the parameter generate-inspector-information (page 12.6) is false during compilation. \n\n" "" "(variable-object 'ref) returns an inspector object containing the current value of the variable. \n\n" "" "(variable-object 'set! e) returns unspecified, after setting the current value of the variable to e. An exception is raised with condition type &assertion if the variable is not assignable.  \n\n" "" "Port inspector objects.Port inspector objects contain ports. \n\n" "" "(port-object 'type) returns the symbol port.  \n\n" "" "(port-object 'input?) returns #t if the port is an input port, #f otherwise.  \n\n" "" "(port-object 'output?) returns #t if the port is an output port, #f otherwise.  \n\n" "" "(port-object 'binary?) returns #t if the port is a binary port, #f otherwise.  \n\n" "" "(port-object 'closed?) returns #t if the port is closed, #f if the port is open.  \n\n" "" "(port-object 'name) returns an inspector object containing the port's name. \n\n" "" "(port-object 'handler) returns a procedure inspector object encapsulating the port handler, such as would be returned by port-handler.  \n\n" "" "(port-object 'output-size) returns the output buffer size as a fixnum if the port is an output port (otherwise the value is unspecified). \n\n" "" "(port-object 'output-index) returns the output buffer index as a fixnum if the port is an output port (otherwise the value is unspecified). \n\n" "" "(port-object 'output-buffer) returns an inspector object containing the string used for buffered output. \n\n" "" "(port-object 'input-size) returns the input buffer size as a fixnum if the port is an input port (otherwise the value is unspecified). \n\n" "" "(port-object 'input-index) returns the input buffer index as a fixnum if the port is an input port (otherwise the value is unspecified). \n\n" "" "(port-object 'input-buffer) returns an inspector object containing the string used for buffered input. \n\n" "" "Symbol inspector objects.Symbol inspector objects contain symbols. These include gensyms. \n\n" "" "(symbol-object 'type) returns the symbol symbol.  \n\n" "" "(symbol-object 'name) returns a string inspector object. The string name associated with a symbol inspector object is the print representation of a symbol, such as would be returned by the procedure symbol->string.  \n\n" "" "(symbol-object 'gensym?) returns #t if the symbol is a gensym, #f otherwise. Gensyms are created by gensym.  \n\n" "" "(symbol-object 'top-level-value) returns an inspector object containing the global value of the symbol. \n\n" "" "(symbol-object 'property-list) returns an inspector object containing the property list for the symbol. \n\n" "" "Record inspector objects.Record inspector objects contain records. \n\n" "" "(record-object 'type) returns the symbol record.  \n\n" "" "(record-object 'name) returns a string inspector object corresponding to the name of the record type. \n\n" "" "(record-object 'fields) returns an inspector object containing a list of the field names of the record type. \n\n" "" "(record-object 'length) returns the number of fields. \n\n" "" "(record-object 'rtd) returns an inspector object containing the record-type descriptor of the record type. \n\n" "" "(record-object 'accessible? name) returns #t if the named field is accessible, #f otherwise. A field may be inaccessible if optimized away by the compiler. \n\n" "" "(record-object 'ref name) returns an inspector object containing the value of the named field. An exception is raised with condition type &assertion if the named field is not accessible.  \n\n" "" "(record-object 'mutable? name) returns #t if the named field is mutable, #f otherwise. A field is immutable if it is not declared mutable or if the compiler optimizes away all assignments to the field. \n\n" "" "(record-object 'set! name value) sets the value of the named field to value. An exception is raised with condition type &assertion if the named field is not assignable.  \n\n") ("debug:s26" "procedure: (make-object-finder pred)\nprocedure: (make-object-finder pred g)\nprocedure: (make-object-finder pred x g)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "The procedure make-object-finder takes a predicate pred and two optional arguments: a starting point x and a maximum generation g. The starting point defaults to the value of the procedure oblist, and the maximum generation defaults to the value of the parameter collect-maximum-generation. make-object-finder returns an object finder p that can be used to search for objects satisfying pred within the starting-point object x. Immediate objects and objects in generations older than g are treated as leaves. p is a procedure accepting no arguments. If an object y satisfying pred can be found starting with x, p returns a list whose first element is y and whose remaining elements represent the path of objects from x to y, listed in reverse order. p can be invoked multiple times to find additional objects satisfying the predicate, if any. p returns #f if no more objects matching the predicate can be found. \n\n" "p maintains internal state recording where it has been so it can restart at the point of the last found object and not return the same object twice. The state can be several times the size of the starting-point object x and all that is reachable from x. \n\n" "The interactive inspector provides a convenient interface to the object finder in the form of find and find-next commands.  \n\n" "Relocation tables for static code objects are discarded by default, which prevents object finders from providing accurate results when static code objects are involved. That is, they will not find any objects pointed to directly from a code object that has been promoted to the static generation. If this is a problem, the command-line argument --retain-static-relocation can be used to prevent the relocation tables from being discarded. \n\n") ("debug:s30" "procedure: (compute-size object)\nprocedure: (compute-size object generation)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "object can be any object. generation must be a fixnum between 0 and the value of collect-maximum-generation, inclusive, or the symbol static. If generation is not supplied, it defaults to the value of collect-maximum-generation.  \n\n" "compute-size returns the amount of memory, in bytes, occupied by object and anything reachable from object in any generation less than or equal to generation. Immediate values such as fixnums, booleans, and characters have zero size. Size computation for a thread is limited when the thread is still active, since its full continuation cannot be inspected in that case, but the full continuation is inspected if the thread is inactive (such as during a garbage collection rendezvous when a different thread is selected by the rendezvous). \n\n" "The following examples are valid for machines with 32-bit pointers. \n\n" "" "(compute-size 0) => 0\n(compute-size (cons 0 0)) => 8\n(compute-size (cons (vector #t #f) 0)) => 24 \n\n(compute-size\n  (let ([x (cons 0 0)])\n    (set-car! x x)\n    (set-cdr! x x)\n    x))                  => 8 \n\n(define-record-type frob (fields x))\n(collect 1 1) ; force rtd into generation 1\n(compute-size\n  (let ([x (make-frob 0)])\n    (cons x x))\n  0)                       => 16\n\n") ("debug:s31" "procedure: (compute-composition object)\nprocedure: (compute-composition object generation)\nreturns: see below \nlibraries: (chezscheme)  \n\n" "object can be any object. generation must be a fixnum between 0 and the value of collect-maximum-generation, inclusive, or the symbol static. If generation is not supplied, it defaults to the value of collect-maximum-generation.  \n\n" "compute-composition returns an association list representing the composition of object, including anything reachable from it in any generation less than or equal to generation. The association list has the following structure: \n\n" "" "((type count . bytes) ...)\n\n" "type is either the name of a primitive type, represented as a symbol, e.g., pair, or a record-type descriptor (rtd). count and bytes are nonnegative fixnums. \n\n" "Immediate values such as fixnums, booleans, and characters are not included in the composition. \n\n" "The following examples are valid for machines with 32-bit pointers. \n\n" "" "(compute-composition 0) => ()\n(compute-composition (cons 0 0)) => ((pair 1 . 8))\n(compute-composition\n  (cons (vector #t #f) 0)) => ((pair 1 . 8) (vector 1 . 16)) \n\n(compute-composition\n  (let ([x (cons 0 0)])\n    (set-car! x x)\n    (set-cdr! x x)\n    x))                 => ((pair 1 . 8) \n\n(define-record-type frob (fields x))\n(collect 1 1) ; force rtd into generation 1\n(compute-composition\n  (let ([x (make-frob 0)])\n    (cons x x))\n  0)                       => ((pair 1 . 8)\n                                (#<record type frob> 1 . 8))\n\n") ("debug:s32" "procedure: (compute-size-increments list)\nprocedure: (compute-size-increments list generation)\nreturns: a list as described below \nlibraries: (chezscheme)  \n\n" "list must be a list, but each element can be any object. generation must be a fixnum between 0 and the value of collect-maximum-generation, inclusive, or the symbol static. If generation is not supplied, it defaults to the value of collect-maximum-generation. In the threaded versions of Chez Scheme, the thread that invokes compute-size-increments must be the only active thread.  \n\n" "compute-size-increments is like mapping compute-size over list, except that any object reachable from an earlier element of list is not treated as reachable by a later element of list. In addition, each immediate element of list is not treated as reachable by earlier elements of list---although other values reachable from later elements of list may be considered reachable from earlier elements. \n\n" "Unlike compute-size, compute-size-increments does not consider the car of a weak pair reachable from the weak pair. It also does not consider the car or cdr of an ephemeron pair to be reachable from the ephemeron pair, unless the car is already determined to be reachable (perhaps from an earlier element of list); if the car of an ephemeron pair is discovered to be reachable later (perhaps from a later element of list), then the cdr of the ephemeron pair is considered to be reachable from the car, which has the effect of charging the memory of the cdr to the same element of list as the memory of the car.  \n\n" "The following examples are valid for machines with 32-bit pointers. \n\n" "" "(compute-size-increments (list 0)) => (0)\n(compute-size-increments (list (cons 0 0))) => (8)\n(compute-size-increments (list (cons 0 0) (cons 0 0))) => (8 8)\n(compute-size-increments (let ([p (cons 0 0)])\n                           (list p p))) => (8 0)\n(compute-size-increments (let ([p (cons 0 0)])\n                           (list (cons 1 p) (cons 1 p)))) => (16 8)\n(compute-size-increments (list (ephemeron-cons 0 0))) => (16)\n(compute-size-increments (let* ([p (cons 0 0)]\n                                [e (ephemeron-cons p (cons 0 0))])\n                           (list e p))) => (16 16)\n\n" "")) (tspl ("exceptions:s3" "procedure: (raise obj)\nprocedure: (raise-continuable obj)\nreturns: see below \nlibraries: (rnrs exceptions), (rnrs)  \n\n" "Both of these procedures raise an exception, effectively invoking the current exception handler, passing obj as the only argument. For raise, the exception is non-continuable, while for raise-continuable, the exception is continuable. An exception handler may return (with zero or more values) to the continuation of a continuable exception. If an exception handler attempts to return to the continuation of a non-continuable exception, however, a new exception with condition type &non-continuable is raised. Thus, raise never returns, while raise-continuable may return zero or more values, depending upon the exception handler. \n\n" "If the current exception handler, p, was established via a guard form or call to with-exception-handler, the current exception handler is reset to the handler that was current when p was established before raise or raise-continuable invokes p. This allows p to defer to the preexisting exception handler simply by reraising the exception, and it helps prevent infinite regression when an exception handler inadvertently causes a different exception to be raised. If p returns and the exception is continuable, p is reinstated as the current exception handler. \n\n" "" "(raise\n   (condition\n    (make-error)\n    (make-message-condition \"no go\"))) => error: no go\n(raise-continuable\n  (condition\n    (make-violation)\n    (make-message-condition \"oops\"))) => violation: oops\n(list\n  (call/cc\n    (lambda (k)\n      (vector\n        (with-exception-handler\n          (lambda (x) (k (+ x 5)))\n          (lambda () (+ (raise 17) 8))))))) => (22)\n(list\n  (vector\n    (with-exception-handler\n      (lambda (x) (+ x 5))\n      (lambda () (+ (raise-continuable 17) 8))))) => (#(30))\n(list\n  (vector\n    (with-exception-handler\n      (lambda (x) (+ x 5))\n      (lambda () (+ (raise 17) 8))))) => violation: non-continuable\n\n") ("exceptions:s4" "procedure: (error who msg irritant ...)\nprocedure: (assertion-violation who msg irritant ...)\nlibraries: (rnrs base), (rnrs)  \n\n" "error raises a non-continuable exception with condition type &error and should be used to describe situations for which the &error condition type is appropriate, typically a situation involving the program's interaction with something outside of the program. assertion-violation raises a non-continuable exception with condition type &assertion and should be used to describe situations for which the &assertion condition type is appropriate, typically an invalid argument to a procedure or invalid value of a subexpression of a syntactic form. \n\n" "The continuation object with which the exception is raised also includes a &who condition whose who field is who if who is not #f, a &message condition whose message field is msg, and an &irritants condition whose irritants field is (irritant ...). \n\n" "who must be a string, a symbol, or #f identifying the procedure or syntactic form reporting the error upon whose behalf the error is being reported. It is usually best to identify a procedure the programmer has called rather than some other procedure the programmer may not be aware is involved in carrying out the operation. msg must be a string and should describe the exceptional situation. The irritants may be any Scheme objects and should include values that may have caused or been materially involved in the exceptional situation. \n\n") ("exceptions:s5" "syntax: (assert expression)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "assert evaluates expression and returns the value of expression if the value is not #f. If the value of expression is #f, assert raises a non-continuable exception with condition types &assertion and &message, with an implementation-dependent value in its message field. Implementations are encouraged to provide information about the location of the assert call within the condition whenever possible.  \n\n") ("exceptions:s6" "procedure: (syntax-violation who msg form)\nprocedure: (syntax-violation who msg form subform)\nreturns: does not return \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "This procedure raises a non-continuable exception with a condition of type &syntax. It should be used to report a syntax error detected by the transformer of a syntactic extension. The value of the condition's form field is form, and the value of its subform field is subform, or #f if subform is not provided. \n\n" "The continuation object with which the exception is raised also includes a &who condition whose who field is who, if who is not #f or is inferred from form, and a &message condition whose message field is msg. \n\n" "who must be a string, a symbol, or #f. If who is #f, it is inferred to be the symbolic name of form if form is an identifier or the symbolic name of the first subform of form if form is a list-structured form whose first subform is an identifier. message must be a string. form should be the syntax object or datum representation of the syntactic form within which the syntax violation occurred, and subform, if not #f, should be a syntax object or datum representation of a subform more specifically involved in the violation. For example, if a duplicate formal parameter is found in a lambda expression, form might be the lambda expression and subform might be the duplicated parameter. \n\n" "Some implementations attach source information to syntax objects, e.g., line, character, and filename for forms originating in a file, in which case this information might also be present as some implementation-dependent condition type within the condition object. \n\n") ("exceptions:s7" "procedure: (with-exception-handler procedure thunk)\nreturns: see below \nlibraries: (rnrs exceptions), (rnrs)  \n\n" "This procedure establishes procedure, which should accept one argument, as the current exception handler in place of the old current exception handler, old-proc, and invokes thunk without arguments. If the call to thunk returns, old-proc is reestablished as the current exception handler and the values returned by thunk are returned. If control leaves or subsequently reenters the call to thunk via the invocation of a continuation obtained via call/cc, the procedure that was the current exception handler when the continuation was captured is reinstated. \n\n" "" "(define (try thunk)\n  (call/cc\n    (lambda (k)\n      (with-exception-handler\n        (lambda (x) (if (error? x) (k #f) (raise x)))\n        thunk))))\n(try (lambda () 17)) => 17\n(try (lambda () (raise (make-error)))) => #f\n(try (lambda () (raise (make-violation)))) => violation\n(with-exception-handler\n  (lambda (x)\n    (raise\n      (apply condition\n        (make-message-condition \"oops\")\n        (simple-conditions x))))\n  (lambda ()\n    (try (lambda () (raise (make-violation)))))) => violation: oops\n\n") ("exceptions:s8" "syntax: (guard (var clause1 clause2 ...) b1 b2 ...)\nreturns: see below \nlibraries: (rnrs exceptions), (rnrs)  \n\n" "A guard expression establishes a new current exception handler, procedure (described below), in place of the old current exception handler, old-proc, and evaluates the body b1 b2 .... If the body returns, guard reestablishes old-proc as the current exception handler. If control leaves or subsequently reenters the body via the invocation of a continuation obtained via call/cc, the procedure that was the current exception handler when the continuation was captured is reinstated. \n\n" "The procedure procedure established by guard binds var to the value it receives and, within the scope of that binding, processes the clauses clause1 clause2 ... in turn, as if contained within an implicit cond expression. This implicit cond expression is evaluated in the continuation of the guard expression, with old-proc as the current exception handler. \n\n" "If no else clause is provided, guard supplies one that reraises the exception with the same value, as if with raise-continuable, in the continuation of the call to procedure, with old-proc as the current exception handler. \n\n" "" "(guard (x [else x]) (raise \"oops\")) => \"oops\"\n(guard (x [#f #f]) (raise (make-error))) =>  error\n(define-syntax try\n  (syntax-rules ()\n    [(_ e1 e2 ...)\n     (guard (x [(error? x) #f]) e1 e2 ...)]))\n(define open-one\n  (lambda fn*\n    (let loop ([ls fn*])\n      (if (null? ls)\n          (error 'open-one \"all open attempts failed\" fn*)\n          (or (try (open-input-file (car ls)))\n              (loop (cdr ls)))))))\n; say bar.ss exists but not foo.ss:\n(open-one \"foo.ss\" \"bar.ss\") => #<input port bar.ss>\n\n") ("exceptions:s13" "syntax: &condition \nlibraries: (rnrs conditions), (rnrs)  \n\n" "&condition is a record-type name (Chapter 9) and the root of the condition-type hierarchy. All simple condition types are extensions of this type, and all conditions, whether simple or compound, are considered instances of this type. \n\n") ("exceptions:s14" "procedure: (condition? obj)\nreturns: #t if obj is a condition object, otherwise #f \nlibraries: (rnrs conditions), (rnrs)  \n\n" "A condition object is an instance of a subtype of &condition or a compound condition, possibly created by user code with condition.  \n\n" "" "(condition? 'stable) => #f\n(condition? (make-error)) => #t\n(condition? (make-message-condition \"oops\")) => #t\n(condition?\n  (condition\n    (make-error)\n    (make-message-condition \"no such element\"))) => #t\n\n") ("exceptions:s15" "procedure: (condition condition ...)\nreturns: a condition, possibly compound \nlibraries: (rnrs conditions), (rnrs)  \n\n" "condition is used to create condition objects that may consist of multiple simple conditions. Each argument condition may be simple or complex; if simple, it is treated as a compound condition with itself as its only simple condition. The simple conditions of the result condition are the simple conditions of the condition arguments, flattened into a single list and appearing in order, with the simple conditions of the first condition followed by the simple conditions of the second, and so on. \n\n" "If the list has exactly one element, the result condition may be simple or compound; otherwise it is compound. The distinction between simple and compound conditions is not usually important but can be detected, if define-record-type rather than define-condition-type is used to extend an existing condition type, via the predicate defined by define-record-type.  \n\n" "" "(condition) => #<condition>\n(condition\n  (make-error)\n  (make-message-condition \"oops\")) => #<condition> \n\n(define-record-type (&xcond make-xcond xcond?) (parent &condition))\n(xcond? (make-xcond)) => #t\n(xcond? (condition (make-xcond))) => #t or #f\n(xcond? (condition)) => #f\n(xcond? (condition (make-error) (make-xcond))) => #f\n\n") ("exceptions:s16" "procedure: (simple-conditions condition)\nreturns: a list of the simple conditions of condition \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "(simple-conditions (condition)) => '()\n(simple-conditions (make-error)) => (#<condition &error>)\n(simple-conditions (condition (make-error))) => (#<condition &error>)\n(simple-conditions\n  (condition\n    (make-error)\n    (make-message-condition\n      \"oops\"))) => (#<condition &error> #<condition &message>) \n\n(let ([c1 (make-error)]\n      [c2 (make-who-condition \"f\")]\n      [c3 (make-message-condition \"invalid argument\")]\n      [c4 (make-message-condition\n            \"error occurred while reading from file\")]\n      [c5 (make-irritants-condition '(\"a.ss\"))])\n  (equal?\n    (simple-conditions\n      (condition\n        (condition (condition c1 c2) c3)\n        (condition c4 (condition c5))))\n    (list c1 c2 c3 c4 c5))) => #t\n\n") ("exceptions:s17" "syntax: (define-condition-type name parent constructor pred field ...)\nlibraries: (rnrs conditions), (rnrs)  \n\n" "A define-condition-type form is a definition and may appear anywhere other definitions may appear. It is used to define new simple condition types. \n\n" "The subforms name, parent, constructor, and pred must be identifiers. Each field must be of the form (field-name accessor-name), where field-name and accessor-name are identifiers. \n\n" "define-condition-type defines name as a new record type whose parent record type is parent, whose constructor name is constructor, whose predicate name is pred, whose fields are field-name ..., and whose field accessors are named by accessor-name .... \n\n" "With the exception of the predicate and field accessors, define-condition-type is essentially an ordinary record definition equivalent to \n\n" "" "(define-record-type (name constructor pred)\n  (parent parent)\n  (fields ((immutable field-name accessor-name) ...)))\n\n" "The predicate differs from one that would be generated by a define-record-type form in that it returns #t not only for an instance of the new type but also for compound conditions whose simple conditions include an instance of the new type. Similarly, field accessors accept instances of the new type as well as compound conditions whose simple conditions include at least one instance of the new record type. If an accessor receives a compound condition whose simple conditions list includes one or more instances of the new type, the accessor operates on the first instance in the list. \n\n" "" "(define-condition-type &mistake &condition make-mistake mistake?\n  (type mistake-type)) \n\n(mistake? 'booboo) => #f \n\n(define c1 (make-mistake 'spelling))\n(mistake? c1) => #t\n(mistake-type c1) => spelling \n\n(define c2 (condition c1 (make-irritants-condition '(eggregius))))\n(mistake? c2) => #t\n(mistake-type c2) => spelling\n(irritants-condition? c2) => #t\n(condition-irritants c2) => (eggregius)\n\n") ("exceptions:s18" "procedure: (condition-predicate rtd)\nreturns: a condition predicate \nprocedure: (condition-accessor rtd procedure)\nreturns: a condition accessor \nlibraries: (rnrs conditions), (rnrs)  \n\n" "These procedures may be used to create the same kind of special predicates and accessors that are created by define-record-type from a record-type descriptor, rtd, of a simple condition type or other type derived from a simple condition type. \n\n" "For both procedures, rtd must be a record-type descriptor of a subtype of &condition, and for condition-accessor, procedure should accept one argument. \n\n" "The predicate returned by condition-predicate accepts one argument, which may be any Scheme value. The predicate returns #t if the value is a condition of the type described by rtd, i.e., an instance of the type described by rtd (or one of its subtypes) or a compound condition whose simple conditions include an instance of the type described by rtd. Otherwise, the predicate returns #f.  \n\n" "The accessor returned by condition-accessor accepts one argument, c, which must be a condition of the type described by rtd. The accessor applies procedure to a single argument, the first element of c's simple condition list that is an instance of the type described by rtd (this is c itself if c is a simple condition), and returns the result of this application. In most situations, procedure is a record accessor for a field of the type described by rtd. \n\n" "" "(define-record-type (&mistake make-mistake $mistake?)\n  (parent &condition)\n  (fields (immutable type $mistake-type))) \n\n; define predicate and accessor as if we'd used define-condition-type\n(define rtd (record-type-descriptor &mistake))\n(define mistake? (condition-predicate rtd))\n(define mistake-type (condition-accessor rtd $mistake-type)) \n\n(define c1 (make-mistake 'spelling))\n(define c2 (condition c1 (make-irritants-condition '(eggregius))))\n(list (mistake? c1) (mistake? c2)) => (#t #t)\n(list ($mistake? c1) ($mistake? c2)) => (#t #f)\n(mistake-type c1) => spelling\n($mistake-type c1) => spelling\n(mistake-type c2) => spelling\n($mistake-type c2) => violation\n\n") ("exceptions:s19" "syntax: &serious \nprocedure: (make-serious-condition) \nreturns: a condition of type &serious \nprocedure: (serious-condition? obj)\nreturns: #t if obj is a condition of type &serious, #f otherwise \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "Conditions of this type indicate situations of a serious nature that, if uncaught, generally result in termination of the program's execution. Conditions of this type typically occur as one of the more specific subtypes &error or &violation. This condition type might be defined as follows. \n\n" "(define-condition-type &serious &condition\n  make-serious-condition serious-condition?)\n\n") ("exceptions:s20" "syntax: &violation \nprocedure: (make-violation) \nreturns: a condition of type &violation \nprocedure: (violation? obj)\nreturns: #t if obj is a condition of type &violation, #f otherwise \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "Conditions of this type indicate that the program has violated some requirement, usually due to a bug in the program. This condition type might be defined as follows. \n\n" "(define-condition-type &violation &serious\n  make-violation violation?)\n\n") ("exceptions:s21" "syntax: &assertion \nprocedure: (make-assertion-violation) \nreturns: a condition of type &assertion \nprocedure: (assertion-violation? obj)\nreturns: #t if obj is a condition of type &assertion, #f otherwise \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "This condition type indicates a specific violation in which  the program has passed the wrong number or types of arguments to a procedure. This condition type might be defined as follows. \n\n" "(define-condition-type &assertion &violation\n  make-assertion-violation assertion-violation?)\n\n") ("exceptions:s22" "syntax: &error \nprocedure: (make-error) \nreturns: a condition of type &error \nprocedure: (error? obj)\nreturns: #t if obj is a condition of type &error, #f otherwise \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "Conditions of this type indicate that an error has occurred with the program's interaction with its operating environment, such as the failure of an attempt to open a file. It is not used to describe situations in which an error in the program has been detected. This condition type might be defined as follows. \n\n" "(define-condition-type &error &serious\n  make-error error?)\n\n") ("exceptions:s23" "syntax: &warning \nprocedure: (make-warning) \nreturns: a condition of type &warning \nprocedure: (warning? obj)\nreturns: #t if obj is a condition of type &warning, #f otherwise \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "Warning conditions indicate situations that do not prevent the program from continuing its execution but, in some cases, might result in a more serious problem at some later point. For example, a compiler might use a condition of this type to indicate that it has processed a call to a standard procedure with the wrong number of arguments; this will not become a serious problem unless the call is actually evaluated at some later point. This condition type might be defined as follows. \n\n" "(define-condition-type &warning &condition\n  make-warning warning?)\n\n") ("exceptions:s24" "syntax: &message \nprocedure: (make-message-condition message)\nreturns: a condition of type &message \nprocedure: (message-condition? obj)\nreturns: #t if obj is a condition of type &message, #f otherwise \nprocedure: (condition-message condition)\nreturns: the contents of condition's message field \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "Conditions of this type are usually included with a &warning condition or one of the &serious condition subtypes to provide a more specific description of the exceptional situation. The message argument to the constructor may be any Scheme value but is typically a string. This condition type might be defined as follows. \n\n" "(define-condition-type &message &condition\n  make-message-condition message-condition?\n  (message condition-message))\n\n") ("exceptions:s25" "syntax: &irritants \nprocedure: (make-irritants-condition irritants)\nreturns: a condition of type &irritants \nprocedure: (irritants-condition? obj)\nreturns: #t if obj is a condition of type &irritants, #f otherwise \nprocedure: (condition-irritants condition)\nreturns: the contents of condition's irritants field \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "Conditions of this type are usually included with a &message condition to provide information about Scheme values that may have caused or been materially involved in the exceptional situation. For example, if a procedure receives the wrong type of argument, it may raise an exception with a compound condition consisting of an assertion condition, a who condition naming the procedure, a message condition stating that the wrong type of argument was received, and an irritants condition listing the argument. The irritants argument to the constructor should be a list. This condition type might be defined as follows. \n\n" "(define-condition-type &irritants &condition\n  make-irritants-condition irritants-condition?\n  (irritants condition-irritants))\n\n") ("exceptions:s26" "syntax: &who \nprocedure: (make-who-condition who)\nreturns: a condition of type &who \nprocedure: (who-condition? obj)\nreturns: #t if obj is a condition of type &who, #f otherwise \nprocedure: (condition-who condition)\nreturns: the contents of condition's who field \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "Conditions of this type are often included with a &message condition to identify the syntactic form or procedure that detected the error. The who argument to the constructor should be a symbol or string. This condition type might be defined as follows. \n\n" "(define-condition-type &who &condition\n  make-who-condition who-condition?\n  (who condition-who))\n\n") ("exceptions:s27" "syntax: &non-continuable \nprocedure: (make-non-continuable-violation) \nreturns: a condition of type &non-continuable \nprocedure: (non-continuable-violation? obj)\nreturns: #t if obj is a condition of type &non-continuable, #f otherwise \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "Conditions of this type indicate that a non-continuable violation has occurred. raise raises an exception with this type if the current exception handler returns. This condition type might be defined as follows. \n\n" "(define-condition-type &non-continuable &violation\n  make-non-continuable-violation\n  non-continuable-violation?)\n\n") ("exceptions:s28" "syntax: &implementation-restriction \nprocedure: (make-implementation-restriction-violation) \nreturns: a condition of type &implementation-restriction \nprocedure: (implementation-restriction-violation? obj)\nreturns: #t if obj is a condition of type &implementation-restriction, #f otherwise \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "An implementation-restriction condition indicates that the program has attempted to exceed some limitation in the implementation, such as when the value of a fixnum addition operation would result in a number that exceeds the implementation's fixnum range. It does not normally indicate a deficiency in the implementation but rather a mismatch between what the program is attempting to do and what the implementation can support. In many cases, implementation restrictions are dictated by the underlying hardware. This condition type might be defined as follows. \n\n" "(define-condition-type &implementation-restriction &violation\n  make-implementation-restriction-violation\n  implementation-restriction-violation?)\n\n") ("exceptions:s29" "syntax: &lexical \nprocedure: (make-lexical-violation) \nreturns: a condition of type &lexical \nprocedure: (lexical-violation? obj)\nreturns: #t if obj is a condition of type &lexical, #f otherwise \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "Conditions of this type indicate that a lexical error has occurred in the parsing of a Scheme program or datum, such as mismatched parentheses or an invalid character appearing within a numeric constant. This condition type might be defined as follows. \n\n" "(define-condition-type &lexical &violation\n  make-lexical-violation lexical-violation?)\n\n") ("exceptions:s30" "syntax: &syntax \nprocedure: (make-syntax-violation form subform)\nreturns: a condition of type &syntax \nprocedure: (syntax-violation? obj)\nreturns: #t if obj is a condition of type &syntax, #f otherwise \nprocedure: (syntax-violation-form condition)\nreturns: the contents of condition's form field \nprocedure: (syntax-violation-subform condition)\nreturns: the contents of condition's subform field \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "Conditions of this type indicate that a syntax error has occurred in the parsing of a Scheme program. In most implementations, syntax errors are detected by the macro expander. Each of the form and subform arguments to make-syntax-violation should be a syntax object (Section 8.3) or datum, the former indicating the containing form and the latter indicating the specific subform. For example, if a duplicate formal parameter is found in a lambda expression, form might be the lambda expression and subform might be the duplicated parameter. If there is no need to identify a subform, subform should be #f. This condition type might be defined as follows. \n\n" "(define-condition-type &syntax &violation\n  make-syntax-violation syntax-violation?\n  (form syntax-violation-form)\n  (subform syntax-violation-subform))\n\n") ("exceptions:s31" "syntax: &undefined \nprocedure: (make-undefined-violation) \nreturns: a condition of type &undefined \nprocedure: (undefined-violation? obj)\nreturns: #t if obj is a condition of type &undefined, #f otherwise \nlibraries: (rnrs conditions), (rnrs)  \n\n" "" "An undefined condition indicates an attempt to reference an unbound variable. This condition type might be defined as follows. \n\n" "(define-condition-type &undefined &violation\n  make-undefined-violation undefined-violation?)\n\n" "" "The next several condition types describe conditions that occur when input or output operations fail in some manner. \n\n") ("exceptions:s32" "syntax: &i/o \nprocedure: (make-i/o-error) \nreturns: a condition of type &i/o \nprocedure: (i/o-error? obj)\nreturns: #t if obj is a condition of type &i/o, #f otherwise \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)  \n\n" "" "A condition of type &i/o indicates that an input/output error of some sort has occurred. Conditions of this type typically occur as one of the more specific subtypes described below. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o &error\n  make-i/o-error i/o-error?)\n\n") ("exceptions:s33" "syntax: &i/o-read \nprocedure: (make-i/o-read-error) \nreturns: a condition of type &i/o-read \nprocedure: (i/o-read-error? obj)\nreturns: #t if obj is a condition of type &i/o-read, #f otherwise \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)  \n\n" "" "This condition type indicates that an error has occurred while reading from a port. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-read &i/o\n  make-i/o-read-error i/o-read-error?)\n\n") ("exceptions:s34" "syntax: &i/o-write \nprocedure: (make-i/o-write-error) \nreturns: a condition of type &i/o-write \nprocedure: (i/o-write-error? obj)\nreturns: #t if obj is a condition of type &i/o-write, #f otherwise \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)  \n\n" "" "This condition type indicates that an error has occurred while writing to a port. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-write &i/o\n  make-i/o-write-error i/o-write-error?)\n\n") ("exceptions:s35" "syntax: &i/o-invalid-position \nprocedure: (make-i/o-invalid-position-error position)\nreturns: a condition of type &i/o-invalid-position \nprocedure: (i/o-invalid-position-error? obj)\nreturns: #t if obj is a condition of type &i/o-invalid-position, #f otherwise \nprocedure: (i/o-error-position condition)\nreturns: the contents of condition's position field \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)  \n\n" "" "This condition type indicates an attempt to set a port's position to a position that is out of range for the underlying file or other object. The position argument to the constructor should be the invalid position. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-invalid-position &i/o\n  make-i/o-invalid-position-error\n  i/o-invalid-position-error?\n  (position i/o-error-position))\n\n") ("exceptions:s36" "syntax: &i/o-filename \nprocedure: (make-i/o-filename-error filename)\nreturns: a condition of type &i/o-filename \nprocedure: (i/o-filename-error? obj)\nreturns: #t if obj is a condition of type &i/o-filename, #f otherwise \nprocedure: (i/o-error-filename condition)\nreturns: the contents of condition's filename field \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)  \n\n" "" "This condition type indicates an input/output error that occurred while operating on a file. The filename argument to the constructor should be the name of the file. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-filename &i/o\n  make-i/o-filename-error i/o-filename-error?\n  (filename i/o-error-filename))\n\n") ("exceptions:s37" "syntax: &i/o-file-protection \nprocedure: (make-i/o-file-protection-error filename)\nreturns: a condition of type &i/o-file-protection \nprocedure: (i/o-file-protection-error? obj)\nreturns: #t if obj is a condition of type &i/o-file-protection, #f otherwise \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)  \n\n" "" "A condition of this type indicates that an attempt has been made to perform some input/output operation on a file for which the program does not have the proper permission. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-file-protection &i/o-filename\n  make-i/o-file-protection-error\n  i/o-file-protection-error?)\n\n") ("exceptions:s38" "syntax: &i/o-file-is-read-only \nprocedure: (make-i/o-file-is-read-only-error filename)\nreturns: a condition of type &i/o-file-is-read-only \nprocedure: (i/o-file-is-read-only-error? obj)\nreturns: #t if obj is a condition of type &i/o-file-is-read-only, #f otherwise \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)  \n\n" "" "A condition of this type indicates an attempt to treat as writeable a read-only file. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-file-is-read-only &i/o-file-protection\n  make-i/o-file-is-read-only-error\n  i/o-file-is-read-only-error?)\n\n") ("exceptions:s39" "syntax: &i/o-file-already-exists \nprocedure: (make-i/o-file-already-exists-error filename)\nreturns: a condition of type &i/o-file-already-exists \nprocedure: (i/o-file-already-exists-error? obj)\nreturns: #t if obj is a condition of type &i/o-file-already-exists, #f otherwise \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)  \n\n" "" "A condition of this type indicates a situation in which an operation on a file failed because the file already exists, e.g., an attempt is made to open an existing file for output without the no-fail file option. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-file-already-exists &i/o-filename\n  make-i/o-file-already-exists-error\n  i/o-file-already-exists-error?)\n\n") ("exceptions:s40" "syntax: &i/o-file-does-not-exist \nprocedure: (make-i/o-file-does-not-exist-error filename)\nreturns: a condition of type &i/o-file-does-not-exist \nprocedure: (i/o-file-does-not-exist-error? obj)\nreturns: #t if obj is a condition of type &i/o-file-does-not-exist, #f otherwise \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)  \n\n" "" "A condition of this type indicates a situation in which an operation on a file failed because the file does not exist, e.g., an attempt is made to open a nonexistent file for input only. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-file-does-not-exist &i/o-filename\n  make-i/o-file-does-not-exist-error\n  i/o-file-does-not-exist-error?)\n\n") ("exceptions:s41" "syntax: &i/o-port \nprocedure: (make-i/o-port-error pobj)\nreturns: a condition of type &i/o-port \nprocedure: (i/o-port-error? obj)\nreturns: #t if obj is a condition of type &i/o-port, #f otherwise \nprocedure: (i/o-error-port condition)\nreturns: the contents of condition's pobj field \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs files), (rnrs)  \n\n" "" "A condition of this type is usually included with a condition of one of the other &i/o subtypes to indicate the port involved in the exceptional situation, if a port is involved. The pobj argument to the constructor should be the port. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-port &i/o\n  make-i/o-port-error i/o-port-error?\n  (pobj i/o-error-port))\n\n") ("exceptions:s42" "syntax: &i/o-decoding \nprocedure: (make-i/o-decoding-error pobj)\nreturns: a condition of type &i/o-decoding \nprocedure: (i/o-decoding-error? obj)\nreturns: #t if obj is a condition of type &i/o-decoding, #f otherwise \nlibraries: (rnrs io ports), (rnrs)  \n\n" "" "A condition of this type indicates that a decoding error has occurred during the transcoding of bytes to characters. The pobj argument to the constructor should be the port involved, if any. The port should be positioned past the invalid encoding. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-decoding &i/o-port\n  make-i/o-decoding-error i/o-decoding-error?)\n\n") ("exceptions:s43" "syntax: &i/o-encoding \nprocedure: (make-i/o-encoding-error pobj cobj)\nreturns: a condition of type &i/o-encoding \nprocedure: (i/o-encoding-error? obj)\nreturns: #t if obj is a condition of type &i/o-encoding, #f otherwise \nprocedure: (i/o-encoding-error-char condition)\nreturns: the contents of condition's cobj field \nlibraries: (rnrs io ports), (rnrs)  \n\n" "" "A condition of this type indicates that an encoding error has occurred during the transcoding of characters to bytes. The pobj argument to the constructor should be the port involved, if any, and the cobj argument should be the character for which the encoding failed. This condition type might be defined as follows. \n\n" "(define-condition-type &i/o-encoding &i/o-port\n  make-i/o-encoding-error i/o-encoding-error?\n  (cobj i/o-encoding-error-char))\n\n" "" "The final two condition types describe conditions that occur when implementations are required to produce a NaN or infinity but have no representations for these values. \n\n") ("exceptions:s44" "syntax: &no-infinities \nprocedure: (make-no-infinities-violation) \nreturns: a condition of type &no-infinities \nprocedure: (no-infinities-violation? obj)\nreturns: #t if obj is a condition of type &no-infinities, #f otherwise \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "" "This condition indicates that the implementation has no representation for infinity. This condition type might be defined as follows. \n\n" "(define-condition-type &no-infinities &implementation-restriction\n  make-no-infinities-violation\n  no-infinities-violation?)\n\n") ("exceptions:s45" "syntax: &no-nans \nprocedure: (make-no-nans-violation) \nreturns: a condition of type &no-nans \nprocedure: (no-nans-violation? obj)\nreturns: #t if obj is a condition of type &no-nans, #f otherwise \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "" "This condition indicates that the implementation has no representation for NaN. This condition type might be defined as follows. \n\n" "(define-condition-type &no-nans &implementation-restriction\n  make-no-nans-violation no-nans-violation?)\n\n" "") ("libraries:s17" "procedure: (command-line) \nreturns: a list of strings representing command-line arguments \nlibraries: (rnrs programs), (rnrs)  \n\n" "This procedure may be used within a top-level program to obtain a list of the command-line arguments passed to the program. \n\n") ("libraries:s18" "procedure: (exit) \nprocedure: (exit obj)\nreturns: does not return \nlibraries: (rnrs programs), (rnrs)  \n\n" "This procedure may be used to exit from a top-level program to the operating system. If no obj is given, the exit value returned to the operating system should indicate a normal exit. If obj is false, the exit value returned to the operating system should indicate an abnormal exit. Otherwise, obj is translated into an exit value as appropriate for the operating system. \n\n") ("records:s13" "syntax: (define-record-type record-name clause ...)\nsyntax: (define-record-type (record-name constructor pred) clause ...)\nlibraries: (rnrs records syntactic), (rnrs)  \n\n" "A define-record-type form, or record definition, is a definition and may appear anywhere other definitions may appear. It defines a record type identified by record-name, plus a predicate, constructor, accessors, and mutators for the record type. If the record definition takes the first form above, the names of the constructor and predicate are derived from record-name: make-record-namefor the constructor and record-name? for the predicate. If the record definition takes the second form above, the name of the constructor is constructor and the name of the predicate is pred. All names defined by a record definition are scoped where the record definition appears. \n\n" "The clauses clause ... of the record definition determine the fields of the record type and the names of their accessors and mutators; its parent type, if any; its construction protocol; whether it is nongenerative and, if so, whether its uid is specified; whether it is sealed; and whether it is opaque. The syntax and impact of each clause is described below. \n\n" "None of the clauses is required; thus, the simplest record definition is \n\n" "" "(define-record-type record-name)\n\n" "which defines a new, generative, non-sealed, non-opaque record type with no parent and no fields, plus a constructor of no arguments and a predicate. \n\n" "At most one of each kind of clause may be present in the set of clauses, and if a parent clause is present, a parent-rtd clause must not be present. The clauses that appear may appear in any order. \n\n" "" "Fields clause.  A (fields field-spec ...) clause declares the fields of the record type. Each field-spec must take one of the following forms: \n\n" "" "field-name\n(immmutable field-name)\n(mutable field-name)\n(immmutable field-name accessor-name)\n(mutable field-name accessor-name mutator-name)\n\n" "where field-name, accessor-name, and mutator-name are identifiers. The first form, field-name, is equivalent to (immutable field-name). The value of a field declared immutable may not be changed, and no mutator is created for it. With the first three forms, the name of the accessor is rname-fname, where rname is the record name and fname is the field name. With the third form, the name of the accessor is rname-fname-set!. The fourth and fifth forms explicitly declare the accessor and mutator names. \n\n" "If no fields clause is present or the list field-spec ...is empty, the record type has no fields (other than parent fields, if any). \n\n" "" "Parent clause.  A (parent parent-name) clause declares the parent record type; parent-name must be the name of a non-sealed record type previously defined via define-record-type. Instances of a record type are also considered instances of its parent record type and have all the fields of its parent record type in addition to those declared via the fields clause.  \n\n" "" "Nongenerative clause.  A nongenerative clause may take one of two forms:  \n\n" "" "(nongenerative)\n (nongenerative uid)\n\n" "where uid is a symbol. The first form is equivalent to the second, with a uid generated by the implementation at macro-expansion time. When a define-record-type form with a nongenerative clause is evaluated, a new type is created if and only if the uid is not the uid of an existing record type. \n\n" "If it is the uid of an existing record type, the parent, field-names, sealed property, and opaque property must match as follows. \n\n" "\n* If a parent is specified, the existing record type must have the same parent rtd (by eqv?). If a parent is not specified, the existing record type must not have a parent. \n* The same number of fields must be provided, with the same names and in the same order, and the mutability of each field must be the same. \n* If a (sealed #t) clause is present, the existing record type must be sealed. Otherwise, the existing record type must not be sealed. \n* If an (opaque #t) clause is present, the existing record type must be opaque. Otherwise, the existing record type must be opaque if and only if an opaque parent type is specified. \n\n" "" "If these constraints are met, no new record type is created, and the other products of the record-type definition (constructor, predicate, accessors, and mutators) operate on records of the existing type. If these constraints are not met, the implementation may treat it as a syntax violation, or it may raise a run-time exception with condition type &assertion.  \n\n" "With the first form of nongenerative clause, the generated uid can be the uid of an existing record type only if the same definition is executed multiple times, e.g., if it appears in the body of a procedure that is invoked multiple times. \n\n" "If uid is not the uid of an existing record type, or if no nongenerative clause is present, a new record type is created.  \n\n" "" "Protocol clause.  A (protocol expression) determines the protocol that the generated constructor uses to construct instances of the record type. It must evaluate to a procedure, and this procedure should be an appropriate protocol for the record type, as described on page 326. \n\n" "" "Sealed clause.  A sealed clause of the form (sealed #t) declares that the record type is sealed. This means that it cannot be extended, i.e., cannot be used as the parent for another record definition or make-record-type-descriptor call. If no sealed clause is present or if one of the form (sealed #f) is present, the record type is not sealed. \n\n" "" "Opaque clause.  An opaque clause of the form (opaque #t) declares that the record type is opaque. Instances of an opaque record type are not considered records by the record? predicate or, more importantly, the rtd-extraction procedure record-rtd, which are both described in Section 9.3. Thus, it is not possible for code that does not have access to the record-name, accessors, or mutators to access or modify any of the fields of an opaque record type. A record type is also opaque if its parent is opaque. If no opaque clause is present or if one of the form (opaque #f) is present, and the parent, if any, is not opaque, the record type is not opaque. \n\n" "" "Parent-rtd clause.  A (parent-rtd parent-rtd parent-rcd) clause is an alternative to the parent clause for specifying the parent record type, along with a parent record constructor descriptor. It is primarily useful when the parent rtd and rcd were obtained via calls to make-record-type-descriptor and make-record-constructor-descriptor.  \n\n" "parent-rtd must evaluate to an rtd or #f. If parent-rtd evaluates to #f, parent-rcd must also evaluate to #f. Otherwise, parent-rcd must evaluate to an rcd or #f. If parent-rcd evaluates to an rcd, it must encapsulate an rtd equivalent (by eqv?) to the value of parent-rtd. If the value of parent-rcd is #f, it is treated as an rcd for the value of parent-rtd with a default protocol. \n\n" "The define-record-type form is designed in such a way that it is normally possible for a compiler to determine the shapes of the record types it defines, including the offsets for all fields. This guarantee does not hold, however, when the parent-rtd clause is used, since the parent rtd might not be determinable until run time. Thus, the parent clause is preferred over the parent-rtd clause whenever the parent clause suffices.  \n\n") ("records:s16" "syntax: fields \nsyntax: mutable \nsyntax: immutable \nsyntax: parent \nsyntax: protocol \nsyntax: sealed \nsyntax: opaque \nsyntax: nongenerative \nsyntax: parent-rtd \nlibraries: (rnrs records syntactic), (rnrs)  \n\n" "These identifiers are auxiliary keywords for define-record-type. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords. \n\n") ("records:s20" "procedure: (make-record-type-descriptor name parent uid s? o? fields)\nreturns: a record-type descriptor (rtd) for a new or existing record type \nlibraries: (rnrs records procedural), (rnrs)  \n\n" "name must be a symbol, parent must be #f or the rtd of a non-sealed record type, uid must be #f or a symbol, and fields must be a vector, each element of which is a two-element list of the form (mutable field-name)or (immutable field-name). The field names field-name ... must be symbols and need not be distinct from each other. \n\n" "If uid is #f or is not the uid of an existing record type, this procedure creates a new record type and returns a record-type descriptor (rtd) for the new type.  The type has the parent type (page 325) described by parent, if nonfalse; the uid specified by uid, if nonfalse; and the fields specified by fields. It is sealed (page 330) if s? is nonfalse. It is opaque (page 330) if opaque is nonfalse or the parent (if specified) is opaque. The name of the new record type is name and the names of the fields are field-name .... \n\n" "If uid is nonfalse and is the uid (page 325) of an existing record type, the parent, fields, s?, and o? arguments must match the corresponding characteristics of the existing record type. That is, parent must be the same (by eqv?); the number of fields must be the same; the fields must have the same names, be in the same order, and have the same mutability; s? must be false if and only if the existing record type is sealed; and, if a parent is not specified or is not opaque, o? must be false if and only if the existing record type is opaque. If this is the case, make-record-type-descriptor returns the rtd for the existing record type. Otherwise, an exception with condition type &assertion is raised.  \n\n" "Using the rtd returned by make-record-type-descriptor, programs can generate constructors, type predicates, field accessors, and field mutators dynamically. The following code demonstrates how the procedural interface might be used to create a point record type and associated definitions similar to those of the second point record definition in Section 9.1, with a mutable x field and an immutable y field.  \n\n" "" "(define point-rtd (make-record-type-descriptor 'point #f #f #f #f\n                '#((mutable x) (immutable y))))\n(define point-rcd (make-record-constructor-descriptor point-rtd\n                    #f #f))\n(define make-point (record-constructor point-rcd))\n(define point? (record-predicate point-rtd))\n(define point-x (record-accessor point-rtd 0))\n(define point-y (record-accessor point-rtd 1))\n(define point-x-set! (record-mutator point-rtd 0))\n\n" "See the additional examples given at the end of this section. \n\n") ("records:s23" "procedure: (record-type-descriptor? obj)\nreturns: #f if obj is a record-type descriptor, otherwise #f \nlibraries: (rnrs records procedural), (rnrs)  \n\n" "See the examples given at the end of this section. \n\n") ("records:s24" "procedure: (make-record-constructor-descriptor rtd parent-rcd protocol)\nreturns: a record-constructor descriptor (rcd) \nlibraries: (rnrs records procedural), (rnrs)  \n\n" "An rtd alone is sufficient to create predicates, accessors, and mutators. To create a constructor, however, it is first necessary to create a record-constructor descriptor (rcd) for the record type. An rcd encapsulates three pieces of information: the rtd of the record type for which the rcd has been created, the parent rcd (if any), and the protocol. \n\n" "The parent-rcd argument must be an rcd or #f. If it is an rcd, rtd must have a parent rtd, and the parent rtd must be the same as the rtd encapsulated within parent-rcd. If parent-rcd is false, either rtd has no parent or an rcd with a default protocol is assumed for the parent. \n\n" "The protocol argument must be a procedure or #f. If it is #f, a default protocol is assumed. Protocols are discussed on page 326. \n\n" "See the examples given at the end of this section. \n\n") ("records:s28" "syntax: (record-type-descriptor record-name)\nreturns: the rtd for the record type identified by record-name \nsyntax: (record-constructor-descriptor record-name)\nreturns: the rcd for the record type identified by record-name \nlibraries: (rnrs records syntactic), (rnrs)  \n\n" "Each record definition creates, behind the scenes, an rtd and rcd for the defined record type. These procedures allow the rtd and rcd to be obtained and used like any other rtd or rcd. record-name must be the name of a record previously defined via define-record-type.  \n\n") ("records:s29" "procedure: (record-constructor rcd)\nreturns: a record constructor for the record type encapsulated within rcd \nlibraries: (rnrs records procedural), (rnrs)  \n\n" "The behavior of the record constructor is determined by the protocol and parent rcd (if any) also encapsulated within rcd. \n\n" "See the examples given at the end of this section. \n\n") ("records:s30" "procedure: (record-predicate rtd)\nreturns: a predicate for rtd \nlibraries: (rnrs records procedural), (rnrs)  \n\n" "This procedure returns a predicate that accepts one argument and returns #t if the argument is an instance of the record-type described by rtd, #f otherwise.  \n\n" "See the examples given at the end of this section. \n\n") ("records:s31" "procedure: (record-accessor rtd idx)\nreturns: an accessor for the field of rtd specified by idx \nlibraries: (rnrs records procedural), (rnrs)  \n\n" "idx must be a nonnegative integer less than the number of fields of rtd, not counting parent fields. An idx value of 0 specifies the first field given in the define-record-type form or make-record-type-descriptor call that created the record type, 1 specifies the second, and so on. \n\n" "A child rtd cannot be used directly to create accessors for parent fields. To create an accessor for a parent field, the record-type descriptor of the parent must be used instead. \n\n" "See the examples given at the end of this section. \n\n") ("records:s32" "procedure: (record-mutator rtd idx)\nreturns: a mutator for the field of rtd specified by idx \nlibraries: (rnrs records procedural), (rnrs)  \n\n" "idx must be a nonnegative integer less than the number of fields of rtd, not counting parent fields. An idx value of 0 specifies the first field given in the define-record-type form or make-record-type-descriptor call that created the record type, 1 specifies the second, and so on. The indicated field must be mutable; otherwise, an exception with condition type &assertion is raised.  \n\n" "A child rtd cannot be used directly to create mutators for parent fields. To create a mutator for a parent field, the record-type descriptor of the parent must be used instead. \n\n" "" "The following example illustrates the creation of parent and child record types, predicates, accessors, mutators, and constructors using the procedures described in this section. \n\n" "" "(define rtd/parent\n  (make-record-type-descriptor 'parent #f #f #f #f\n    '#((mutable x)))) \n\n(record-type-descriptor? rtd/parent) => #t\n(define parent? (record-predicate rtd/parent))\n(define parent-x (record-accessor rtd/parent 0))\n(define set-parent-x! (record-mutator rtd/parent 0)) \n\n(define rtd/child\n  (make-record-type-descriptor 'child rtd/parent #f #f #f\n    '#((mutable x) (immutable y)))) \n\n(define child? (record-predicate rtd/child))\n(define child-x (record-accessor rtd/child 0))\n(define set-child-x! (record-mutator rtd/child 0))\n(define child-y (record-accessor rtd/child 1)) \n\n(record-mutator rtd/child 1) => exception: immutable field\n\n(define rcd/parent\n  (make-record-constructor-descriptor rtd/parent #f\n    (lambda (new) (lambda (x) (new (* x x)))))) \n\n(record-type-descriptor? rcd/parent) => #f \n\n(define make-parent (record-constructor rcd/parent)) \n\n(define p (make-parent 10))\n(parent? p) => #t\n(parent-x p) => 100\n(set-parent-x! p 150)\n(parent-x p) => 150 \n\n(define rcd/child\n  (make-record-constructor-descriptor rtd/child rcd/parent\n    (lambda (pargs->new)\n      (lambda (x y)\n        ((pargs->new x) (+ x 5) y))))) \n\n(define make-child (record-constructor rcd/child))\n(define c (make-child 10 'cc))\n(parent? c) => #t\n(child? c) => #t\n(child? p) => #f \n\n(parent-x c) => 100\n(child-x c) => 15\n(child-y c) => cc \n\n(child-x p) => exception: invalid argument type\n\n") ("records:s34" "procedure: (record-type-name rtd)\nreturns: the name associated with rtd \nlibraries: (rnrs records inspection), (rnrs)  \n\n" "" "(define record->name\n  (lambda (x)\n    (and (record? x) (record-type-name (record-rtd x))))) \n\n(define-record-type dim (fields w l h))\n(record->name (make-dim 10 15 6)) => dim \n\n(define-record-type dim (fields w l h) (opaque #t))\n(record->name (make-dim 10 15 6)) => #f\n\n") ("records:s35" "procedure: (record-type-parent rtd)\nreturns: the parent of rtd, or #f if it has no parent \nlibraries: (rnrs records inspection), (rnrs)  \n\n" "" "(define-record-type point (fields x y))\n(define-record-type cpoint (parent point) (fields color))\n(record-type-parent (record-type-descriptor point)) => #f\n(record-type-parent (record-type-descriptor cpoint)) => #<rtd>\n\n") ("records:s36" "procedure: (record-type-uid rtd)\nreturns: the uid of rtd, or #f if it has no uid \nlibraries: (rnrs records inspection), (rnrs)  \n\n" "Whether a record type created without a programmer-supplied uid actually has one anyway is left up to the implementation, so this procedure is never guaranteed to return #f.  \n\n" "" "(define-record-type point (fields x y))\n(define-record-type cpoint\n  (parent point)\n  (fields color)\n  (nongenerative e40cc926-8cf4-4559-a47c-cac636630314))\n(record-type-uid (record-type-descriptor point)) => unspecified\n(record-type-uid (record-type-descriptor cpoint)) =>\n                             e40cc926-8cf4-4559-a47c-cac636630314\n\n") ("records:s37" "procedure: (record-type-generative? rtd)\nreturns: #t if the record type described by rtd is generative, #f otherwise \nprocedure: (record-type-sealed? rtd)\nreturns: #t if the record type described by rtd is sealed, #f otherwise \nprocedure: (record-type-opaque? rtd)\nreturns: #t if the record type described by rtd is opaque, #f otherwise \nlibraries: (rnrs records inspection), (rnrs)  \n\n" "" "(define-record-type table\n  (fields keys vals)\n  (opaque #t))\n(define rtd (record-type-descriptor table))\n(record-type-generative? rtd) => #t\n(record-type-sealed? rtd) => #f\n(record-type-opaque? rtd) => #t \n\n(define-record-type cache-table\n  (parent table)\n  (fields key val)\n  (nongenerative))\n(define rtd (record-type-descriptor cache-table))\n(record-type-generative? rtd) => #f\n(record-type-sealed? rtd) => #f\n(record-type-opaque? rtd) => #t\n\n") ("records:s38" "procedure: (record-type-field-names rtd)\nreturns: a vector containing the names of the fields of the type described by rtd \nlibraries: (rnrs records inspection), (rnrs)  \n\n" "The vector returned by this procedure is immutable: the effect on rtd of modifying it is unspecified. The vector does not include parent field names. The order of the names in the vector is the same as the order in which the fields were specified in the define-record-type form or make-record-type-descriptor call that created the record type.  \n\n" "" "(define-record-type point (fields x y))\n(define-record-type cpoint (parent point) (fields color))\n(record-type-field-names\n  (record-type-descriptor point)) => #(x y)\n(record-type-field-names\n  (record-type-descriptor cpoint)) => #(color)\n\n") ("records:s39" "procedure: (record-field-mutable? rtd idx)\nreturns: #t if the specified field of rtd is mutable, #f otherwise \nlibraries: (rnrs records inspection), (rnrs)  \n\n" "idx must be a nonnegative integer less than the number of fields of rtd, not counting parent fields. An idx value of 0 specifies the first field given in the define-record-type form or make-record-type-descriptor call that created the record type, 1 specifies the second, and so on. \n\n" "" "(define-record-type point (fields (mutable x) (mutable y)))\n(define-record-type cpoint (parent point) (fields color)) \n\n(record-field-mutable? (record-type-descriptor point) 0) => #t\n(record-field-mutable? (record-type-descriptor cpoint) 0) => #f\n\n") ("records:s40" "procedure: (record? obj)\nreturns: #t if obj is a non-opaque record instance, #f otherwise \nlibraries: (rnrs records inspection), (rnrs)  \n\n" "When passed an instance of an opaque record type, record? returns #f. While an instance of an opaque record type is, in essence, a record, the point of opacity is to hide all representation information from the parts of a program that should not have access to the information, and this includes whether an object is a record. Furthermore, the primary purpose of this predicate is to allow programs to check whether it is possible to obtain from the argument an rtd via the record-rtd procedure described below.  \n\n" "" "(define-record-type statement (fields str))\n(define q (make-statement \"He's dead, Jim\"))\n(statement? q) => #t\n(record? q) => #t \n\n(define-record-type opaque-statement (fields str) (opaque #t))\n(define q (make-opaque-statement \"He's moved on, Jim\"))\n(opaque-statement? q) => #t\n(record? q) => #f\n\n") ("records:s41" "procedure: (record-rtd record)\nreturns: the record-type descriptor (rtd) of record \nlibraries: (rnrs records inspection), (rnrs)  \n\n" "The argument must be an instance of a non-opaque record type. In combination with some of the other procedures described in this section and Section 9.2, record-rtd allows the inspection or mutation of record instances, even if the type of the instance is unknown to the inspector. This capability is illustrated by the procedure print-fields below, which accepts a record argument and writes the name and value of each field of the record. \n\n" "" "(define print-fields\n  (lambda (r)\n    (unless (record? r)\n      (assertion-violation 'print-fields \"not a record\" r))\n    (let loop ([rtd (record-rtd r)])\n      (let ([prtd (record-type-parent rtd)])\n        (when prtd (loop prtd)))\n      (let* ([v (record-type-field-names rtd)]\n             [n (vector-length v)])\n        (do ([i 0 (+ i 1)])\n            ((= i n))\n          (write (vector-ref v i))\n          (display \"=\")\n          (write ((record-accessor rtd i) r))\n          (newline))))))\n\n" "With the familiar definitions of point and cpoint:  \n\n" "" "(define-record-type point (fields x y))\n(define-record-type cpoint (parent point) (fields color))\n\n" "the expression (print-fields (make-cpoint -3 7 'blue)) displays the following three lines. \n\n" "" "x=-3\n y=7\ncolor=blue\n\n" "") ("syntax:s12" "syntax: (define-syntax keyword expr)\nlibraries: (rnrs base), (rnrs)  \n\n" "expr must evaluate to a transformer. \n\n" "The following example defines let* as a syntactic extension, specifying the transformer with syntax-rules (see Section 8.2). \n\n" "" "(define-syntax let*\n  (syntax-rules ()\n    [(_ () b1 b2 ...) (let () b1 b2 ...)]\n    [(_ ((i1 e1) (i2 e2) ...) b1 b2 ...)\n     (let ([i1 e1])\n       (let* ([i2 e2] ...) b1 b2 ...))]))\n\n" "All bindings established by a set of internal definitions, whether keyword or variable definitions, are visible everywhere within the immediately enclosing body, including within the definitions themselves. For example, the expression \n\n" "" "(let ()\n  (define even?\n    (lambda (x)\n      (or (= x 0) (odd? (- x 1)))))\n  (define-syntax odd?\n    (syntax-rules ()\n      [(_ x) (not (even? x))]))\n  (even? 10))\n\n" "is valid and should evaluate to #t.  \n\n" "The expander processes the initial forms in a library, lambda, or other body from left to right. If it encounters a variable definition, it records the fact that the defined identifier is a variable but defers expansion of the right-hand-side expression until after all of the definitions have been processed. If it encounters a keyword definition, it expands and evaluates the right-hand-side expression and binds the keyword to the resulting transformer. If it encounters an expression, it fully expands all deferred right-hand-side expressions along with the current and remaining body expressions. \n\n" "An implication of the left-to-right processing order is that one internal definition can affect whether a subsequent form is also a definition. For example, the expression \n\n" "" "(let ()\n  (define-syntax bind-to-zero\n    (syntax-rules ()\n      [(_ id) (define id 0)]))\n  (bind-to-zero x)\n  x)\n\n" "evaluates to 0, regardless of any binding for bind-to-zero that might appear outside of the let expression. \n\n") ("syntax:s13" "syntax: (let-syntax ((keyword expr) ...) form1 form2 ...)\nsyntax: (letrec-syntax ((keyword expr) ...) form1 form2 ...)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "Each expr must evaluate to a transformer. For let-syntax and letrec-syntax both, each keyword is bound within the forms form1 form2 .... For letrec-syntax the binding scope also includes each expr. \n\n" "A let-syntax or letrec-syntax form may expand into one or more expressions anywhere expressions are permitted, in which case the resulting expressions are treated as if enclosed in a begin expression. It may also expand into zero or more definitions anywhere definitions are permitted, in which case the definitions are treated as if they appeared in place of the let-syntax or letrec-syntax form.  \n\n" "The following example highlights how let-syntax and letrec-syntax differ.  \n\n" "" "(let ([f (lambda (x) (+ x 1))])\n  (let-syntax ([f (syntax-rules ()\n                       [(_ x) x])]\n               [g (syntax-rules ()\n                       [(_ x) (f x)])])\n    (list (f 1) (g 1)))) => (1 2) \n\n(let ([f (lambda (x) (+ x 1))])\n  (letrec-syntax ([f (syntax-rules ()\n                       [(_ x) x])]\n                  [g (syntax-rules ()\n                       [(_ x) (f x)])])\n    (list (f 1) (g 1)))) => (1 1)\n\n" "The two expressions are identical except that the let-syntax form in the first expression is a letrec-syntax form in the second. In the first expression, the f occurring in g refers to the let-bound variable f, whereas in the second it refers to the keyword f whose binding is established by the letrec-syntax form.  \n\n") ("syntax:s14" "syntax: (syntax-rules (literal ...) clause ...)\nreturns: a transformer \nlibraries: (rnrs base), (rnrs)  \n\n" "Each literal must be an identifier other than an underscore ( _ ) or ellipsis ( ... ). Each clause must take the form below. \n\n" "" "(pattern template)\n\n" "Each pattern specifies one possible syntax that the input form might take, and the corresponding template specifies how the output should appear. \n\n" "Patterns consist of list structure, vector structure, identifiers, and constants. Each identifier within a pattern is either a literal, a pattern variable, an underscore, or an ellipsis. The identifier _ is an underscore, and the identifier ... is an ellipsis. Any identifier other than _ or ... is a literal if it appears in the list of literals (literal ...); otherwise, it is a pattern variable. Literals serve as auxiliary keywords, such as else in case and cond expressions. List and vector structure within a pattern specifies the basic structure required of the input, the underscore and pattern variables specify arbitrary substructure, and literals and constants specify atomic pieces that must match exactly. Ellipses specify repeated occurrences of the subpatterns they follow. \n\n" "An input form F matches a pattern P if and only if \n\n" "\n* P is an underscore or pattern variable, \n* P is a literal identifier and F is an identifier with the same binding as determined by the predicate free-identifier=? (Section 8.3), \n* P is of the form (P1 ... Pn)and F is a list of n elements that match P1 through Pn, \n* P is of the form (P1 ... Pn . Px)and F is a list or improper list of n or more elements whose first n elements match P1 through Pnand whose nth cdr matches Px, \n* P is of the form (P1 ... Pk Pe ellipsis Pm+1 ... Pn), where ellipsis is the identifier ... and F is a proper list of nelements whose first k elements match P1 through Pk, whose next m - k elements each match Pe, and whose remaining n - m elements match Pm+1 through Pn, \n* P is of the form (P1 ... Pk Pe ellipsis Pm+1 ... Pn . Px), where ellipsis is the identifier ... and F is a list or improper list of nelements whose first k elements match P1 through Pk, whose next m - k elements each match Pe, whose next n - m elements match Pm+1 through Pn, and  whose nth and final cdr matches Px, \n* P is of the form #(P1 ... Pn)and F is a vector of n elements that match P1 through Pn, \n* P is of the form #(P1 ... Pk Pe ellipsis Pm+1 ... Pn), where ellipsis is the identifier ... and F is a vector of n elements whose first k elements match P1 through Pk, whose next m - k elements each match Pe, and whose remaining n - m elements match Pm+1 through Pn, or \n* P is a pattern datum (any nonlist, nonvector, nonsymbol object) and F is equal to P in the sense of the equal? procedure.  \n\n" "" "The outermost structure of a syntax-rules pattern must actually be in one of the list-structured forms above, although subpatterns of the pattern may be in any of the above forms. Furthermore, the first element of the outermost pattern is ignored, since it is always assumed to be the keyword naming the syntactic form. (These statements do not apply to syntax-case; see Section 8.3.) \n\n" "If an input form passed to a syntax-rules transformer matches the pattern for a given clause, the clause is accepted and the form is transformed as specified by the associated template. As this transformation takes place, pattern variables appearing in the pattern are bound to the corresponding input subforms. Pattern variables appearing within a subpattern followed by one or more ellipses may be bound to a sequence or sequences of zero or more input subforms. \n\n" "A template is a pattern variable, an identifier that is not a pattern variable, a pattern datum, a list of subtemplates (S1 ... Sn), an improper list of subtemplates (S1 S2 ... Sn . T), or a vector of subtemplates #(S1 ... Sn). Each subtemplate Si is a template followed by zero or more ellipses. The final element T of an improper subtemplate list is a template. \n\n" "Pattern variables appearing within a template are replaced in the output by the input subforms to which they are bound. Pattern data and identifiers that are not pattern variables are inserted directly into the output. List and vector structure within the template remains list and vector structure in the output. A subtemplate followed by an ellipsis expands into zero or more occurrences of the subtemplate. The subtemplate must contain at least one pattern variable from a subpattern followed by an ellipsis. (Otherwise, the expander could not determine how many times the subform should be repeated in the output.) Pattern variables that occur in subpatterns followed by one or more ellipses may occur only in subtemplates that are followed by (at least) as many ellipses. These pattern variables are replaced in the output by the input subforms to which  they are bound, distributed as specified. If a pattern variable is followed by more ellipses in the template than in the associated pattern, the input form is replicated as necessary. \n\n" "A template of the form (... template) is identical to template, except that ellipses within the template have no special meaning. That is, any ellipses contained within template are treated as ordinary identifiers. In particular, the template (... ...) produces a single ellipsis, .... This allows syntactic extensions to expand into forms containing ellipses, including syntax-rules or syntax-case patterns and templates. \n\n" "" "The definition of or below demonstrates the use of syntax-rules.  \n\n" "" "(define-syntax or\n  (syntax-rules ()\n    [(_) #f]\n    [(_ e) e]\n    [(_ e1 e2 e3 ...)\n     (let ([t e1]) (if t t (or e2 e3 ...)))]))\n\n" "The input patterns specify that the input must consist of the keyword and zero or more subexpressions. An underscore ( _ ), which is a special pattern symbol that matches any input, is often used for the keyword position to remind the programmer and anyone reading the definition that the keyword position never fails to contain the expected keyword and need not be matched. (In fact, as mentioned above, syntax-rules ignores what appears in the keyword position.) If more than one subexpression is present (third clause), the expanded code both tests the value of the first subexpression and returns the value if it is not false. To avoid evaluating the expression twice, the transformer introduces a binding for the temporary variable t.  \n\n" "The expansion algorithm maintains lexical scoping automatically by renaming local identifiers as necessary. Thus, the binding for t introduced by the transformer is visible only within code introduced by the transformer and not within subforms of the input. Similarly, the references to the identifiers let and if are unaffected by any bindings present in the context of the input. \n\n" "" "(let ([if #f])\n  (let ([t 'okay])\n    (or if t))) => okay\n\n" "This expression is transformed during expansion to the equivalent of the expression below. \n\n" "" "((lambda (if1)\n   ((lambda (t1)\n      ((lambda (t2)\n         (if t2 t2 t1))\n       if1))\n    'okay))\n #f) => okay\n\n" "In this sample expansion, if1, t1, and t2 represent identifiers to which if and t in the original expression and t in the expansion of or have been renamed. \n\n" "The definition of a simplified version of cond below (simplified because it requires at least one output expression per clause and  does not support the auxiliary keyword =>) demonstrates how auxiliary keywords such as else are recognized in the input to a transformer, via inclusion in the list of literals. \n\n" "" "(define-syntax cond\n  (syntax-rules (else)\n    [(_ (else e1 e2 ...)) (begin e1 e2 ...)]\n    [(_ (e0 e1 e2 ...)) (if e0 (begin e1 e2 ...))]\n    [(_ (e0 e1 e2 ...) c1 c2 ...)\n     (if e0 (begin e1 e2 ...) (cond c1 c2 ...))]))\n\n") ("syntax:s26" "syntax: _ \nsyntax: ... \nlibraries: (rnrs base), (rnrs syntax-case), (rnrs)  \n\n" "These identifiers are auxiliary keywords for syntax-rules, identifier-syntax, and syntax-case. The second ( ... ) is also an auxiliary keyword for syntax and quasisyntax. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords. \n\n") ("syntax:s27" "syntax: (identifier-syntax tmpl)\nsyntax: (identifier-syntax (id1 tmpl1) ((set! id2 e2) tmpl2))\nreturns: a transformer \nlibraries: (rnrs base), (rnrs)  \n\n" "When a keyword is bound to a transformer produced by the first form of identifier-syntax, references to the keyword within the scope of the binding are replaced by tmpl. \n\n" "" "(let ()\n  (define-syntax a (identifier-syntax car))\n  (list (a '(1 2 3)) a)) => (1 #<procedure>)\n\n" "With the first form of identifier-syntax, an apparent assignment of the associated keyword with set! is a syntax violation. The second, more general, form of identifier-syntax permits the transformer to specify what happens when set! is used.  \n\n" "" "(let ([ls (list 0)])\n  (define-syntax a\n    (identifier-syntax\n      [id (car ls)]\n      [(set! id e) (set-car! ls e)]))\n  (let ([before a])\n    (set! a 1)\n    (list before a ls))) => (0 1 (1))\n\n" "A definition of identifier-syntax in terms of make-variable-transformer is shown on page 307. \n\n") ("syntax:s30" "syntax: (syntax-case expr (literal ...) clause ...)\nreturns: see below \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "Each literal must be an identifier. Each clause must take one of the following two forms. \n\n" "" "(pattern output-expression)\n(pattern fender output-expression)\n\n" "syntax-case patterns may be in any of the forms described in Section 8.2. \n\n" "syntax-case first evaluates expr, then attempts to match the resulting value against the pattern from the first clause. This value may be any Scheme object. If the value matches the pattern and no fender is present, output-expression is evaluated and its values returned as the values of the syntax-case expression. If the value does not match the pattern, the value is compared against the next clause, and so on. It is a syntax violation if the value does not match any of the patterns. \n\n" "If the optional fender is present, it serves as an additional constraint on acceptance of a clause. If the value of the syntax-case expr matches the pattern for a given clause, the corresponding fender is evaluated. If fender evaluates to a true value, the clause is accepted; otherwise, the clause is rejected as if the input had failed to match the pattern. Fenders are logically a part of the matching process, i.e., they specify additional matching constraints beyond the basic structure of an expression. \n\n" "Pattern variables contained within a clause's pattern are bound to the corresponding pieces of the input value within the clause's fender (if present) and output-expression. Pattern variables occupy the same namespace as program variables and keywords; pattern variable bindings created by syntax-case can shadow (and be shadowed by) program variable and keyword bindings as well as other pattern variable bindings. Pattern variables, however, can be referenced only within syntax expressions. \n\n" "See the examples following the description of syntax.  \n\n") ("syntax:s33" "syntax: (syntax template)\nsyntax: #'template\nreturns: see below \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "#'template is equivalent to (syntax template). The abbreviated form is converted into the longer form when a program is read, prior to macro expansion. \n\n" "A syntax expression is like a quote expression except that the values of pattern variables appearing within template are inserted into template, and contextual information associated both with the input and with the template is retained in the output to support lexical scoping. A syntax template is identical to a syntax-rules template and is treated similarly. \n\n" "List and vector structures within the template become true lists or vectors (suitable for direct application of list or vector operations, like map or vector-ref) to the extent that the list or vector structures must be copied to insert the values of pattern variables, and empty lists are never wrapped. For example, #'(x ...), #'(a b c), #'() are all lists if x, a, b, and c are pattern variables. \n\n" "The definition of or below is equivalent to the one given in Section 8.2 except that it employs syntax-case and syntax in place of syntax-rules.  \n\n" "" "(define-syntax or\n  (lambda (x)\n    (syntax-case x ()\n      [(_) #'#f]\n      [(_ e) #'e]\n      [(_ e1 e2 e3 ...)\n       #'(let ([t e1]) (if t t (or e2 e3 ...)))])))\n\n" "In this version, the lambda expression that produces the transformer is explicit, as are the syntax forms in the output part of each clause. Any syntax-rules form can be expressed with syntax-case by making the lambda expression and syntax expressions explicit. This observation leads to the following definition of syntax-rules in terms of syntax-case.  \n\n" "" "(define-syntax syntax-rules\n  (lambda (x)\n    (syntax-case x ()\n      [(_ (i ...) ((keyword . pattern) template) ...)\n       #'(lambda (x)\n           (syntax-case x (i ...)\n             [(_ . pattern) #'template] ...))])))\n\n" "An underscore is used in place of each keyword since the first position of each syntax-rules pattern is always ignored.  \n\n" "Since the lambda and syntax expressions are implicit in a syntax-rules form, definitions expressed with syntax-rules are often shorter than the equivalent definitions expressed with syntax-case. The choice of which to use when either suffices is a matter of taste, but many transformers that can be written easily with syntax-case cannot be written easily or at all with syntax-rules (see Section 8.4). \n\n") ("syntax:s35" "procedure: (identifier? obj)\nreturns: #t if obj is an identifier, #f otherwise \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "identifier? is often used within fenders to verify that certain subforms of an input form are identifiers, as in the definition of unnamed let below.  \n\n" "" "(define-syntax let\n  (lambda (x)\n    (define ids?\n      (lambda (ls)\n        (or (null? ls)\n            (and (identifier? (car ls))\n                 (ids? (cdr ls))))))\n    (syntax-case x ()\n      [(_ ((i e) ...) b1 b2 ...)\n       (ids? #'(i ...))\n       #'((lambda (i ...) b1 b2 ...) e ...)])))\n\n" "Syntactic extensions ordinarily take the form (keyword subform ...), but the syntax-case system permits them to take the form of singleton identifiers as well. For example, the keyword pcar in the expression below may be used both as an identifier (in which case it expands into a call to car) or as a structured form (in which case it expands into a call to set-car!).  \n\n" "" "(let ([p (cons 0 #f)])\n  (define-syntax pcar\n    (lambda (x)\n      (syntax-case x ()\n        [_ (identifier? x) #'(car p)]\n        [(_ e) #'(set-car! p e)])))\n  (let ([a pcar])\n    (pcar 1)\n    (list a pcar))) => (0 1)\n\n" "The fender (identifier? x) is used to recognize the singleton identifier case. \n\n") ("syntax:s37" "procedure: (free-identifier=? identifier1 identifier2)\nprocedure: (bound-identifier=? identifier1 identifier2)\nreturns: see below \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "Symbolic names alone do not distinguish identifiers unless the identifiers are to be used only as symbolic data. The predicates free-identifier=? and bound-identifier=? are used to compare identifiers according to their intended useas free references or bound identifiers in a given context. \n\n" "free-identifier=? is used to determine whether two identifiers would be equivalent if they were to appear as free identifiers in the output of a transformer. Because identifier references are lexically scoped, this means (free-identifier=? id1 id2) is true if and only if the identifiers id1 and id2 refer to the same binding. (For this comparison, two like-named identifiers are assumed to have the same binding if neither is bound.) Literal identifiers (auxiliary keywords) appearing in syntax-case patterns (such as else in case and cond) are matched with free-identifier=?.  \n\n" "Similarly, bound-identifier=? is used to determine whether two identifiers would be equivalent if they were to appear as bound identifiers in the output of a transformer. In other words, if bound-identifier=? returns true for two identifiers, a binding for one will capture references to the other within its scope. In general, two identifiers are bound-identifier=? only if both are present in the original program or both are introduced by the same transformer application (perhaps implicitly---see datum->syntax). bound-identifier=? can be used for detecting duplicate identifiers in a binding construct or for other preprocessing of a binding construct that requires detecting instances of the bound identifiers. \n\n" "The definition below is equivalent to the earlier definition of a simplified version of cond with syntax-rules, except that else is recognized via an explicit call to free-identifier? within a fender rather than via inclusion in the literals list. \n\n" "" "(define-syntax cond\n  (lambda (x)\n    (syntax-case x ()\n      [(_ (e0 e1 e2 ...))\n       (and (identifier? #'e0) (free-identifier=? #'e0 #'else))\n       #'(begin e1 e2 ...)]\n      [(_ (e0 e1 e2 ...)) #'(if e0 (begin e1 e2 ...))]\n      [(_ (e0 e1 e2 ...) c1 c2 ...)\n       #'(if e0 (begin e1 e2 ...) (cond c1 c2 ...))])))\n\n" "With either definition of cond, else is not recognized as an auxiliary keyword if an enclosing lexical binding for else exists. For example, \n\n" "" "(let ([else #f])\n  (cond [else (write \"oops\")]))\n\n" "does not write \"oops\", since else is bound lexically and is therefore not the same else that appears in the definition of cond.  \n\n" "The following definition of unnamed let uses bound-identifier=? to detect duplicate identifiers.  \n\n" "" "(define-syntax let\n  (lambda (x)\n    (define ids?\n      (lambda (ls)\n        (or (null? ls)\n            (and (identifier? (car ls)) (ids? (cdr ls))))))\n    (define unique-ids?\n      (lambda (ls)\n        (or (null? ls)\n            (and (not (memp\n                        (lambda (x) (bound-identifier=? x (car ls)))\n                        (cdr ls)))\n                 (unique-ids? (cdr ls))))))\n    (syntax-case x ()\n      [(_ ((i e) ...) b1 b2 ...)\n       (and (ids? #'(i ...)) (unique-ids? #'(i ...)))\n       #'((lambda (i ...) b1 b2 ...) e ...)])))\n\n" "With the definition of let above, the expression  \n\n" "" "(let ([a 3] [a 4]) (+ a a))\n\n" "is a syntax violation, whereas \n\n" "" "(let ([a 0])\n  (let-syntax ([dolet (lambda (x)\n                        (syntax-case x ()\n                          [(_ b)\n                           #'(let ([a 3] [b 4]) (+ a b))]))])\n    (dolet a)))\n\n" "evaluates to 7 since the identifier a introduced by dolet and the identifier a extracted from the input form are not bound-identifier=?. Since both occurrences of a, however, if left as free references, would refer to the same binding for a, free-identifier=? would not distinguish them. \n\n" "Two identifiers that are free-identifier=? may not be bound-identifier=?. An identifier introduced by a transformer may refer to the same enclosing binding as an identifier not introduced by the transformer, but an introduced binding for one will not capture references to the other. On the other hand, identifiers that are bound-identifier=? are free-identifier=?, as long as the identifiers have valid bindings in the context where they are compared. \n\n") ("syntax:s38" "syntax: (with-syntax ((pattern expr) ...) body1 body2 ...)\nreturns: the values of the final body expression \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "It is sometimes useful to construct a transformer's output in separate pieces, then put the pieces together. with-syntax facilitates this by allowing the creation of local pattern bindings. \n\n" "pattern is identical in form to a syntax-case pattern. The value of each expr is computed and destructured according to the corresponding pattern, and pattern variables within the pattern are bound as with syntax-case to appropriate portions of the value within the body body1 body2 ..., which is processed and evaluated like a lambda body.  \n\n" "with-syntax may be defined as a syntactic extension in terms of syntax-case.  \n\n" "" "(define-syntax with-syntax\n  (lambda (x)\n    (syntax-case x ()\n      [(_ ((p e) ...) b1 b2 ...)\n       #'(syntax-case (list e ...) ()\n           [(p ...) (let () b1 b2 ...)])])))\n\n" "The following definition of full cond demonstrates the use of with-syntax to support transformers that employ recursion internally to construct their output. \n\n" "" "(define-syntax cond\n  (lambda (x)\n    (syntax-case x ()\n      [(_ c1 c2 ...)\n       (let f ([c1 #'c1] [cmore #'(c2 ...)])\n         (if (null? cmore)\n             (syntax-case c1 (else =>)\n               [(else e1 e2 ...) #'(begin e1 e2 ...)]\n               [(e0) #'(let ([t e0]) (if t t))]\n               [(e0 => e1) #'(let ([t e0]) (if t (e1 t)))]\n               [(e0 e1 e2 ...) #'(if e0 (begin e1 e2 ...))])\n             (with-syntax ([rest (f (car cmore) (cdr cmore))])\n               (syntax-case c1 (=>)\n                 [(e0) #'(let ([t e0]) (if t t rest))]\n                 [(e0 => e1) #'(let ([t e0]) (if t (e1 t) rest))]\n                 [(e0 e1 e2 ...)\n                  #'(if e0 (begin e1 e2 ...) rest)]))))])))\n\n") ("syntax:s40" "syntax: (quasisyntax template ...)\nsyntax: #`template\nsyntax: (unsyntax template ...)\nsyntax: #,template\nsyntax: (unsyntax-splicing template ...)\nsyntax: #,@template\nreturns: see below \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "#`template is equivalent to (quasisyntax template), while #,template is equivalent to (unsyntax template), and #,@template to (unsyntax-splicing template). The abbreviated forms are converted into the longer forms when the program is read, prior to macro expansion. \n\n" "quasisyntax is similar to syntax, but it allows parts of the quoted text to be evaluated, in a manner similar to quasiquote (Section 6.1). \n\n" "Within a quasisyntax template, subforms of unsyntax and unsyntax-splicing forms are evaluated, and everything else is treated as ordinary template material, as with syntax. The value of each unsyntax subform is inserted into the output in place of the unsyntax form, while the value of each unsyntax-splicing subform is spliced into the surrounding list or vector structure. unsyntax and unsyntax-splicing are valid only within quasisyntax expressions.  \n\n" "quasisyntax expressions may be nested, with each quasisyntax introducing a new level of syntax quotation and each unsyntax or unsyntax-splicing taking away a level of quotation. An expression nested within n quasisyntax expressions must be within n unsyntax or unsyntax-splicing expressions to be evaluated. \n\n" "quasisyntax can be used in place of with-syntax in many cases. For example, the following definition of case employs quasisyntax to construct its output, using internal recursion in a manner similar to the definition of cond given under the description of with-syntax above.  \n\n" "" "(define-syntax case\n  (lambda (x)\n    (syntax-case x ()\n      [(_ e c1 c2 ...)\n       #`(let ([t e])\n           #,(let f ([c1 #'c1] [cmore #'(c2 ...)])\n               (if (null? cmore)\n                   (syntax-case c1 (else)\n                     [(else e1 e2 ...) #'(begin e1 e2 ...)]\n                     [((k ...) e1 e2 ...)\n                      #'(if (memv t '(k ...)) (begin e1 e2 ...))])\n                   (syntax-case c1 ()\n                     [((k ...) e1 e2 ...)\n                      #`(if (memv t '(k ...))\n                            (begin e1 e2 ...)\n                            #,(f (car cmore) (cdr cmore)))]))))])))\n\n" "unsyntax and unsyntax-splicing forms that contain zero or more than one subform are valid only in splicing (list or vector) contexts. (unsyntax template ...) is equivalent to (unsyntax template) ..., and (unsyntax-splicing template ...) is equivalent to (unsyntax-splicing template) .... These forms are primarily useful as intermediate forms in the output of the quasisyntax expander. They support certain useful nested quasiquotation (quasisyntax) idioms [3], such as #,@#,@, which has the effect of a doubly indirect splicing when used within a doubly nested and doubly evaluated quasisyntax expression, as with the nested quasiquote examples shown in Section 6.1. \n\n" "unsyntax and unsyntax-splicing are auxiliary keywords for quasisyntax. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords. \n\n") ("syntax:s42" "procedure: (make-variable-transformer procedure)\nreturns: a variable transformer \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "As described in the lead-in to this section, transformers may simply be procedures that accept one argument, a syntax object representing the input form, and return a new syntax object representing the output form. The form passed to a transformer usually represents a parenthesized form whose first subform is the keyword bound to the transformer or just the keyword itself. make-variable-transformer may be used to convert a procedure into a special kind of transformer to which the expander also passes set! forms in which the keyword appears just after the set! keyword, as if it were a variable to be assigned. This allows the programmer to control what happens when the keyword appears in such contexts. The argument, procedure, should accept one argument. \n\n" "" "(let ([ls (list 0)])\n  (define-syntax a\n    (make-variable-transformer\n      (lambda (x)\n        (syntax-case x ()\n          [id (identifier? #'id) #'(car ls)]\n          [(set! _ e) #'(set-car! ls e)]\n          [(_ e ...) #'((car ls) e ...)]))))\n  (let ([before a])\n    (set! a 1)\n    (list before a ls))) => (0 1 (1))\n\n" "This syntactic abstraction can be defined more succinctly using identifier-syntax, as shown in Section 8.2, but make-variable-transformer can be used to create transformers that perform arbitrary computations, while identifier-syntax is limited to simple term rewriting, like syntax-rules. identifier-syntax can be defined in terms of make-variable-transformer, as shown below.  \n\n" "" "(define-syntax identifier-syntax\n  (lambda (x)\n    (syntax-case x (set!)\n      [(_ e)\n       #'(lambda (x)\n           (syntax-case x ()\n             [id (identifier? #'id) #'e]\n             [(_ x (... ...)) #'(e x (... ...))]))]\n      [(_ (id exp1) ((set! var val) exp2))\n       (and (identifier? #'id) (identifier? #'var))\n       #'(make-variable-transformer\n           (lambda (x)\n             (syntax-case x (set!)\n               [(set! var val) #'exp2]\n               [(id x (... ...)) #'(exp1 x (... ...))]\n               [id (identifier? #'id) #'exp1])))])))\n\n") ("syntax:s44" "procedure: (syntax->datum obj)\nreturns: obj stripped of syntactic information \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "The procedure syntax->datum strips all syntactic information from a syntax object and returns the corresponding Scheme \"datum.\" Identifiers stripped in this manner are converted to their symbolic names, which can then be compared with eq?. Thus, a predicate symbolic-identifier=? might be defined as follows.  \n\n" "" "(define symbolic-identifier=?\n  (lambda (x y)\n    (eq? (syntax->datum x)\n         (syntax->datum y))))\n\n" "Two identifiers that are free-identifier=? need not be symbolic-identifier=?: two identifiers that refer to the same binding usually have the same name, but the rename and prefix subforms of the library's import form (page 345) may result in two identifiers with different names but the same binding. \n\n") ("syntax:s45" "procedure: (datum->syntax template-identifier obj)\nreturns: a syntax object \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "datum->syntax constructs a syntax object from obj that contains the same contextual information as template-identifier, with the effect that the syntax object behaves as if it were introduced into the code when template-identifier was introduced. The template identifier is often the keyword of an input form, extracted from the form, and the object is often a symbol naming an identifier to be constructed. \n\n" "datum->syntax allows a transformer to \"bend\" lexical scoping rules by creating implicit identifiersthat behave as if they were present in the input form, thus permitting the definition of syntactic extensions that introduce visible bindings for or references to identifiers that do not appear explicitly in the input form. For example, we can define a loop expression that binds the variable break to an escape procedure within the loop body. \n\n" "" "(define-syntax loop\n  (lambda (x)\n    (syntax-case x ()\n      [(k e ...)\n       (with-syntax ([break (datum->syntax #'k 'break)])\n         #'(call/cc\n             (lambda (break)\n               (let f () e ... (f)))))]))) \n\n(let ([n 3] [ls '()])\n  (loop\n    (if (= n 0) (break ls))\n    (set! ls (cons 'a ls))\n    (set! n (- n 1)))) => (a a a)\n\n" "Were we to define loop as  \n\n" "" "(define-syntax loop\n  (lambda (x)\n    (syntax-case x ()\n      [(_ e ...)\n       #'(call/cc\n           (lambda (break)\n             (let f () e ... (f))))])))\n\n" "the variable break would not be visible in e .... \n\n" "It is also useful for obj to represent an arbitrary Scheme form, as demonstrated by the following definition of include.  \n\n" "" "(define-syntax include\n  (lambda (x)\n    (define read-file\n      (lambda (fn k)\n        (let ([p (open-input-file fn)])\n          (let f ([x (read p)])\n            (if (eof-object? x)\n                (begin (close-port p) '())\n                (cons (datum->syntax k x) (f (read p))))))))\n    (syntax-case x ()\n      [(k filename)\n       (let ([fn (syntax->datum #'filename)])\n         (with-syntax ([(expr ...) (read-file fn #'k)])\n           #'(begin expr ...)))])))\n\n" "(include \"filename\") expands into a begin expression containing the forms found in the file named by \"filename\". For example, if the file f-def.ss contains the expression (define f (lambda () x)), the expression \n\n" "" "(let ([x \"okay\"])\n  (include \"f-def.ss\")\n  (f))\n\n" "evaluates to \"okay\".  \n\n" "The definition of include uses datum->syntax to convert the objects read from the file into syntax objects in the proper lexical context, so that identifier references and definitions within those expressions are scoped where the include form appears.  \n\n") ("syntax:s49" "procedure: (generate-temporaries list)\nreturns: a list of distinct generated identifiers \nlibraries: (rnrs syntax-case), (rnrs)  \n\n" "Transformers can introduce a fixed number of identifiers into their output by naming each identifier. In some cases, however, the number of identifiers to be introduced depends upon some characteristic of the input expression. A straightforward definition of letrec, for example, requires as many temporary identifiers as there are binding pairs in the input expression. The procedure generate-temporaries is used to construct lists of temporary identifiers. \n\n" "list may be any list; its contents are not important. The number of temporaries generated is the number of elements in list. Each temporary is guaranteed to be different from all other identifiers. \n\n" "A definition of letrec that uses generate-temporaries is shown below.  \n\n" "" "(define-syntax letrec\n  (lambda (x)\n    (syntax-case x ()\n      [(_ ((i e) ...) b1 b2 ...)\n       (with-syntax ([(t ...) (generate-temporaries #'(i ...))])\n         #'(let ([i #f] ...)\n             (let ([t e] ...)\n               (set! i t)\n               ...\n               (let () b1 b2 ...))))])))\n\n" "Any transformer that uses generate-temporaries in this fashion can be rewritten to avoid using it, albeit with a loss of clarity. The trick is to use a recursively defined intermediate form that generates one temporary per expansion step and completes the expansion after enough temporaries have been generated. Here is a definition of let-values (page 99) that uses this technique to support multiple sets of bindings. \n\n" "" "(define-syntax let-values\n  (syntax-rules ()\n    [(_ () f1 f2 ...) (let () f1 f2 ...)]\n    [(_ ((fmls1 expr1) (fmls2 expr2) ...) f1 f2 ...)\n     (lvhelp fmls1 () () expr1 ((fmls2 expr2) ...) (f1 f2 ...))])) \n\n(define-syntax lvhelp\n  (syntax-rules ()\n    [(_ (x1 . fmls) (x ...) (t ...) e m b)\n     (lvhelp fmls (x ... x1) (t ... tmp) e m b)]\n    [(_ () (x ...) (t ...) e m b)\n     (call-with-values\n       (lambda () e)\n       (lambda (t ...)\n         (let-values m (let ([x t] ...) . b))))]\n    [(_ xr (x ...) (t ...) e m b)\n     (call-with-values\n       (lambda () e)\n       (lambda (t ... . tmpr)\n         (let-values m (let ([x t] ... [xr tmpr]) . b))))]))\n\n" "The implementation of lvhelp is complicated by the need to evaluate all of the right-hand-side expressions before creating any of the bindings and by the need to support improper formals lists. \n\n") ("io:s19" "procedure: (make-transcoder codec)\nprocedure: (make-transcoder codec eol-style)\nprocedure: (make-transcoder codec eol-style error-handling-mode)\nreturns: a transcoder encapsulating codec, eol-style, and error-handling-mode \nlibraries: (rnrs io ports), (rnrs)  \n\n" "eol-style must be a valid eol-style symbol (lf, cr, nel, ls, crlf, crnel, or none); it defaults to the native eol-style for the platform. error-handling-mode must be a valid error-handling-mode symbol (ignore, raise, or replace) and defaults to replace.  \n\n") ("io:s20" "procedure: (transcoder-codec transcoder)\nreturns: the codec encapsulated in transcoder \nprocedure: (transcoder-eol-style transcoder)\nreturns: the eol-style symbol encapsulated in transcoder \nprocedure: (transcoder-error-handling-mode transcoder)\nreturns: the error-handling-mode symbol encapsulated in transcoder \nlibraries: (rnrs io ports), (rnrs)  \n\n") ("io:s21" "procedure: (native-transcoder) \nreturns: the native transcoder \nlibraries: (rnrs io ports), (rnrs)  \n\n" "The native transcoder is implementation-dependent and may vary by platform or locale. \n\n") ("io:s22" "procedure: (latin-1-codec) \nreturns: a codec for ISO 8859-1 (Latin 1) character encodings \nprocedure: (utf-8-codec) \nreturns: a codec for Unicode UTF-8 character encodings \nprocedure: (utf-16-codec) \nreturns: a codec for Unicode UTF-16 character encodings \nlibraries: (rnrs io ports), (rnrs)  \n\n") ("io:s23" "syntax: (eol-style symbol)\nreturns: symbol \nlibraries: (rnrs io ports), (rnrs)  \n\n" "symbol must be one of the symbols lf, cr, nel, ls, crlf, crnel, or none. The expression (eol-style symbol) is equivalent to the expression (quote symbol) except the former checks at expansion time that symbol is one of the eol-style symbols. The eol-style syntax provides useful documentation as well.  \n\n" "" "(eol-style crlf) => crlf\n(eol-style lfcr) => syntax violation\n\n") ("io:s24" "procedure: (native-eol-style) \nreturns: the native eol style \nlibraries: (rnrs io ports), (rnrs)  \n\n" "The native eol style is implementation-dependent and may vary by platform or locale. \n\n") ("io:s25" "syntax: (error-handling-mode symbol)\nreturns: symbol \nlibraries: (rnrs io ports), (rnrs)  \n\n" "symbol must be one of the symbols ignore, raise, or replace. The expression (error-handling-mode symbol) is equivalent to the expression (quote symbol) except that the former checks at expansion time that symbol is one of the error-handling-mode symbols. The error-handling-mode syntax provides useful documentation as well.  \n\n" "" "(error-handling-mode replace) => replace\n(error-handling-mode relpace) => syntax violation\n\n") ("io:s26" "syntax: (file-options symbol ...)\nreturns: a file-options enumeration set \nlibraries: (rnrs io ports), (rnrs)  \n\n" "File-options enumeration sets may be passed to file-open operations to control aspects of the open operation. There are three standard file options: no-create, no-fail, and no-truncate, which affect only file-open operations that create output (including input/output) ports. \n\n" "With the default file options, i.e., the value of (file-options), when a program attempts to open a file for output, an exception is raised with condition type i/o-file-already-exists if the file already exists, and the file is created if it does not already exist. If the no-fail option is included, no exception is raised if the file already exists; instead, the file is opened and truncated to zero length. If the no-create option is included, the file is not created if it does not exist; instead, an exception is raised with condition type i/o-file-does-not-exist. The no-create option implies the no-fail option. The no-truncate option is relevant only if the no-fail option is included or implied, in which case if an existing file is opened, it is not truncated, but the port's position is still set to the beginning of the file. \n\n" "It is perhaps easier to imagine that the default file options are the imaginary option symbols create, fail-if-exists, and truncate; no-create removes create, no-fail removes fail-if-exists, and no-truncate removes truncate.  \n\n" "Implementations may support additional file option symbols. Chez Scheme, for example, supports options that control whether the file is or should be compressed, whether it is locked for exclusive access, and what permissions are given to the file if it is created [9]. \n\n") ("io:s27" "syntax: (buffer-mode symbol)\nreturns: symbol \nlibraries: (rnrs io ports), (rnrs)  \n\n" "symbol must be one of the symbols block, line, or none. The expression (buffer-mode symbol) is equivalent to the expression (quote symbol) except that the former checks at expansion time that symbol is one of the buffer-mode symbols. The buffer-mode syntax provides useful documentation as well.  \n\n" "" "(buffer-mode block) => block\n(buffer-mode cushion) => syntax violation\n\n") ("io:s28" "syntax: (buffer-mode? obj)\nreturns: #t if obj is a valid buffer mode, #f otherwise \nlibraries: (rnrs io ports), (rnrs)  \n\n" "" "(buffer-mode? 'block) => #t\n(buffer-mode? 'line) => #t\n(buffer-mode? 'none) => #t\n(buffer-mode? 'something-else) => #f\n\n") ("io:s29" "procedure: (open-file-input-port path)\nprocedure: (open-file-input-port path options)\nprocedure: (open-file-input-port path options b-mode)\nprocedure: (open-file-input-port path options b-mode ?transcoder)\nreturns: a new input port for the named file \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual input port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary input port. See the lead-in to this section for a description of the constraints on and effects of the other arguments. \n\n") ("io:s30" "procedure: (open-file-output-port path)\nprocedure: (open-file-output-port path options)\nprocedure: (open-file-output-port path options b-mode)\nprocedure: (open-file-output-port path options b-mode ?transcoder)\nreturns: a new output port for the named file \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual output port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments. \n\n") ("io:s31" "procedure: (open-file-input/output-port path)\nprocedure: (open-file-input/output-port path options)\nprocedure: (open-file-input/output-port path options b-mode)\nprocedure: (open-file-input/output-port path options b-mode ?transcoder)\nreturns: a new input/output port for the named file \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary input/output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments. \n\n") ("io:s32" "procedure: (current-input-port) \nreturns: the current input port \nprocedure: (current-output-port) \nreturns: the current output port \nprocedure: (current-error-port) \nreturns: the current error port \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs)  \n\n" "The current-input, current-output, and current-error ports return pre-built textual ports that are initially associated with a process's standard input, standard output, and standard error streams. \n\n" "The values returned by current-input-port and current-output-port can be altered temporarily by the convenience I/O procedures with-input-from-file and with-output-to-file (Section 7.9). \n\n") ("io:s33" "procedure: (standard-input-port) \nreturns: a fresh binary input port connected to the standard input stream \nprocedure: (standard-output-port) \nreturns: a fresh binary output port connected to the standard output stream \nprocedure: (standard-error-port) \nreturns: a fresh binary output port connected to the standard error stream \nlibraries: (rnrs io ports), (rnrs)  \n\n" "Because ports may be buffered, confusion can result if operations on more than one port attached to one of a process's standard streams are interleaved. Thus, these procedures are typically appropriate only when a program no longer needs to use any existing ports attached to the standard streams. \n\n") ("io:s34" "procedure: (open-bytevector-input-port bytevector)\nprocedure: (open-bytevector-input-port bytevector ?transcoder)\nreturns: a new input port that draws input from bytevector \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If ?transcoder is present and not #f, it must be a transcoder, and this procedure returns a textual input port whose transcoder is ?transcoder. Otherwise, this procedure returns a binary input port. \n\n" "The effect of modifying bytevector after this procedure is called is unspecified. \n\n" "" "(let ([ip (open-bytevector-input-port #vu8(1 2))])\n  (let* ([x1 (get-u8 ip)] [x2 (get-u8 ip)] [x3 (get-u8 ip)])\n    (list x1 x2 (eof-object? x3)))) => (1 2 #t)\n\n" "There is no need to close a bytevector port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open bytevector port does not tie up any operating system resources. \n\n") ("io:s35" "procedure: (open-string-input-port string)\nreturns: a new textual input port that draws input from string \nlibraries: (rnrs io ports), (rnrs)  \n\n" "The effect of modifying string after this procedure is called is unspecified. The new port may or may not have a transcoder, and if it does, the transcoder is implementation-dependent. While not required, implementations are encouraged to support port-position and set-port-position! for string ports.  \n\n" "" "(get-line (open-string-input-port \"hi.\\nwhat's up?\\n\")) => \"hi.\"\n\n" "There is no need to close a string port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open string port does not tie up any operating system resources. \n\n") ("io:s36" "procedure: (open-bytevector-output-port) \nprocedure: (open-bytevector-output-port ?transcoder)\nreturns: two values, a new output port and an extraction procedure \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If ?transcoder is present and not #f, it must be a transcoder, and the port value is a textual output port whose transcoder is ?transcoder. Otherwise, the port value is a binary output port. \n\n" "The extraction procedure is a procedure that, when called without arguments, creates a bytevector containing the accumulated bytes in the port, clears the port of its accumulated bytes, resets its position to zero, and returns the bytevector. The accumulated bytes include any bytes written beyond the end of the current position, if the position has been set back from its maximum extent. \n\n" "" "(let-values ([(op g) (open-bytevector-output-port)])\n  (put-u8 op 15)\n  (put-u8 op 73)\n  (put-u8 op 115)\n  (set-port-position! op 2)\n  (let ([bv1 (g)])\n    (put-u8 op 27)\n    (list bv1 (g)))) => (#vu8(15 73 115) #vu8(27))\n\n" "There is no need to close a bytevector port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open bytevector port does not tie up any operating system resources. \n\n") ("io:s37" "procedure: (open-string-output-port) \nreturns: two values, a new textual output port and an extraction procedure \nlibraries: (rnrs io ports), (rnrs)  \n\n" "The extraction procedure is a procedure that, when called without arguments, creates a string containing the accumulated characters in the port, clears the port of its accumulated characters, resets its position to zero, and returns the string. The accumulated characters include any characters written beyond the end of the current position, if the position has been set back from its maximum extent. While not required, implementations are encouraged to support port-position and set-port-position! for string ports.  \n\n" "" "(let-values ([(op g) (open-string-output-port)])\n  (put-string op \"some data\")\n  (let ([str1 (g)])\n    (put-string op \"new stuff\")\n    (list str1 (g)))) => (\"some data\" \"new stuff\")\n\n" "There is no need to close a string port; it's storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open string port does not tie up any operating system resources. \n\n") ("io:s38" "procedure: (call-with-bytevector-output-port procedure)\nprocedure: (call-with-bytevector-output-port procedure ?transcoder)\nreturns: a bytevector containing the accumulated bytes \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If ?transcoder is present and not #f, it must be a transcoder, and procedure is called with a textual bytevector output port whose transcoder is ?transcoder. Otherwise, procedure is called with a binary bytevector output port. If procedure returns, a bytevector containing the bytes accumulated in the port is created, the accumulated bytes are cleared from the port, the port's position is reset to zero, and the bytevector is returned from call-with-bytevector-output-port. These actions occur each time procedure returns, if it returns multiple times due to the invocation of a continuation created while procedure is active. \n\n" "" "(let ([tx (make-transcoder (latin-1-codec) (eol-style lf)\n            (error-handling-mode replace))])\n  (call-with-bytevector-output-port\n    (lambda (p) (put-string p \"abc\"))\n    tx)) => #vu8(97 98 99)\n\n") ("io:s39" "procedure: (call-with-string-output-port procedure)\nreturns: a string containing the accumulated characters \nlibraries: (rnrs io ports), (rnrs)  \n\n" "procedure is called with one argument, a string output port. If procedure returns, a string containing the characters accumulated in the port is created, the accumulated characters are cleared from the port, the port's position is reset to zero, and the string is returned from call-with-string-output-port. These actions occur each time procedure returns, if it returns multiple times due to the invocation of a continuation created while procedure is active. \n\n" "call-with-string-output-port can be used along with put-datum to define a procedure, object->string, that returns a string containing the printed representation of an object. \n\n" "" "(define (object->string x)\n  (call-with-string-output-port\n    (lambda (p) (put-datum p x)))) \n\n(object->string (cons 'a '(b c))) => \"(a b c)\"\n\n") ("io:s41" "procedure: (make-custom-binary-input-port id r! gp sp! close)\nreturns: a new custom binary input port \nprocedure: (make-custom-binary-output-port id w! gp sp! close)\nreturns: a new custom binary output port \nprocedure: (make-custom-binary-input/output-port id r! w! gp sp! close)\nreturns: a new custom binary input/output port \nlibraries: (rnrs io ports), (rnrs)  \n\n" "These procedures allow programs to create ports from arbitrary byte streams. id must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. r! and w! must be procedures, while gp, sp!, and close must each be a procedure or #f. These arguments are described below. \n\n" "\nr!\n     is called to draw input from the custom port, e.g., to support get-u8 or get-bytevector-n. It is called with three arguments: bytevector, start, and n. start will be a nonnegative exact integer, n will be a positive exact integer, and the sum of start and n will not exceed the length of bytevector. If the byte stream is at end of file, r! should return exact 0. Otherwise, it should read at least one and at most n bytes from the stream, store these bytes in consecutive locations of bytevector starting at start, and return as an exact positive integer the number of bytes actually read. \n\n" "\nw!\n     is called to send output to the port, e.g., to support put-u8 or put-bytevector. It is called with three arguments: bytevector, start, and n. start and n will be nonnegative exact integers, and the sum of start and n will not exceed the length of bytevector. w! should write up to n consecutive bytes from bytevector starting at start and return, as an exact nonnegative integer, the number of bytes actually written. \n\n" "\ngp\n     is called to query the port's position. If it is #f, the port will not support port-position. If it is not #f, it will be passed zero arguments and should return the current position as a displacement in bytes from the start of the byte stream as an exact nonnegative integer. \n\n" "\nsp!\n     is called to set the port's position. If it is #f, the port will not support set-port-position!. If it is not #f, it will be passed one argument, an exact nonnegative integer representing the new position as a displacement in bytes from the start of the byte stream, and it should set the position to this value. \n\n" "\nclose\n     is called to close the byte stream. If it is #f, no action will be taken to close the byte stream when the new port is closed. If it is not #f, it will be passed zero arguments and should take whatever actions are necessary to close the byte stream. \n\n" "If the new port is an input/output port and does not provide either a gp or sp! procedure, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, due to input buffering that must be done to support lookahead-u8 and is often done anyway for efficiency. For the same reason, a call to port-position after an input operation may not return an accurate position if the sp! procedure is not provided. Thus, programs that create custom binary input/output ports should generally provide both gp and sp! procedures. \n\n") ("io:s42" "procedure: (make-custom-textual-input-port id r! gp sp! close)\nreturns: a new custom textual input port \nprocedure: (make-custom-textual-output-port id w! gp sp! close)\nreturns: a new custom textual output port \nprocedure: (make-custom-textual-input/output-port id r! w! gp sp! close)\nreturns: a new custom textual input/output port \nlibraries: (rnrs io ports), (rnrs)  \n\n" "These procedures allow programs to create ports from arbitrary character streams. id must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. r! and w! must be procedures, while gp, sp!, and close must each be a procedure or #f. These arguments are described below. \n\n" "\nr!\n     is called to draw input from the port, e.g., to support get-char or get-string-n. It is called with three arguments: string, start, and n. start will be a nonnegative exact integer, n will be a positive exact integer, and the sum of start and n will not exceed the length of string. If the character stream is at end of file, r! should return exact 0. Otherwise, it should read at least one and at most n characters from the stream, store these characters in consecutive locations of string starting at start, and return as an exact positive integer the number of characters actually read. \n\n" "\nw!\n     is called to send output to the port, e.g., to support put-char or put-string. It is called with three arguments: string, start, and n. start and n will be nonnegative exact integers, and the sum of start and n will not exceed the length of string. w! should write up to n consecutive characters from string starting at start and return, as an exact nonnegative integer, the number of characters actually written. \n\n" "\ngp\n     is called to query the port's position. If it is #f, the port will not support port-position. If it is not #f, it will be passed zero arguments and should return the current position, which may be an arbitrary value. \n\n" "\nsp!\n     is called to set the port's position. If it is #f, the port will not support set-port-position!. If it is not #f, it will be passed one argument, pos, a value representing the new position. If pos is the result of a previous call to gp, sp! should set the position to pos. \n\n" "\nclose\n     is called to close the character stream. If it is #f, no action will be taken to close the character stream when the new port is closed. If it is not #f, it will be passed zero arguments and should take whatever actions are necessary to close the character stream. \n\n" "If the new port is an input/output port, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, even if the gp and sp! procedures are provided, due to input buffering that must be done to support lookahead-char and is often done anyway for efficiency. Since the representations of port positions are not specified, it is not possible for the implementation to adjust the gp return value to account for the number of buffered characters. For the same reason, a call to port-position after an input operation may not return an accurate position, even if the sp! procedure is provided. \n\n" "It should, however, be possible to perform output reliably after reading if the position is reset to the starting position. Thus, programs that create custom textual input/output ports should generally provide both gp and sp! procedures, and consumers of these ports should obtain the starting position via port-position before any input operations and reset the position back to the starting position before doing any output operations. \n\n") ("io:s43" "procedure: (port? obj)\nreturns: #t if obj is a port, #f otherwise \nlibraries: (rnrs io ports), (rnrs)  \n\n") ("io:s44" "procedure: (input-port? obj)\nreturns: #t if obj is an input or input/output port, #f otherwise \nprocedure: (output-port? obj)\nreturns: #t if obj is an output or input/output port, #f otherwise \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs)  \n\n") ("io:s45" "procedure: (binary-port? obj)\nreturns: #t if obj is a binary port, #f otherwise \nprocedure: (textual-port? obj)\nreturns: #t if obj is a textual port, #f otherwise \nlibraries: (rnrs io ports), (rnrs)  \n\n") ("io:s46" "procedure: (close-port port)\nreturns: unspecified \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If port is not already closed, close-port closes it, first flushing any buffered bytes or characters to the underlying stream if the port is an output port. Once a port has been closed, no more input or output operations may be performed on the port. Because the operating system may place limits on the number of file ports open at one time or restrict access to an open file, it is good practice to close any file port that will no longer be used for input or output. If the port is an output port, closing the port explicitly also ensures that buffered data is written to the underlying stream. Some Scheme implementations close file ports automatically after they become inaccessible to the program or when the Scheme program exits, but it is best to close file ports explicitly whenever possible. Closing a port that has already been closed has no effect. \n\n") ("io:s47" "procedure: (transcoded-port binary-port transcoder)\nreturns: a new textual port with the same byte stream as binary-port \nlibraries: (rnrs io ports), (rnrs)  \n\n" "This procedure returns a new textual port with transcoder transcoder and the same underlying byte stream as binary-port, positioned at the current position of binary-port. \n\n" "As a side effect of creating the textual port, binary-port is closed to prevent read or write operations on binary-port from interfering with read and write operations on the new textual port. The underlying byte stream remains open, however, until the textual port is closed. \n\n") ("io:s48" "procedure: (port-transcoder port)\nreturns: the transcoder associated with port if any, #f otherwise \nlibraries: (rnrs io ports), (rnrs)  \n\n" "This procedure always returns #f for binary ports and may return #f for some textual ports.  \n\n") ("io:s49" "procedure: (port-position port)\nreturns: the port's current position \nprocedure: (port-has-port-position? port)\nreturns: #t if the port supports port-position, #f otherwise \nlibraries: (rnrs io ports), (rnrs)  \n\n" "A port may allow queries to determine its current position in the underlying stream of bytes or characters. If so, the procedure port-has-port-position? returns #t and port-position returns the current position. For binary ports, the position is always an exact nonnegative integer byte displacement from the start of the byte stream. For textual ports, the representation of a position is unspecified; it may not be an exact nonnegative integer and, even if it is, it may not represent either a byte or character displacement in the underlying stream. The position may be used at some later time to reset the position if the port supports set-port-position!. If port-position is called on a port that does not support it, an exception with condition type &assertion is raised.  \n\n") ("io:s50" "procedure: (set-port-position! port pos)\nreturns: unspecified \nprocedure: (port-has-set-port-position!? port)\nreturns: #t if the port supports set-port-position!, #f otherwise \nlibraries: (rnrs io ports), (rnrs)  \n\n" "A port may allow its current position to be moved directly to a different position in the underlying stream of bytes or characters. If so, the procedure port-has-set-port-position!? returns #t and set-port-position! changes the current position. For binary ports, the position pos must be an exact nonnegative integer byte displacement from the start of the byte stream. For textual ports, the representation of a position is unspecified, as described in the entry for port-position above, but pos must be an appropriate position for the textual port, which is usually guaranteed to be the case only if it was obtained from a call to port-position on the same port. If set-port-position! is called on a port that does not support it, an exception with condition type &assertion is raised.  \n\n" "If port is a binary output port and the position is set beyond the current end of the data in the underlying stream, the stream is not extended until new data is written at that position. If new data is written at that position, the contents of each intervening position is unspecified. Binary ports created with open-file-output-port and open-file-input/output-port can always be extended in this manner within the limits of the underlying operating system. In other cases, attempts to set the port beyond the current end of data in the underlying object may result in an exception with condition type &i/o-invalid-position.  \n\n") ("io:s51" "procedure: (call-with-port port procedure)\nreturns: the values returned by procedure \nlibraries: (rnrs io ports), (rnrs)  \n\n" "call-with-port calls procedure with port as the only argument. If procedure returns, call-with-port closes the port and returns the values returned by procedure. \n\n" "call-with-port does not automatically close the port if a continuation created outside of procedure is invoked, since it is possible that another continuation created inside of procedure will be invoked at a later time, returning control to procedure. If procedure does not return, an implementation is free to close the port only if it can prove that the output port is no longer accessible. \n\n" "The example below copies the contents of infile to outfile, overwriting outfile if it exists. Unless an error occurs, the ports are closed after the copy has been completed. \n\n" "" "(call-with-port (open-file-input-port \"infile\" (file-options)\n                  (buffer-mode block) (native-transcoder))\n  (lambda (ip)\n    (call-with-port (open-file-output-port \"outfile\"\n                      (file-options no-fail)\n                      (buffer-mode block)\n                      (native-transcoder)) \n      (lambda (op)\n        (do ([c (get-char ip) (get-char ip)])\n            ((eof-object? c))\n          (put-char op c))))))\n\n" "A definition of call-with-port is given on page 135. \n\n") ("io:s52" "procedure: (output-port-buffer-mode port)\nreturns: the symbol representing the buffer mode of port \nlibraries: (rnrs io ports), (rnrs)  \n\n") ("io:s53" "procedure: (eof-object? obj)\nreturns: #t if obj is an eof object, #f otherwise \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs)  \n\n" "The end-of-file object is returned by input operations, e.g., get-datum, when an input port has reached the end of input. \n\n") ("io:s54" "procedure: (eof-object) \nreturns: the eof object \nlibraries: (rnrs io ports), (rnrs io simple), (rnrs)  \n\n" "" "(eof-object? (eof-object)) => #t\n\n") ("io:s55" "procedure: (get-u8 binary-input-port)\nreturns: the next byte from binary-input-port, or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If binary-input-port is at end of file, the eof object is returned. Otherwise, the next available byte is returned as an unsigned 8-bit quantity, i.e., an exact unsigned integer less than or equal to 255, and the port's position is advanced one byte. \n\n") ("io:s56" "procedure: (lookahead-u8 binary-input-port)\nreturns: the next byte from binary-input-port, or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If binary-input-port is at end of file, the eof object is returned. Otherwise, the next available byte is returned as an unsigned 8-bit quantity, i.e., an exact unsigned integer less than or equal to 255. In contrast to get-u8, lookahead-u8 does not consume the byte it reads from the port, so if the next operation on the port is a call to lookahead-u8 or get-u8, the same byte is returned. \n\n") ("io:s57" "procedure: (get-bytevector-n binary-input-port n)\nreturns: a nonempty bytevector containing up to n bytes, or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "n must be an exact nonnegative integer. If binary-input-port is at end of file, the eof object is returned. Otherwise, get-bytevector-n reads (as if with get-u8) as many bytes, up to n, as are available before the port is at end of file, and returns a new (nonempty) bytevector containing these bytes. The port's position is advanced past the bytes read. \n\n") ("io:s58" "procedure: (get-bytevector-n! binary-input-port bytevector start n)\nreturns: the count of bytes read or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "start and n must be exact nonnegative integers, and the sum of start and n must not exceed the length of bytevector. \n\n" "If binary-input-port is at end of file, the eof object is returned. Otherwise, get-bytevector-n! reads (as if with get-u8) as many bytes, up to n, as are available before the port is at end of file, stores the bytes in consecutive locations of bytevector starting at start, and returns the count of bytes read as an exact positive integer. The port's position is advanced past the bytes read. \n\n") ("io:s59" "procedure: (get-bytevector-some binary-input-port)\nreturns: a nonempty bytevector or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If binary-input-port is at end of file, the eof object is returned. Otherwise, get-bytevector-some reads (as if with get-u8) at least one byte and possibly more, and returns a bytevector containing these bytes. The port's position is advanced past the bytes read. The maximum number of bytes read by this operation is implementation-dependent. \n\n") ("io:s60" "procedure: (get-bytevector-all binary-input-port)\nreturns: a nonempty bytevector or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If binary-input-port is at end of file, the eof object is returned. Otherwise, get-bytevector-all reads (as if with get-u8) all of the bytes available before the port is at end of file and returns a bytevector containing these bytes. The port's position is advanced past the bytes read. \n\n") ("io:s61" "procedure: (get-char textual-input-port)\nreturns: the next character from textual-input-port, or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If textual-input-port is at end of file, the eof object is returned. Otherwise, the next available character is returned and the port's position is advanced one character. If textual-input-port is a transcoded port, the position in the underlying byte stream may advance by more than one byte. \n\n") ("io:s62" "procedure: (lookahead-char textual-input-port)\nreturns: the next character from textual-input-port, or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If textual-input-port is at end of file, the eof object is returned. Otherwise, the next available character is returned. In contrast to get-char, lookahead-char does not consume the character it reads from the port, so if the next operation on the port is a call to lookahead-char or get-char, the same character is returned. \n\n" "lookahead-char is provided for applications requiring one character of lookahead. The procedure get-word defined below returns the next word from a textual input port as a string, where a word is defined to be a sequence of alphabetic characters. Since get-word does not know until it sees one character beyond the word that it has read the entire word, it uses lookahead-char to determine the next character and get-char to consume the character.  \n\n" "" "(define get-word\n  (lambda (p)\n    (list->string\n      (let f ()\n        (let ([c (lookahead-char p)])\n          (cond\n            [(eof-object? c) '()]\n            [(char-alphabetic? c) (get-char p) (cons c (f))]\n            [else '()]))))))\n\n") ("io:s63" "procedure: (get-string-n textual-input-port n)\nreturns: a nonempty string containing up to n characters, or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "n must be an exact nonnegative integer. If textual-input-port is at end of file, the eof object is returned. Otherwise, get-string-n reads (as if with get-char) as many characters, up to n, as are available before the port is at end of file, and returns a new (nonempty) string containing these characters. The port's position is advanced past the characters read. \n\n") ("io:s64" "procedure: (get-string-n! textual-input-port string start n)\nreturns: the count of characters read or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "start and n must be exact nonnegative integers, and the sum of start and n must not exceed the length of string. \n\n" "If textual-input-port is at end of file, the eof object is returned. Otherwise, get-string-n! reads (as if with get-char) as many characters, up to n, as are available before the port is at end of file, stores the characters in consecutive locations of string starting at start, and returns the count of characters read as an exact positive integer. The port's position is advanced past the characters read. \n\n" "get-string-n! may be used to implement string-set! and string-fill!, as illustrated below, although this is not its primary purpose. \n\n" "" "(define string-set!\n  (lambda (s i c)\n    (let ([sip (open-string-input-port (string c))])\n      (get-string-n! sip s i 1)\n     ; return unspecified values:\n      (if #f #f)))) \n\n(define string-fill!\n  (lambda (s c)\n    (let ([n (string-length s)])\n      (let ([sip (open-string-input-port (make-string n c))])\n        (get-string-n! sip s 0 n)\n       ; return unspecified values:\n        (if #f #f))))) \n\n(let ([x (make-string 3)])\n  (string-fill! x #\\-)\n  (string-set! x 2 #\\))\n  (string-set! x 0 #\\;)\n  x) => \";-)\"\n\n") ("io:s65" "procedure: (get-string-all textual-input-port)\nreturns: a nonempty string or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If textual-input-port is at end of file, the eof object is returned. Otherwise, get-string-all reads (as if with get-char) all of the characters available before the port is at end of file and returns a string containing these characters. The port's position is advanced past the characters read. \n\n") ("io:s66" "procedure: (get-line textual-input-port)\nreturns: a string or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "If textual-input-port is at end of file, the eof object is returned. Otherwise, get-line reads (as if with get-char) all of the characters available before the port is at end of file or a line-feed character has been read and returns a string containing all but the line-feed character of the characters read. The port's position is advanced past the characters read. \n\n" "" "(let ([sip (open-string-input-port \"one\\ntwo\\n\")])\n  (let* ([s1 (get-line sip)] [s2 (get-line sip)])\n    (list s1 s2 (port-eof? sip)))) => (\"one\" \"two\" #t) \n\n(let ([sip (open-string-input-port \"one\\ntwo\")])\n  (let* ([s1 (get-line sip)] [s2 (get-line sip)])\n    (list s1 s2 (port-eof? sip)))) => (\"one\" \"two\" #t)\n\n") ("io:s67" "procedure: (get-datum textual-input-port)\nreturns: a Scheme datum object or the eof object \nlibraries: (rnrs io ports), (rnrs)  \n\n" "This procedure scans past whitespace and comments to find the start of the external representation of a datum. If textual-input-port reaches end of file before the start of the external representation of a datum is found, the eof object is returned. \n\n" "Otherwise, get-datum reads as many characters as necessary, and no more, to parse a single datum, and returns a newly allocated object whose structure is determined by the external representation. The port's position is advanced past the characters read. If an end-of-file is reached before the external representation of the datum is complete, or an unexpected character is read, an exception is raised with condition types &lexical and i/o-read.  \n\n" "" "(let ([sip (open-string-input-port \"; a\\n\\n one (two)\\n\")])\n  (let* ([x1 (get-datum sip)]\n         [c1 (lookahead-char sip)]\n         [x2 (get-datum sip)])\n    (list x1 c1 x2 (port-eof? sip)))) => (one #\\space (two) #f)\n\n") ("io:s68" "procedure: (port-eof? input-port)\nreturns: #t if input-port is at end-of-file, #f otherwise \nlibraries: (rnrs io ports), (rnrs)  \n\n" "This procedure is similar to lookahead-u8 on a binary input port or lookahead-char on a textual input port, except that instead of returning the next byte/character or eof object, it returns a boolean value to indicate whether the value would be the eof object. \n\n") ("io:s69" "procedure: (put-u8 binary-output-port octet)\nreturns: unspecified \nlibraries: (rnrs io ports), (rnrs)  \n\n" "octet must be an exact nonnegative integer less than or equal to 255. This procedure writes octet to binary-output-port, advancing the port's position by one byte. \n\n") ("io:s70" "procedure: (put-bytevector binary-output-port bytevector)\nprocedure: (put-bytevector binary-output-port bytevector start)\nprocedure: (put-bytevector binary-output-port bytevector start n)\nreturns: unspecified \nlibraries: (rnrs io ports), (rnrs)  \n\n" "start and n must be nonnegative exact integers, and the sum of start and n must not exceed the length of bytevector. If not supplied, start defaults to zero and n defaults to the difference between the length of bytevector and start. \n\n" "This procedure writes the n bytes of bytevector starting at start to the port and advances the its position past the end of the bytes written. \n\n") ("io:s71" "procedure: (put-char textual-output-port char)\nreturns: unspecified \nlibraries: (rnrs io ports), (rnrs)  \n\n" "This procedure writes char to textual-output-port, advancing the port's position by one character. If textual-output-port is a transcoded port, the position in the underlying byte stream may advance by more than one byte. \n\n") ("io:s72" "procedure: (put-string textual-output-port string)\nprocedure: (put-string textual-output-port string start)\nprocedure: (put-string textual-output-port string start n)\nreturns: unspecified \nlibraries: (rnrs io ports), (rnrs)  \n\n" "start and n must be nonnegative exact integers, and the sum of start and n must not exceed the length of string. If not supplied, start defaults to zero and n defaults to the difference between the length of string and start. \n\n" "This procedure writes the n characters of string starting at start to the port and advances the its position past the end of the characters written. \n\n") ("io:s73" "procedure: (put-datum textual-output-port obj)\nreturns: unspecified \nlibraries: (rnrs io ports), (rnrs)  \n\n" "This procedure writes an external representation of obj to textual-output-port. If obj does not have an external representation as a datum, the behavior is unspecified. The precise external representation is implementation-dependent, but when obj does have an external representation as a datum, put-datum should produce a sequence of characters that can later be read by get-datum as an object equivalent (in the sense of equal?) to obj. See Section 12.5 for an implementation of put-datum, write, and display.  \n\n") ("io:s74" "procedure: (flush-output-port output-port)\nreturns: unspecified \nlibraries: (rnrs io ports), (rnrs)  \n\n" "This procedure forces any bytes or characters in the buffer associated with output-port to be sent immediately to the underlying stream. \n\n") ("io:s75" "procedure: (open-input-file path)\nreturns: a new input port \nlibraries: (rnrs io simple), (rnrs)  \n\n" "path must be a string or some other implementation-dependent  value that names a file. open-input-file creates a new textual input port for the file named by path, as if by open-file-input-port with default options, an implementation-dependent buffer mode, and an implementation-dependent transcoder. \n\n" "The following shows the use of open-input-file, read, and close-port in an expression that gathers a list of objects from the file named by \"myfile.ss.\" \n\n" "" "(let ([p (open-input-file \"myfile.ss\")])\n  (let f ([x (read p)])\n    (if (eof-object? x)\n        (begin\n          (close-port p)\n          '())\n        (cons x (f (read p))))))\n\n") ("io:s76" "procedure: (open-output-file path)\nreturns: a new output port \nlibraries: (rnrs io simple), (rnrs)  \n\n" "path must be a string or some other implementation-dependent  value that names a file. open-output-file creates a new output port for the file named by path, as if by open-file-output-port with default options, an implementation-dependent buffer mode, and an implementation-dependent transcoder. \n\n" "The following shows the use of open-output-file  to write a list of objects (the value of list-to-be-printed), separated by newlines, to the file named by \"myfile.ss.\" \n\n" "" "(let ([p (open-output-file \"myfile.ss\")])\n  (let f ([ls list-to-be-printed])\n    (if (not (null? ls))\n        (begin\n          (write (car ls) p)\n          (newline p)\n          (f (cdr ls)))))\n  (close-port p))\n\n") ("io:s77" "procedure: (call-with-input-file path procedure)\nreturns: the values returned by procedure \nlibraries: (rnrs io simple), (rnrs)  \n\n" "path must be a string or some other implementation-dependent  value that names a file. procedure should accept one argument. \n\n" "call-with-input-file creates a new input port for the file named by path, as if with open-input-file, and passes this port to procedure. If procedure returns, call-with-input-file closes the input port and returns the values returned by procedure. \n\n" "call-with-input-file does not automatically close the input port if a continuation created outside of procedure is invoked, since it is possible that another continuation created inside of procedure will be invoked at a later time, returning control to procedure. If procedure does not return, an implementation is free to close the input port only if it can prove that the input port is no longer accessible. As shown in Section 5.6, dynamic-wind may be used to ensure that the port is closed if a continuation created outside of procedure is invoked. \n\n" "The following example shows the use of call-with-input-file in an expression that gathers a list of objects from the file named by \"myfile.ss.\" It is functionally equivalent to the example given for open-input-file above.  \n\n" "" "(call-with-input-file \"myfile.ss\"\n  (lambda (p)\n    (let f ([x (read p)])\n      (if (eof-object? x)\n          '()\n          (cons x (f (read p)))))))\n\n" "call-with-input-file might be defined without error checking as follows.  \n\n" "" "(define call-with-input-file\n  (lambda (filename proc)\n    (let ([p (open-input-file filename)])\n      (let-values ([v* (proc p)])\n        (close-port p)\n        (apply values v*)))))\n\n") ("io:s78" "procedure: (call-with-output-file path procedure)\nreturns: the values returned by procedure \nlibraries: (rnrs io simple), (rnrs)  \n\n" "path must be a string or some other implementation-dependent  value that names a file. procedure should accept one argument. \n\n" "call-with-output-file creates a new output port for the file named by path, as if with open-output-file, and passes this port to procedure. If procedure returns, call-with-output-file closes the output port and returns the values returned by procedure. \n\n" "call-with-output-file does not automatically close the output port if a continuation created outside of procedure is invoked, since it is possible that another continuation created inside of procedure will be invoked at a later time, returning control to procedure. If procedure does not return, an implementation is free to close the output port only if it can prove that the output port is no longer accessible. As shown in Section 5.6, dynamic-wind may be used to ensure that the port is closed if a continuation created outside of procedure is invoked. \n\n" "The following shows the use of call-with-output-file to write a list of objects (the value of  list-to-be-printed), separated by newlines, to the file named by \"myfile.ss.\" It is functionally equivalent to the example given for open-output-file above.  \n\n" "" "(call-with-output-file \"myfile.ss\"\n  (lambda (p)\n    (let f ([ls list-to-be-printed])\n      (unless (null? ls)\n        (write (car ls) p)\n        (newline p)\n        (f (cdr ls))))))\n\n" "call-with-output-file might be defined without error checking as follows.  \n\n" "" "(define call-with-output-file\n  (lambda (filename proc)\n    (let ([p (open-output-file filename)])\n      (let-values ([v* (proc p)])\n        (close-port p)\n        (apply values v*)))))\n\n") ("io:s79" "procedure: (with-input-from-file path thunk)\nreturns: the values returned by thunk \nlibraries: (rnrs io simple), (rnrs)  \n\n" "path must be a string or some other implementation-dependent  value that names a file. thunk must be a procedure and should accept zero arguments. \n\n" "with-input-from-file temporarily changes the current input port to be the result of opening the file named by path, as if with open-input-file, during the application of thunk. If thunk returns, the port is closed and the current input port is restored to its old value. \n\n" "The behavior of with-input-from-file is unspecified if a continuation created outside of thunk is invoked before thunk returns. An implementation may close the port and restore the current input port to its old value---but it may not. \n\n") ("io:s80" "procedure: (with-output-to-file path thunk)\nreturns: the values returned by thunk \nlibraries: (rnrs io simple), (rnrs)  \n\n" "path must be a string or some other implementation-dependent  value that names a file. thunk must be a procedure and should accept zero arguments. \n\n" "with-output-to-file temporarily rebinds the current output port to be the result of opening the file named by path, as if with open-output-file, during the application of thunk. If thunk returns, the port is closed and the current output port is restored to its old value. \n\n" "The behavior of with-output-to-file is unspecified if a continuation created outside of thunk is invoked before thunk returns. An implementation may close the port and restore the current output port to its old value---but it may not. \n\n") ("io:s81" "procedure: (read) \nprocedure: (read textual-input-port)\nreturns: a Scheme datum object or the eof object \nlibraries: (rnrs io simple), (rnrs)  \n\n" "If textual-input-port is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to get-datum.  \n\n") ("io:s82" "procedure: (read-char) \nprocedure: (read-char textual-input-port)\nreturns: the next character from textual-input-port \nlibraries: (rnrs io simple), (rnrs)  \n\n" "If textual-input-port is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to get-char.  \n\n") ("io:s83" "procedure: (peek-char) \nprocedure: (peek-char textual-input-port)\nreturns: the next character from textual-input-port \nlibraries: (rnrs io simple), (rnrs)  \n\n" "If textual-input-port is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to lookahead-char.  \n\n") ("io:s84" "procedure: (write obj)\nprocedure: (write obj textual-output-port)\nreturns: unspecified \nlibraries: (rnrs io simple), (rnrs)  \n\n" "If textual-output-port is not supplied, it defaults to the current output port. This procedure is otherwise equivalent to put-datum, with the arguments reversed. See Section 12.5 for an implementation of put-datum, write, and display.  \n\n") ("io:s85" "procedure: (display obj)\nprocedure: (display obj textual-output-port)\nreturns: unspecified \nlibraries: (rnrs io simple), (rnrs)  \n\n" "If textual-output-port is not supplied, it defaults to the current output port. \n\n" "display is similar to write or put-datum but prints strings and characters found within obj directly. Strings are printed without quotation marks or escapes for special characters, as if by put-string, and characters are printed without the #\\ notation, as if by put-char. With display, the three-element list (a b c)and the two-element list (\"a b\" c) both print as (a b c). Because of this, display should not be used to print objects that are intended to be read with read. display is useful primarily for printing messages, with obj most often being a string. See Section 12.5 for an implementation of put-datum, write, and display.  \n\n") ("io:s86" "procedure: (write-char char)\nprocedure: (write-char char textual-output-port)\nreturns: unspecified \nlibraries: (rnrs io simple), (rnrs)  \n\n" "If textual-output-port is not supplied, it defaults to the current output port. This procedure is otherwise equivalent to put-char, with the arguments reversed. \n\n") ("io:s87" "procedure: (newline) \nprocedure: (newline textual-output-port)\nreturns: unspecified \nlibraries: (rnrs io simple), (rnrs)  \n\n" "If textual-output-port is not supplied, it defaults to the current output port. newline sends a line-feed character to the port.  \n\n") ("io:s88" "procedure: (close-input-port input-port)\nprocedure: (close-output-port output-port)\nreturns: unspecified \nlibraries: (rnrs io simple), (rnrs)  \n\n" "close-input-port closes an input port, and close-output-port closes an output port. These procedures are provided for backward compatibility with the Revised^5Report; they are not actually more convenient to use than close-port.  \n\n") ("io:s89" "procedure: (file-exists? path)\nreturns: #t if the file named by path exists, #f otherwise \nlibraries: (rnrs files), (rnrs)  \n\n" "path must be a string or some other implementation-dependent  value that names a file. Whether file-exists? follows symbolic links is unspecified.  \n\n") ("io:s90" "procedure: (delete-file path)\nreturns: unspecified \nlibraries: (rnrs files), (rnrs)  \n\n" "path must be a string or some other implementation-dependent  value that names a file. delete-file removes the file named by path if it exists and can be deleted, otherwise it raises an exception with condition type &i/o-filename. Whether delete-file follows symbolic links is unspecified.  \n\n") ("io:s91" "procedure: (bytevector->string bytevector transcoder)\nreturns: a string containing the characters encoded in bytevector \nlibraries: (rnrs io ports), (rnrs)  \n\n" "This operation, at least in effect, creates a bytevector input port with the specified transcoder from which all of the available characters are read, as if by get-string-all, and placed into the output string. \n\n" "" "(let ([tx (make-transcoder (utf-8-codec) (eol-style lf)\n            (error-handling-mode replace))])\n  (bytevector->string #vu8(97 98 99) tx)) => \"abc\"\n\n") ("io:s92" "procedure: (string->bytevector string transcoder)\nreturns: a bytevector containing the encodings of the characters in string \nlibraries: (rnrs io ports), (rnrs)  \n\n" "This operation, at least in effect, creates a bytevector output port with the specified transcoder to which all of the characters of string are written, then extracts a bytevector containing the accumulated bytes. \n\n" "" "(let ([tx (make-transcoder (utf-8-codec) (eol-style none)\n            (error-handling-mode raise))])\n  (string->bytevector \"abc\" tx)) => #vu8(97 98 99)\n\n") ("io:s93" "procedure: (string->utf8 string)\nreturns: a bytevector containing the UTF-8 encoding of string \nlibraries: (rnrs bytevectors), (rnrs)  \n\n") ("io:s94" "procedure: (string->utf16 string)\nprocedure: (string->utf16 string endianness)\nprocedure: (string->utf32 string)\nprocedure: (string->utf32 string endianness)\nreturns: a bytevector containing the specified encoding of string \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "endianness must be one of the symbols big or little. If endianness is not provided or is the symbol big, string->utf16 returns the UTF-16BE encoding of string and string->utf32 returns the UTF-32BE encoding of string. If endianness is the symbol little, string->utf16 returns the UTF-16LE encoding of string and string->utf32 returns the UTF-32LE encoding of string. No byte-order mark is included in the encoding. \n\n") ("io:s95" "procedure: (utf8->string bytevector)\nreturns: a string containing the UTF-8 decoding of bytevector \nlibraries: (rnrs bytevectors), (rnrs)  \n\n") ("io:s96" "procedure: (utf16->string bytevector endianness)\nprocedure: (utf16->string bytevector endianness endianness-mandatory?)\nprocedure: (utf32->string bytevector endianness)\nprocedure: (utf32->string bytevector endianness endianness-mandatory?)\nreturns: a string containing the specified decoding of bytevector \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "endianness must be one of the symbols big or little. These procedures return a UTF-16 or UTF-32 decoding of bytevector, with the endianness of the representation determined from the endianness argument or byte-order mark (BOM). If endianness-mandatory? is not provided or is #f, the endianness is determined by a BOM at the front of bytevector or, if no BOM is present, by endianness. If endianness-mandatory? is #t, the endianness is determined by endianness, and, if a BOM appears at the front of bytevector, it is treated as a regular character encoding. \n\n" "The UTF-16 BOM is the two-byte sequence #xFE, #xFF specifying \"big\" or the two-byte sequence #xFF, #xFE specifying \"little.\" The UTF-32 BOM is the four-byte sequence #x00, #x00, #xFE, #xFF specifying \"big\" or the four-byte sequence #xFF, #xFE, #x00, #x00 specifying \"little.\" \n\n") ("objects:s1" "syntax: constant \nreturns: constant \n\n" "constant is any self-evaluating constant, i.e., a number, boolean, character, string, or bytevector. Constants are immutable; see the note in the description of quote below.  \n\n" "" "3.2 => 3.2\n#f => #f\n#\\c => #\\c\n\"hi\" => \"hi\"\n#vu8(3 4 5) => #vu8(3 4 5)\n\n") ("objects:s2" "syntax: (quote obj)\nsyntax: 'obj\nreturns: obj \nlibraries: (rnrs base), (rnrs)  \n\n" "'obj is equivalent to (quote obj). The abbreviated form is converted into the longer form by the Scheme reader (see read).  \n\n" "quote inhibits the normal evaluation rule for obj, allowing obj to be employed as data. Although any Scheme object may be quoted, quotation is not necessary for self-evaluating constants, i.e., numbers, booleans, characters, strings, and bytevectors. \n\n" "Quoted and self-evaluating constants are immutable. That is, programs should not alter a constant via set-car!, string-set!, etc., and implementations are permitted to raise an exception with condition type &assertion if such an alteration is attempted. If an attempt to alter an immutable object is undetected, the behavior of the program is unspecified. An implementation may choose to share storage among different constants to save space. \n\n" "" "(+ 2 3) => 5\n'(+ 2 3) => (+ 2 3)\n(quote (+ 2 3)) => (+ 2 3)\n'a => a\n'cons => cons\n'() => ()\n'7 => 7\n\n") ("objects:s5" "syntax: (quasiquote obj ...)\nsyntax: `obj\nsyntax: (unquote obj ...)\nsyntax: ,obj\nsyntax: (unquote-splicing obj ...)\nsyntax: ,@obj\nreturns: see below  \nlibraries: (rnrs base), (rnrs)  \n\n" "`obj is equivalent to (quasiquote obj), ,obj is equivalent to (unquote obj), and ,@obj is equivalent to (unquote-splicing obj). The abbreviated forms are converted into the longer forms by the Scheme reader (see read).  \n\n" "quasiquote is similar to quote, but it allows parts of the quoted text to be \"unquoted.\" Within a quasiquote expression, unquote and unquote-splicing subforms are evaluated, and everything else is quoted, i.e., left unevaluated. The value of each unquote subform is inserted into the output in place of the unquote form, while the value of each unquote-splicing subform is spliced into the surrounding list or vector structure. unquote and unquote-splicing are valid only within quasiquote expressions.  \n\n" "quasiquote expressions may be nested, with each quasiquote introducing a new level of quotation and each unquote or unquote-splicing taking away a level of quotation. An expression nested within n quasiquote expressions must be within n unquote or unquote-splicing expressions to be evaluated. \n\n" "" "`(+ 2 3) => (+ 2 3) \n\n`(+ 2 ,(* 3 4)) => (+ 2 12)\n`(a b (,(+ 2 3) c) d) => (a b (5 c) d)\n`(a b ,(reverse '(c d e)) f g) => (a b (e d c) f g)\n(let ([a 1] [b 2])\n  `(,a . ,b)) => (1 . 2) \n\n`(+ ,@(cdr '(* 2 3))) => (+ 2 3)\n`(a b ,@(reverse '(c d e)) f g) => (a b e d c f g)\n(let ([a 1] [b 2])\n  `(,a ,@b)) => (1 . 2)\n`#(,@(list 1 2 3)) => #(1 2 3) \n\n'`,(cons 'a 'b) => `,(cons 'a 'b)\n`',(cons 'a 'b) => '(a . b)\n\n" "unquote and unquote-splicing forms with zero or more than one subform are valid only in splicing (list or vector) contexts. (unquote obj ...) is equivalent to (unquote obj) ..., and (unquote-splicing obj ...) is equivalent to (unquote-splicing obj) .... These forms are primarily useful as intermediate forms in the output of the quasiquote expander. They support certain useful nested quasiquotation idioms [3], such as ,@,@, which has the effect of a doubly indirect splicing when used within a doubly nested and doubly evaluated quasiquote expression.  \n\n" "" "`(a (unquote) b) => (a b)\n`(a (unquote (+ 3 3)) b) => (a 6 b)\n`(a (unquote (+ 3 3) (* 3 3)) b) => (a 6 9 b) \n\n(let ([x '(m n)]) ``(a ,@,@x f)) => `(a (unquote-splicing m n) f)\n(let ([x '(m n)])\n  (eval `(let ([m '(b c)] [n '(d e)]) `(a ,@,@x f))\n        (environment '(rnrs)))) => (a b c d e f)\n\n" "unquote and unquote-splicing are auxiliary keywords for quasiquote. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords. \n\n") ("objects:s10" "procedure: (eq? obj1 obj2)\nreturns: #t if obj1 and obj2 are identical, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "In most Scheme systems, two objects are considered identical if they are represented internally by the same pointer value and distinct (not identical) if they are represented internally by different pointer values, although other criteria, such as time-stamping, are possible. \n\n" "Although the particular rules for object identity vary somewhat from system to system, the following rules always hold. \n\n" "\n* Two objects of different types (booleans, the empty list, pairs, numbers, characters, strings, vectors, symbols, and procedures) are distinct. \n* Two objects of the same type with different contents or values are distinct. \n* The boolean object #t is identical to itself wherever it appears, and #f is identical to itself wherever it appears, but #t and #f are distinct.  \n* The empty list () is identical to itself wherever it appears.  \n* Two symbols are identical if and only if they have the same name (by string=?).  \n* A constant pair, vector, string, or bytevector is identical to itself, as is a pair, vector, string, or bytevector created by an application of cons, vector, string, make-bytevector, etc. Two pairs, vectors, strings, or bytevectors created by different applications of cons, vector, string, make-bytevector, etc., are distinct. One consequence is that cons, for example, may be used to create a unique object distinct from all other objects. \n* Two procedures that may behave differently are distinct. A procedure created by an evaluation of a lambda expression is identical to itself. Two procedures created by the same lambda expression at different times, or by similar lambda expressions, may or may not be distinct. \n\n" "" "eq? cannot be used to compare numbers and characters reliably. Although every inexact number is distinct from every exact number, two exact numbers, two inexact numbers, or two characters with the same value may or may not be identical. \n\n" "Since constant objects are immutable, i.e., programs should not modify them via vector-set!, set-car!, or any other structure mutation operation, all or portions of different quoted constants or self-evaluating literals may be represented internally by the same object. Thus, eq? may return #t when applied to equal parts of different immutable constants. \n\n" "eq? is most often used to compare symbols or to check for pointer equivalence of allocated objects, e.g., pairs, vectors, or record instances. \n\n" "" "(eq? 'a 3) => #f\n(eq? #t 't) => #f\n(eq? \"abc\" 'abc) => #f\n(eq? \"hi\" '(hi)) => #f\n(eq? #f '()) => #f \n\n(eq? 9/2 7/2) => #f\n(eq? 3.4 53344) => #f\n(eq? 3 3.0) => #f\n(eq? 1/3 #i1/3) => #f \n\n(eq? 9/2 9/2) => unspecified\n(eq? 3.4 (+ 3.0 .4)) => unspecified\n(let ([x (* 12345678987654321 2)])\n  (eq? x x)) => unspecified\n\n(eq? #\\a #\\b) => #f\n(eq? #\\a #\\a) => unspecified\n(let ([x (string-ref \"hi\" 0)])\n  (eq? x x)) => unspecified\n\n(eq? #t #t) => #t\n(eq? #f #f) => #t\n(eq? #t #f) => #f\n(eq? (null? '()) #t) => #t\n(eq? (null? '(a)) #f) => #t \n\n(eq? (cdr '(a)) '()) => #t \n\n(eq? 'a 'a) => #t\n(eq? 'a 'b) => #f\n(eq? 'a (string->symbol \"a\")) => #t \n\n(eq? '(a) '(b)) => #f\n(eq? '(a) '(a)) => unspecified\n(let ([x '(a . b)]) (eq? x x)) => #t\n(let ([x (cons 'a 'b)])\n  (eq? x x)) => #t\n(eq? (cons 'a 'b) (cons 'a 'b)) => #f \n\n(eq? \"abc\" \"cba\") => #f\n(eq? \"abc\" \"abc\") => unspecified\n(let ([x \"hi\"]) (eq? x x)) => #t\n(let ([x (string #\\h #\\i)]) (eq? x x)) => #t\n(eq? (string #\\h #\\i)\n     (string #\\h #\\i)) => #f \n\n(eq? '#vu8(1) '#vu8(1)) => unspecified\n(eq? '#vu8(1) '#vu8(2)) => #f\n(let ([x (make-bytevector 10 0)])\n  (eq? x x)) => #t\n(let ([x (make-bytevector 10 0)])\n  (eq? x (make-bytevector 10 0))) => #f \n\n(eq? '#(a) '#(b)) => #f\n(eq? '#(a) '#(a)) => unspecified\n(let ([x '#(a)]) (eq? x x)) => #t\n(let ([x (vector 'a)])\n  (eq? x x)) => #t\n(eq? (vector 'a) (vector 'a)) => #f \n\n(eq? car car) => #t\n(eq? car cdr) => #f\n(let ([f (lambda (x) x)])\n  (eq? f f)) => #t\n(let ([f (lambda () (lambda (x) x))])\n  (eq? (f) (f))) => unspecified\n(eq? (lambda (x) x) (lambda (y) y)) => unspecified\n\n(let ([f (lambda (x)\n           (lambda ()\n             (set! x (+ x 1))\n             x))])\n  (eq? (f 0) (f 0))) => #f\n\n") ("objects:s12" "procedure: (eqv? obj1 obj2)\nreturns: #t if obj1 and obj2 are equivalent, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "eqv? is similar to eq? except eqv? is guaranteed to return #t for two characters that are considered equal by char=? and two numbers that are (a) considered equal by = and (b) cannot be distinguished by any other operation besides eq? and eqv?. A consequence of (b) is that (eqv? -0.0 +0.0) is #f even though (= -0.0 +0.0) is #t in systems that distinguish -0.0 and +0.0, such as those based on IEEE floating-point arithmetic. This is because operations such as / can expose the difference:  \n\n" "" "(/ 1.0 -0.0) => -inf.0\n(/ 1.0 +0.0) => +inf.0\n\n" "Similarly, although 3.0 and 3.0+0.0i are considered numerically equal, they are not considered equivalent by eqv? if -0.0 and 0.0 have different representations. \n\n" "" "(= 3.0+0.0i 3.0) => #t\n(eqv? 3.0+0.0i 3.0) => #f\n\n" "The boolean value returned by eqv? is not specified when the arguments are NaNs. \n\n" "" "(eqv? +nan.0 (/ 0.0 0.0)) => unspecified\n\n" "eqv? is less implementation-dependent but generally more expensive than eq?.  \n\n" "" "(eqv? 'a 3) => #f\n(eqv? #t 't) => #f\n(eqv? \"abc\" 'abc) => #f\n(eqv? \"hi\" '(hi)) => #f\n(eqv? #f '()) => #f \n\n(eqv? 9/2 7/2) => #f\n(eqv? 3.4 53344) => #f\n(eqv? 3 3.0) => #f\n(eqv? 1/3 #i1/3) => #f \n\n(eqv? 9/2 9/2) => #t\n(eqv? 3.4 (+ 3.0 .4)) => #t\n(let ([x (* 12345678987654321 2)])\n  (eqv? x x)) => #t \n\n(eqv? #\\a #\\b) => #f\n(eqv? #\\a #\\a) => #t\n(let ([x (string-ref \"hi\" 0)])\n  (eqv? x x)) => #t \n\n(eqv? #t #t) => #t\n(eqv? #f #f) => #t\n(eqv? #t #f) => #f\n(eqv? (null? '()) #t) => #t\n(eqv? (null? '(a)) #f) => #t \n\n(eqv? (cdr '(a)) '()) => #t \n\n(eqv? 'a 'a) => #t\n(eqv? 'a 'b) => #f\n(eqv? 'a (string->symbol \"a\")) => #t \n\n(eqv? '(a) '(b)) => #f\n(eqv? '(a) '(a)) => unspecified\n(let ([x '(a . b)]) (eqv? x x)) => #t\n(let ([x (cons 'a 'b)])\n  (eqv? x x)) => #t\n(eqv? (cons 'a 'b) (cons 'a 'b)) => #f \n\n(eqv? \"abc\" \"cba\") => #f\n(eqv? \"abc\" \"abc\") => unspecified\n(let ([x \"hi\"]) (eqv? x x)) => #t\n(let ([x (string #\\h #\\i)]) (eqv? x x)) => #t\n(eqv? (string #\\h #\\i)\n      (string #\\h #\\i)) => #f \n\n(eqv? '#vu8(1) '#vu8(1)) => unspecified\n(eqv? '#vu8(1) '#vu8(2)) => #f\n(let ([x (make-bytevector 10 0)])\n  (eqv? x x)) => #t\n(let ([x (make-bytevector 10 0)])\n  (eqv? x (make-bytevector 10 0))) => #f \n\n(eqv? '#(a) '#(b)) => #f\n(eqv? '#(a) '#(a)) => unspecified\n(let ([x '#(a)]) (eqv? x x)) => #t\n(let ([x (vector 'a)])\n  (eqv? x x)) => #t\n(eqv? (vector 'a) (vector 'a)) => #f \n\n(eqv? car car) => #t\n(eqv? car cdr) => #f\n(let ([f (lambda (x) x)])\n  (eqv? f f)) => #t\n(let ([f (lambda () (lambda (x) x))])\n  (eqv? (f) (f))) => unspecified\n(eqv? (lambda (x) x) (lambda (y) y)) => unspecified\n\n(let ([f (lambda (x)\n           (lambda ()\n             (set! x (+ x 1))\n             x))])\n  (eqv? (f 0) (f 0))) => #f\n\n") ("objects:s13" "procedure: (equal? obj1 obj2)\nreturns: #t if obj1 and obj2 have the same structure and contents, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "Two objects are equal if they are equivalent according to eqv?, strings that are string=?, bytevectors that are bytevector=?, pairs whose cars and cdrs are equal, or vectors of the same length whose corresponding elements are equal. \n\n" "equal? is required to terminate even for cyclic arguments and return #t \"if and only if the (possibly infinite) unfoldings of its arguments into regular trees are equal as ordered trees\" [24]. In essence, two values are equivalent, in the sense of equal?, if the structure of the two objects cannot be distinguished by any composition of pair and vector accessors along with the eqv?, string=?, and bytevector=? procedures for comparing data at the leaves. \n\n" "Implementing equal? efficiently is tricky [1], and even with a good implementation, it is likely to be more expensive than either eqv? or eq?.  \n\n" "" "(equal? 'a 3) => #f\n(equal? #t 't) => #f\n(equal? \"abc\" 'abc) => #f\n(equal? \"hi\" '(hi)) => #f\n(equal? #f '()) => #f \n\n(equal? 9/2 7/2) => #f\n(equal? 3.4 53344) => #f\n(equal? 3 3.0) => #f\n(equal? 1/3 #i1/3) => #f \n\n(equal? 9/2 9/2) => #t\n(equal? 3.4 (+ 3.0 .4)) => #t\n(let ([x (* 12345678987654321 2)])\n  (equal? x x)) => #t \n\n(equal? #\\a #\\b) => #f\n(equal? #\\a #\\a) => #t\n(let ([x (string-ref \"hi\" 0)])\n  (equal? x x)) => #t \n\n(equal? #t #t) => #t\n(equal? #f #f) => #t\n(equal? #t #f) => #f\n(equal? (null? '()) #t) => #t\n(equal? (null? '(a)) #f) => #t \n\n(equal? (cdr '(a)) '()) => #t \n\n(equal? 'a 'a) => #t\n(equal? 'a 'b) => #f\n(equal? 'a (string->symbol \"a\")) => #t \n\n(equal? '(a) '(b)) => #f\n(equal? '(a) '(a)) => #t\n(let ([x '(a . b)]) (equal? x x)) => #t\n(let ([x (cons 'a 'b)])\n  (equal? x x)) => #t\n(equal? (cons 'a 'b) (cons 'a 'b)) => #t \n\n(equal? \"abc\" \"cba\") => #f\n(equal? \"abc\" \"abc\") => #t\n(let ([x \"hi\"]) (equal? x x)) => #t\n(let ([x (string #\\h #\\i)]) (equal? x x)) => #t\n(equal? (string #\\h #\\i)\n        (string #\\h #\\i)) => #t \n\n(equal? '#vu8(1) '#vu8(1)) => #t\n(equal? '#vu8(1) '#vu8(2)) => #f\n(let ([x (make-bytevector 10 0)])\n  (equal? x x)) => #t\n(let ([x (make-bytevector 10 0)])\n  (equal? x (make-bytevector 10 0))) => #t \n\n(equal? '#(a) '#(b)) => #f\n(equal? '#(a) '#(a)) => #t\n(let ([x '#(a)]) (equal? x x)) => #t\n(let ([x (vector 'a)])\n  (equal? x x)) => #t\n(equal? (vector 'a) (vector 'a)) => #t \n\n(equal? car car) => #t\n(equal? car cdr) => #f\n(let ([f (lambda (x) x)])\n  (equal? f f)) => #t\n(let ([f (lambda () (lambda (x) x))])\n  (equal? (f) (f))) => unspecified\n(equal? (lambda (x) x) (lambda (y) y)) => unspecified\n\n(let ([f (lambda (x)\n           (lambda ()\n             (set! x (+ x 1))\n             x))])\n  (equal? (f 0) (f 0))) => #f \n\n(equal?\n  (let ([x (cons 'x 'x)])\n    (set-car! x x)\n    (set-cdr! x x)\n    x)\n  (let ([x (cons 'x 'x)])\n    (set-car! x x)\n    (set-cdr! x x)\n    (cons x x))) => #t\n\n") ("objects:s14" "procedure: (boolean? obj)\nreturns: #t if obj is either #t or #f, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "boolean? is equivalent to (lambda (x) (or (eq? x #t) (eq? x #f))). \n\n" "" "(boolean? #t) => #t\n(boolean? #f) => #t\n(or (boolean? 't) (boolean? '())) => #f\n\n") ("objects:s15" "procedure: (null? obj)\nreturns: #t if obj is the empty list, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "null? is equivalent to (lambda (x) (eq? x '())). \n\n" "" "(null? '()) => #t\n(null? '(a)) => #f\n(null? (cdr '(a))) => #t\n(null? 3) => #f\n(null? #f) => #f\n\n") ("objects:s16" "procedure: (pair? obj)\nreturns: #t if obj is a pair, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(pair? '(a b c)) => #t\n(pair? '(3 . 4)) => #t\n(pair? '()) => #f\n(pair? '#(a b)) => #f\n(pair? 3) => #f\n\n") ("objects:s17" "procedure: (number? obj)\nreturns: #t if obj is a number object, #f otherwise \nprocedure: (complex? obj)\nreturns: #t if obj is a complex number object, #f otherwise \nprocedure: (real? obj)\nreturns: #t if obj is a real number object, #f otherwise \nprocedure: (rational? obj)\nreturns: #t if obj is a rational number object, #f otherwise \nprocedure: (integer? obj)\nreturns: #t if obj is an integer object, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "These predicates form a hierarchy: any integer is rational, any rational is real, any real is complex, and any complex is numeric. Most implementations do not provide internal representations for irrational numbers, so all real numbers are typically rational as well. \n\n" "The real?, rational?, and integer? predicates do not recognize as real, rational, or integer complex numbers with inexact zero imaginary parts. \n\n" "" "(integer? 1901) => #t\n(rational? 1901) => #t\n(real? 1901) => #t\n(complex? 1901) => #t\n(number? 1901) => #t \n\n(integer? -3.0) => #t\n(rational? -3.0) => #t\n(real? -3.0) => #t\n(complex? -3.0) => #t\n(number? -3.0) => #t \n\n(integer? 7+0i) => #t\n(rational? 7+0i) => #t\n(real? 7+0i) => #t\n(complex? 7+0i) => #t\n(number? 7+0i) => #t \n\n(integer? -2/3) => #f\n(rational? -2/3) => #t\n(real? -2/3) => #t\n(complex? -2/3) => #t\n(number? -2/3) => #t \n\n(integer? -2.345) => #f\n(rational? -2.345) => #t\n(real? -2.345) => #t\n(complex? -2.345) => #t\n(number? -2.345) => #t \n\n(integer? 7.0+0.0i) => #f\n(rational? 7.0+0.0i) => #f\n(real? 7.0+0.0i) => #f\n(complex? 7.0+0.0i) => #t\n(number? 7.0+0.0i) => #t \n\n(integer? 3.2-2.01i) => #f\n(rational? 3.2-2.01i) => #f\n(real? 3.2-2.01i) => #f\n(complex? 3.2-2.01i) => #t\n(number? 3.2-2.01i) => #t \n\n(integer? 'a) => #f\n(rational? '(a b c)) => #f\n(real? \"3\") => #f\n(complex? '#(1 2)) => #f\n(number? #\\a) => #f\n\n") ("objects:s18" "procedure: (real-valued? obj)\nreturns: #t if obj is a real number, #f otherwise \nprocedure: (rational-valued? obj)\nreturns: #t if obj is a rational number, #f otherwise \nprocedure: (integer-valued? obj)\nreturns: #t if obj is an integer, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "These predicates are similar to real?, rational?, and integer?, but treat as real, rational, or integral complex numbers with inexact zero imaginary parts. \n\n" "" "(integer-valued? 1901) => #t\n(rational-valued? 1901) => #t\n(real-valued? 1901) => #t \n\n(integer-valued? -3.0) => #t\n(rational-valued? -3.0) => #t\n(real-valued? -3.0) => #t \n\n(integer-valued? 7+0i) => #t\n(rational-valued? 7+0i) => #t\n(real-valued? 7+0i) => #t \n\n(integer-valued? -2/3) => #f\n(rational-valued? -2/3) => #t\n(real-valued? -2/3) => #t \n\n(integer-valued? -2.345) => #f\n(rational-valued? -2.345) => #t\n(real-valued? -2.345) => #t \n\n(integer-valued? 7.0+0.0i) => #t\n(rational-valued? 7.0+0.0i) => #t\n(real-valued? 7.0+0.0i) => #t \n\n(integer-valued? 3.2-2.01i) => #f\n(rational-valued? 3.2-2.01i) => #f\n(real-valued? 3.2-2.01i) => #f\n\n" "As with real?, rational?, and integer?, these predicates return #f for all non-numeric values.  \n\n" "" "(integer-valued? 'a) => #f\n(rational-valued? '(a b c)) => #f\n(real-valued? \"3\") => #f\n\n") ("objects:s19" "procedure: (char? obj)\nreturns: #t if obj is a character, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(char? 'a) => #f\n(char? 97) => #f\n(char? #\\a) => #t\n(char? \"a\") => #f\n(char? (string-ref (make-string 1) 0)) => #t\n\n") ("objects:s20" "procedure: (string? obj)\nreturns: #t if obj is a string, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(string? \"hi\") => #t\n(string? 'hi) => #f\n(string? #\\h) => #f\n\n") ("objects:s21" "procedure: (vector? obj)\nreturns: #t if obj is a vector, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(vector? '#()) => #t\n(vector? '#(a b c)) => #t\n(vector? (vector 'a 'b 'c)) => #t\n(vector? '()) => #f\n(vector? '(a b c)) => #f\n(vector? \"abc\") => #f\n\n") ("objects:s22" "procedure: (symbol? obj)\nreturns: #t if obj is a symbol, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(symbol? 't) => #t\n(symbol? \"t\") => #f\n(symbol? '(t)) => #f\n(symbol? #\\t) => #f\n(symbol? 3) => #f\n(symbol? #t) => #f\n\n") ("objects:s23" "procedure: (procedure? obj)\nreturns: #t if obj is a procedure, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(procedure? car) => #t\n(procedure? 'car) => #f\n(procedure? (lambda (x) x)) => #t\n(procedure? '(lambda (x) x)) => #f\n(call/cc procedure?) => #t\n\n") ("objects:s24" "procedure: (bytevector? obj)\nreturns: #t if obj is a bytevector, #f otherwise \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "" "(bytevector? #vu8()) => #t\n(bytevector? '#()) => #f\n(bytevector? \"abc\") => #f\n\n") ("objects:s25" "procedure: (hashtable? obj)\nreturns: #t if obj is a hashtable, #f otherwise \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "" "(hashtable? (make-eq-hashtable)) => #t\n(hashtable? '(not a hash table)) => #f\n\n") ("objects:s37" "procedure: (cons obj1 obj2)\nreturns: a new pair whose car and cdr are obj1 and obj2\nlibraries: (rnrs base), (rnrs)  \n\n" "cons is the pair constructor procedure. obj1 becomes the car and obj2 becomes the cdr of the new pair. \n\n" "" "(cons 'a '()) => (a)\n(cons 'a '(b c)) => (a b c)\n(cons 3 4) => (3 . 4)\n\n") ("objects:s38" "procedure: (car pair)\nreturns: the car of pair \nlibraries: (rnrs base), (rnrs)  \n\n" "The empty list is not a pair, so the argument must not be the empty list. \n\n" "" "(car '(a)) => a\n(car '(a b c)) => a\n(car (cons 3 4)) => 3\n\n") ("objects:s39" "procedure: (cdr pair)\nreturns: the cdr of pair \nlibraries: (rnrs base), (rnrs)  \n\n" "The empty list is not a pair, so the argument must not be the empty list. \n\n" "" "(cdr '(a)) => ()\n(cdr '(a b c)) => (b c)\n(cdr (cons 3 4)) => 4\n\n") ("objects:s40" "procedure: (set-car! pair obj)\nreturns: unspecified \nlibraries: (rnrs mutable-pairs)\n\n" "set-car! changes the car of pair to obj. \n\n" "" "(let ([x (list 'a 'b 'c)])\n  (set-car! x 1)\n  x) => (1 b c)\n\n") ("objects:s41" "procedure: (set-cdr! pair obj)\nreturns: unspecified \nlibraries: (rnrs mutable-pairs)\n\n" "set-cdr! changes the cdr of pair to obj. \n\n" "" "(let ([x (list 'a 'b 'c)])\n  (set-cdr! x 1)\n  x) => (a . 1)\n\n") ("objects:s42" "procedure: (caar pair)\nprocedure: (cadr pair) \nprocedure: (cddddr pair)\nreturns: the caar, cadr, ..., or cddddr of pair \nlibraries: (rnrs base), (rnrs)  \n\n" "These procedures are defined as the composition of up to four cars and cdrs. The a's and d's between the c and r represent the application of car or cdr in order from right to left. For example, the procedure cadr applied to a pair yields the car of the cdr of the pair and is equivalent to (lambda (x) (car (cdr x))). \n\n" "" "(caar '((a))) => a\n(cadr '(a b c)) => b\n(cdddr '(a b c d)) => (d)\n(cadadr '(a (b c))) => c\n\n") ("objects:s43" "procedure: (list obj ...)\nreturns: a list of obj ...\nlibraries: (rnrs base), (rnrs)  \n\n" "list is equivalent to (lambda x x). \n\n" "" "(list) => ()\n(list 1 2 3) => (1 2 3)\n(list 3 2 1) => (3 2 1)\n\n") ("objects:s44" "procedure: (cons* obj ... final-obj)\nreturns: a list of obj ... terminated by final-obj \nlibraries: (rnrs lists), (rnrs)  \n\n" "If the objects obj ... are omitted, the result is simply final-obj. Otherwise, a list of obj ... is constructed, as with list, except that the final cdr field is final-obj instead of (). If final-obj is not a list, the result is an improper list. \n\n" "" "(cons* '()) => ()\n(cons* '(a b)) => (a b)\n(cons* 'a 'b 'c) => (a b . c)\n(cons* 'a 'b '(c d)) => (a b c d)\n\n") ("objects:s45" "procedure: (list? obj)\nreturns: #t if obj is a proper list, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "list? must return #f for all improper lists, including cyclic lists. A definition of list? is shown on page 67. \n\n" "" "(list? '()) => #t\n(list? '(a b c)) => #t\n(list? 'a) => #f\n(list? '(3 . 4)) => #f\n(list? 3) => #f\n(let ([x (list 'a 'b 'c)])\n  (set-cdr! (cddr x) x)\n  (list? x)) => #f\n\n") ("objects:s46" "procedure: (length list)\nreturns: the number of elements in list \nlibraries: (rnrs base), (rnrs)  \n\n" "length may be defined as follows, using an adaptation of the hare and tortoise algorithm used for the definition of list? on page 67. \n\n" "" "(define length\n  (lambda (x)\n    (define improper-list\n      (lambda ()\n        (assertion-violation 'length \"not a proper list\" x))) \n\n    (let f ([h x] [t x] [n 0])\n      (if (pair? h)\n          (let ([h (cdr h)])\n            (if (pair? h)\n                (if (eq? h t)\n                    (improper-list)\n                    (f (cdr h) (cdr t) (+ n 2)))\n                (if (null? h)\n                    (+ n 1)\n                    (improper-list))))\n          (if (null? h)\n              n\n              (improper-list)))))) \n\n(length '()) => 0\n(length '(a b c)) => 3\n(length '(a b . c)) => exception\n(length\n  (let ([ls (list 'a 'b)])\n    (set-cdr! (cdr ls) ls) => exception\n    ls))\n(length\n  (let ([ls (list 'a 'b)])\n    (set-car! (cdr ls) ls) => 2\n    ls))\n\n") ("objects:s47" "procedure: (list-ref list n)\nreturns: the nth element (zero-based) of list \nlibraries: (rnrs base), (rnrs)  \n\n" "n must be an exact nonnegative integer less than the length of list. list-ref may be defined without error checks as follows.  \n\n" "" "(define list-ref\n  (lambda (ls n)\n    (if (= n 0)\n        (car ls)\n        (list-ref (cdr ls) (- n 1))))) \n\n(list-ref '(a b c) 0) => a\n(list-ref '(a b c) 1) => b\n(list-ref '(a b c) 2) => c\n\n") ("objects:s48" "procedure: (list-tail list n)\nreturns: the nth tail (zero-based) of list \nlibraries: (rnrs base), (rnrs)  \n\n" "n must be an exact nonnegative integer less than or equal to the length of list. The result is not a copy; the tail is eq? to the nth cdr of list (or to list itself, if n is zero). \n\n" "list-tail may be defined without error checks as follows.  \n\n" "" "(define list-tail\n  (lambda (ls n)\n    (if (= n 0)\n        ls\n        (list-tail (cdr ls) (- n 1))))) \n\n(list-tail '(a b c) 0) => (a b c)\n(list-tail '(a b c) 2) => (c)\n(list-tail '(a b c) 3) => ()\n(list-tail '(a b c . d) 2) => (c . d)\n(list-tail '(a b c . d) 3) => d\n(let ([x (list 1 2 3)])\n  (eq? (list-tail x 2)\n       (cddr x))) => #t\n\n") ("objects:s49" "procedure: (append) \nprocedure: (append list ... obj)\nreturns: the concatenation of the input lists \nlibraries: (rnrs base), (rnrs)  \n\n" "append returns a new list consisting of the elements of the first list followed by the elements of the second list, the elements of the third list, and so on. The new list is made from new pairs for all arguments but the last; the last (which need not be a list) is merely placed at the end of the new structure. append may be defined without error checks as follows.  \n\n" "" "(define append\n  (lambda args\n    (let f ([ls '()] [args args])\n      (if (null? args)\n          ls\n          (let g ([ls ls])\n            (if (null? ls)\n                (f (car args) (cdr args))\n                (cons (car ls) (g (cdr ls))))))))) \n\n(append '(a b c) '()) => (a b c)\n(append '() '(a b c)) => (a b c)\n(append '(a b) '(c d)) => (a b c d)\n(append '(a b) 'c) => (a b . c)\n(let ([x (list 'b)])\n  (eq? x (cdr (append '(a) x)))) => #t\n\n") ("objects:s50" "procedure: (reverse list)\nreturns: a new list containing the elements of list in reverse order \nlibraries: (rnrs base), (rnrs)  \n\n" "reverse may be defined without error checks as follows.  \n\n" "" "(define reverse\n  (lambda (ls)\n    (let rev ([ls ls] [new '()])\n      (if (null? ls)\n          new\n          (rev (cdr ls) (cons (car ls) new)))))) \n\n(reverse '()) => ()\n(reverse '(a b c)) => (c b a)\n\n") ("objects:s51" "procedure: (memq obj list)\nprocedure: (memv obj list)\nprocedure: (member obj list)\nreturns: the first tail of list whose car is equivalent to obj, or #f \nlibraries: (rnrs lists), (rnrs)  \n\n" "These procedures traverse the argument list in order, comparing the elements of list against obj. If an object equivalent to obj is found, the tail of the list whose first element is that object is returned. If the list contains more than one object equivalent to obj, the first tail whose first element is equivalent to obj is returned. If no object equivalent to obj is found, #f is returned. The equivalence test for memq is eq?, for memv is eqv?, and for member is equal?.  \n\n" "These procedures are most often used as predicates, but their names do not end with a question mark because they return a useful true value in place of #t. memq may be defined without error checks as follows.  \n\n" "" "(define memq\n  (lambda (x ls)\n    (cond\n      [(null? ls) #f]\n      [(eq? (car ls) x) ls]\n      [else (memq x (cdr ls))])))\n\n" "memv and member may be defined similarly, with eqv? and equal? in place of eq?.  \n\n" "" "(memq 'a '(b c a d e)) => (a d e)\n(memq 'a '(b c d e g)) => #f\n(memq 'a '(b a c a d a)) => (a c a d a) \n\n(memv 3.4 '(1.2 2.3 3.4 4.5)) => (3.4 4.5)\n(memv 3.4 '(1.3 2.5 3.7 4.9)) => #f\n(let ([ls (list 'a 'b 'c)])\n  (set-car! (memv 'b ls) 'z)\n  ls) => (a z c) \n\n(member '(b) '((a) (b) (c))) => ((b) (c))\n(member '(d) '((a) (b) (c))) => #f\n(member \"b\" '(\"a\" \"b\" \"c\")) => (\"b\" \"c\") \n\n(let ()\n  (define member?\n    (lambda (x ls)\n      (and (member x ls) #t)))\n  (member? '(b) '((a) (b) (c)))) => #t \n\n(define count-occurrences\n  (lambda (x ls)\n    (cond\n      [(memq x ls) =>\n       (lambda (ls)\n         (+ (count-occurrences x (cdr ls)) 1))]\n      [else 0]))) \n\n(count-occurrences 'a '(a b c d a)) => 2\n\n") ("objects:s52" "procedure: (memp procedure list)\nreturns: the first tail of list for whose car procedure returns true, or #f \nlibraries: (rnrs lists), (rnrs)  \n\n" "procedure should accept one argument and return a single value. It should not modify list. \n\n" "" "(memp odd? '(1 2 3 4)) => (1 2 3 4)\n(memp even? '(1 2 3 4)) => (2 3 4)\n(let ([ls (list 1 2 3 4)])\n  (eq? (memp odd? ls) ls)) => #t\n(let ([ls (list 1 2 3 4)])\n  (eq? (memp even? ls) (cdr ls))) => #t\n(memp odd? '(2 4 6 8)) => #f\n\n") ("objects:s53" "procedure: (remq obj list)\nprocedure: (remv obj list)\nprocedure: (remove obj list)\nreturns: a list containing the elements of list with all occurrences of obj removed \nlibraries: (rnrs lists), (rnrs)  \n\n" "These procedures traverse the argument list, removing any objects that are equivalent to obj. The elements remaining in the output list are in the same order as they appear in the input list. If a tail of list (including list itself) contains no occurrences of  obj, the corresponding tail of the result list may be the same (by eq?) as the tail of the input list.  \n\n" "The equivalence test for remq is eq?, for remv is eqv?, and for remove is equal?.  \n\n" "" "(remq 'a '(a b a c a d)) => (b c d)\n(remq 'a '(b c d)) => (b c d) \n\n(remv 1/2 '(1.2 1/2 0.5 3/2 4)) => (1.2 0.5 3/2 4) \n\n(remove '(b) '((a) (b) (c))) => ((a) (c))\n\n") ("objects:s54" "procedure: (remp procedure list)\nreturns: a list of the elements of list for which procedure returns #f \nlibraries: (rnrs lists), (rnrs)  \n\n" "procedure should accept one argument and return a single value. It should not modify list. \n\n" "remp applies procedure to each element of list and returns a list containing only the elements for which procedure returns #f. The elements of the returned list appear in the same order as they appeared in the original list. \n\n" "" "(remp odd? '(1 2 3 4)) => (2 4)\n(remp\n  (lambda (x) (and (> x 0) (< x 10)))\n  '(-5 15 3 14 -20 6 0 -9)) => (-5 15 14 -20 0 -9)\n\n") ("objects:s55" "procedure: (filter procedure list)\nreturns: a list of the elements of list for which procedure returns true \nlibraries: (rnrs lists), (rnrs)  \n\n" "procedure should accept one argument and return a single value. It should not modify list. \n\n" "filter applies procedure to each element of list and returns a new list containing only the elements for which procedure returns true. The elements of the returned list appear in the same order as they appeared in the original list. \n\n" "" "(filter odd? '(1 2 3 4)) => (1 3)\n(filter\n  (lambda (x) (and (> x 0) (< x 10)))\n  '(-5 15 3 14 -20 6 0 -9)) => (3 6)\n\n") ("objects:s56" "procedure: (partition procedure list)\nreturns: see below \nlibraries: (rnrs lists), (rnrs)  \n\n" "procedure should accept one argument and return a single value. It should not modify list. \n\n" "partition applies procedure to each element of list and returns two values: a new list containing only the elements for which procedure returns true, and a new list containing only the elements for which procedure returns #f. The elements of the returned lists appear in the same order as they appeared in the original list. \n\n" "" "(partition odd? '(1 2 3 4)) => (1 3)\n                               (2 4)\n(partition\n  (lambda (x) (and (> x 0) (< x 10)))\n  '(-5 15 3 14 -20 6 0 -9)) => (3 6)\n                               (-5 15 14 -20 0 -9)\n\n" "The values returned by partition can be obtained by calling filter and remp separately, but this would require two calls to procedure for each element of list. \n\n") ("objects:s57" "procedure: (find procedure list)\nreturns: the first element of list for which procedure returns true, or #f \nlibraries: (rnrs lists), (rnrs)  \n\n" "procedure should accept one argument and return a single value. It should not modify list. \n\n" "find traverses the argument list in order, applying procedure to each element in turn. If procedure returns a true value for a given element, find returns that element without applying procedure to the remaining elements. If procedure returns #f for each element of list, find returns #f.  \n\n" "If a program must distinguish between finding #f in the list and finding no element at all, memp should be used instead.  \n\n" "" "(find odd? '(1 2 3 4)) => 1\n(find even? '(1 2 3 4)) => 2\n(find odd? '(2 4 6 8)) => #f\n(find not '(1 a #f 55)) => #f\n\n") ("objects:s58" "procedure: (assq obj alist)\nprocedure: (assv obj alist)\nprocedure: (assoc obj alist)\nreturns: first element of alist whose car is equivalent to obj, or #f \nlibraries: (rnrs lists), (rnrs)  \n\n" "The argument alist must be an association list. An association list is a proper list whose elements are key-value pairs of the form (key . value). Associations are useful for storing information (values) associated with certain objects (keys). \n\n" "These procedures traverse the association list, testing each key for equivalence with obj. If an equivalent key is found, the key-value pair is returned. Otherwise, #f is returned.  \n\n" "The equivalence test for assq is eq?, for assv is eqv?, and for assoc is equal?. assq may be defined without error checks as follows.  \n\n" "" "(define assq\n  (lambda (x ls)\n    (cond\n      [(null? ls) #f]\n      [(eq? (caar ls) x) (car ls)]\n      [else (assq x (cdr ls))])))\n\n" "assv and assoc may be defined similarly, with eqv? and equal? in place of eq?.  \n\n" "" "(assq 'b '((a . 1) (b . 2))) => (b . 2)\n(cdr (assq 'b '((a . 1) (b . 2)))) => 2\n(assq 'c '((a . 1) (b . 2))) => #f \n\n(assv 2/3 '((1/3 . 1) (2/3 . 2))) => (2/3 . 2)\n(assv 2/3 '((1/3 . a) (3/4 . b))) => #f \n\n(assoc '(a) '(((a) . a) (-1 . b))) => ((a) . a)\n(assoc '(a) '(((b) . b) (a . c))) => #f \n\n(let ([alist (list (cons 2 'a) (cons 3 'b))])\n  (set-cdr! (assv 3 alist) 'c)\n  alist) => ((2 . a) (3 . c))\n\n" "The interpreter given in Section 12.7 represents environments as association lists and uses assq for both variable lookup and assignment. \n\n") ("objects:s60" "procedure: (assp procedure alist)\nreturns: first element of alist for whose car procedure returns true, or #f \nlibraries: (rnrs lists), (rnrs)  \n\n" "alist must be an association list. An association list is a proper list whose elements are key-value pairs of the form (key . value). procedure should accept one argument and return a single value. It should not modify list. \n\n" "" "(assp odd? '((1 . a) (2 . b))) => (1 . a)\n(assp even? '((1 . a) (2 . b))) => (2 . b)\n(let ([ls (list (cons 1 'a) (cons 2 'b))])\n  (eq? (assp odd? ls) (car ls))) => #t\n(let ([ls (list (cons 1 'a) (cons 2 'b))])\n  (eq? (assp even? ls) (cadr ls))) => #t\n(assp odd? '((2 . b))) => #f\n\n") ("objects:s62" "procedure: (list-sort predicate list)\nreturns: a list containing the elements of list sorted according to predicate \nlibraries: (rnrs sorting), (rnrs)  \n\n" "predicate should be a procedure that expects two arguments and returns #t if its first argument must precede its second in the sorted list. That is, if predicate is applied to two elements x and y, where x appears after y in the input list, it should return true only if x should appear before y in the output list. If this constraint is met, list-sort performs a stable sort, i.e., two elements are reordered only when necessary according to predicate. Duplicate elements are not removed. This procedure may call predicate up to nlogn times, where n is the length of list. \n\n" "" "(list-sort < '(3 4 2 1 2 5)) => (1 2 2 3 4 5)\n(list-sort > '(0.5 1/2)) => (0.5 1/2)\n(list-sort > '(1/2 0.5)) => (1/2 0.5)\n(list->string\n  (list-sort char>?\n    (string->list \"hello\"))) => \"ollhe\"\n\n") ("objects:s86" "procedure: (exact? num)\nreturns: #t if num is exact, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(exact? 1) => #t\n(exact? -15/16) => #t\n(exact? 2.01) => #f\n(exact? #i77) => #f\n(exact? #i2/3) => #f\n(exact? 1.0-2i) => #f\n\n") ("objects:s87" "procedure: (inexact? num)\nreturns: #t if num is inexact, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(inexact? -123) => #f\n(inexact? #i123) => #t\n(inexact? 1e23) => #t\n(inexact? +i) => #f\n\n") ("objects:s88" "procedure: (= num1 num2 num3 ...)\nprocedure: (< real1 real2 real3 ...)\nprocedure: (> real1 real2 real3 ...)\nprocedure: (<= real1 real2 real3 ...)\nprocedure: (>= real1 real2 real3 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "The predicate = returns #t if its arguments are equal. The predicate < returns #t if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while > returns #t if its arguments are monotonically decreasing. The predicate <= returns #t if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while >= returns #t if its arguments are monotonically nonincreasing.  \n\n" "As implied by the names of the arguments, = is defined for complex arguments while the other relational predicates are defined only for real arguments. Two complex numbers are considered equal if their real and imaginary parts are equal. Comparisons involving NaNs always return #f.  \n\n" "" "(= 7 7) => #t\n(= 7 9) => #f \n\n(< 2e3 3e2) => #f\n(<= 1 2 3 3 4 5) => #t\n(<= 1 2 3 4 5) => #t \n\n(> 1 2 2 3 3 4) => #f\n(>= 1 2 2 3 3 4) => #f \n\n(= -1/2 -0.5) => #t\n(= 2/3 .667) => #f\n(= 7.2+0i 7.2) => #t\n(= 7.2-3i 7) => #f \n\n(< 1/2 2/3 3/4) => #t\n(> 8 4.102 2/3 -5) => #t \n\n(let ([x 0.218723452])\n  (< 0.210 x 0.220)) => #t \n\n(let ([i 1] [v (vector 'a 'b 'c)])\n  (< -1 i (vector-length v))) => #t \n\n(apply < '(1 2 3 4)) => #t\n(apply > '(4 3 3 2)) => #f \n\n(= +nan.0 +nan.0) => #f\n(< +nan.0 +nan.0) => #f\n(> +nan.0 +nan.0) => #f\n(>= +inf.0 +nan.0) => #f\n(>= +nan.0 -inf.0) => #f\n(> +nan.0 0.0) => #f\n\n") ("objects:s89" "procedure: (+ num ...)\nreturns: the sum of the arguments num ...\nlibraries: (rnrs base), (rnrs)  \n\n" "When called with no arguments, + returns 0.  \n\n" "" "(+) => 0\n(+ 1 2) => 3\n(+ 1/2 2/3) => 7/6\n(+ 3 4 5) => 12\n(+ 3.0 4) => 7.0\n(+ 3+4i 4+3i) => 7+7i\n(apply + '(1 2 3 4 5)) => 15\n\n") ("objects:s90" "procedure: (- num)\nreturns: the additive inverse of num \nprocedure: (- num1 num2 num3 ...)\nreturns: the difference between num1 and the sum of num2 num3 ...\nlibraries: (rnrs base), (rnrs)  \n\n" "" "(- 3) => -3\n(- -2/3) => 2/3\n(- 4 3.0) => 1.0\n(- 3.25+4.25i 1/4+1/4i) => 3.0+4.0i\n(- 4 3 2 1) => -2\n\n") ("objects:s91" "procedure: (* num ...)\nreturns: the product of the arguments num ...\nlibraries: (rnrs base), (rnrs)  \n\n" "When called with no arguments, * returns 1.  \n\n" "" "(*) => 1\n(* 3.4) => 3.4\n(* 1 1/2) => 1/2\n(* 3 4 5.5) => 66.0\n(* 1+2i 3+4i) => -5+10i\n(apply * '(1 2 3 4 5)) => 120\n\n") ("objects:s92" "procedure: (/ num)\nreturns: the multiplicative inverse of num \nprocedure: (/ num1 num2 num3 ...)\nreturns: the result of dividing num1 by the product of num2 num3 ...\nlibraries: (rnrs base), (rnrs)  \n\n" "" "(/ -17) => -1/17\n(/ 1/2) => 2\n(/ .5) => 2.0\n(/ 3 4) => 3/4\n(/ 3.0 4) => .75\n(/ -5+10i 3+4i) => 1+2i\n(/ 60 5 4 3 2) => 1/2\n\n") ("objects:s93" "procedure: (zero? num)\nreturns: #t if num is zero, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "zero? is equivalent to (lambda (x) (= x 0)). \n\n" "" "(zero? 0) => #t\n(zero? 1) => #f\n(zero? (- 3.0 3.0)) => #t\n(zero? (+ 1/2 1/2)) => #f\n(zero? 0+0i) => #t\n(zero? 0.0-0.0i) => #t\n\n") ("objects:s94" "procedure: (positive? real)\nreturns: #t if real is greater than zero, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "positive? is equivalent to (lambda (x) (> x 0)). \n\n" "" "(positive? 128) => #t\n(positive? 0.0) => #f\n(positive? 1.8e-15) => #t\n(positive? -2/3) => #f\n(positive? .001-0.0i) => exception: not a real number\n\n") ("objects:s95" "procedure: (negative? real)\nreturns: #t if real is less than zero, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "negative? is equivalent to (lambda (x) (< x 0)). \n\n" "" "(negative? -65) => #t\n(negative? 0) => #f\n(negative? -0.0121) => #t\n(negative? 15/16) => #f\n(negative? -7.0+0.0i) => exception: not a real number\n\n") ("objects:s96" "procedure: (even? int)\nreturns: #t if int is even, #f otherwise \nprocedure: (odd? int)\nreturns: #t if int is odd, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(even? 0) => #t\n(even? 1) => #f\n(even? 2.0) => #t\n(even? -120762398465) => #f\n(even? 2.0+0.0i) => exception: not an integer\n\n(odd? 0) => #f\n(odd? 1) => #t\n(odd? 2.0) => #f\n(odd? -120762398465) => #t\n(odd? 2.0+0.0i) => exception: not an integer\n\n") ("objects:s97" "procedure: (finite? real)\nreturns: #t if real is finite, #f otherwise \nprocedure: (infinite? real)\nreturns: #t if real is infinite, #f otherwise \nprocedure: (nan? real)\nreturns: #t if real is a NaN, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(finite? 2/3) => #t\n(infinite? 2/3) => #f\n(nan? 2/3) => #f \n\n(finite? 3.1415) => #t\n(infinite? 3.1415) => #f\n(nan? 3.1415) => #f \n\n(finite? +inf.0) => #f\n(infinite? -inf.0) => #t\n(nan? -inf.0) => #f \n\n(finite? +nan.0) => #f\n(infinite? +nan.0) => #f\n(nan? +nan.0) => #t\n\n") ("objects:s98" "procedure: (quotient int1 int2)\nreturns: the integer quotient of int1 and int2\nprocedure: (remainder int1 int2)\nreturns: the integer remainder of int1 and int2\nprocedure: (modulo int1 int2)\nreturns: the integer modulus of int1 and int2\nlibraries: (rnrs r5rs)\n\n" "The result of remainder has the same sign as int1, while the result of modulo has the same sign as int2. \n\n" "" "(quotient 45 6) => 7\n(quotient 6.0 2.0) => 3.0\n(quotient 3.0 -2) => -1.0 \n\n(remainder 16 4) => 0\n(remainder 5 2) => 1\n(remainder -45.0 7) => -3.0\n(remainder 10.0 -3.0) => 1.0\n(remainder -17 -9) => -8 \n\n(modulo 16 4) => 0\n(modulo 5 2) => 1\n(modulo -45.0 7) => 4.0\n(modulo 10.0 -3.0) => -2.0\n(modulo -17 -9) => -8\n\n") ("objects:s99" "procedure: (div x1 x2)\nprocedure: (mod x1 x2)\nprocedure: (div-and-mod x1 x2)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "If x1 and x2 are exact, x2 must not be zero. These procedures implement number-theoretic integer division, with the div operation being related to quotient and the mod operation being related to remainder or modulo, but in both cases extended to handle real numbers.  \n\n" "The value nd of (div x1 x2) is an integer, and the value xm of (mod x1 x2) is a real number such that x1 = nd  x2 + xm and 0 <= xm < |x2|. In situations where the implementation cannot represent the mathematical results prescribed by these equations as a number object, div and mod return an unspecified number or raise an exception with condition type &implementation-restriction.  \n\n" "The div-and-mod procedure behaves as if defined as follows.  \n\n" "" "(define (div-and-mod x1 x2) (values (div x1 x2) (mod x1 x2)))\n\n" "That is, unless it raises an exception in the circumstance described above, it returns two values: the result of calling div on the two arguments and the result of calling mod on the two arguments. \n\n" "" "(div 17 3) => 5\n(mod 17 3) => 2\n(div -17 3) => -6\n(mod -17 3) => 1\n(div 17 -3) => -5\n(mod 17 -3) => 2\n(div -17 -3) => 6\n(mod -17 -3) => 1 \n\n(div-and-mod 17.5 3) => 5.0\n                        2.5\n\n") ("objects:s100" "procedure: (div0 x1 x2)\nprocedure: (mod0 x1 x2)\nprocedure: (div0-and-mod0 x1 x2)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "If x1 and x2 are exact, x2 must not be zero. These procedures are similar to div, mod, and div-and-mod, but constrain the \"mod\" value differently, which also affects the \"div\" value. The value nd of (div0 x1 x2) is an integer, and the value xm of (mod0 x1 x2) is a real number such that x1 = nd  x2 + xm and -|x2/2| <= xm < |x2/2|. In situations where the implementation cannot represent the mathematical results prescribed by these equations as a number object, div0 and mod0 return an unspecified number or raise an exception with condition type &implementation-restriction.  \n\n" "The div0-and-mod0 procedure behaves as if defined as follows.  \n\n" "" "(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))\n\n" "That is, unless it raises an exception in the circumstance described above, it returns two values: the result of calling div0 on the two arguments and the result of calling mod0 on the two arguments. \n\n" "" "(div0 17 3) => 6\n(mod0 17 3) => -1\n(div0 -17 3) => -6\n(mod0 -17 3) => 1\n(div0 17 -3) => -6\n(mod0 17 -3) => -1\n(div0 -17 -3) => 6\n(mod0 -17 -3) => 1 \n\n(div0-and-mod0 17.5 3) => 6.0\n                          -0.5\n\n") ("objects:s101" "procedure: (truncate real)\nreturns: the integer closest to real toward zero \nlibraries: (rnrs base), (rnrs)  \n\n" "If real is an infinity or NaN, truncate returns real. \n\n" "" "(truncate 19) => 19\n(truncate 2/3) => 0\n(truncate -2/3) => 0\n(truncate 17.3) => 17.0\n(truncate -17/2) => -8\n\n") ("objects:s102" "procedure: (floor real)\nreturns: the integer closest to real toward -\nlibraries: (rnrs base), (rnrs)  \n\n" "If real is an infinity or NaN, floor returns real. \n\n" "" "(floor 19) => 19\n(floor 2/3) => 0\n(floor -2/3) => -1\n(floor 17.3) => 17.0\n(floor -17/2) => -9\n\n") ("objects:s103" "procedure: (ceiling real)\nreturns: the integer closest to real toward +\nlibraries: (rnrs base), (rnrs)  \n\n" "If real is an infinity or NaN, ceiling returns real. \n\n" "" "(ceiling 19) => 19\n(ceiling 2/3) => 1\n(ceiling -2/3) => 0\n(ceiling 17.3) => 18.0\n(ceiling -17/2) => -8\n\n") ("objects:s104" "procedure: (round real)\nreturns: the integer closest to real \nlibraries: (rnrs base), (rnrs)  \n\n" "If real is exactly between two integers, the closest even integer is returned. If real is an infinity or NaN, round returns real. \n\n" "" "(round 19) => 19\n(round 2/3) => 1\n(round -2/3) => -1\n(round 17.3) => 17.0\n(round -17/2) => -8\n(round 2.5) => 2.0\n(round 3.5) => 4.0\n\n") ("objects:s105" "procedure: (abs real)\nreturns: the absolute value of real \nlibraries: (rnrs base), (rnrs)  \n\n" "abs is equivalent to (lambda (x) (if (< x 0) (- x) x)). abs and magnitude (see page 183) are identical for real inputs. \n\n" "" "(abs 1) => 1\n(abs -3/4) => 3/4\n(abs 1.83) => 1.83\n(abs -0.093) => 0.093\n\n") ("objects:s107" "procedure: (max real1 real2 ...)\nreturns: the maximum of real1 real2 ...\nlibraries: (rnrs base), (rnrs)  \n\n" "" "(max 4 -7 2 0 -6) => 4\n(max 1/2 3/4 4/5 5/6 6/7) => 6/7\n(max 1.5 1.3 -0.3 0.4 2.0 1.8) => 2.0\n(max 5 2.0) => 5.0\n(max -5 -2.0) => -2.0\n(let ([ls '(7 3 5 2 9 8)])\n  (apply max ls)) => 9\n\n") ("objects:s108" "procedure: (min real1 real2 ...)\nreturns: the minimum of real1 real2 ...\nlibraries: (rnrs base), (rnrs)  \n\n" "" "(min 4 -7 2 0 -6) => -7\n(min 1/2 3/4 4/5 5/6 6/7) => 1/2\n(min 1.5 1.3 -0.3 0.4 2.0 1.8) => -0.3\n(min 5 2.0) => 2.0\n(min -5 -2.0) => -5.0\n(let ([ls '(7 3 5 2 9 8)])\n  (apply min ls)) => 2\n\n") ("objects:s109" "procedure: (gcd int ...)\nreturns: the greatest common divisor of its arguments int ...\nlibraries: (rnrs base), (rnrs)  \n\n" "The result is always nonnegative, i.e., factors of -1 are ignored. When called with no arguments, gcd returns 0.  \n\n" "" "(gcd) => 0\n(gcd 34) => 34\n(gcd 33.0 15.0) => 3.0\n(gcd 70 -42 28) => 14\n\n") ("objects:s110" "procedure: (lcm int ...)\nreturns: the least common multiple of its arguments int ...\nlibraries: (rnrs base), (rnrs)  \n\n" "The result is always nonnegative, i.e., common multiples of -1 are ignored. Although lcm should probably return  when called with no arguments, it is defined to return 1. If one or more of the arguments is 0, lcm returns 0.  \n\n" "" "(lcm) => 1\n(lcm 34) => 34\n(lcm 33.0 15.0) => 165.0\n(lcm 70 -42 28) => 420\n(lcm 17.0 0) => 0.0\n\n") ("objects:s111" "procedure: (expt num1 num2)\nreturns: num1 raised to the num2 power \nlibraries: (rnrs base), (rnrs)  \n\n" "If both arguments are 0, expt returns 1.  \n\n" "" "(expt 2 10) => 1024\n(expt 2 -10) => 1/1024\n(expt 2 -10.0) => 9.765625e-4\n(expt -1/2 5) => -1/32\n(expt 3.0 3) => 27.0\n(expt +i 2) => -1\n\n") ("objects:s112" "procedure: (inexact num)\nreturns: an inexact representation of num \nlibraries: (rnrs base), (rnrs)  \n\n" "If num is already inexact, it is returned unchanged. If no inexact representation for num is supported by the implementation, an exception with condition type &implementation-violation may be raised. inexact may also return +inf.0 or -inf.0 for inputs whose magnitude exceeds the range of the implementation's inexact number representations. \n\n" "" "(inexact 3) => 3.0\n(inexact 3.0) => 3.0\n(inexact -1/4) => -.25\n(inexact 3+4i) => 3.0+4.0i\n(inexact (expt 10 20)) => 1e20\n\n") ("objects:s114" "procedure: (exact num)\nreturns: an exact representation of num \nlibraries: (rnrs base), (rnrs)  \n\n" "If num is already exact, it is returned unchanged. If no exact representation for num is supported by the implementation, an exception with condition type &implementation-violation may be raised. \n\n" "" "(exact 3.0) => 3\n(exact 3) => 3\n(exact -.25) => -1/4\n(exact 3.0+4.0i) => 3+4i\n(exact 1e20) => 100000000000000000000\n\n") ("objects:s116" "procedure: (exact->inexact num)\nreturns: an inexact representation of num \nprocedure: (inexact->exact num)\nreturns: an exact representation of num \nlibraries: (rnrs r5rs)\n\n" "These are alternative names for inexact and exact, supported for compatibility with the Revised^5 Report. \n\n") ("objects:s117" "procedure: (rationalize real1 real2)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "rationalize returns the simplest rational number that differs from real1 by no more than real2. A rational number q1 = n1/m1 is simpler than another rational number q2 = n2/m2 if |n1| <= |n2| and |m1| <= |m2| and either |n1| < |n2| or |m1| < |m2|. \n\n" "" "(rationalize 3/10 1/10) => 1/3\n(rationalize .3 1/10) => 0.3333333333333333\n(eqv? (rationalize .3 1/10) #i1/3) => #t\n\n") ("objects:s118" "procedure: (numerator rat)\nreturns: the numerator of rat \nlibraries: (rnrs base), (rnrs)  \n\n" "If rat is an integer, the numerator is rat. \n\n" "" "(numerator 9) => 9\n(numerator 9.0) => 9.0\n(numerator 0.0) => 0.0\n(numerator 2/3) => 2\n(numerator -9/4) => -9\n(numerator -2.25) => -9.0\n\n") ("objects:s119" "procedure: (denominator rat)\nreturns: the denominator of rat \nlibraries: (rnrs base), (rnrs)  \n\n" "If rat is an integer, including zero, the denominator is one. \n\n" "" "(denominator 9) => 1\n(denominator 9.0) => 1.0\n(denominator 0) => 1\n(denominator 0.0) => 1.0\n(denominator 2/3) => 3\n(denominator -9/4) => 4\n(denominator -2.25) => 4.0\n\n") ("objects:s120" "procedure: (real-part num)\nreturns: the real component of num \nlibraries: (rnrs base), (rnrs)  \n\n" "If num is real, real-part returns num. \n\n" "" "(real-part 3+4i) => 3\n(real-part -2.3+0.7i) => -2.3\n(real-part -i) => 0\n(real-part 17.2) => 17.2\n(real-part -17/100) => -17/100\n\n") ("objects:s121" "procedure: (imag-part num)\nreturns: the imaginary component of num \nlibraries: (rnrs base), (rnrs)  \n\n" "If num is real, imag-part returns exact zero.  \n\n" "" "(imag-part 3+4i) => 4\n(imag-part -2.3+0.7i) => 0.7\n(imag-part -i) => -1\n(imag-part -2.5) => 0\n(imag-part -17/100) => 0\n\n") ("objects:s122" "procedure: (make-rectangular real1 real2)\nreturns: a complex number with real component real1 and imaginary   component real2\nlibraries: (rnrs base), (rnrs)  \n\n" "" "(make-rectangular -2 7) => -2+7i\n(make-rectangular 2/3 -1/2) => 2/3-1/2i\n(make-rectangular 3.2 5.3) => 3.2+5.3i\n\n") ("objects:s123" "procedure: (make-polar real1 real2)\nreturns: a complex number with magnitude real1 and angle     real2\nlibraries: (rnrs base), (rnrs)  \n\n" "" "(make-polar 2 0) => 2\n(make-polar 2.0 0.0) => 2.0+0.0i\n(make-polar 1.0 (asin -1.0)) => 0.0-1.0i\n(eqv? (make-polar 7.2 -0.588) 7.2@-0.588) => #t\n\n") ("objects:s124" "procedure: (angle num)\nreturns: the angle part of the polar representation of num \nlibraries: (rnrs base), (rnrs)  \n\n" "The range of the result is - (exclusive) to + (inclusive). \n\n" "" "(angle 7.3@1.5708) => 1.5708\n(angle 5.2) => 0.0\n\n") ("objects:s125" "procedure: (magnitude num)\nreturns: the magnitude of num \nlibraries: (rnrs base), (rnrs)  \n\n" "magnitude and abs (see page 178) are identical for real arguments. The magnitude of a complex number x + yi is [image not available]. \n\n" "" "(magnitude 1) => 1\n(magnitude -3/4) => 3/4\n(magnitude 1.83) => 1.83\n(magnitude -0.093) => 0.093\n(magnitude 3+4i) => 5\n(magnitude 7.25@1.5708) => 7.25\n\n") ("objects:s127" "procedure: (sqrt num)\nreturns: the principal square root of num \nlibraries: (rnrs base), (rnrs)  \n\n" "Implementations are encouraged, but not required, to return exact results for exact inputs to sqrt whenever feasible.  \n\n" "" "(sqrt 16) => 4\n(sqrt 1/4) => 1/2\n(sqrt 4.84) => 2.2\n(sqrt -4.84) => 0.0+2.2i\n(sqrt 3+4i) => 2+1i\n(sqrt -3.0-4.0i) => 1.0-2.0i\n\n") ("objects:s128" "procedure: (exact-integer-sqrt n)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "This procedure returns two nonnegative exact integers s and r where n = s^2 + r and n < (s + 1)^2. \n\n" "" "(exact-integer-sqrt 0) => 0\n                          0\n(exact-integer-sqrt 9) => 3\n                       => 0\n(exact-integer-sqrt 19) => 4\n                        => 3\n\n") ("objects:s129" "procedure: (exp num)\nreturns: e to the num power \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(exp 0.0) => 1.0\n(exp 1.0) => 2.7182818284590455\n(exp -.5) => 0.6065306597126334\n\n") ("objects:s130" "procedure: (log num)\nreturns: the natural logarithm of num \nprocedure: (log num1 num2)\nreturns: the base-num2 logarithm of num1\nlibraries: (rnrs base), (rnrs)  \n\n" "" "(log 1.0) => 0.0\n(log (exp 1.0)) => 1.0\n(/ (log 100) (log 10)) => 2.0\n(log (make-polar (exp 2.0) 1.0)) => 2.0+1.0i \n\n(log 100.0 10.0) => 2.0\n(log .125 2.0) => -3.0\n\n") ("objects:s131" "procedure: (sin num)\nprocedure: (cos num)\nprocedure: (tan num)\nreturns: the sine, cosine, or tangent of num \nlibraries: (rnrs base), (rnrs)  \n\n" "The argument is specified in radians. \n\n" "" "(sin 0.0) => 0.0\n(cos 0.0) => 1.0\n(tan 0.0) => 0.0\n\n") ("objects:s132" "procedure: (asin num)\nprocedure: (acos num)\nreturns: the arc sine or the arc cosine of num \nlibraries: (rnrs base), (rnrs)  \n\n" "The result is in radians. The arc sine and arc cosine of a complex number z are defined as follows. \n\n" "" "[image not available]\n\n" "" "[image not available]\n\n" "" "" "(define pi (* (asin 1) 2))\n(= (* (acos 0) 2) pi) => #t\n\n") ("objects:s133" "procedure: (atan num)\nprocedure: (atan real1 real2)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "When passed a single complex argument num (the first form), atan returns the arc tangent of num. The arc tangent of a complex number z is defined as follows. \n\n" "" "[image not available]\n\n" "" "When passed two real arguments (the second form), atan is equivalent to (lambda (y x) (angle (make-rectangular x y))). \n\n" "" "(define pi (* (atan 1) 4))\n(= (* (atan 1.0 0.0) 2) pi) => #t\n\n") ("objects:s134" "procedure: (bitwise-not exint)\nreturns: the bitwise not of exint \nprocedure: (bitwise-and exint ...)\nreturns: the bitwise and of exint ...\nprocedure: (bitwise-ior exint ...)\nreturns: the bitwise inclusive or of exint ...\nprocedure: (bitwise-xor exint ...)\nreturns: the bitwise exclusive or of exint ...\nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "The inputs are treated as if represented in two's complement, even if they are not represented that way internally. \n\n" "" "(bitwise-not 0) => -1\n(bitwise-not 3) => -4 \n\n(bitwise-and #b01101 #b00111) => #b00101\n(bitwise-ior #b01101 #b00111) => #b01111\n(bitwise-xor #b01101 #b00111) => #b01010\n\n") ("objects:s135" "procedure: (bitwise-if exint1 exint2 exint3)\nreturns: the bitwise \"if\" of its arguments \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "The inputs are treated as if represented in two's complement, even if they are not represented that way internally. \n\n" "For each bit set in exint1, the corresponding bit of the result is taken from exint2, and for each bit not set in exint1, the corresponding bit of the result is taken from x3. \n\n" "" "(bitwise-if #b101010 #b111000 #b001100) => #b101100\n\n" "bitwise-if might be defined as follows:  \n\n" "" "(define bitwise-if\n  (lambda (exint1 exint2 exint3)\n    (bitwise-ior\n      (bitwise-and exint1 exint2)\n      (bitwise-and (bitwise-not exint1) exint3))))\n\n") ("objects:s136" "procedure: (bitwise-bit-count exint)\nreturns: see below \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "For nonnegative inputs, bitwise-bit-count returns the number of bits set in the two's complement representation of exint. For negative inputs, it returns a negative number whose magnitude is one greater than the number of bits not set in the two's complement representation of exint, which is equivalent to (bitwise-not (bitwise-bit-count (bitwise-not exint))). \n\n" "" "(bitwise-bit-count #b00000) => 0\n(bitwise-bit-count #b00001) => 1\n(bitwise-bit-count #b00100) => 1\n(bitwise-bit-count #b10101) => 3 \n\n(bitwise-bit-count -1) => -1\n(bitwise-bit-count -2) => -2\n(bitwise-bit-count -4) => -3\n\n") ("objects:s137" "procedure: (bitwise-length exint)\nreturns: see below \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "This procedure returns the number of bits of the smallest two's complement representation of exint, not including the sign bit for negative numbers. For 0 bitwise-length returns 0.  \n\n" "" "(bitwise-length #b00000) => 0\n(bitwise-length #b00001) => 1\n(bitwise-length #b00100) => 3\n(bitwise-length #b00110) => 3 \n\n(bitwise-length -1) => 0\n(bitwise-length -6) => 3\n(bitwise-length -9) => 4\n\n") ("objects:s138" "procedure: (bitwise-first-bit-set exint)\nreturns: the index of the least significant bit set in exint \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "The input is treated as if represented in two's complement, even if it is not represented that way internally. \n\n" "If exint is 0, bitwise-first-bit-set returns -1.  \n\n" "" "(bitwise-first-bit-set #b00000) => -1\n(bitwise-first-bit-set #b00001) => 0\n(bitwise-first-bit-set #b01100) => 2 \n\n(bitwise-first-bit-set -1) => 0\n(bitwise-first-bit-set -2) => 1\n(bitwise-first-bit-set -3) => 0\n\n") ("objects:s139" "procedure: (bitwise-bit-set? exint1 exint2)\nreturns: #t if bit exint2 of exint1 is set, #f otherwise \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "exint2 is taken as a zero-based index for the bits in the two's complement representation of exint1. The two's complement representation of a nonnegative number conceptually extends to the left (toward more significant bits) with an infinite number of zero bits, and the two's complement representation of a negative number conceptually extends to the left with an infinite number of one bits. Thus, exact integers can be used to represent arbitrarily large sets, where 0 is the empty set, -1 is the universe, and bitwise-bit-set? is used to test for membership. \n\n" "" "(bitwise-bit-set? #b01011 0) => #t\n(bitwise-bit-set? #b01011 2) => #f \n\n(bitwise-bit-set? -1 0) => #t\n(bitwise-bit-set? -1 20) => #t\n(bitwise-bit-set? -3 1) => #f \n\n(bitwise-bit-set? 0 5000) => #f\n(bitwise-bit-set? -1 5000) => #t\n\n") ("objects:s140" "procedure: (bitwise-copy-bit exint1 exint2 exint3)\nreturns: exint1 with bit exint2 replaced by exint3\nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "exint2 is taken as a zero-based index for the bits in the two's complement representation of exint1. exint3 must be 0 or 1. This procedure effectively clears or sets the specified bit depending on the value of exint3. exint1 is treated as if represented in two's complement, even if it is not represented that way internally. \n\n" "" "(bitwise-copy-bit #b01110 0 1) => #b01111\n(bitwise-copy-bit #b01110 2 0) => #b01010\n\n") ("objects:s141" "procedure: (bitwise-bit-field exint1 exint2 exint3)\nreturns: see below \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "exint2 and exint3 must be nonnegative, and exint2 must not be greater than exint3. This procedure returns the number represented by extracting from exint1the sequence of bits from exint2 (inclusive) to exint3 (exclusive). exint1 is treated as if represented in two's complement, even if it is not represented that way internally. \n\n" "" "(bitwise-bit-field #b10110 0 3) => #b00110\n(bitwise-bit-field #b10110 1 3) => #b00011\n(bitwise-bit-field #b10110 2 3) => #b00001\n(bitwise-bit-field #b10110 3 3) => #b00000\n\n") ("objects:s142" "procedure: (bitwise-copy-bit-field exint1 exint2 exint3 exint4)\nreturns: see below \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "exint2 and exint3 must be nonnegative, and exint2must not be greater than exint3. This procedure returns exint1 with the n bits from exint2 (inclusive) to exint3 (exclusive) replaced by the low-order n bits of exint4. exint1 and exint4 are treated as if represented in two's complement, even if they are not represented that way internally. \n\n" "" "(bitwise-copy-bit-field #b10000 0 3 #b10101) => #b10101\n(bitwise-copy-bit-field #b10000 1 3 #b10101) => #b10010\n(bitwise-copy-bit-field #b10000 2 3 #b10101) => #b10100\n(bitwise-copy-bit-field #b10000 3 3 #b10101) => #b10000\n\n") ("objects:s143" "procedure: (bitwise-arithmetic-shift-right exint1 exint2)\nreturns: exint1 arithmetically shifted right by exint2 bits \nprocedure: (bitwise-arithmetic-shift-left exint1 exint2)\nreturns: exint1 shifted left by exint2 bits \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "exint2 must be nonnegative. exint1 is treated as if represented in two's complement, even if it is not represented that way internally. \n\n" "" "(bitwise-arithmetic-shift-right #b10000 3) => #b00010\n(bitwise-arithmetic-shift-right -1 1) => -1\n(bitwise-arithmetic-shift-right -64 3) => -8 \n\n(bitwise-arithmetic-shift-left #b00010 2) => #b01000\n(bitwise-arithmetic-shift-left -1 2) => -4\n\n") ("objects:s144" "procedure: (bitwise-arithmetic-shift exint1 exint2)\nreturns: see below \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "If exint2 is negative, bitwise-arithmetic-shift returns the result of arithmetically shifting exint1 right by -exint2 bits. Otherwise, bitwise-arithmetic-shift returns the result of shifting exint1 left by exint2 bits. exint1 is treated as if represented in two's complement, even if it is not represented that way internally. \n\n" "" "(bitwise-arithmetic-shift #b10000 -3) => #b00010\n(bitwise-arithmetic-shift -1 -1) => -1\n(bitwise-arithmetic-shift -64 -3) => -8\n(bitwise-arithmetic-shift #b00010 2) => #b01000\n(bitwise-arithmetic-shift -1 2) => -4\n\n" "Thus, bitwise-arithmetic-shift behaves as if defined as follows.  \n\n" "" "(define bitwise-arithmetic-shift\n  (lambda (exint1 exint2)\n    (if (< exint2 0)\n        (bitwise-arithmetic-shift-right exint1 (- exint2))\n        (bitwise-arithmetic-shift-left exint1 exint2))))\n\n") ("objects:s145" "procedure: (bitwise-rotate-bit-field exint1 exint2 exint3 exint4)\nreturns: see below \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "exint2, exint3, and exint4 must be nonnegative, and exint2 must not be greater than exint3. This procedure returns the result of shifting the bits of exint1 from bit exint2 (inclusive) through bit exint3 (exclusive) left by (mod exint4 (- exint3 exint2)) bits, with the bits shifted out of the range inserted at the bottom end of the range. exint1 is treated as if represented in two's complement, even if it is not represented that way internally. \n\n" "" "(bitwise-rotate-bit-field #b00011010 0 5 3) => #b00010110\n(bitwise-rotate-bit-field #b01101011 2 7 3) => #b01011011\n\n") ("objects:s146" "procedure: (bitwise-reverse-bit-field exint1 exint2 exint3)\nreturns: see below \nlibraries: (rnrs arithmetic bitwise), (rnrs)  \n\n" "exint2 and exint3 must be nonnegative, and exint2must not be greater than exint3. This procedure returns the result of reversing the bits of exint1 from bit exint2 (inclusive) through bit exint3 (exclusive). exint1 is treated as if represented in two's complement, even if it is not represented that way internally. \n\n" "" "(bitwise-reverse-bit-field #b00011010 0 5) => #b00001011\n(bitwise-reverse-bit-field #b01101011 2 7) => #b00101111\n\n") ("objects:s147" "procedure: (string->number string)\nprocedure: (string->number string radix)\nreturns: the number represented by string, or #f \nlibraries: (rnrs base), (rnrs)  \n\n" "If string is a valid representation of a number, that number is returned, otherwise #f is returned. The number is interpreted in radix radix, which must be an exact integer in the set {2,8,10,16}. If not specified, radix defaults to 10. Any radix specifier within string, e.g., #x, overrides the radix argument. \n\n" "" "(string->number \"0\") => 0\n(string->number \"3.4e3\") => 3400.0\n(string->number \"#x#e-2e2\") => -738\n(string->number \"#e-2e2\" 16) => -738\n(string->number \"#i15/16\") => 0.9375\n(string->number \"10\" 16) => 16\n\n") ("objects:s148" "procedure: (number->string num)\nprocedure: (number->string num radix)\nprocedure: (number->string num radix precision)\nreturns: an external representation of num as a string \nlibraries: (rnrs base), (rnrs)  \n\n" "The num is expressed in radix radix, which must be an exact integer in the set {2,8,10,16}. If not specified, radix defaults to 10. In any case, no radix specifier appears in the resulting string. \n\n" "The external representation is such that, when converted back into a number using string->number, the resulting numeric value is equivalent to num. That is, for all inputs: \n\n" "" "(eqv? (string->number\n        (number->string num radix)\n        radix)\n      num)\n\n" "returns #t. An exception with condition type &implementation-restriction is raised if this is not possible. \n\n" "If precision is provided, it must be an exact positive integer, num must be inexact, and radix must be 10. In this case, the real part and, if present, the imaginary part of the number are each printed with an explicit mantissa width m, where m is the least possible value greater than or equal to precision that makes the expression above true. \n\n" "If radix is 10, inexact values of num are expressed using the fewest number of significant digits possible [5] without violating the above restriction. \n\n" "" "(number->string 3.4) => \"3.4\"\n(number->string 1e2) => \"100.0\"\n(number->string 1e-23) => \"1e-23\"\n(number->string -7/2) => \"-7/2\"\n(number->string 220/9 16) => \"DC/9\"\n\n") ("objects:s150" "procedure: (fixnum? obj)\nreturns: #t if obj is a fixnum, #f otherwise \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "" "(fixnum? 0) => #t\n(fixnum? -1) => #t\n(fixnum? (- (expt 2 23))) => #t\n(fixnum? (- (expt 2 23) 1)) => #t\n\n") ("objects:s151" "procedure: (least-fixnum) \nreturns: the least (most negative) fixnum supported by the implementation \nprocedure: (greatest-fixnum) \nreturns: the greatest (most positive) fixnum supported by the implementation \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "" "(fixnum? (- (least-fixnum) 1)) => #f\n(fixnum? (least-fixnum)) => #t\n(fixnum? (greatest-fixnum)) => #t\n(fixnum? (+ (greatest-fixnum) 1)) => #f\n\n") ("objects:s152" "procedure: (fixnum-width) \nreturns: the implementation-dependent fixnum width\nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "As described in the lead-in to this section, the fixnum width determines the size of the fixnum range and must be at least 24. \n\n" "" "(define w (fixnum-width))\n(= (least-fixnum) (- (expt 2 (- w 1)))) => #t\n(= (greatest-fixnum) (- (expt 2 (- w 1)) 1)) => #t\n(>= w 24) => #t\n\n") ("objects:s153" "procedure: (fx=? fx1 fx2 fx3 ...)\nprocedure: (fx<? fx1 fx2 fx3 ...)\nprocedure: (fx>? fx1 fx2 fx3 ...)\nprocedure: (fx<=? fx1 fx2 fx3 ...)\nprocedure: (fx>=? fx1 fx2 fx3 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "The predicate fx=? returns #t if its arguments are equal. The predicate fx<? returns #t if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while fx>? returns #t if its arguments are monotonically decreasing. The predicate fx<=? returns #t if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while fx>=? returns #t if its arguments are monotonically nonincreasing.  \n\n" "" "(fx=? 0 0) => #t\n(fx=? -1 1) => #f\n(fx<? (least-fixnum) 0 (greatest-fixnum)) => #t\n(let ([x 3]) (fx<=? 0 x 9)) => #t\n(fx>? 5 4 3 2 1) => #t\n(fx<=? 1 3 2) => #f\n(fx>=? 0 0 (least-fixnum)) => #t\n\n") ("objects:s154" "procedure: (fxzero? fx)\nreturns: #t if fx is zero, #f otherwise \nprocedure: (fxpositive? fx)\nreturns: #t if fx is greater than zero, #f otherwise \nprocedure: (fxnegative? fx)\nreturns: #t if fx is less than zero, #f otherwise \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "fxzero? is equivalent to (lambda (x) (fx=? x 0)), fxpositive? is equivalent to (lambda (x) (fx>? x 0)), and fxnegative? to (lambda (x) (fx<? x 0)). \n\n" "" "(fxzero? 0) => #t\n(fxzero? 1) => #f \n\n(fxpositive? 128) => #t\n(fxpositive? 0) => #f\n(fxpositive? -1) => #f \n\n(fxnegative? -65) => #t\n(fxnegative? 0) => #f\n(fxnegative? 1) => #f\n\n") ("objects:s155" "procedure: (fxeven? fx)\nreturns: #t if fx is even, #f otherwise \nprocedure: (fxodd? fx)\nreturns: #t if fx is odd, #f otherwise \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "" "(fxeven? 0) => #t\n(fxeven? 1) => #f\n(fxeven? -1) => #f\n(fxeven? -10) => #t \n\n(fxodd? 0) => #f\n(fxodd? 1) => #t\n(fxodd? -1) => #t\n(fxodd? -10) => #f\n\n") ("objects:s156" "procedure: (fxmin fx1 fx2 ...)\nreturns: the minimum of fx1 fx2 ... \nprocedure: (fxmax fx1 fx2 ...)\nreturns: the maximum of fx1 fx2 ...\nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "" "(fxmin 4 -7 2 0 -6) => -7 \n\n(let ([ls '(7 3 5 2 9 8)])\n  (apply fxmin ls)) => 2 \n\n(fxmax 4 -7 2 0 -6) => 4 \n\n(let ([ls '(7 3 5 2 9 8)])\n  (apply fxmax ls)) => 9\n\n") ("objects:s157" "procedure: (fx+ fx1 fx2)\nreturns: the sum of fx1 and fx2\nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "" "(fx+ -3 4) => 1\n\n") ("objects:s158" "procedure: (fx- fx)\nreturns: the additive inverse of fx \nprocedure: (fx- fx1 fx2)\nreturns: the difference between fx1 and fx2\nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "" "(fx- 3) => -3\n(fx- -3 4) => -7\n\n") ("objects:s159" "procedure: (fx* fx1 fx2)\nreturns: the product of fx1 and fx2\nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "" "(fx* -3 4) => -12\n\n") ("objects:s160" "procedure: (fxdiv fx1 fx2)\nprocedure: (fxmod fx1 fx2)\nprocedure: (fxdiv-and-mod fx1 fx2)\nreturns: see below \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "fx2 must not be zero. These are fixnum-specific versions of the generic div, mod, and div-and-mod.  \n\n" "" "(fxdiv 17 3) => 5\n(fxmod 17 3) => 2\n(fxdiv -17 3) => -6\n(fxmod -17 3) => 1\n(fxdiv 17 -3) => -5\n(fxmod 17 -3) => 2\n(fxdiv -17 -3) => 6\n(fxmod -17 -3) => 1 \n\n(fxdiv-and-mod 17 3) => 5\n                        2\n\n") ("objects:s161" "procedure: (fxdiv0 fx1 fx2)\nprocedure: (fxmod0 fx1 fx2)\nprocedure: (fxdiv0-and-mod0 fx1 fx2)\nreturns: see below \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "fx2 must not be zero. These are fixnum-specific versions of the generic div0, mod0, and div0-and-mod0.  \n\n" "" "(fxdiv0 17 3) => 6\n(fxmod0 17 3) => -1\n(fxdiv0 -17 3) => -6\n(fxmod0 -17 3) => 1\n(fxdiv0 17 -3) => -6\n(fxmod0 17 -3) => -1\n(fxdiv0 -17 -3) => 6\n(fxmod0 -17 -3) => 1 \n\n(fxdiv0-and-mod0 17 3) => 6\n                          -1\n\n") ("objects:s162" "procedure: (fx+/carry fx1 fx2 fx3)\nprocedure: (fx-/carry fx1 fx2 fx3)\nprocedure: (fx*/carry fx1 fx2 fx3)\nreturns: see below \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "When an ordinary fixnum addition, subtraction, or multiplication operation overflows, an exception is raised. These alternative procedures instead return a carry and also allow the carry to be propagated to the next operation. They can be used to implement portable code for multiple-precision arithmetic. \n\n" "These procedures return the two fixnum values of the following computations. For fx+/carry:  \n\n" "" "(let* ([s (+ fx1 fx2 fx3)]\n       [s0 (mod0 s (expt 2 (fixnum-width)))]\n       [s1 (div0 s (expt 2 (fixnum-width)))])\n  (values s0 s1))\n\n" "for fx-/carry:  \n\n" "" "(let* ([d (- fx1 fx2 fx3)]\n       [d0 (mod0 d (expt 2 (fixnum-width)))]\n       [d1 (div0 d (expt 2 (fixnum-width)))])\n  (values d0 d1))\n\n" "and for fx*/carry:  \n\n" "" "(let* ([s (+ (* fx1 fx2) fx3)]\n       [s0 (mod0 s (expt 2 (fixnum-width)))]\n       [s1 (div0 s (expt 2 (fixnum-width)))])\n  (values s0 s1))\n\n") ("objects:s163" "procedure: (fxnot fx)\nreturns: the bitwise not of fx \nprocedure: (fxand fx ...)\nreturns: the bitwise and of fx ...\nprocedure: (fxior fx ...)\nreturns: the bitwise inclusive or of fx ...\nprocedure: (fxxor fx ...)\nreturns: the bitwise exclusive or of fx ...\nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "" "(fxnot 0) => -1\n(fxnot 3) => -4 \n\n(fxand #b01101 #b00111) => #b00101\n(fxior #b01101 #b00111) => #b01111\n(fxxor #b01101 #b00111) => #b01010\n\n") ("objects:s164" "procedure: (fxif fx1 fx2 fx3)\nreturns: the bitwise \"if\" of its arguments \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "For each bit set in fx1, the corresponding bit of the result is taken from fx2, and for each bit not set in fx1, the corresponding bit of the result is taken from x3. \n\n" "" "(fxif #b101010 #b111000 #b001100) => #b101100\n\n" "fxif might be defined as follows:  \n\n" "" "(define fxif\n  (lambda (fx1 fx2 fx3)\n    (fxior (fxand fx1 fx2)\n           (fxand (fxnot fx1) fx3))))\n\n") ("objects:s165" "procedure: (fxbit-count fx)\nreturns: see below \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "For nonnegative inputs, fxbit-count returns the number of bits set in the two's complement representation of fx. For negative inputs, it returns a negative number whose magnitude is one greater than the number of bits not set in fx, which is equivalent to (fxnot (fxbit-count (fxnot fx))). \n\n" "" "(fxbit-count #b00000) => 0\n(fxbit-count #b00001) => 1\n(fxbit-count #b00100) => 1\n(fxbit-count #b10101) => 3 \n\n(fxbit-count -1) => -1\n(fxbit-count -2) => -2\n(fxbit-count -4) => -3\n\n") ("objects:s166" "procedure: (fxlength fx)\nreturns: see below \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "This procedure returns the number of bits of the smallest two's complement representation of fx, not including the sign bit for negative numbers. For 0 fxlength returns 0.  \n\n" "" "(fxlength #b00000) => 0\n(fxlength #b00001) => 1\n(fxlength #b00100) => 3\n(fxlength #b00110) => 3 \n\n(fxlength -1) => 0\n(fxlength -6) => 3\n(fxlength -9) => 4\n\n") ("objects:s167" "procedure: (fxfirst-bit-set fx)\nreturns: the index of the least significant bit set in fx \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "If fx is 0, fxfirst-bit-set returns -1.  \n\n" "" "(fxfirst-bit-set #b00000) => -1\n(fxfirst-bit-set #b00001) => 0\n(fxfirst-bit-set #b01100) => 2 \n\n(fxfirst-bit-set -1) => 0\n(fxfirst-bit-set -2) => 1\n(fxfirst-bit-set -3) => 0\n\n") ("objects:s168" "procedure: (fxbit-set? fx1 fx2)\nreturns: #t if bit fx2 of fx1 is set, #f otherwise \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "fx2 must be nonnegative. It is taken as a zero-based index for the bits in the two's complement representation of fx1, with the sign bit virtually replicated an infinite number of positions to the left. \n\n" "" "(fxbit-set? #b01011 0) => #t\n(fxbit-set? #b01011 2) => #f \n\n(fxbit-set? -1 0) => #t\n(fxbit-set? -1 20) => #t\n(fxbit-set? -3 1) => #f\n(fxbit-set? 0 (- (fixnum-width) 1)) => #f\n(fxbit-set? -1 (- (fixnum-width) 1)) => #t\n\n") ("objects:s169" "procedure: (fxcopy-bit fx1 fx2 fx3)\nreturns: fx1 with bit fx2 replaced by fx3\nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "fx2 must be nonnegative and less than the value of (- (fixnum-width) 1). fx3 must be 0 or 1. This procedure effectively clears or sets the specified bit depending on the value of fx3. \n\n" "" "(fxcopy-bit #b01110 0 1) => #b01111\n(fxcopy-bit #b01110 2 0) => #b01010\n\n") ("objects:s170" "procedure: (fxbit-field fx1 fx2 fx3)\nreturns: see below \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "fx2 and fx3 must be nonnegative and less than the value of (fixnum-width), and fx2 must not be greater than fx3. This procedure returns the number represented by extracting from fx1the sequence of bits from fx2 (inclusive) to fx3 (exclusive). \n\n" "" "(fxbit-field #b10110 0 3) => #b00110\n(fxbit-field #b10110 1 3) => #b00011\n(fxbit-field #b10110 2 3) => #b00001\n(fxbit-field #b10110 3 3) => #b00000\n\n") ("objects:s171" "procedure: (fxcopy-bit-field fx1 fx2 fx3 fx4)\nreturns: see below \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "fx2 and fx3 must be nonnegative and less than the value of (fixnum-width), and fx2 must not be greater than fx3. This procedure returns fx1 with n bits from fx2 (inclusive) to fx3 (exclusive) replaced by the low-order n bits of x4. \n\n" "" "(fxcopy-bit-field #b10000 0 3 #b10101) => #b10101\n(fxcopy-bit-field #b10000 1 3 #b10101) => #b10010\n(fxcopy-bit-field #b10000 2 3 #b10101) => #b10100\n(fxcopy-bit-field #b10000 3 3 #b10101) => #b10000\n\n") ("objects:s172" "procedure: (fxarithmetic-shift-right fx1 fx2)\nreturns: fx1 arithmetically shifted right by fx2 bits \nprocedure: (fxarithmetic-shift-left fx1 fx2)\nreturns: fx1 shifted left by fx2 bits \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "fx2 must be nonnegative and less than the value of (fixnum-width).  \n\n" "" "(fxarithmetic-shift-right #b10000 3) => #b00010\n(fxarithmetic-shift-right -1 1) => -1\n(fxarithmetic-shift-right -64 3) => -8 \n\n(fxarithmetic-shift-left #b00010 2) => #b01000\n(fxarithmetic-shift-left -1 2) => -4\n\n") ("objects:s173" "procedure: (fxarithmetic-shift fx1 fx2)\nreturns: see below \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "The absolute value of fx2 must be less than the value of (fixnum-width). If fx2 is negative, fxarithmetic-shift returns the result of arithmetically shifting fx1 right by fx2 bits. Otherwise, fxarithmetic-shift returns the result of shifting fx1 left by fx2 bits. \n\n" "" "(fxarithmetic-shift #b10000 -3) => #b00010\n(fxarithmetic-shift -1 -1) => -1\n(fxarithmetic-shift -64 -3) => -8\n(fxarithmetic-shift #b00010 2) => #b01000\n(fxarithmetic-shift -1 2) => -4\n\n" "Thus, fxarithmetic-shift behaves as if defined as follows.  \n\n" "" "(define fxarithmetic-shift\n  (lambda (fx1 fx2)\n    (if (fx<? fx2 0)\n        (fxarithmetic-shift-right fx1 (fx- fx2))\n        (fxarithmetic-shift-left fx1 fx2))))\n\n") ("objects:s174" "procedure: (fxrotate-bit-field fx1 fx2 fx3 fx4)\nreturns: see below \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "fx2, fx3, and fx4 must be nonnegative and less than the value of (fixnum-width), fx2 must not be greater than fx3, and fx4 must not be greater than the difference between fx3 and fx2. \n\n" "This procedure returns the result of shifting the bits of fx1 from bit fx2 (inclusive) through bit fx3 (exclusive) left by fx4 bits, with the bits shifted out of the range inserted at the bottom end of the range. \n\n" "" "(fxrotate-bit-field #b00011010 0 5 3) => #b00010110\n(fxrotate-bit-field #b01101011 2 7 3) => #b01011011\n\n") ("objects:s175" "procedure: (fxreverse-bit-field fx1 fx2 fx3)\nreturns: see below \nlibraries: (rnrs arithmetic fixnums), (rnrs)  \n\n" "fx2 and fx3 must be nonnegative and less than the value of (fixnum-width), and fx2 must not be greater than fx3. This procedure returns the result of reversing the bits of fx1 from bit fx2 (inclusive) through bit fx3 (exclusive). \n\n" "" "(fxreverse-bit-field #b00011010 0 5) => #b00001011\n(fxreverse-bit-field #b01101011 2 7) => #b00101111\n\n") ("objects:s177" "procedure: (flonum? obj)\nreturns: #t if obj is a flonum, otherwise #f \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "" "(flonum? 0) => #f\n(flonum? 3/4) => #f\n(flonum? 3.5) => #t\n(flonum? .02) => #t\n(flonum? 1e10) => #t\n(flonum? 3.0+0.0i) => #f\n\n") ("objects:s178" "procedure: (fl=? fl1 fl2 fl3 ...)\nprocedure: (fl<? fl1 fl2 fl3 ...)\nprocedure: (fl>? fl1 fl2 fl3 ...)\nprocedure: (fl<=? fl1 fl2 fl3 ...)\nprocedure: (fl>=? fl1 fl2 fl3 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "The predicate fl=? returns #t if its arguments are equal. The predicate fl<? returns #t if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while fl>? returns #t if its arguments are monotonically decreasing. The predicate fl<=? returns #t if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while fl>=? returns #t if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns #t.  \n\n" "Comparisons involving NaNs always return #f.  \n\n" "" "(fl=? 0.0 0.0) => #t\n(fl<? -1.0 0.0 1.0) => #t\n(fl>? -1.0 0.0 1.0) => #f\n(fl<=? 0.0 3.0 3.0) => #t\n(fl>=? 4.0 3.0 3.0) => #t\n(fl<? 7.0 +inf.0) => #t\n(fl=? +nan.0 0.0) => #f\n(fl=? +nan.0 +nan.0) => #f\n(fl<? +nan.0 +nan.0) => #f\n(fl<=? +nan.0 +inf.0) => #f\n(fl>=? +nan.0 +inf.0) => #f\n\n") ("objects:s179" "procedure: (flzero? fl)\nreturns: #t if fl is zero, #f otherwise \nprocedure: (flpositive? fl)\nreturns: #t if fl is greater than zero, #f otherwise \nprocedure: (flnegative? fl)\nreturns: #t if fl is less than zero, #f otherwise \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "flzero? is equivalent to (lambda (x) (fl=? x 0.0)), flpositive? is equivalent to (lambda (x) (fl>? x 0.0)), and flnegative? to (lambda (x) (fl<? x 0.0)). \n\n" "Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is considered both zero and nonnegative. \n\n" "" "(flzero? 0.0) => #t\n(flzero? 1.0) => #f \n\n(flpositive? 128.0) => #t\n(flpositive? 0.0) => #f\n(flpositive? -1.0) => #f \n\n(flnegative? -65.0) => #t\n(flnegative? 0.0) => #f\n(flnegative? 1.0) => #f \n\n(flzero? -0.0) => #t\n(flnegative? -0.0) => #f \n\n(flnegative? +nan.0) => #f\n(flzero? +nan.0) => #f\n(flpositive? +nan.0) => #f \n\n(flnegative? +inf.0) => #f\n(flnegative? -inf.0) => #t\n\n") ("objects:s180" "procedure: (flinteger? fl)\nreturns: #t if fl is integer, #f otherwise \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "" "(flinteger? 0.0) => #t\n(flinteger? -17.0) => #t\n(flinteger? +nan.0) => #f\n(flinteger? +inf.0) => #f\n\n") ("objects:s181" "procedure: (flfinite? fl)\nreturns: #t if fl is finite, #f otherwise \nprocedure: (flinfinite? fl)\nreturns: #t if fl is infinite, #f otherwise \nprocedure: (flnan? fl)\nreturns: #t if fl is a NaN, #f otherwise \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "" "(flfinite? 3.1415) => #t\n(flinfinite? 3.1415) => #f\n(flnan? 3.1415) => #f \n\n(flfinite? +inf.0) => #f\n(flinfinite? -inf.0) => #t\n(flnan? -inf.0) => #f \n\n(flfinite? +nan.0) => #f\n(flinfinite? +nan.0) => #f\n(flnan? +nan.0) => #t\n\n") ("objects:s182" "procedure: (fleven? fl-int)\nreturns: #t if fl-int is even, #f otherwise \nprocedure: (flodd? fl-int)\nreturns: #t if fl-int is odd, #f otherwise \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "fl-int must be an integer-valued flonum. \n\n" "" "(fleven? 0.0) => #t\n(fleven? 1.0) => #f\n(fleven? -1.0) => #f\n(fleven? -10.0) => #t \n\n(flodd? 0.0) => #f\n(flodd? 1.0) => #t\n(flodd? -1.0) => #t\n(flodd? -10.0) => #f\n\n") ("objects:s183" "procedure: (flmin fl1 fl2 ...)\nreturns: the minimum of fl1 fl2 ... \nprocedure: (flmax fl1 fl2 ...)\nreturns: the maximum of fl1 fl2 ...\nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "" "(flmin 4.2 -7.5 2.0 0.0 -6.4) => -7.5 \n\n(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])\n  (apply flmin ls)) => 2.6 \n\n(flmax 4.2 -7.5 2.0 0.0 -6.4) => 4.2 \n\n(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])\n  (apply flmax ls)) => 8.0\n\n") ("objects:s184" "procedure: (fl+ fl ...)\nreturns: the sum of the arguments fl ...\nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "When called with no arguments, fl+ returns 0.0.  \n\n" "" "(fl+) => 0.0\n(fl+ 1.0 2.5) => 3.25\n(fl+ 3.0 4.25 5.0) => 12.25\n(apply fl+ '(1.0 2.0 3.0 4.0 5.0)) => 15.0\n\n") ("objects:s185" "procedure: (fl- fl)\nreturns: the additive inverse of fl \nprocedure: (fl- fl1 fl2 fl3 ...)\nreturns: the difference between fl1 and the sum of fl2 fl3 ...\nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "With an IEEE floating-point representation of flonums, the single-argument fl- is equivalent to  \n\n" "" "(lambda (x) (fl* -1.0 x))\n\n" "or \n\n" "" "(lambda (x) (fl- -0.0 x))\n\n" "but not \n\n" "" "(lambda (x) (fl- 0.0 x))\n\n" "since the latter returns 0.0 rather than -0.0 for 0.0.  \n\n" "" "(fl- 0.0) => -0.0\n(fl- 3.0) => -3.0\n(fl- 4.0 3.0) => 1.0\n(fl- 4.0 3.0 2.0 1.0) => -2.0\n\n") ("objects:s186" "procedure: (fl* fl ...)\nreturns: the product of the arguments fl ...\nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "When called with no arguments, fl* returns 1.0.  \n\n" "" "(fl*) => 1.0\n(fl* 1.5 2.5) => 3.75\n(fl* 3.0 -4.0 5.0) => -60.0\n(apply fl* '(1.0 -2.0 3.0 -4.0 5.0)) => 120.0\n\n") ("objects:s187" "procedure: (fl/ fl)\nreturns: the multiplicative inverse of fl \nprocedure: (fl/ fl1 fl2 fl3 ...)\nreturns: the result of dividing fl1 by the product of fl2 fl3 ...\nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "" "(fl/ -4.0) => -0.25\n(fl/ 8.0 -2.0) => -4.0\n(fl/ -9.0 2.0) => -4.5\n(fl/ 60.0 5.0 3.0 2.0) => 2.0\n\n") ("objects:s188" "procedure: (fldiv fl1 fl2)\nprocedure: (flmod fl1 fl2)\nprocedure: (fldiv-and-mod fl1 fl2)\nreturns: see below \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "These are flonum-specific versions of the generic div, mod, and div-and-mod.  \n\n" "" "(fldiv 17.0 3.0) => 5.0\n(flmod 17.0 3.0) => 2.0\n(fldiv -17.0 3.0) => -6.0\n(flmod -17.0 3.0) => 1.0\n(fldiv 17.0 -3.0) => -5.0\n(flmod 17.0 -3.0) => 2.0\n(fldiv -17.0 -3.0) => 6.0\n(flmod -17.0 -3.0) => 1.0 \n\n(fldiv-and-mod 17.5 3.75) => 4.0\n                             2.5\n\n") ("objects:s189" "procedure: (fldiv0 fl1 fl2)\nprocedure: (flmod0 fl1 fl2)\nprocedure: (fldiv0-and-mod0 fl1 fl2)\nreturns: see below \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "These are flonum-specific versions of the generic div0, mod0, and div0-and-mod0.  \n\n" "" "(fldiv0 17.0 3.0) => 6.0\n(flmod0 17.0 3.0) => -1.0\n(fldiv0 -17.0 3.0) => -6.0\n(flmod0 -17.0 3.0) => 1.0\n(fldiv0 17.0 -3.0) => -6.0\n(flmod0 17.0 -3.0) => -1.0\n(fldiv0 -17.0 -3.0) => 6.0\n(flmod0 -17.0 -3.0) => 1.0 \n\n(fldiv0-and-mod0 17.5 3.75) => 5.0\n                               -1.25\n\n") ("objects:s190" "procedure: (flround fl)\nreturns: the integer closest to fl \nprocedure: (fltruncate fl)\nreturns: the integer closest to fl toward zero \nprocedure: (flfloor fl)\nreturns: the integer closest to fl toward -\nprocedure: (flceiling fl)\nreturns: the integer closest to fl toward +\nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "If fl is an integer, NaN, or infinity, each of these procedures returns fl. If fl is exactly between two integers, flround returns the closest even integer. \n\n" "" "(flround 17.3) => 17.0\n(flround -17.3) => -17.0\n(flround 2.5) => 2.0\n(flround 3.5) => 4.0 \n\n(fltruncate 17.3) => 17.0\n(fltruncate -17.3) => -17.0 \n\n(flfloor 17.3) => 17.0\n(flfloor -17.3) => -18.0 \n\n(flceiling 17.3) => 18.0\n(flceiling -17.3) => -17.0\n\n") ("objects:s191" "procedure: (flnumerator fl)\nreturns: the numerator of fl \nprocedure: (fldenominator fl)\nreturns: the denominator of fl \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "If fl is an integer, including 0.0, or infinity, the numerator is fl and the denominator is 1.0. \n\n" "" "(flnumerator -9.0) => -9.0\n(fldenominator -9.0) => 1.0\n(flnumerator 0.0) => 0.0\n(fldenominator 0.0) => 1.0\n(flnumerator -inf.0) => -inf.0\n(fldenominator -inf.0) => 1.0\n\n" "The following hold for IEEE floats, but not necessarily other flonum representations. \n\n" "" "(flnumerator 3.5) => 7.0\n(fldenominator 3.5) => 2.0\n\n") ("objects:s192" "procedure: (flabs fl)\nreturns: absolute value of fl \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "" "(flabs 3.2) => 3.2\n(flabs -2e-20) => 2e-20\n\n") ("objects:s193" "procedure: (flexp fl)\nreturns: e to the fl power \nprocedure: (fllog fl)\nreturns: the natural logarithm of fl \nprocedure: (fllog fl1 fl2)\nreturns: the base-fl2 logarithm of fl1\nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "" "(flexp 0.0) => 1.0\n(flexp 1.0) => 2.7182818284590455 \n\n(fllog 1.0) => 0.0\n(fllog (exp 1.0)) => 1.0\n(fl/ (fllog 100.0) (fllog 10.0)) => 2.0 \n\n(fllog 100.0 10.0) => 2.0\n(fllog .125 2.0) => -3.0\n\n") ("objects:s194" "procedure: (flsin fl)\nreturns: the sine of fl \nprocedure: (flcos fl)\nreturns: the cosine of fl \nprocedure: (fltan fl)\nreturns: the tangent of fl \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n") ("objects:s195" "procedure: (flasin fl)\nreturns: the arc sine of fl \nprocedure: (flacos fl)\nreturns: the arc cosine of fl \nprocedure: (flatan fl)\nreturns: the arc tangent of fl \nprocedure: (flatan fl1 fl2)\nreturns: the arc tangent of fl1/fl2\nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n") ("objects:s196" "procedure: (flsqrt fl)\nreturns: the principal square root of fl \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "Returns the principal square root of fl. The square root of -0.0 should be -0.0. The result for other negative numbers may be a NaN or some other unspecified flonum. \n\n" "" "(flsqrt 4.0) => 2.0\n(flsqrt 0.0) => 0.0\n(flsqrt -0.0) => -0.0\n\n") ("objects:s197" "procedure: (flexpt fl1 fl2)\nreturns: fl1 raised to the fl2 power \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "If fl1 is negative and fl2 is not an integer, the result may be a NaN or some other unspecified flonum. If fl1 and fl2 are both zero, the result is 1.0.  If fl1 is zero and fl2 is positive, the result is zero.  In other cases where fl1 is zero, the result may be a NaN or some other unspecified flonum. \n\n" "" "(flexpt 3.0 2.0) => 9.0\n(flexpt 0.0 +inf.0) => 0.0\n\n") ("objects:s198" "procedure: (fixnum->flonum fx)\nreturns: the flonum representation closest to fx \nprocedure: (real->flonum real)\nreturns: the flonum representation closest to real \nlibraries: (rnrs arithmetic flonums), (rnrs)  \n\n" "fixnum->flonum is a restricted variant of inexact. real->flonum is a restricted variant of inexact when the input is an exact real; when it is an inexact non-flonum real, it coverts the inexact non-flonum real into the closest flonum. \n\n" "" "(fixnum->flonum 0) => 0.0\n(fixnum->flonum 13) => 13.0 \n\n(real->flonum -1/2) => -0.5\n(real->flonum 1s3) => 1000.0\n\n") ("objects:s201" "procedure: (char=? char1 char2 char3 ...)\nprocedure: (char<? char1 char2 char3 ...)\nprocedure: (char>? char1 char2 char3 ...)\nprocedure: (char<=? char1 char2 char3 ...)\nprocedure: (char>=? char1 char2 char3 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "These predicates behave in a similar manner to the numeric predicates =, <, >, <=, and >=. For example, char=? returns #t when its arguments are equivalent characters, and char<? returns #t when its arguments are monotonically increasing character (Unicode scalar) values. \n\n" "" "(char>? #\\a #\\b) => #f\n(char<? #\\a #\\b) => #t\n(char<? #\\a #\\b #\\c) => #t\n(let ([c #\\r])\n  (char<=? #\\a c #\\z)) => #t\n(char<=? #\\Z #\\W) => #f\n(char=? #\\+ #\\+) => #t\n\n") ("objects:s202" "procedure: (char-ci=? char1 char2 char3 ...)\nprocedure: (char-ci<? char1 char2 char3 ...)\nprocedure: (char-ci>? char1 char2 char3 ...)\nprocedure: (char-ci<=? char1 char2 char3 ...)\nprocedure: (char-ci>=? char1 char2 char3 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (rnrs unicode), (rnrs)  \n\n" "These predicates are identical to the predicates char=?, char<?, char>?, char<=?, and char>=? except that they are case-insensitive, i.e., compare the case-folded versions of their arguments. For example, char=? considers #\\a and #\\A to be distinct values; char-ci=? does not.  \n\n" "" "(char-ci<? #\\a #\\B) => #t\n(char-ci=? #\\W #\\w) => #t\n(char-ci=? #\\= #\\+) => #f\n(let ([c #\\R])\n  (list (char<=? #\\a c #\\z)\n        (char-ci<=? #\\a c #\\z))) => (#f #t)\n\n") ("objects:s203" "procedure: (char-alphabetic? char)\nreturns: #t if char is a letter, #f otherwise \nprocedure: (char-numeric? char)\nreturns: #t if char is a digit, #f otherwise \nprocedure: (char-whitespace? char)\nreturns: #t if char is whitespace, #f otherwise \nlibraries: (rnrs unicode), (rnrs)  \n\n" "A character is alphabetic if it has the Unicode \"Alphabetic\" property, numeric if it has the Unicode \"Numeric\" property, and whitespace if has the Unicode \"White_Space\" property. \n\n" "" "(char-alphabetic? #\\a) => #t\n(char-alphabetic? #\\T) => #t\n(char-alphabetic? #\\8) => #f\n(char-alphabetic? #\\$) => #f \n\n(char-numeric? #\\7) => #t\n(char-numeric? #\\2) => #t\n(char-numeric? #\\X) => #f\n(char-numeric? #\\space) => #f \n\n(char-whitespace? #\\space) => #t\n(char-whitespace? #\\newline) => #t\n(char-whitespace? #\\Z) => #f\n\n") ("objects:s204" "procedure: (char-lower-case? char)\nreturns: #t if char is lower case, #f otherwise \nprocedure: (char-upper-case? char)\nreturns: #t if char is upper case, #f otherwise \nprocedure: (char-title-case? char)\nreturns: #t if char is title case, #f otherwise \nlibraries: (rnrs unicode), (rnrs)  \n\n" "A character is upper-case if it has the Unicode \"Uppercase\" property, lower-case if it has the \"Lowercase\" property, and title-case if it is in the Lt general category. \n\n" "" "(char-lower-case? #\\r) => #t\n(char-lower-case? #\\R) => #f \n\n(char-upper-case? #\\r) => #f\n(char-upper-case? #\\R) => #t \n\n(char-title-case? #\\I) => #f\n(char-title-case? #\\x01C5) => #t\n\n") ("objects:s205" "procedure: (char-general-category char)\nreturns: a symbol representing the Unicode general category of char \nlibraries: (rnrs unicode), (rnrs)  \n\n" "The return value is one of the symbols Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No, Ps, Pe, Pi, Pf, Pd, Pc, Po, Sc, Sm, Sk, So, Zs, Zp, Zl, Cc, Cf, Cs, Co, or Cn.  \n\n" "" "(char-general-category #\\a) => Ll\n(char-general-category #\\space) => Zs\n(char-general-category #\\x10FFFF) => Cn  \n\n") ("objects:s206" "procedure: (char-upcase char)\nreturns: the upper-case character counterpart of char \nlibraries: (rnrs unicode), (rnrs)  \n\n" "If char is a lower- or title-case character and has a single upper-case counterpart, char-upcase returns the upper-case counterpart. Otherwise char-upcase returns char. \n\n" "" "(char-upcase #\\g) => #\\G\n(char-upcase #\\G) => #\\G\n(char-upcase #\\7) => #\\7\n(char-upcase #\\) => #\\\n\n") ("objects:s207" "procedure: (char-downcase char)\nreturns: the lower-case character equivalent of char \nlibraries: (rnrs unicode), (rnrs)  \n\n" "If char is an upper- or title-case character and has a single lower-case counterpart, char-downcase returns the lower-case counterpart. Otherwise char-downcase returns char. \n\n" "" "(char-downcase #\\g) => #\\g\n(char-downcase #\\G) => #\\g\n(char-downcase #\\7) => #\\7\n(char-downcase #\\) => #\\\n\n") ("objects:s208" "procedure: (char-titlecase char)\nreturns: the title-case character equivalent of char \nlibraries: (rnrs unicode), (rnrs)  \n\n" "If char is an upper- or lower-case character and has a single title-case counterpart, char-titlecase returns the title-case counterpart. Otherwise, if it is not a title-case character, has no single title-case counterpart, but does have a single upper-case counterpart, char-titlecase returns the upper-case counterpart. Otherwise char-titlecase returns char. \n\n" "" "(char-titlecase #\\g) => #\\G\n(char-titlecase #\\G) => #\\G\n(char-titlecase #\\7) => #\\7\n(char-titlecase #\\) => #\\\n\n") ("objects:s209" "procedure: (char-foldcase char)\nreturns: the case-folded character equivalent of char \nlibraries: (rnrs unicode), (rnrs)  \n\n" "If char has a case-folded counterpart, char-foldcase returns the case-folded counterpart. Otherwise, char-foldcase returns char. For most characters, (char-foldcase char) is equivalent to (char-downcase (char-upcase char)), but for Turkic  and , char-foldcase acts as the identity.  \n\n" "" "(char-foldcase #\\g) => #\\g\n(char-foldcase #\\G) => #\\g\n(char-foldcase #\\7) => #\\7\n(char-foldcase #\\) => #\\\n\n") ("objects:s210" "procedure: (char->integer char)\nreturns: the Unicode scalar value of char as an exact integer \nlibraries: (rnrs base), (rnrs)  \n\n" "" "(char->integer #\\newline) => 10\n(char->integer #\\space) => 32\n(- (char->integer #\\Z) (char->integer #\\A)) => 25\n\n") ("objects:s211" "procedure: (integer->char n)\nreturns: the character corresponding to the Unicode scalar value n \nlibraries: (rnrs base), (rnrs)  \n\n" "n must be an exact integer and a valid Unicode scalar value, i.e., [image not available] or [image not available]. \n\n" "" "(integer->char 48) => #\\0\n(integer->char #x3BB) => #\\\n\n") ("objects:s215" "procedure: (string=? string1 string2 string3 ...)\nprocedure: (string<? string1 string2 string3 ...)\nprocedure: (string>? string1 string2 string3 ...)\nprocedure: (string<=? string1 string2 string3 ...)\nprocedure: (string>=? string1 string2 string3 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "As with =, <, >, <=, and >=, these predicates express relationships among all of the arguments. For example, string>? determines if the lexicographic ordering of its arguments is monotonically decreasing. \n\n" "The comparisons are based on the character predicates char=? and char<?. Two strings are lexicographically equivalent if they are the same length and consist of the same sequence of characters according to char=?. If two strings differ only in length, the shorter string is considered to be lexicographically less than the longer string. Otherwise, the first character position at which the strings differ (by char=?) determines which string is lexicographically less than the other, according to char<?.  \n\n" "Two-argument string=? may be defined without error checks as follows.  \n\n" "" "(define string=?\n  (lambda (s1 s2)\n    (let ([n (string-length s1)])\n      (and (= (string-length s2) n)\n           (let loop ([i 0])\n             (or (= i n)\n                 (and (char=? (string-ref s1 i) (string-ref s2 i))\n                      (loop (+ i 1)))))))))\n\n" "Two-argument string<? may be defined without error checks as follows.  \n\n" "" "(define string<?\n  (lambda (s1 s2)\n    (let ([n1 (string-length s1)] [n2 (string-length s2)])\n      (let loop ([i 0])\n        (and (not (= i n2))\n             (or (= i n1)\n                 (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])\n                   (or (char<? c1 c2)\n                       (and (char=? c1 c2)\n                            (loop (+ i 1)))))))))))\n\n" "These definitions may be extended straightforwardly to support three or more arguments. string<=?, string>?, and string>=? may be defined similarly. \n\n" "" "(string=? \"mom\" \"mom\") => #t\n(string<? \"mom\" \"mommy\") => #t\n(string>? \"Dad\" \"Dad\") => #f\n(string=? \"Mom and Dad\" \"mom and dad\") => #f\n(string<? \"a\" \"b\" \"c\") => #t\n\n") ("objects:s216" "procedure: (string-ci=? string1 string2 string3 ...)\nprocedure: (string-ci<? string1 string2 string3 ...)\nprocedure: (string-ci>? string1 string2 string3 ...)\nprocedure: (string-ci<=? string1 string2 string3 ...)\nprocedure: (string-ci>=? string1 string2 string3 ...)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (rnrs unicode), (rnrs)  \n\n" "These predicates are identical to string=?, string<?, string>?, string<=?, and string>=? except that they are case-insensitive, i.e., compare the case-folded versions of their arguments. \n\n" "" "(string-ci=? \"Mom and Dad\" \"mom and dad\") => #t\n(string-ci<=? \"say what\" \"Say What!?\") => #t\n(string-ci>? \"N\" \"m\" \"L\" \"k\") => #t\n(string-ci=? \"Strae\" \"Strasse\") => #t\n\n") ("objects:s217" "procedure: (string char ...)\nreturns: a string containing the characters char ...\nlibraries: (rnrs base), (rnrs)  \n\n" "" "(string) => \"\"\n(string #\\a #\\b #\\c) => \"abc\"\n(string #\\H #\\E #\\Y #\\!) => \"HEY!\"\n\n") ("objects:s218" "procedure: (make-string n)\nprocedure: (make-string n char)\nreturns: a string of length n \nlibraries: (rnrs base), (rnrs)  \n\n" "n must be an exact nonnegative integer. If char is supplied, the string is filled with n occurrences of char, otherwise the characters contained in the string are unspecified. \n\n" "" "(make-string 0) => \"\"\n(make-string 0 #\\x) => \"\"\n(make-string 5 #\\x) => \"xxxxx\"\n\n") ("objects:s219" "procedure: (string-length string)\nreturns: the number of characters in string \nlibraries: (rnrs base), (rnrs)  \n\n" "The length of a string is always an exact nonnegative integer. \n\n" "" "(string-length \"abc\") => 3\n(string-length \"\") => 0\n(string-length \"hi there\") => 8\n(string-length (make-string 1000000)) => 1000000\n\n") ("objects:s220" "procedure: (string-ref string n)\nreturns: the nth character (zero-based) of string \nlibraries: (rnrs base), (rnrs)  \n\n" "n must be an exact nonnegative integer less than the length of string. \n\n" "" "(string-ref \"hi there\" 0) => #\\h\n(string-ref \"hi there\" 5) => #\\e\n\n") ("objects:s221" "procedure: (string-set! string n char)\nreturns: unspecified \nlibraries: (rnrs mutable-strings)\n\n" "n must be an exact nonnegative integer less than the length of string. string-set! changes the nth element of string to char. \n\n" "" "(let ([str (string-copy \"hi three\")])\n  (string-set! str 5 #\\e)\n  (string-set! str 6 #\\r)\n  str) => \"hi there\"\n\n") ("objects:s222" "procedure: (string-copy string)\nreturns: a new copy of string \nlibraries: (rnrs base), (rnrs)  \n\n" "This procedure creates a new string with the same length and contents as string. \n\n" "" "(string-copy \"abc\") => \"abc\" \n\n(let ([str \"abc\"])\n  (eq? str (string-copy str))) => #f\n\n") ("objects:s223" "procedure: (string-append string ...)\nreturns: a new string formed by concatenating the strings string ...\nlibraries: (rnrs base), (rnrs)  \n\n" "" "(string-append) => \"\"\n(string-append \"abc\" \"def\") => \"abcdef\"\n(string-append \"Hey \" \"you \" \"there!\") => \"Hey you there!\"\n\n" "The following implementation of string-append recurs down the list of strings to compute the total length, then allocates the new string, then fills it up as it unwinds the recursion. \n\n" "" "(define string-append\n  (lambda args\n    (let f ([ls args] [n 0])\n      (if (null? ls)\n          (make-string n)\n          (let* ([s1 (car ls)]\n                 [m (string-length s1)]\n                 [s2 (f (cdr ls) (+ n m))])\n            (do ([i 0 (+ i 1)] [j n (+ j 1)])\n                ((= i m) s2)\n              (string-set! s2 j (string-ref s1 i))))))))\n\n") ("objects:s224" "procedure: (substring string start end)\nreturns: a copy of string from start (inclusive) to end   (exclusive) \nlibraries: (rnrs base), (rnrs)  \n\n" "start and end must be exact nonnegative integers; start must be less than or equal to end, while end must be less than or equal to the length of string. If end = start, a string of length zero is returned. substring may be defined without error checks as follows.  \n\n" "" "(define substring\n  (lambda (s1 m n)\n    (let ([s2 (make-string (- n m))])\n      (do ([j 0 (+ j 1)] [i m (+ i 1)])\n          ((= i n) s2)\n        (string-set! s2 j (string-ref s1 i)))))) \n\n(substring \"hi there\" 0 1) => \"h\"\n(substring \"hi there\" 3 6) => \"the\"\n(substring \"hi there\" 5 5) => \"\" \n\n(let ([str \"hi there\"])\n  (let ([end (string-length str)])\n    (substring str 0 end))) => \"hi there\"\n\n") ("objects:s225" "procedure: (string-fill! string char)\nreturns: unspecified \nlibraries: (rnrs mutable-strings)\n\n" "string-fill! sets every character in string to char. \n\n" "" "(let ([str (string-copy \"sleepy\")])\n  (string-fill! str #\\Z)\n  str) => \"ZZZZZZ\"\n\n" "string-fill! might be defined as follows:  \n\n" "" "(define string-fill!\n  (lambda (s c)\n    (let ([n (string-length s)])\n      (do ([i 0 (+ i 1)])\n          ((= i n))\n          (string-set! s i c)))))\n\n" "An alternative definition is given on page 276. \n\n") ("objects:s226" "procedure: (string-upcase string)\nreturns: the upper-case equivalent of string \nprocedure: (string-downcase string)\nreturns: the lower-case equivalent of string \nprocedure: (string-foldcase string)\nreturns: the case-folded equivalent of string \nprocedure: (string-titlecase string)\nreturns: the title-case equivalent of string \nlibraries: (rnrs unicode), (rnrs)  \n\n" "These procedures implement Unicode's locale-independent case mappings from scalar-value sequences to scalar-value sequences. These mappings do not always map single characters to single characters, so the length of the result string may differ from the length of string. If the result string is the same as string (by string=?), string or a copy of string may be returned. Otherwise, the result string is newly allocated. string-foldcase does not use the special mappings for Turkic languages. \n\n" "string-titlecase converts the first cased character of each word in string to its title-case counterpart and converts each other character to its lower-case counterpart. Word breaks are recognized as specified in Unicode Standard Annex #29 [8]. \n\n" "" "(string-upcase \"Hi\") => \"HI\"\n(string-downcase \"Hi\") => \"hi\"\n(string-foldcase \"Hi\") => \"hi\" \n\n(string-upcase \"Strae\") => \"STRASSE\"\n(string-downcase \"Strae\") => \"strae\"\n(string-foldcase \"Strae\") => \"strasse\"\n(string-downcase \"STRASSE\")  => \"strasse\" \n\n(string-downcase \"\") => \"\" \n\n(string-titlecase \"kNock KNoCK\") => \"Knock Knock\"\n(string-titlecase \"who's there?\") => \"Who's There?\"\n(string-titlecase \"r6rs\") => \"R6rs\"\n(string-titlecase \"R6RS\") => \"R6rs\"\n\n") ("objects:s227" "procedure: (string-normalize-nfd string)\nreturns: the Unicode normalized form D of string \nprocedure: (string-normalize-nfkd string)\nreturns: the Unicode normalized form KD of string \nprocedure: (string-normalize-nfc string)\nreturns: the Unicode normalized form C of string \nprocedure: (string-normalize-nfkc string)\nreturns: the Unicode normalized form KC of string \nlibraries: (rnrs unicode), (rnrs)  \n\n" "If the result string is the same as string (by string=?), string or a copy of string may be returned. Otherwise, the result string is newly allocated. \n\n" "" "(string-normalize-nfd \"\\xE9;\") => \"e\\x301;\"\n(string-normalize-nfc \"\\xE9;\") => \"\\xE9;\"\n(string-normalize-nfd \"\\x65;\\x301;\") => \"e\\x301;\"\n(string-normalize-nfc \"\\x65;\\x301;\") => \"\\xE9;\"\n\n") ("objects:s228" "procedure: (string->list string)\nreturns: a list of the characters in string \nlibraries: (rnrs base), (rnrs)  \n\n" "string->list allows a string to be converted into a list, so that Scheme's list-processing operations may be applied to the processing of strings. string->list may be defined without error checks as follows.  \n\n" "" "(define string->list\n  (lambda (s)\n    (do ([i (- (string-length s) 1) (- i 1)]\n         [ls '() (cons (string-ref s i) ls)])\n        ((< i 0) ls)))) \n\n(string->list \"\") => ()\n(string->list \"abc\") => (#\\a #\\b #\\c)\n(apply char<? (string->list \"abc\")) => #t\n(map char-upcase (string->list \"abc\")) => (#\\A #\\B #\\C)\n\n") ("objects:s229" "procedure: (list->string list)\nreturns: a string of the characters in list \nlibraries: (rnrs base), (rnrs)  \n\n" "list must consist entirely of characters. \n\n" "list->string is the functional inverse of string->list. A program might use both procedures together, first converting a string into a list, then operating on this list to produce a new list, and finally converting the new list back into a string. \n\n" "list->string may be defined without error checks as follows.  \n\n" "" "(define list->string\n  (lambda (ls)\n    (let ([s (make-string (length ls))])\n      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])\n          ((null? ls) s)\n        (string-set! s i (car ls)))))) \n\n(list->string '()) => \"\"\n(list->string '(#\\a #\\b #\\c)) => \"abc\"\n(list->string\n  (map char-upcase\n       (string->list \"abc\"))) => \"ABC\"\n\n") ("objects:s231" "procedure: (vector obj ...)\nreturns: a vector of the objects obj ...\nlibraries: (rnrs base), (rnrs)  \n\n" "" "(vector) => #()\n(vector 'a 'b 'c) => #(a b c)\n\n") ("objects:s232" "procedure: (make-vector n)\nprocedure: (make-vector n obj)\nreturns: a vector of length n \nlibraries: (rnrs base), (rnrs)  \n\n" "n must be an exact nonnegative integer. If obj is supplied, each element of the vector is filled with obj; otherwise, the elements are unspecified. \n\n" "" "(make-vector 0) => #()\n(make-vector 0 '#(a)) => #()\n(make-vector 5 '#(a)) => #(#(a) #(a) #(a) #(a) #(a))\n\n") ("objects:s233" "procedure: (vector-length vector)\nreturns: the number of elements in vector \nlibraries: (rnrs base), (rnrs)  \n\n" "The length of a vector is always an exact nonnegative integer. \n\n" "" "(vector-length '#()) => 0\n(vector-length '#(a b c)) => 3\n(vector-length (vector 1 '(2) 3 '#(4 5))) => 4\n(vector-length (make-vector 300)) => 300\n\n") ("objects:s234" "procedure: (vector-ref vector n)\nreturns: the nth element (zero-based) of vector \nlibraries: (rnrs base), (rnrs)  \n\n" "n must be an exact nonnegative integer less than the length of vector. \n\n" "" "(vector-ref '#(a b c) 0) => a\n(vector-ref '#(a b c) 1) => b\n(vector-ref '#(x y z w) 3) => w\n\n") ("objects:s235" "procedure: (vector-set! vector n obj)\nreturns: unspecified \nlibraries: (rnrs base), (rnrs)  \n\n" "n must be an exact nonnegative integer less than the length of vector. vector-set! changes the nth element of vector to obj. \n\n" "" "(let ([v (vector 'a 'b 'c 'd 'e)])\n  (vector-set! v 2 'x)\n  v) => #(a b x d e)\n\n") ("objects:s236" "procedure: (vector-fill! vector obj)\nreturns: unspecified \nlibraries: (rnrs base), (rnrs)  \n\n" "vector-fill! replaces each element of vector with obj. It may be defined without error checks as follows. \n\n" "" "(define vector-fill!\n  (lambda (v x)\n    (let ([n (vector-length v)])\n      (do ([i 0 (+ i 1)])\n          ((= i n))\n        (vector-set! v i x))))) \n\n(let ([v (vector 1 2 3)])\n  (vector-fill! v 0)\n  v) => #(0 0 0)\n\n") ("objects:s237" "procedure: (vector->list vector)\nreturns: a list of the elements of vector \nlibraries: (rnrs base), (rnrs)  \n\n" "vector->list provides a convenient method for applying list-processing operations to vectors. It may be defined without error checks as follows. \n\n" "" "(define vector->list\n  (lambda (s)\n    (do ([i (- (vector-length s) 1) (- i 1)]\n         [ls '() (cons (vector-ref s i) ls)])\n        ((< i 0) ls)))) \n\n(vector->list (vector)) => ()\n(vector->list '#(a b c)) => (a b c) \n\n(let ((v '#(1 2 3 4 5)))\n  (apply * (vector->list v))) => 120\n\n") ("objects:s238" "procedure: (list->vector list)\nreturns: a vector of the elements of list \nlibraries: (rnrs base), (rnrs)  \n\n" "list->vector is the functional inverse of vector->list. The two procedures are often used in combination to take advantage of a list-processing operation. A vector may be converted to a list with vector->list, this list processed in some manner to produce a new list, and the new list converted back into a vector with list->vector.  \n\n" "list->vector may be defined without error checks as follows.  \n\n" "" "(define list->vector\n  (lambda (ls)\n    (let ([s (make-vector (length ls))])\n      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])\n          ((null? ls) s)\n        (vector-set! s i (car ls)))))) \n\n(list->vector '()) => #()\n(list->vector '(a b c)) => #(a b c) \n\n(let ([v '#(1 2 3 4 5)])\n  (let ([ls (vector->list v)])\n    (list->vector (map * ls ls)))) => #(1 4 9 16 25)\n\n") ("objects:s239" "procedure: (vector-sort predicate vector)\nreturns: a vector containing the elements of vector, sorted according to predicate \nprocedure: (vector-sort! predicate vector)\nreturns: unspecified \nlibraries: (rnrs sorting), (rnrs)  \n\n" "predicate should be a procedure that expects two arguments and returns #t if its first argument must precede its second in the sorted vector. That is, if predicate is applied to two elements x and y, where x appears after y in the input vector, the predicate should return true only if x should appear before y in the output vector. If this constraint is met, vector-sort performs a stable sort, i.e., two elements are reordered only when necessary according to predicate. vector-sort! performs the sort destructively and does not necessarily perform a stable sort. Duplicate elements are not removed. predicate should not have any side effects. \n\n" "vector-sort may call predicate up to nlogn times, where n is the length of vector, while vector-sort! may call the predicate up to n^2 times. The looser bound for vector-sort! allows an implementation to use a quicksort algorithm, which may be faster in some cases than algorithms that have the tighter nlogn bound. \n\n" "" "(vector-sort < '#(3 4 2 1 2 5)) => #(1 2 2 3 4 5)\n(vector-sort > '#(0.5 1/2)) => #(0.5 1/2)\n(vector-sort > '#(1/2 0.5)) => #(1/2 0.5) \n\n(let ([v (vector 3 4 2 1 2 5)])\n  (vector-sort! < v)\n  v) => #(1 2 2 3 4 5)\n\n") ("objects:s240" "syntax: (endianness symbol)\nreturns: symbol \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "symbol must be the symbol little, the symbol big, or some other symbol recognized by the implementation as an endianness symbol. It is a syntax violation if symbol is not a symbol or if it is not recognized by the implementation as an endianness symbol. \n\n" "" "(endianness little) => little\n(endianness big) => big\n(endianness \"spam\") => exception\n\n") ("objects:s241" "procedure: (native-endianness) \nreturns: a symbol naming the implementation's native endianness \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "The return value is the symbol little, the symbol big, or some other endianness symbol recognized by the implementation. It typically reflects the endianness of the underlying hardware. \n\n" "" "(symbol? (native-endianness)) => #t\n\n") ("objects:s242" "procedure: (make-bytevector n)\nprocedure: (make-bytevector n fill)\nreturns: a new bytevector of length n \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "If fill is supplied, each element of the bytevector is initialized to fill; otherwise, the elements are unspecified. The fill value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent. \n\n" "" "(make-bytevector 0) => #vu8()\n(make-bytevector 0 7) => #vu8()\n(make-bytevector 5 7) => #vu8(7 7 7 7 7)\n(make-bytevector 5 -7) => #vu8(249 249 249 249 249)\n\n") ("objects:s243" "procedure: (bytevector-length bytevector)\nreturns: the length of bytevector in 8-bit bytes \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "" "(bytevector-length #vu8()) => 0\n(bytevector-length #vu8(1 2 3)) => 3\n(bytevector-length (make-bytevector 300)) => 300\n\n") ("objects:s244" "procedure: (bytevector=? bytevector1 bytevector2)\nreturns: #t if the relation holds, #f otherwise \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "Two bytevectors are equal by bytevector=? if and only if they have the same length and same contents. \n\n" "" "(bytevector=? #vu8() #vu8()) => #t\n(bytevector=? (make-bytevector 3 0) #vu8(0 0 0)) => #t\n(bytevector=? (make-bytevector 5 0) #vu8(0 0 0)) => #f\n(bytevector=? #vu8(1 127 128 255) #vu8(255 128 127 1)) => #f\n\n") ("objects:s245" "procedure: (bytevector-fill! bytevector fill)\nreturns: unspecified \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "The fill value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent. \n\n" "bytevector-fill! replaces each element of bytevector with fill. \n\n" "" "(let ([v (make-bytevector 6)])\n  (bytevector-fill! v 255)\n  v) => #vu8(255 255 255 255 255 255) \n\n(let ([v (make-bytevector 6)])\n  (bytevector-fill! v -128)\n  v) => #vu8(128 128 128 128 128 128)\n\n") ("objects:s246" "procedure: (bytevector-copy bytevector)\nreturns: a new bytevector that is a copy of bytevector  \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "bytevector-copy creates a new bytevector with the same length and contents as bytevector. \n\n" "" "(bytevector-copy #vu8(1 127 128 255)) => #vu8(1 127 128 255) \n\n(let ([v #vu8(1 127 128 255)])\n  (eq? v (bytevector-copy v))) => #f\n\n") ("objects:s247" "procedure: (bytevector-copy! src src-start dst dst-start n)\nreturns: unspecified \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "src and dst must be bytevectors. src-start, dst-start, and n must be exact nonnegative integers. The sum of src-start and n must not exceed the length of src, and the sum of dst-start and n must not exceed the length of dst. \n\n" "bytevector-copy! overwrites the n bytes of dst starting at dst-start with the n bytes of src starting at src-start. This works even if dst is the same bytevector as src and the source and destination locations overlap. That is, the destination is filled with the bytes that appeared at the source before the operation began. \n\n" "" "(define v1 #vu8(31 63 95 127 159 191 223 255))\n(define v2 (make-bytevector 10 0)) \n\n(bytevector-copy! v1 2 v2 1 4)\nv2 => #vu8(0 95 127 159 191 0 0 0 0 0)\n \n(bytevector-copy! v1 5 v2 7 3)\nv2 => #vu8(0 95 127 159 191 0 0 191 223 255)\n \n(bytevector-copy! v2 3 v2 0 6)\nv2 => #vu8(159 191 0 0 191 223 0 191 223 255)\n \n(bytevector-copy! v2 0 v2 1 9)\nv2 => #vu8(159 159 191 0 0 191 223 0 191 223)\n\n") ("objects:s248" "procedure: (bytevector-u8-ref bytevector n)\nreturns: the 8-bit unsigned byte at index n (zero-based) of bytevector  \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer less than the length of bytevector. \n\n" "The value is returned as an exact 8-bit unsigned integer, i.e., a value in the range 0 to 255 inclusive. \n\n" "" "(bytevector-u8-ref #vu8(1 127 128 255) 0) => 1\n(bytevector-u8-ref #vu8(1 127 128 255) 2) => 128\n(bytevector-u8-ref #vu8(1 127 128 255) 3) => 255\n\n") ("objects:s249" "procedure: (bytevector-s8-ref bytevector n)\nreturns: the 8-bit signed byte at index n (zero-based) of bytevector  \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer less than the length of bytevector. \n\n" "The value returned is an exact 8-bit signed integer, i.e., a value in the range -128 to 127 inclusive, and is the equivalent of the stored value treated as a two's complement value. \n\n" "" "(bytevector-s8-ref #vu8(1 127 128 255) 0) => 1\n(bytevector-s8-ref #vu8(1 127 128 255) 1) => 127\n(bytevector-s8-ref #vu8(1 127 128 255) 2) => -128\n(bytevector-s8-ref #vu8(1 127 128 255) 3) => -1\n\n") ("objects:s250" "procedure: (bytevector-u8-set! bytevector n u8)\nreturns: unspecified \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer less than the length of bytevector. u8 must be an 8-bit unsigned value, i.e., a value in the range 0 to 255 inclusive. \n\n" "bytevector-u8-set! changes the 8-bit value at index n (zero-based) of bytevector to u8. \n\n" "" "(let ([v (make-bytevector 5 -1)])\n  (bytevector-u8-set! v 2 128)\n  v) => #vu8(255 255 128 255 255)\n\n") ("objects:s251" "procedure: (bytevector-s8-set! bytevector n s8)\nreturns: unspecified \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer less than the length of bytevector. s8 must be an 8-bit signed value, i.e., a value in the range -128 to 127 inclusive. \n\n" "bytevector-s8-set! changes the 8-bit value at index n (zero-based) of bytevector to the two's complement equivalent of s8. \n\n" "" "(let ([v (make-bytevector 4 0)])\n  (bytevector-s8-set! v 1 100)\n  (bytevector-s8-set! v 2 -100)\n  v) => #vu8(0 100 156 0)\n\n") ("objects:s252" "procedure: (bytevector->u8-list bytevector)\nreturns: a list of the 8-bit unsigned elements of bytevector \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "" "(bytevector->u8-list (make-bytevector 0)) => ()\n(bytevector->u8-list #vu8(1 127 128 255)) => (1 127 128 255) \n\n(let ([v #vu8(1 2 3 255)])\n  (apply * (bytevector->u8-list v))) => 1530\n\n") ("objects:s253" "procedure: (u8-list->bytevector list)\nreturns: a new bytevector of the elements of list \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "list must consist entirely of exact 8-bit unsigned integers, i.e., values in the range 0 to 255 inclusive. \n\n" "" "(u8-list->bytevector '()) => #vu8()\n(u8-list->bytevector '(1 127 128 255)) => #vu8(1 127 128 255) \n\n(let ([v #vu8(1 2 3 4 5)])\n  (let ([ls (bytevector->u8-list v)])\n    (u8-list->bytevector (map * ls ls)))) => #vu8(1 4 9 16 25)\n\n") ("objects:s254" "procedure: (bytevector-u16-native-ref bytevector n)\nreturns: the 16-bit unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-s16-native-ref bytevector n)\nreturns: the 16-bit signed integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-u32-native-ref bytevector n)\nreturns: the 32-bit unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-s32-native-ref bytevector n)\nreturns: the 32-bit signed integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-u64-native-ref bytevector n)\nreturns: the 64-bit unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-s64-native-ref bytevector n)\nreturns: the 64-bit signed integer at index n (zero-based) of bytevector  \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of n and the number of bytes occupied by the value must not exceed the length of bytevector. The native endianness is assumed. \n\n" "The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value. \n\n" "" "(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))\n\n" "If native endianness is big: \n\n" "" "(bytevector-u16-native-ref v 2) => #xfe56\n(bytevector-s16-native-ref v 2) => #x-1aa\n(bytevector-s16-native-ref v 6) => #x7898 \n\n(bytevector-u32-native-ref v 0) => #x1234fe56\n(bytevector-s32-native-ref v 0) => #x1234fe56\n(bytevector-s32-native-ref v 4) => #x-23458768 \n\n(bytevector-u64-native-ref v 0) => #x1234fe56dcba7898\n(bytevector-s64-native-ref v 0) => #x1234fe56dcba7898\n\n" "If native endianness is little: \n\n" "" "(bytevector-u16-native-ref v 2) => #x56fe\n(bytevector-s16-native-ref v 2) => #x56fe\n(bytevector-s16-native-ref v 6) => #x-6788 \n\n(bytevector-u32-native-ref v 0) => #x56fe3412\n(bytevector-s32-native-ref v 0) => #x56fe3412\n(bytevector-s32-native-ref v 4) => #x-67874524 \n\n(bytevector-u64-native-ref v 0) => #x9878badc56fe3412\n(bytevector-s64-native-ref v 0) => #x-67874523a901cbee\n\n") ("objects:s255" "procedure: (bytevector-u16-native-set! bytevector n u16)\nprocedure: (bytevector-s16-native-set! bytevector n s16)\nprocedure: (bytevector-u32-native-set! bytevector n u32)\nprocedure: (bytevector-s32-native-set! bytevector n s32)\nprocedure: (bytevector-u64-native-set! bytevector n u64)\nprocedure: (bytevector-s64-native-set! bytevector n s64)\nreturns: unspecified \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of n and the number of bytes occupied by the value must not exceed the length bytevector. u16 must be a 16-bit unsigned value, i.e., a value in the range 0 to 2^16 - 1 inclusive; s16 must be a 16-bit signed value, i.e., a value in the range -2^15 to 2^15 - 1 inclusive; u32 must be a 32-bit unsigned value, i.e., a value in the range 0 to 2^32 - 1 inclusive; s32 must be a 32-bit signed value, i.e., a value in the range -2^31 to 2^31 - 1 inclusive; u64 must be a 64-bit unsigned value, i.e., a value in the range 0 to 2^64 - 1 inclusive; and s64 must be a 64-bit signed value, i.e., a value in the range -2^63 to 2^63 - 1 inclusive. The native endianness is assumed. \n\n" "These procedures store the given value in the 2, 4, or 8 bytes starting at index n (zero-based) of bytevector. Negative values are stored as their two's complement equivalent. \n\n" "" "(define v (make-bytevector 8 0))\n(bytevector-u16-native-set! v 0 #xfe56)\n(bytevector-s16-native-set! v 2 #x-1aa)\n(bytevector-s16-native-set! v 4 #x7898)\n\n" "If native endianness is big: \n\n" "" "v => #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)\n\n" "If native endianness is little: \n\n" "" "v => #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)\n\n" "" "(define v (make-bytevector 16 0))\n(bytevector-u32-native-set! v 0 #x1234fe56)\n(bytevector-s32-native-set! v 4 #x1234fe56)\n(bytevector-s32-native-set! v 8 #x-23458768)\n\n" "If native endianness is big: \n\n" "" "v => #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56\n          #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)\n\n" "If native endianness is little: \n\n" "" "v => #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12\n          #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)\n\n" "" "(define v (make-bytevector 24 0))\n(bytevector-u64-native-set! v 0 #x1234fe56dcba7898)\n(bytevector-s64-native-set! v 8 #x1234fe56dcba7898)\n(bytevector-s64-native-set! v 16 #x-67874523a901cbee)\n\n" "If native endianness is big: \n\n" "" "v => #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\n          #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98\n          #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)\n\n" "If native endianness is little: \n\n" "" "v => #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\n          #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12\n          #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)\n\n") ("objects:s256" "procedure: (bytevector-u16-ref bytevector n eness)\nreturns: the 16-bit unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-s16-ref bytevector n eness)\nreturns: the 16-bit signed integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-u32-ref bytevector n eness)\nreturns: the 32-bit unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-s32-ref bytevector n eness)\nreturns: the 32-bit signed integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-u64-ref bytevector n eness)\nreturns: the 64-bit unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-s64-ref bytevector n eness)\nreturns: the 64-bit signed integer at index n (zero-based) of bytevector  \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value (2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness symbol naming the endianness. \n\n" "The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value. \n\n" "" "(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))\n(bytevector-u16-ref v 0 (endianness big)) => #x1234\n(bytevector-s16-ref v 1 (endianness big)) => #x34fe\n(bytevector-s16-ref v 5 (endianness big)) => #x-4588 \n\n(bytevector-u32-ref v 2 'big) => #xfe56dcba\n(bytevector-s32-ref v 3 'big) => #x56dcba78\n(bytevector-s32-ref v 4 'big) => #x-23458768 \n\n(bytevector-u64-ref v 0 'big) => #x1234fe56dcba7898\n(bytevector-s64-ref v 1 'big) => #x34fe56dcba78989a \n\n(bytevector-u16-ref v 0 (endianness little)) => #x3412\n(bytevector-s16-ref v 1 (endianness little)) => #x-1cc\n(bytevector-s16-ref v 5 (endianness little)) => #x78ba \n\n(bytevector-u32-ref v 2 'little) => #xbadc56fe\n(bytevector-s32-ref v 3 'little) => #x78badc56\n(bytevector-s32-ref v 4 'little) => #x-67874524 \n\n(bytevector-u64-ref v 0 'little) => #x9878badc56fe3412\n(bytevector-s64-ref v 1 'little) => #x-6567874523a901cc\n\n") ("objects:s257" "procedure: (bytevector-u16-set! bytevector n u16 eness)\nprocedure: (bytevector-s16-set! bytevector n s16 eness)\nprocedure: (bytevector-u32-set! bytevector n u32 eness)\nprocedure: (bytevector-s32-set! bytevector n s32 eness)\nprocedure: (bytevector-u64-set! bytevector n u64 eness)\nprocedure: (bytevector-s64-set! bytevector n s64 eness)\nreturns: unspecified \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. u16 must be a 16-bit unsigned value, i.e., a value in the range 0 to 2^16 - 1 inclusive; s16 must be a 16-bit signed value, i.e., a value in the range -2^15 to 2^15 - 1 inclusive; u32 must be a 32-bit unsigned value, i.e., a value in the range 0 to 2^32 - 1 inclusive; s32 must be a 32-bit signed value, i.e., a value in the range -2^31 to 2^31 - 1 inclusive; u64 must be a 64-bit unsigned value, i.e., a value in the range 0 to 2^64 - 1 inclusive; and s64 must be a 64-bit signed value, i.e., a value in the range -2^63 to 2^63 - 1 inclusive. eness must be a valid endianness symbol naming the endianness. \n\n" "These procedures store the given value in the 2, 4, or 8 bytes starting at index n (zero-based) of bytevector. Negative values are stored as their two's complement equivalent. \n\n" "" "(define v (make-bytevector 8 0))\n(bytevector-u16-set! v 0 #xfe56 (endianness big))\n(bytevector-s16-set! v 3 #x-1aa (endianness little))\n(bytevector-s16-set! v 5 #x7898 (endianness big))\nv => #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0) \n\n(define v (make-bytevector 16 0))\n(bytevector-u32-set! v 0 #x1234fe56 'little)\n(bytevector-s32-set! v 6 #x1234fe56 'big)\n(bytevector-s32-set! v 11 #x-23458768 'little)\nv => #vu8(#x56 #xfe #x34 #x12 #x0 #x0\n          #x12 #x34 #xfe #x56 #x0\n          #x98 #x78 #xba #xdc #x0) \n\n(define v (make-bytevector 28 0))\n(bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)\n(bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)\n(bytevector-s64-set! v 19 #x-67874523a901cbee 'big)\nv => #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0\n          #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0\n          #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)\n\n") ("objects:s258" "procedure: (bytevector-uint-ref bytevector n eness size)\nreturns: the size-byte unsigned integer at index n (zero-based) of bytevector  \nprocedure: (bytevector-sint-ref bytevector n eness size)\nreturns: the size-byte signed integer at index n (zero-based) of bytevector  \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer and indexes the starting byte of the value. size must be an exact positive integer and specifies the number of bytes occupied by the value. The sum of n and size must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness symbol naming the endianness. \n\n" "The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value. \n\n" "" "(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76)) \n\n(bytevector-uint-ref v 0 'big 1) => #x12\n(bytevector-uint-ref v 0 'little 1) => #x12\n(bytevector-uint-ref v 1 'big 3) => #x34fe56\n(bytevector-uint-ref v 2 'little 7) => #x9a9878badc56fe \n\n(bytevector-sint-ref v 2 'big 1) => #x-02\n(bytevector-sint-ref v 1 'little 6) => #x78badc56fe34\n(bytevector-sint-ref v 2 'little 7) => #x-6567874523a902 \n\n(bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000) => -1\n\n") ("objects:s259" "procedure: (bytevector-uint-set! bytevector n uint eness size)\nprocedure: (bytevector-sint-set! bytevector n sint eness size)\nreturns: unspecified \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer and indexes the starting byte of the value. size must be an exact positive integer and specifies the number of bytes occupied by the value. The sum of n and size must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. uint must be an exact integer in the range 0 to 2^size8 - 1 inclusive. sint must be an exact integer in the range -2^size8-1 to 2^size8-1 - 1 inclusive. eness must be a valid endianness symbol naming the endianness. \n\n" "These procedures store the given value in the size bytes starting at index n (zero-based) of bytevector. Negative values are stored as their two's complement equivalent. \n\n" "" "(define v (make-bytevector 5 0))\n(bytevector-uint-set! v 1 #x123456 (endianness big) 3)\nv => #vu8(0 #x12 #x34 #x56 0) \n\n(define v (make-bytevector 7 -1))\n(bytevector-sint-set! v 1 #x-8000000000 (endianness little) 5)\nv => #vu8(#xff 0 0 0 0 #x80 #xff)\n\n") ("objects:s260" "procedure: (bytevector->uint-list bytevector eness size)\nreturns: a new list of the size-byte unsigned elements of bytevector \nprocedure: (bytevector->sint-list bytevector eness size)\nreturns: a new list of the size-byte signed elements of bytevector \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "eness must be a valid endianness symbol naming the endianness. size must be an exact positive integer and specifies the number of bytes occupied by the value. It must be a value that evenly divides the length of bytevector. \n\n" "" "(bytevector->uint-list (make-bytevector 0) 'little 3) => () \n\n(let ([v #vu8(1 2 3 4 5 6)])\n  (bytevector->uint-list v 'big 3)) => (#x010203 #x040506) \n\n(let ([v (make-bytevector 80 -1)])\n  (bytevector->sint-list v 'big 20)) => (-1 -1 -1 -1)\n\n") ("objects:s261" "procedure: (uint-list->bytevector list eness size)\nprocedure: (sint-list->bytevector list eness size)\nreturns: a new bytevector of the elements of list \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "eness must be a valid endianness symbol naming the endianness. size must be an exact positive integer and specifies the number of bytes occupied by the value. For uint-list->bytevector, list must consist entirely of size-byte exact unsigned integers, i.e., values in the range 0 to 2^size8 - 1 inclusive. For sint-list->bytevector, list must consist entirely of size-byte exact signed integers, i.e., values in the range -2^size8-1 to 2^size8-1 - 1 inclusive. Each value occupies size bytes in the resulting bytevector, whose length is thus size times the length of list. \n\n" "" "(uint-list->bytevector '() 'big 25) => #vu8()\n(sint-list->bytevector '(0 -1) 'big 3) => #vu8(0 0 0 #xff #xff #xff) \n\n(define (f size)\n  (let ([ls (list (- (expt 2 (- (* 8 size) 1)))\n                  (- (expt 2 (- (* 8 size) 1)) 1))])\n    (sint-list->bytevector ls 'little size)))\n(f 6) => #vu8(#x00 #x00 #x00 #x00 #x00 #x80\n              #xff #xff #xff #xff #xff #x7f)\n\n") ("objects:s262" "procedure: (bytevector-ieee-single-native-ref bytevector n)\nreturns: the single floating-point value at index n (zero-based) of bytevector  \nprocedure: (bytevector-ieee-double-native-ref bytevector n)\nreturns: the double floating-point value at index n (zero-based) of bytevector  \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of n and the number of bytes occupied by the value must not exceed the length of bytevector. The native endianness is assumed. \n\n" "The return value is an inexact real number. Examples appear after the mutation operators below. \n\n") ("objects:s263" "procedure: (bytevector-ieee-single-native-set! bytevector n x)\nprocedure: (bytevector-ieee-double-native-set! bytevector n x)\nreturns: unspecified \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of n and the number of bytes occupied by the value must not exceed the length of bytevector. The native endianness is assumed. \n\n" "These procedures store the given value as an IEEE-754 single or double floating-point value at index n (zero-based) of bytevector. \n\n" "" "(define v (make-bytevector 8 0))\n(bytevector-ieee-single-native-set! v 0 .125)\n(bytevector-ieee-single-native-set! v 4 -3/2)\n(list\n  (bytevector-ieee-single-native-ref v 0)\n  (bytevector-ieee-single-native-ref v 4)) => (0.125 -1.5) \n\n(bytevector-ieee-double-native-set! v 0 1e23)\n(bytevector-ieee-double-native-ref v 0) => 1e23\n\n") ("objects:s264" "procedure: (bytevector-ieee-single-ref bytevector n eness)\nreturns: the single floating-point value at index n (zero-based) of bytevector  \nprocedure: (bytevector-ieee-double-ref bytevector n eness)\nreturns: the double floating-point value at index n (zero-based) of bytevector  \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness symbol naming the endianness. \n\n" "The return value is an inexact real number. Examples appear after the mutation operators below. \n\n") ("objects:s265" "procedure: (bytevector-ieee-single-set! bytevector n x eness)\nprocedure: (bytevector-ieee-double-set! bytevector n x eness)\nreturns: unspecified \nlibraries: (rnrs bytevectors), (rnrs)  \n\n" "n must be an exact nonnegative integer and indexes the starting byte of the value. The sum of n and the number of bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of bytevector. n need not be a multiple of the number of bytes occupied by the value. eness must be a valid endianness symbol naming the endianness. \n\n" "These procedures store the given value as an IEEE-754 single or double floating-point value at index n (zero-based) of bytevector. \n\n" "" "(define v (make-bytevector 10 #xc7))\n(bytevector-ieee-single-set! v 1 .125 'little)\n(bytevector-ieee-single-set! v 6 -3/2 'big)\n(list\n  (bytevector-ieee-single-ref v 1 'little)\n  (bytevector-ieee-single-ref v 6 'big)) => (0.125 -1.5)\nv => #vu8(#xc7 #x0 #x0 #x0 #x3e #xc7 #xbf #xc0 #x0 #x0) \n\n(bytevector-ieee-double-set! v 1 1e23 'big)\n(bytevector-ieee-double-ref v 1 'big) => 1e23\n\n") ("objects:s268" "procedure: (symbol=? symbol1 symbol2)\nreturns: #t if the two symbols are the same, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "Symbols can also be compared with eq?, which is typically more efficient than symbol=?.  \n\n" "" "(symbol=? 'a 'a) => #t\n(symbol=? 'a (string->symbol \"a\")) => #t\n(symbol=? 'a 'b) => #f\n\n") ("objects:s269" "procedure: (string->symbol string)\nreturns: a symbol whose name is string \nlibraries: (rnrs base), (rnrs)  \n\n" "string->symbol records all symbols it creates in an internal table that it shares with the system reader. If a symbol whose name is equivalent to string (according to the predicate string=?) already exists in the table, this symbol is returned. Otherwise, a new symbol is created with string as its name; this symbol is entered into the table and returned. \n\n" "The effect of modifying a string after it is used as an argument to string->symbol is unspecified.  \n\n" "" "(string->symbol \"x\") => x \n\n(eq? (string->symbol \"x\") 'x) => #t\n(eq? (string->symbol \"X\") 'x) => #f \n\n(eq? (string->symbol \"x\")\n     (string->symbol \"x\")) => #t \n\n(string->symbol \"()\") => \\x28;\\x29;\n\n") ("objects:s270" "procedure: (symbol->string symbol)\nreturns: a string, the name of symbol \nlibraries: (rnrs base), (rnrs)  \n\n" "The string returned by symbol->string should be treated as immutable. Unpredictable behavior can result if a string returned from symbol->string is altered with string-set! or by any other means.  \n\n" "" "(symbol->string 'xyz) => \"xyz\"\n(symbol->string 'Hi) => \"Hi\"\n(symbol->string (string->symbol \"()\")) => \"()\"\n\n") ("objects:s271" "procedure: (boolean=? boolean1 boolean2)\nreturns: #t if the two booleans are the same, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "The boolean values #t and #f may also be compared with eq?, which is typically more efficient than boolean=?.  \n\n" "" "(boolean=? #t #t) => #t\n(boolean=? #t #f) => #f\n(boolean=? #t (< 3 4)) => #t\n\n") ("objects:s274" "procedure: (make-eq-hashtable) \nprocedure: (make-eq-hashtable size)\nreturns: a new mutable eq hashtable \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "If size is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero size can help limit the amount of rehashing that must be done as the table is initially populated. \n\n" "An eq hashtable compares keys using the eq? (pointer equality) procedure and typically employs a hash function based on object addresses. Its hash and equivalence functions are suitable for any Scheme object. \n\n" "" "(define ht1 (make-eq-hashtable))\n(define ht2 (make-eq-hashtable 32))\n\n") ("objects:s275" "procedure: (make-eqv-hashtable) \nprocedure: (make-eqv-hashtable size)\nreturns: a new mutable eqv hashtable \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "If size is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero size can help limit the amount of rehashing that must be done as the table is initially populated. \n\n" "An eqv hashtable compares keys using the eqv? procedure and typically employs a hash function based on object addresses for objects that are identifiable with eq?. Its hash and equivalence functions are suitable for any Scheme object. \n\n") ("objects:s276" "procedure: (make-hashtable hash equiv?)\nprocedure: (make-hashtable hash equiv? size)\nreturns: a new mutable hashtable \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "hash and equiv? must be procedures. If size is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero size can help limit the amount of rehashing that must be done as the table is initially populated. \n\n" "The new hashtable computes hash values using hash and compares keys using equiv?, neither of which should modify the hashtable. equiv? should compare two keys and return false only if the two keys should be distinguished. hash should accept a key as an argument and return a nonnegative exact integer value that is the same each time it is called with arguments that equiv? does not distinguish. The hash and equiv? procedures need not accept arbitrary inputs as long as the hashtable is used only for keys that they do accept, and both procedures may assume that the keys are immutable as long as the keys are not modified while they have associations stored in the table. The hashtable operation may call hash and equiv? once, not at all, or multiple times for each hashtable operation. \n\n" "" "(define ht (make-hashtable string-hash string=?))\n\n") ("objects:s277" "procedure: (hashtable-mutable? hashtable)\nreturns: #t if hashtable is mutable, #f otherwise \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "Hashtables returned by one of the hashtable creation procedures above are mutable, but those created by hashtable-copy may be immutable. Immutable hashtables cannot be altered by any of the procedures hashtable-set!, hashtable-update!, hashtable-delete!, or hashtable-clear!.  \n\n" "" "(hashtable-mutable? (make-eq-hashtable)) => #t\n(hashtable-mutable? (hashtable-copy (make-eq-hashtable))) => #f\n\n") ("objects:s278" "procedure: (hashtable-hash-function hashtable)\nreturns: the hash function associated with hashtable \nprocedure: (hashtable-equivalence-function hashtable)\nreturns: the equivalence function associated with hashtable \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "hashtable-hash-function returns #f for eq and eqv hashtables.  \n\n" "" "(define ht (make-eq-hashtable))\n(hashtable-hash-function ht) => #f\n(eq? (hashtable-equivalence-function ht) eq?) => #t \n\n(define ht (make-hashtable string-hash string=?))\n(eq? (hashtable-hash-function ht) string-hash) => #t\n(eq? (hashtable-equivalence-function ht) string=?) => #t\n\n") ("objects:s279" "procedure: (equal-hash obj)\nprocedure: (string-hash string)\nprocedure: (string-ci-hash string)\nprocedure: (symbol-hash symbol)\nreturns: an exact nonnegative integer hash value \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "These procedures are hash functions suitable for use with the appropriate Scheme predicate: equal? for equal-hash, string=? for string-hash, string-ci=? for string-ci-hash, and symbol=? (or eq?) for symbol-hash. The hash values returned by equal-hash, string-hash, and string-ci-hash are typically dependent on the current structure and contents of the input values and are thus unsuitable if keys are modified while they have associations in a hashtable. \n\n") ("objects:s280" "procedure: (hashtable-set! hashtable key obj)\nreturns: unspecified \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "hashtable must be a mutable hashtable. key should be an appropriate key for the hashtable's hash and equivalence functions. obj may be any Scheme object. \n\n" "hashtable-set! associates key with obj in hashtable, replacing the existing association, if any. \n\n" "" "(define ht (make-eq-hashtable))\n(hashtable-set! ht 'a 73)\n\n") ("objects:s281" "procedure: (hashtable-ref hashtable key default)\nreturns: see below \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "key should be an appropriate key for the hashtable's hash and equivalence functions. default may be any Scheme object. \n\n" "hashtable-ref returns the value associated with key in hashtable. If no value is associated with key in hashtable, hashtable-ref returns default. \n\n" "" "(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b)) \n\n(define eqht (make-eq-hashtable))\n(hashtable-set! eqht p1 73)\n(hashtable-ref eqht p1 55) => 73\n(hashtable-ref eqht p2 55) => 55 \n\n(define equalht (make-hashtable equal-hash equal?))\n(hashtable-set! equalht p1 73)\n(hashtable-ref equalht p1 55) => 73\n(hashtable-ref equalht p2 55) => 73\n\n") ("objects:s282" "procedure: (hashtable-contains? hashtable key)\nreturns: #t if an association for key exists in hashtable, #f otherwise \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "key should be an appropriate key for the hashtable's hash and equivalence functions. \n\n" "" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 73)\n(hashtable-contains? ht p1) => #t\n(hashtable-contains? ht p2) => #f\n\n") ("objects:s283" "procedure: (hashtable-update! hashtable key procedure default)\nreturns: unspecified \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "hashtable must be a mutable hashtable. key should be an appropriate key for the hashtable's hash and equivalence functions. default may be any Scheme object. procedure should accept one argument, should return one value, and should not modify hashtable. \n\n" "hashtable-update! applies procedure to the value associated with key in hashtable, or to default if no value is associated with key in hashtable. If procedure returns, hashtable-update! associates key with the value returned by procedure, replacing the old association, if any. \n\n" "A version of hashtable-update! that does not verify that it receives arguments of the proper type might be defined as follows. \n\n" "" "(define hashtable-update!\n  (lambda (ht key proc value)\n    (hashtable-set! ht key\n      (proc (hashtable-ref ht key value)))))\n\n" "An implementation may, however, be able to implement hashtable-update! more efficiently by avoiding multiple hash computations and hashtable lookups. \n\n" "" "(define ht (make-eq-hashtable))\n(hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  55)\n(hashtable-ref ht 'a 0) => 110\n(hashtable-update! ht 'a\n  (lambda (x) (* x 2))\n  0)\n(hashtable-ref ht 'a 0) => 220\n\n") ("objects:s284" "procedure: (hashtable-delete! hashtable key)\nreturns: unspecified \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "hashtable must be a mutable hashtable. key should be an appropriate key for the hashtable's hash and equivalence functions. \n\n" "hashtable-delete! drops any association for key from hashtable. \n\n" "" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 73)\n(hashtable-contains? ht p1) => #t\n(hashtable-delete! ht p1)\n(hashtable-contains? ht p1) => #f\n(hashtable-contains? ht p2) => #f\n(hashtable-delete! ht p2)\n\n") ("objects:s285" "procedure: (hashtable-size hashtable)\nreturns: number of entries in hashtable \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-size ht) => 0\n(hashtable-set! ht p1 73)\n(hashtable-size ht) => 1\n(hashtable-delete! ht p1)\n(hashtable-size ht) => 0\n\n") ("objects:s286" "procedure: (hashtable-copy hashtable)\nprocedure: (hashtable-copy hashtable mutable?)\nreturns: a new hashtable containing the same entries as hashtable \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "If mutable? is present and not false, the copy is mutable; otherwise, the copy is immutable. \n\n" "" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(hashtable-set! ht p1 \"c\")\n(define ht-copy (hashtable-copy ht))\n(hashtable-mutable? ht-copy) => #f\n(hashtable-delete! ht p1)\n(hashtable-ref ht p1 #f) => #f\n(hashtable-delete! ht-copy p1) => exception: not mutable\n(hashtable-ref ht-copy p1 #f) => \"c\"\n\n") ("objects:s287" "procedure: (hashtable-clear! hashtable)\nprocedure: (hashtable-clear! hashtable size)\nreturns: unspecified \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "hashtable must be a mutable hashtable. If size is provided, it must be a nonnegative exact integer. \n\n" "hashtable-clear! removes all entries from hashtable. If size is provided, the hashtable is reset to the given size, as if newly created by one of the hashtable creation operations with size argument size. \n\n" "" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 \"first\")\n(hashtable-set! ht p2 \"second\")\n(hashtable-size ht) => 2\n(hashtable-clear! ht)\n(hashtable-size ht) => 0\n(hashtable-ref ht p1 #f) => #f\n\n") ("objects:s288" "procedure: (hashtable-keys hashtable)\nreturns: a vector containing the keys in hashtable \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "The keys may appear in any order in the returned vector. \n\n" "" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 \"one\")\n(hashtable-set! ht p2 \"two\")\n(hashtable-set! ht 'q \"three\")\n(hashtable-keys ht) => #((a . b) q (a . b))\n\n") ("objects:s289" "procedure: (hashtable-entries hashtable)\nreturns: two vectors: one of keys and a second of values \nlibraries: (rnrs hashtables), (rnrs)  \n\n" "hashtable-entries returns two values. The first is a vector containing the keys in hashtable, and the second is a vector containing the corresponding values. The keys and values may appear in any order, but the order is the same for the keys and for the corresponding values. \n\n" "" "(define ht (make-eq-hashtable))\n(define p1 (cons 'a 'b))\n(define p2 (cons 'a 'b))\n(hashtable-set! ht p1 \"one\")\n(hashtable-set! ht p2 \"two\")\n(hashtable-set! ht 'q \"three\")\n(hashtable-entries ht) => #((a . b) q (a . b))\n                          #(\"two\" \"three\" \"one\")\n\n") ("objects:s290" "syntax: (define-enumeration name (symbol ...) constructor)\nlibraries: (rnrs enums), (rnrs)  \n\n" "A define-enumeration form is a definition and can appear anywhere any other definition can appear. \n\n" "The define-enumeration syntax creates a new enumeration set with the specified symbols in the specified order forming the enumeration's universe. It defines a new syntactic form named by name that may be used to verify that a symbol is in the universe. If x is in the universe, (name x) evaluates to x. It is a syntax violation if x is not in the universe. \n\n" "define-enumeration also defines a new syntactic form named by constructor that may be used to create subsets of the enumeration type. If x ... are each in the universe, (constructor x ...) evaluates to an enumeration set containing x .... Otherwise, it is a syntax violation. The same symbol may appear more than once in x ..., but the resulting set contains only one occurrence of the symbol. \n\n" "" "(define-enumeration weather-element\n  (hot warm cold sunny rainy snowy windy)\n  weather) \n\n(weather-element hot) => hot\n(weather-element fun) => syntax violation\n(weather hot sunny windy) => #<enum-set>\n(enum-set->list (weather rainy cold rainy)) => (cold rainy)\n\n") ("objects:s291" "procedure: (make-enumeration symbol-list)\nreturns: an enumeration set \nlibraries: (rnrs enums), (rnrs)  \n\n" "This procedure creates a new enumeration type whose universe comprises the elements of symbol-list, which must be a list of symbols, in the order of their first appearance in the list. It returns the universe of the new enumeration type as an enumeration set. \n\n" "" "(define positions (make-enumeration '(top bottom above top beside)))\n(enum-set->list positions) => (top bottom above beside)\n\n") ("objects:s292" "procedure: (enum-set-constructor enum-set)\nreturns: an enumeration-set construction procedure \nlibraries: (rnrs enums), (rnrs)  \n\n" "This procedure returns a procedure p that may be used to create subsets of the universe of enum-set. p must be passed a list of symbols, and each element of the list must be an element of the universe of enum-set. The enumeration set returned by p contains all and only the symbols in the list it is passed. The value returned by p may contain elements not in enum-set if the universe of enum-set contains those elements. \n\n" "" "(define e1 (make-enumeration '(one two three four)))\n(define p1 (enum-set-constructor e1))\n(define e2 (p1 '(one three)))\n(enum-set->list e2) => (one three)\n(define p2 (enum-set-constructor e2))\n(define e3 (p2 '(one two four)))\n(enum-set->list e3) => (one two four)\n\n") ("objects:s293" "procedure: (enum-set-universe enum-set)\nreturns: the universe of enum-set, as an enumeration set \nlibraries: (rnrs enums), (rnrs)  \n\n" "" "(define e1 (make-enumeration '(a b c a b c d)))\n(enum-set->list (enum-set-universe e1)) => (a b c d)\n(define e2 ((enum-set-constructor e1) '(c)))\n(enum-set->list (enum-set-universe e2)) => (a b c d)\n\n") ("objects:s294" "procedure: (enum-set->list enum-set)\nreturns: a list of the elements of enum-set \nlibraries: (rnrs enums), (rnrs)  \n\n" "The symbols in the resulting list appear in the order given to them when the enumeration type of enum-set was created.  \n\n" "" "(define e1 (make-enumeration '(a b c a b c d)))\n(enum-set->list e1) => (a b c d)\n(define e2 ((enum-set-constructor e1) '(d c a b)))\n(enum-set->list e2) => (a b c d)\n\n") ("objects:s295" "procedure: (enum-set-subset? enum-set1 enum-set2)\nreturns: #t if enum-set1 is a subset of enum-set2, #f otherwise \nlibraries: (rnrs enums), (rnrs)  \n\n" "An enumeration set enum-set1 is a subset of an enumeration set enum-set2if and only if the universe of enum-set1 is a subset of the universe of enum-set2and each element of enum-set1 is an element of enum-set2. \n\n" "" "(define e1 (make-enumeration '(a b c)))\n(define e2 (make-enumeration '(a b c d e)))\n(enum-set-subset? e1 e2) => #t\n(enum-set-subset? e2 e1) => #f\n(define e3 ((enum-set-constructor e2) '(a c)))\n(enum-set-subset? e3 e1) => #f\n(enum-set-subset? e3 e2) => #t\n\n") ("objects:s296" "procedure: (enum-set=? enum-set1 enum-set2)\nreturns: #t if enum-set1 and enum-set2 are equivalent, #f otherwise \nlibraries: (rnrs enums), (rnrs)  \n\n" "Two enumeration sets enum-set1 and enum-set2 are equivalent if each is a subset of the other. \n\n" "" "(define e1 (make-enumeration '(a b c d)))\n(define e2 (make-enumeration '(b d c a)))\n(enum-set=? e1 e2) => #t\n(define e3 ((enum-set-constructor e1) '(a c)))\n(define e4 ((enum-set-constructor e2) '(a c)))\n(enum-set=? e3 e4) => #t\n(enum-set=? e3 e2) => #f\n\n" "enum-set=? could be defined in terms of enum-set-subset? as follows.  \n\n" "" "(define enum-set=?\n  (lambda (e1 e2)\n    (and (enum-set-subset? e1 e2) (enum-set-subset? e2 e1))))\n\n") ("objects:s297" "procedure: (enum-set-member? symbol enum-set)\nreturns: #t if symbol is an element of enum-set, #f otherwise \nlibraries: (rnrs enums), (rnrs)  \n\n" "" "(define e1 (make-enumeration '(a b c d e)))\n(define e2 ((enum-set-constructor e1) '(d b)))\n(enum-set-member? 'c e1) => #t\n(enum-set-member? 'c e2) => #f\n\n") ("objects:s298" "procedure: (enum-set-union enum-set1 enum-set2)\nreturns: the union of enum-set1 and enum-set2\nprocedure: (enum-set-intersection enum-set1 enum-set2)\nreturns: the intersection of enum-set1 and enum-set2\nprocedure: (enum-set-difference enum-set1 enum-set2)\nreturns: the difference of enum-set1 and enum-set2\nlibraries: (rnrs enums), (rnrs)  \n\n" "enum-set1 and enum-set2 must have the same enumeration type. Each procedure returns a new enumeration set representing the union, intersection, or difference of the two sets. \n\n" "" "(define e1 (make-enumeration '(a b c d)))\n(define e2 ((enum-set-constructor e1) '(a c)))\n(define e3 ((enum-set-constructor e1) '(b c)))\n(enum-set->list (enum-set-union e2 e3)) => (a b c)\n(enum-set->list (enum-set-intersection e2 e3)) => (c)\n(enum-set->list (enum-set-difference e2 e3)) => (a)\n(enum-set->list (enum-set-difference e3 e2)) => (b)\n(define e4 (make-enumeration '(b d c a)))\n(enum-set-union e1 e4) => exception: different enumeration types\n\n") ("objects:s299" "procedure: (enum-set-complement enum-set)\nreturns: the complement of enum-set relative to its universe \nlibraries: (rnrs enums), (rnrs)  \n\n" "" "(define e1 (make-enumeration '(a b c d)))\n(enum-set->list (enum-set-complement e1)) => ()\n(define e2 ((enum-set-constructor e1) '(a c)))\n(enum-set->list (enum-set-complement e2)) => (b d)\n\n") ("objects:s300" "procedure: (enum-set-projection enum-set1 enum-set2)\nreturns: the projection of enum-set1 into the universe of enum-set2\nlibraries: (rnrs enums), (rnrs)  \n\n" "Any elements of enum-set1 not in the universe of enum-set2 are dropped. The result is of the same enumeration type as enum-set2. \n\n" "" "(define e1 (make-enumeration '(a b c d)))\n(define e2 (make-enumeration '(a b c d e f g)))\n(define e3 ((enum-set-constructor e1) '(a d)))\n(define e4 ((enum-set-constructor e2) '(a c e g)))\n(enum-set->list (enum-set-projection e4 e3)) => (a c)\n(enum-set->list\n  (enum-set-union e3\n    (enum-set-projection e4 e3))) => (a c d)\n\n") ("objects:s301" "procedure: (enum-set-indexer enum-set)\nreturns: a procedure that returns the index of a symbol in the universe of enum-set \nlibraries: (rnrs enums), (rnrs)  \n\n" "enum-set-indexer returns a procedure p that, when applied to a symbol in the universe of enum-set, returns the index of the symbol (zero-based) in the ordered set of symbols that form the universe. If applied to a symbol not in the universe, p returns #f.  \n\n" "" "(define e1 (make-enumeration '(a b c d)))\n(define e2 ((enum-set-constructor e1) '(a d)))\n(define p (enum-set-indexer e2))\n(list (p 'a) (p 'c) (p 'e)) => (0 2 #f)\n\n" "") ("control:s1" "syntax: (expr0 expr1 ...)\nreturns: values of applying the value of expr0 to the values of expr1 ...\n\n" "Procedure application is the most basic Scheme control structure. Any structured form without a syntax keyword in the first position is a procedure application. The expressions expr0 and expr1 ... are evaluated; each should evaluate to a single value. After each of these expressions has been evaluated, the value of expr0 is applied to the values of expr1 .... If expr0 does not evaluate to a procedure, or if the procedure does not accept the number of arguments provided, an exception with condition type &assertion is raised.  \n\n" "The order in which the procedure and argument expressions are evaluated is unspecified. It may be left to right, right to left, or any other order. The evaluation is guaranteed to be sequential, however: whatever order is chosen, each expression is fully evaluated before evaluation of the next is started. \n\n" "" "(+ 3 4) => 7 \n\n((if (odd? 3) + -) 6 2) => 8 \n\n((lambda (x) x) 5) => 5 \n\n(let ([f (lambda (x) (+ x x))])\n  (f 8)) => 16\n\n") ("control:s3" "procedure: (apply procedure obj ... list)\nreturns: the values of applying procedure to obj ... and the elements of list \nlibraries: (rnrs base), (rnrs)  \n\n" "apply invokes procedure, passing the first obj as the first argument, the second obj as the second argument, and so on for each object in obj ..., and passing the elements of list in order as the remaining arguments. Thus, procedure is called with as many arguments as there are objs plus elements of list. \n\n" "apply is useful when some or all of the arguments to be passed to a procedure are in a list, since it frees the programmer from explicitly destructuring the list. \n\n" "" "(apply + '(4 5)) => 9 \n\n(apply min '(6 8 3 2 5)) => 2 \n\n(apply min  5 1 3 '(6 8 3 2 5)) => 1 \n\n(apply vector 'a 'b '(c d e)) => #(a b c d e) \n\n(define first\n  (lambda (ls)\n    (apply (lambda (x . y) x) ls)))\n(define rest\n  (lambda (ls)\n    (apply (lambda (x . y) y) ls)))\n(first '(a b c d)) => a\n(rest '(a b c d)) => (b c d) \n\n(apply append\n  '(1 2 3)\n  '((a b) (c d e) (f))) => (1 2 3 a b c d e f)\n\n") ("control:s4" "syntax: (begin expr1 expr2 ...)\nreturns: the values of the last subexpression \nlibraries: (rnrs base), (rnrs)  \n\n" "The expressions expr1 expr2 ... are evaluated in sequence from left to right. begin is used to sequence assignments, input/output, or other operations that cause side effects. \n\n" "" "(define x 3)\n(begin\n  (set! x (+ x 1))\n  (+ x x)) => 8\n\n" "A begin form may contain zero or more definitions in place of the expressions expr1 expr2 ..., in which case it is considered to be a definition and may appear only where definitions are valid. \n\n" "" "(let ()\n  (begin (define x 3) (define y 4))\n  (+ x y)) => 7\n\n" "This form of begin is primarily used by syntactic extensions that must expand into multiple definitions. (See page 101.) \n\n" "The bodies of many syntactic forms, including lambda, case-lambda, let, let*, letrec, and letrec*, as well as the result clauses of cond, case, and do, are treated as if they were inside an implicit begin; i.e., the expressions making up the body or result clause are executed in sequence, with the values of the last expression being returned. \n\n" "" "(define swap-pair!\n  (lambda (x)\n    (let ([temp (car x)])\n      (set-car! x (cdr x))\n      (set-cdr! x temp)\n      x)))\n(swap-pair! (cons 'a 'b)) => (b . a)\n\n") ("control:s8" "syntax: (if test consequent alternative)\nsyntax: (if test consequent)\nreturns: the values of consequent or alternative depending on the value of test \nlibraries: (rnrs base), (rnrs)  \n\n" "The test, consequent, and alternative subforms must be expressions. If test evaluates to a true value (anything other than #f), consequent is evaluated and its values are returned. Otherwise, alternative is evaluated and its values are returned. With the second, \"one-armed,\" form, which has no alternative, the result is unspecified if test evaluates to false. \n\n" "" "(let ([ls '(a b c)])\n  (if (null? ls)\n      '()\n      (cdr ls))) => (b c) \n\n(let ([ls '()])\n  (if (null? ls)\n      '()\n      (cdr ls))) => () \n\n(let ([abs\n       (lambda (x)\n         (if (< x 0)\n             (- 0 x)\n             x))])\n  (abs -4)) => 4 \n\n(let ([x -4])\n  (if (< x 0)\n      (list 'minus (- 0 x))\n      (list 'plus 4))) => (minus 4)\n\n") ("control:s10" "procedure: (not obj)\nreturns: #t if obj is false, #f otherwise \nlibraries: (rnrs base), (rnrs)  \n\n" "not is equivalent to (lambda (x) (if x #f #t)). \n\n" "" "(not #f) => #t\n(not #t) => #f\n(not '()) => #f\n(not (< 4 5)) => #f\n\n") ("control:s11" "syntax: (and expr ...)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "If no subexpressions are present, the and form evaluates to #t. Otherwise, and evaluates each subexpression in sequence from left to right until only one subexpression remains or a subexpression returns #f. If one subexpression remains, it is evaluated and its values are returned. If a subexpression returns #f, and returns #f without evaluating the remaining subexpressions. A syntax definition of and appears on page 62. \n\n" "" "(let ([x 3])\n  (and (> x 2) (< x 4))) => #t \n\n(let ([x 5])\n  (and (> x 2) (< x 4))) => #f \n\n(and #f '(a b) '(c d)) => #f\n(and '(a b) '(c d) '(e f)) => (e f)\n\n") ("control:s12" "syntax: (or expr ...)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "If no subexpressions are present, the or form evaluates to #f. Otherwise, or evaluates each subexpression in sequence from left to right until only one subexpression remains or a subexpression returns a value other than #f. If one subexpression remains, it is evaluated and its values are returned. If a subexpression returns a value other than #f, or returns that value without evaluating the remaining subexpressions. A syntax definition of or appears on page 63. \n\n" "" "(let ([x 3])\n  (or (< x 2) (> x 4))) => #f \n\n(let ([x 5])\n  (or (< x 2) (> x 4))) => #t \n\n(or #f '(a b) '(c d)) => (a b)\n\n") ("control:s13" "syntax: (cond clause1 clause2 ...)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "Each clause but the last must take one of the forms below. \n\n" "" "(test)\n(test expr1 expr2 ...)\n(test => expr)\n\n" "The last clause may be in any of the above forms, or it may be an \"else clause\" of the form  \n\n" "" "(else expr1 expr2 ...)\n\n" "Each test is evaluated in order until one evaluates to a true value or until all of the tests have been evaluated. If the first clause whose test evaluates to a true value is in the first form given above, the value of test is returned. \n\n" "If the first clause whose test evaluates to a true value is in the second form given above, the expressions expr1 expr2... are evaluated in sequence and the values of the last expression are returned. \n\n" "If the first clause whose test evaluates to a true value is in the third form given above, the expression expr is evaluated. The value should be a procedure of one argument, which is applied to the value of test. The values of this application are returned. \n\n" "If none of the tests evaluates to a true value and an else clause is present, the expressions expr1 expr2 ... of the else clause are evaluated in sequence and the values of the last expression are returned. \n\n" "If none of the tests evaluates to a true value and no else clause is present, the value or values are unspecified. \n\n" "See page 305 for a syntax definition of cond.  \n\n" "" "(let ([x 0])\n  (cond\n    [(< x 0) (list 'minus (abs x))]\n    [(> x 0) (list 'plus x)]\n    [else (list 'zero x)])) => (zero 0) \n\n(define select\n  (lambda (x)\n    (cond\n      [(not (symbol? x))]\n      [(assq x '((a . 1) (b . 2) (c . 3))) => cdr]\n      [else 0]))) \n\n(select 3) => #t\n(select 'b) => 2\n(select 'e) => 0\n\n") ("control:s16" "syntax: else \nsyntax: => \nlibraries: (rnrs base), (rnrs exceptions), (rnrs)  \n\n" "These identifiers are auxiliary keywords for cond. Both also serve as auxiliary keywords for guard, and else also serves as an auxiliary keyword for case. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords. \n\n") ("control:s17" "syntax: (when test-expr expr1 expr2 ...)\nsyntax: (unless test-expr expr1 expr2 ...)\nreturns: see below \nlibraries: (rnrs control), (rnrs)  \n\n" "For when, if test-expr evaluates to a true value, the expressions expr1 expr2 ... are evaluated in sequence, and the values of the last expression are returned. If test-expr evaluates to false, none of the other expressions are evaluated, and the value or values of when are unspecified.  \n\n" "For unless, if test-expr evaluates to false, the expressions expr1 expr2 ... are evaluated in sequence, and the values of the last expression are returned. If test-expr evaluates to a true value, none of the other expressions are evaluated, and the value or values of unless are unspecified.  \n\n" "A when or unless expression is usually clearer than the corresponding \"one-armed\" if expression.  \n\n" "" "(let ([x -4] [sign 'plus])\n  (when (< x 0)\n    (set! x (- 0 x))\n    (set! sign 'minus))\n  (list sign x)) => (minus 4) \n\n(define check-pair\n  (lambda (x)\n    (unless (pair? x)\n      (syntax-violation 'check-pair \"invalid argument\" x))\n    x)) \n\n(check-pair '(a b c)) => (a b c)\n\n" "when may be defined as follows:  \n\n" "" "(define-syntax when\n  (syntax-rules ()\n    [(_ e0 e1 e2 ...)\n     (if e0 (begin e1 e2 ...))]))\n\n" "unless may be defined as follows:  \n\n" "" "(define-syntax unless\n  (syntax-rules ()\n    [(_ e0 e1 e2 ...)\n     (if (not e0) (begin e1 e2 ...))]))\n\n" "or in terms of when as follows:  \n\n" "" "(define-syntax unless\n  (syntax-rules ()\n    [(_ e0 e1 e2 ...)\n     (when (not e0) e1 e2 ...)]))\n\n") ("control:s18" "syntax: (case expr0 clause1 clause2 ...)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "Each clause but the last must take the form \n\n" "" "((key ...) expr1 expr2 ...)\n\n" "where each key is a datum distinct from the other keys. The last clause may be in the above form or it may be an else clause of the form  \n\n" "" "(else expr1 expr2 ...)\n\n" "expr0 is evaluated and the result is compared (using eqv?) against the keys of each clause in order. If a clause containing a matching key is found, the expressions expr1 expr2 ... are evaluated in sequence and the values of the last expression are returned. \n\n" "If none of the clauses contains a matching key and an else clause is present, the expressions expr1 expr2 ... of the else clause are evaluated in sequence and the values of the last expression are returned. \n\n" "If none of the clauses contains a matching key and no else clause is present, the value or values are unspecified. \n\n" "See page 306 for a syntax definition of case.  \n\n" "" "(let ([x 4] [y 5])\n  (case (+ x y)\n    [(1 3 5 7 9) 'odd]\n    [(0 2 4 6 8) 'even]\n    [else 'out-of-range])) => odd\n\n") ("control:s20" "syntax: (let name ((var expr) ...) body1 body2 ...)\nreturns: values of the final body expression \nlibraries: (rnrs base), (rnrs)  \n\n" "This form of let, called named let, is a general-purpose iteration and recursion construct. It is similar to the more common form of let (see Section 4.4) in the binding of the variables var ... to the values of expr ... within the body body1 body2 ..., which is processed and evaluated like a lambda body. In addition, the variable name is bound within the body to a procedure that may be called to recur or iterate; the arguments to the procedure become the new values of the variables var .... \n\n" "A named let expression of the form  \n\n" "" "(let name ((var expr) ...)\n  body1 body2 ...)\n\n" "can be rewritten with letrec as follows.  \n\n" "" "((letrec ((name (lambda (var ...) body1 body2 ...)))\n   name)\n expr ...)\n\n" "A syntax definition of let that implements this transformation and handles unnamed let as well can be found on page 312. \n\n" "The procedure divisors defined below uses named let to compute the nontrivial divisors of a nonnegative integer. \n\n" "" "(define divisors\n  (lambda (n)\n    (let f ([i 2])\n      (cond\n        [(>= i n) '()]\n        [(integer? (/ n i)) (cons i (f (+ i 1)))]\n        [else (f (+ i 1))])))) \n\n(divisors 5) => ()\n(divisors 32) => (2 4 8 16)\n\n" "The version above is non-tail-recursive when a divisor is found and tail-recursive when a divisor is not found. The version below is fully tail-recursive. It builds up the list in reverse order, but this is easy to remedy, if desired, by reversing the list on exit. \n\n" "" "(define divisors\n  (lambda (n)\n    (let f ([i 2] [ls '()])\n      (cond\n        [(>= i n) ls]\n        [(integer? (/ n i)) (f (+ i 1) (cons i ls))]\n        [else (f (+ i 1) ls)]))))\n\n") ("control:s25" "syntax: (do ((var init update) ...) (test result ...) expr ...)\nreturns: the values of the last result expression \nlibraries: (rnrs control), (rnrs)  \n\n" "do allows a common restricted form of iteration to be expressed succinctly. The variables var ... are bound initially to the values of init ... and are rebound on each subsequent iteration to the values of update .... The expressions test,  update ..., expr ..., and result ...are all within the scope of the bindings established for var .... \n\n" "On each step, the test expression test is evaluated. If the value of test is true, iteration ceases, the expressions result ... are evaluated in sequence, and the values of the last expression are returned. If no result expressions are present, the value or values of the do expression are unspecified. \n\n" "If the value of test is false, the expressions expr ...are evaluated in sequence, the expressions update ... are evaluated, new bindings for var ... to the values of update ... are created, and iteration continues. \n\n" "The expressions expr ... are evaluated only for effect and are often omitted entirely. Any update expression may be omitted, in which case the effect is the same as if the update were simply the corresponding var. \n\n" "Although looping constructs in most languages require that the loop iterands be updated via assignment, do requires the loop iterands var ... to be updated via rebinding. In fact, no side effects are involved in the evaluation of a do expression unless they are performed explicitly by its subexpressions. \n\n" "See page 313 for a syntax definition of do.  \n\n" "The definitions of factorial and fibonacci below are straightforward translations of the tail-recursive named-let versions given in Section 3.2. \n\n" "" "(define factorial\n  (lambda (n)\n    (do ([i n (- i 1)] [a 1 (* a i)])\n        ((zero? i) a)))) \n\n(factorial 10) => 3628800 \n\n(define fibonacci\n  (lambda (n)\n    (if (= n 0)\n        0\n        (do ([i n (- i 1)] [a1 1 (+ a1 a2)] [a2 0 a1])\n            ((= i 1) a1))))) \n\n(fibonacci 6) => 8\n\n" "The definition of divisors below is similar to the tail-recursive definition of divisors given with the description of named let above.  \n\n" "" "(define divisors\n  (lambda (n)\n    (do ([i 2 (+ i 1)]\n         [ls '()\n             (if (integer? (/ n i))\n                 (cons i ls)\n                 ls)])\n        ((>= i n) ls))))\n\n" "The definition of scale-vector! below, which scales each element of a vector v by a constant k, demonstrates a nonempty do body.  \n\n" "" "(define scale-vector!\n  (lambda (v k)\n    (let ([n (vector-length v)])\n      (do ([i 0 (+ i 1)])\n          ((= i n))\n        (vector-set! v i (* (vector-ref v i) k)))))) \n\n(define vec (vector 1 2 3 4 5))\n(scale-vector! vec 2)\nvec => #(2 4 6 8 10)\n\n") ("control:s30" "procedure: (map procedure list1 list2 ...)\nreturns: list of results \nlibraries: (rnrs base), (rnrs)  \n\n" "map applies procedure to corresponding elements of the lists list1 list2 ... and returns a list of the resulting values. The lists list1 list2 ... must be of the same length. procedure should accept as many arguments as there are lists, should return a single value, and should not mutate the list arguments. \n\n" "" "(map abs '(1 -2 3 -4 5 -6)) => (1 2 3 4 5 6) \n\n(map (lambda (x y) (* x y))\n     '(1 2 3 4)\n     '(8 7 6 5)) => (8 14 18 20)\n\n" "While the order in which the applications themselves occur is not specified, the order of the values in the output list is the same as that of the corresponding values in the input lists. \n\n" "map might be defined as follows.  \n\n" "" "(define map\n  (lambda (f ls . more)\n    (if (null? more)\n        (let map1 ([ls ls])\n          (if (null? ls)\n              '()\n              (cons (f (car ls))\n                    (map1 (cdr ls)))))\n        (let map-more ([ls ls] [more more])\n          (if (null? ls)\n              '()\n              (cons\n                (apply f (car ls) (map car more))\n                (map-more (cdr ls) (map cdr more))))))))\n\n" "No error checking is done by this version of map; f is assumed to be a procedure and the other arguments are assumed to be proper lists of the same length. An interesting feature of this definition is that map uses itself to pull out the cars and cdrs of the list of input lists; this works because of the special treatment of the single-list case. \n\n") ("control:s33" "procedure: (for-each procedure list1 list2 ...)\nreturns: unspecified \nlibraries: (rnrs base), (rnrs)  \n\n" "for-each is similar to map except that for-each does not create and return a list of the resulting values, and for-each guarantees to perform the applications in sequence over the elements from left to right. procedure should accept as many arguments as there are lists and should not mutate the list arguments. for-each may be defined without error checks as follows.  \n\n" "" "(define for-each\n  (lambda (f ls . more)\n    (do ([ls ls (cdr ls)] [more more (map cdr more)])\n        ((null? ls))\n      (apply f (car ls) (map car more))))) \n\n(let ([same-count 0])\n  (for-each\n    (lambda (x y)\n      (when (= x y)\n        (set! same-count (+ same-count 1))))\n    '(1 2 3 4 5 6)\n    '(2 3 3 4 7 6))\n  same-count) => 3\n\n") ("control:s36" "procedure: (exists procedure list1 list2 ...)\nreturns: see below \nlibraries: (rnrs lists), (rnrs)  \n\n" "The lists list1 list2 ... must be of the same length. procedure should accept as many arguments as there are lists and should not mutate the list arguments. If the lists are empty, exists returns #f. Otherwise, exists applies procedure to corresponding elements of the lists list1 list2 ... in sequence until either the lists each have only one element or procedure returns a true value t. In the former case, exists tail-calls procedure, applying it to the remaining element of each list. In the latter case, exists returns t. \n\n" "" "(exists symbol? '(1.0 #\\a \"hi\" '())) => #f \n\n(exists member\n        '(a b c)\n        '((c b) (b a) (a c))) => (b a) \n\n(exists (lambda (x y z) (= (+ x y) z))\n        '(1 2 3 4)\n        '(1.2 2.3 3.4 4.5)\n        '(2.3 4.4 6.4 8.6)) => #t\n\n" "exists may be defined (somewhat inefficiently and without error checks) as follows: \n\n" "" "(define exists\n  (lambda (f ls . more)\n    (and (not (null? ls))\n      (let exists ([x (car ls)] [ls (cdr ls)] [more more])\n        (if (null? ls)\n            (apply f x (map car more))\n            (or (apply f x (map car more))\n                (exists (car ls) (cdr ls) (map cdr more))))))))\n\n") ("control:s37" "procedure: (for-all procedure list1 list2 ...)\nreturns: see below \nlibraries: (rnrs lists), (rnrs)  \n\n" "The lists list1 list2 ... must be of the same length. procedure should accept as many arguments as there are lists and should not mutate the list arguments. If the lists are empty, for-all returns #t. Otherwise, for-all applies procedure to corresponding elements of the lists list1 list2 ... in sequence until either the lists each have only one element left or procedure returns #f. In the former case, for-all tail-calls procedure, applying it to the remaining element of each list. In the latter case, for-all returns #f.  \n\n" "" "(for-all symbol? '(a b c d)) => #t \n\n(for-all =\n         '(1 2 3 4)\n         '(1.0 2.0 3.0 4.0)) => #t \n\n(for-all (lambda (x y z) (= (+ x y) z))\n         '(1 2 3 4)\n         '(1.2 2.3 3.4 4.5)\n         '(2.2 4.3 6.5 8.5)) => #f\n\n" "for-all may be defined (somewhat inefficiently and without error checks) as follows: \n\n" "" "(define for-all\n  (lambda (f ls . more)\n    (or (null? ls)\n      (let for-all ([x (car ls)] [ls (cdr ls)] [more more])\n        (if (null? ls)\n            (apply f x (map car more))\n            (and (apply f x (map car more))\n                 (for-all (car ls) (cdr ls) (map cdr more))))))))\n\n") ("control:s38" "procedure: (fold-left procedure obj list1 list2 ...)\nreturns: see below \nlibraries: (rnrs lists), (rnrs)  \n\n" "The list arguments should all have the same length. procedure should accept one more argument than the number of list arguments and return a single value. It should not mutate the list arguments. \n\n" "fold-left returns obj if the list arguments are empty. If they are not empty, fold-left applies procedure to obj and the cars of list1 list2 ..., then recurs with the value returned by procedure in place of obj and the cdr of each list in place of the list. \n\n" "" "(fold-left cons '() '(1 2 3 4)) => ((((() . 1) . 2) . 3) . 4) \n\n(fold-left\n  (lambda (a x) (+ a (* x x)))\n  0 '(1 2 3 4 5)) => 55 \n\n(fold-left\n  (lambda (a . args) (append args a))\n  '(question)\n  '(that not to)\n  '(is to be)\n  '(the be: or)) => (to be or not to be: that is the question)\n\n") ("control:s41" "procedure: (fold-right procedure obj list1 list2 ...)\nreturns: see below \nlibraries: (rnrs lists), (rnrs)  \n\n" "The list arguments should all have the same length. procedure should accept one more argument than the number of list arguments and return a single value. It should not mutate the list arguments. \n\n" "fold-right returns obj if the list arguments are empty. If they are not empty, fold-right recurs with the cdr of each list replacing the list, then applies procedure to the cars of list1 list2 ... and the result returned by the recursion. \n\n" "" "(fold-right cons '() '(1 2 3 4)) => (1 2 3 4) \n\n(fold-right\n  (lambda (x a) (+ a (* x x)))\n  0 '(1 2 3 4 5)) => 55 \n\n(fold-right\n  (lambda (x y a) (cons* x y a))   => (parting is such sweet sorrow\n  '((with apologies))                  gotta go see ya tomorrow\n  '(parting such sorrow go ya)         (with apologies))\n  '(is sweet gotta see tomorrow))\n\n") ("control:s44" "procedure: (vector-map procedure vector1 vector1 ...)\nreturns: vector of results \nlibraries: (rnrs base), (rnrs)  \n\n" "vector-map applies procedure to corresponding elements of vector1 vector2 ... and returns a vector of the resulting values. The vectors vector1 vector2 ... must be of the same length, and procedure should accept as many arguments as there are vectors and return a single value. \n\n" "" "(vector-map abs '#(1 -2 3 -4 5 -6)) => #(1 2 3 4 5 6)\n(vector-map (lambda (x y) (* x y))\n  '#(1 2 3 4)\n  '#(8 7 6 5)) => #(8 14 18 20)\n\n" "While the order in which the applications themselves occur is not specified, the order of the values in the output vector is the same as that of the corresponding values in the input vectors. \n\n") ("control:s47" "procedure: (vector-for-each procedure vector1 vector2 ...)\nreturns: unspecified \nlibraries: (rnrs base), (rnrs)  \n\n" "vector-for-each is similar to vector-map except that vector-for-each does not create and return a vector of the resulting values, and vector-for-each guarantees to perform the applications in sequence over the elements from left to right. \n\n" "" "(let ([same-count 0])\n  (vector-for-each\n    (lambda (x y)\n      (when (= x y)\n        (set! same-count (+ same-count 1))))\n    '#(1 2 3 4 5 6)\n    '#(2 3 3 4 7 6))\n  same-count) => 3\n\n") ("control:s50" "procedure: (string-for-each procedure string1 string2 ...)\nreturns: unspecified \nlibraries: (rnrs base), (rnrs)  \n\n" "string-for-each is similar to for-each and vector-for-each except that the inputs are strings rather than lists or vectors. \n\n" "" "(let ([ls '()])\n  (string-for-each\n    (lambda r (set! ls (cons r ls)))\n    \"abcd\"\n    \"====\"\n    \"1234\")\n  (map list->string (reverse ls))) => (\"a=1\" \"b=2\" \"c=3\" \"d=4\")\n\n") ("control:s54" "procedure: (call/cc procedure)\nprocedure: (call-with-current-continuation procedure)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "These procedures are the same. The shorter name is often used for the obvious reason that it requires fewer keystrokes to type. \n\n" "call/cc obtains its continuation and passes it to procedure, which should accept one argument. The continuation itself is represented by a procedure. Each time this procedure is applied to zero or more values, it returns the values to the continuation of the call/cc application. That is, when the continuation procedure is called, it returns its arguments as the values of the application of call/cc.  \n\n" "If procedure returns normally when passed the continuation procedure, the values returned by call/cc are the values returned by procedure. \n\n" "Continuations allow the implementation of nonlocal exits, backtracking [14,29], coroutines [16], and multitasking [10,32]. \n\n" "The example below illustrates the use of a continuation to perform a nonlocal exit from a loop. \n\n" "" "(define member\n  (lambda (x ls)\n    (call/cc\n      (lambda (break)\n        (do ([ls ls (cdr ls)])\n            ((null? ls) #f)\n          (when (equal? x (car ls))\n            (break ls))))))) \n\n(member 'd '(a b c)) => #f\n(member 'b '(a b c)) => (b c)\n\n" "Additional examples are given in Sections 3.3and 12.11. \n\n" "The current continuation is typically represented internally as a stack of procedure activation records, and obtaining the continuation involves encapsulating the stack within a procedural object. Since an encapsulated stack has indefinite extent, some mechanism must be used to preserve the stack contents indefinitely. This can be done with surprising ease and efficiency and with no impact on programs that do not use continuations [17]. \n\n") ("control:s56" "procedure: (dynamic-wind in body out)\nreturns: values resulting from the application of body \nlibraries: (rnrs base), (rnrs)  \n\n" "dynamic-wind offers \"protection\" from continuation invocation. It is useful for performing tasks that must be performed whenever control enters or leaves body, either normally or by continuation application. \n\n" "The three arguments in, body, and out must be procedures and should accept zero arguments, i.e., they should be thunks. Before applying body, and each time body is entered subsequently by the application of a continuation created within body, the in thunk is applied. Upon normal exit from body and each time body is exited by the application of a continuation created outside body, the out thunk is applied. \n\n" "Thus, it is guaranteed that in is invoked at least once. In addition, if body ever returns, out is invoked at least once. \n\n" "The following example demonstrates the use of dynamic-wind to be sure that an input port is closed after processing, regardless of whether the processing completes normally. \n\n" "" "(let ([p (open-input-file \"input-file\")])\n  (dynamic-wind\n    (lambda () #f)\n    (lambda () (process p))\n    (lambda () (close-port p))))\n\n" "Common Lisp provides a similar facility (unwind-protect) for protection from nonlocal exits. This is often sufficient. unwind-protect provides only the equivalent to out, however, since Common Lisp does not support fully general continuations. Here is how unwind-protect might be specified with dynamic-wind.  \n\n" "" "(define-syntax unwind-protect\n  (syntax-rules ()\n    [(_ body cleanup ...)\n     (dynamic-wind\n       (lambda () #f)\n       (lambda () body)\n       (lambda () cleanup ...))])) \n\n((call/cc\n   (let ([x 'a])\n     (lambda (k)\n       (unwind-protect\n         (k (lambda () x))\n         (set! x 'b)))))) => b\n\n" "Some Scheme implementations support a controlled form of assignment known as fluid binding, in which a variable takes on a temporary value during a given computation and reverts to the old value after the computation has completed. The syntactic form fluid-let defined below in terms of dynamic-wind permits the fluid binding of a single variable x to the value of an expression e within a the body b1 b2 .... \n\n" "" "(define-syntax fluid-let\n  (syntax-rules ()\n    [(_ ((x e)) b1 b2 ...)\n     (let ([y e])\n       (let ([swap (lambda () (let ([t x]) (set! x y) (set! y t)))])\n         (dynamic-wind swap (lambda () b1 b2 ...) swap)))]))\n\n" "Implementations that support fluid-let typically extend it to allow an indefinite number of (x e) pairs, as with let.  \n\n" "If no continuations are invoked within the body of a fluid-let, the behavior is the same as if the variable were simply assigned the new value on entry and assigned the old value on return. \n\n" "" "(let ([x 3])\n  (+ (fluid-let ([x 5])\n       x)\n     x)) => 8\n\n" "A fluid-bound variable also reverts to the old value if a continuation created outside of the fluid-let is invoked.  \n\n" "" "(let ([x 'a])\n  (let ([f (lambda () x)])\n    (cons (call/cc\n            (lambda (k)\n              (fluid-let ([x 'b])\n                (k (f)))))\n          (f)))) => (b . a)\n\n" "If control has left a fluid-let body, either normally or by the invocation of a continuation, and control reenters the body by the invocation of a continuation, the temporary value of the fluid-bound variable is reinstated. Furthermore, any changes to the temporary value are maintained and reflected upon reentry. \n\n" "" "(define reenter #f)\n(define x 0)\n(fluid-let ([x 1])\n  (call/cc (lambda (k) (set! reenter k)))\n  (set! x (+ x 1))\n  x) => 2\nx => 0\n(reenter '*) => 3\n(reenter '*) => 4\nx => 0\n\n" "A library showing how dynamic-wind might be implemented were it not already built in is given below. In addition to defining dynamic-wind, the code defines a version of call/cc that does its part to support dynamic-wind.  \n\n" "" "(library (dynamic-wind)\n  (export dynamic-wind call/cc\n    (rename (call/cc call-with-current-continuation)))\n  (import (rename (except (rnrs) dynamic-wind) (call/cc rnrs:call/cc))) \n\n  (define winders '()) \n\n  (define common-tail\n    (lambda (x y)\n      (let ([lx (length x)] [ly (length y)])\n        (do ([x (if (> lx ly) (list-tail x (- lx ly)) x) (cdr x)]\n             [y (if (> ly lx) (list-tail y (- ly lx)) y) (cdr y)])\n            ((eq? x y) x))))) \n\n  (define do-wind\n    (lambda (new)\n      (let ([tail (common-tail new winders)])\n        (let f ([ls winders])\n          (if (not (eq? ls tail))\n              (begin\n                (set! winders (cdr ls))\n                ((cdar ls))\n                (f (cdr ls)))))\n        (let f ([ls new])\n          (if (not (eq? ls tail))\n              (begin\n                (f (cdr ls))\n                ((caar ls))\n                (set! winders ls)))))))\n\n" "" "  (define call/cc\n    (lambda (f)\n      (rnrs:call/cc\n        (lambda (k)\n          (f (let ([save winders])\n               (lambda (x)\n                 (unless (eq? save winders) (do-wind save))\n                 (k x)))))))) \n\n  (define dynamic-wind\n    (lambda (in body out)\n      (in)\n      (set! winders (cons (cons in out) winders))\n      (let-values ([ans* (body)])\n        (set! winders (cdr winders))\n        (out)\n        (apply values ans*)))))\n\n" "Together, dynamic-wind and call/cc manage a list of winders. A winder is a pair of in and out thunks established by a call to dynamic-wind. Whenever dynamic-wind is invoked, the in thunk is invoked, a new winder containing the in and out thunks is placed on the winders list, the body thunk is invoked, the winder is removed from the winders list, and the outthunk is invoked. This ordering ensures that the winder is on the winders list only when control has passed through in and not yet entered out. Whenever a continuation is obtained, the winders list is saved, and whenever the continuation is invoked, the saved winders list is reinstated. During reinstatement, the out thunk of each winder on the current winders list that is not also on the saved winders list is invoked, followed by the in thunk of each winder on the saved winders list that is not also on the current winders list. The winders list is updated incrementally, again to ensure that a winder is on the current winders list only if control has passed through its in thunk and not entered its out thunk. \n\n" "The test (not (eq? save winders)) performed in call/cc is not strictly necessary but makes invoking a continuation less costly whenever the saved winders list is the same as the current winders list. \n\n") ("control:s65" "syntax: (delay expr)\nreturns: a promise \nprocedure: (force promise)\nreturns: result of forcing promise \nlibraries: (rnrs r5rs)\n\n" "The first time a promise created by delay is forced (with force), it evaluates expr, \"remembering\" the resulting value. Thereafter, each time the promise is forced, it returns the remembered value instead of reevaluating expr. \n\n" "delay and force are typically used only in the absence of side effects, e.g., assignments, so that the order of evaluation is unimportant. \n\n" "The benefit of using delay and force is that some amount of computation might be avoided altogether if it is delayed until absolutely required. Delayed evaluation may be used to construct conceptually infinite lists, or streams. The example below shows how a stream abstraction may be built with delay and force. A stream is a promise that, when forced, returns a pair whose cdr is a stream. \n\n" "" "(define stream-car\n  (lambda (s)\n    (car (force s)))) \n\n(define stream-cdr\n  (lambda (s)\n    (cdr (force s)))) \n\n(define counters\n  (let next ([n 1])\n    (delay (cons n (next (+ n 1)))))) \n\n(stream-car counters) => 1 \n\n(stream-car (stream-cdr counters)) => 2 \n\n(define stream-add\n  (lambda (s1 s2)\n    (delay (cons\n             (+ (stream-car s1) (stream-car s2))\n             (stream-add (stream-cdr s1) (stream-cdr s2)))))) \n\n(define even-counters\n  (stream-add counters counters)) \n\n(stream-car even-counters) => 2 \n\n(stream-car (stream-cdr even-counters)) => 4\n\n" "delay may be defined by  \n\n" "" "(define-syntax delay\n  (syntax-rules ()\n    [(_ expr) (make-promise (lambda () expr))]))\n\n" "where make-promise might be defined as follows. \n\n" "" "(define make-promise\n  (lambda (p)\n    (let ([val #f] [set? #f])\n      (lambda ()\n        (unless set?\n          (let ([x (p)])\n            (unless set?\n              (set! val x)\n              (set! set? #t))))\n        val))))\n\n" "With this definition of delay, force simply invokes the promise to force evaluation or to retrieve the saved value. \n\n" "" "(define force\n  (lambda (promise)\n    (promise)))\n\n" "The second test of the variable set? in make-promise is necessary in the event that, as a result of applying p, the promise is recursively forced. Since a promise must always return the same value, the result of the first application of p to complete is returned. \n\n" "Whether delay and force handle multiple return values is unspecified; the implementation given above does not, but the following version does, with the help of call-with-values and apply.  \n\n" "" "(define make-promise\n  (lambda (p)\n    (let ([vals #f] [set? #f])\n      (lambda ()\n        (unless set?\n          (call-with-values p\n            (lambda x\n              (unless set?\n                (set! vals x)\n                (set! set? #t)))))\n        (apply values vals))))) \n\n(define p (delay (values 1 2 3)))\n(force p) => 1\n             2\n             3\n(call-with-values (lambda () (force p)) +) => 6\n\n" "Neither implementation is quite right, since force must raise an exception with condition type &assertion if its argument is not a promise. Since distinguishing procedures created by make-promise from other procedures is impossible, force cannot do so reliably. The following reimplementation of make-promise and force represents promises as records of the type promise to allow force to make the required check.  \n\n" "" "(define-record-type promise\n  (fields (immutable p) (mutable vals) (mutable set?))\n  (protocol (lambda (new) (lambda (p) (new p #f #f))))) \n\n(define force\n  (lambda (promise)\n    (unless (promise? promise)\n      (assertion-violation 'promise \"invalid argument\" promise))\n    (unless (promise-set? promise)\n      (call-with-values (promise-p promise)\n        (lambda x\n          (unless (promise-set? promise)\n            (promise-vals-set! promise x)\n            (promise-set?-set! promise #t)))))\n    (apply values (promise-vals promise))))\n\n") ("control:s70" "procedure: (values obj ...)\nreturns: obj ...\nlibraries: (rnrs base), (rnrs)  \n\n" "The procedure values accepts any number of arguments and simply passes (returns) the arguments to its continuation. \n\n" "" "(values) =>\n\n(values 1) => 1 \n\n(values 1 2 3) => 1\n                  2\n                  3 \n\n(define head&tail\n  (lambda (ls)\n    (values (car ls) (cdr ls)))) \n\n(head&tail '(a b c)) => a\n                        (b c)\n\n") ("control:s71" "procedure: (call-with-values producer consumer)\nreturns: see below \nlibraries: (rnrs base), (rnrs)  \n\n" "producer and consumer must be procedures. call-with-values applies consumer to the values returned by invoking producer without arguments. \n\n" "" "(call-with-values\n   (lambda () (values 'bond 'james))\n  (lambda (x y) (cons y x))) => (james . bond) \n\n(call-with-values values list) => '()\n\n" "In the second example, values itself serves as the producer. It receives no arguments and thus returns no values. list is thus applied to no arguments and so returns the empty list. \n\n" "The procedure dxdy defined below computes the change in x and y coordinates for a pair of points whose coordinates are represented by (x . y) pairs. \n\n" "" "(define dxdy\n  (lambda (p1 p2)\n    (values (- (car p2) (car p1))\n            (- (cdr p2) (cdr p1))))) \n\n(dxdy '(0 . 0) '(0 . 5)) => 0\n                            5\n\n" "dxdy can be used to compute the length and slope of a segment represented by two endpoints.\n\n" "" "(define segment-length\n  (lambda (p1 p2)\n    (call-with-values\n      (lambda () (dxdy p1 p2))\n      (lambda (dx dy) (sqrt (+ (* dx dx) (* dy dy))))))) \n\n(define segment-slope\n  (lambda (p1 p2)\n    (call-with-values\n      (lambda () (dxdy p1 p2))\n      (lambda (dx dy) (/ dy dx))))) \n\n(segment-length '(1 . 4) '(4 . 8)) => 5\n(segment-slope '(1 . 4) '(4 . 8)) => 4/3\n\n" "We can of course combine these to form one procedure that returns two values.\n\n" "" "(define describe-segment\n  (lambda (p1 p2)\n    (call-with-values\n      (lambda () (dxdy p1 p2))\n      (lambda (dx dy)\n        (values\n          (sqrt (+ (* dx dx) (* dy dy)))\n          (/ dy dx)))))) \n\n(describe-segment '(1 . 4) '(4 . 8)) => 5\n                                     => 4/3\n\n" "The example below employs multiple values to divide a list nondestructively into two sublists of alternating elements. \n\n" "" "(define split\n  (lambda (ls)\n    (if (or (null? ls) (null? (cdr ls)))\n        (values ls '())\n        (call-with-values\n          (lambda () (split (cddr ls)))\n          (lambda (odds evens)\n            (values (cons (car ls) odds)\n                    (cons (cadr ls) evens))))))) \n\n(split '(a b c d e f)) => (a c e)\n                          (b d f)\n\n" "At each level of recursion, the procedure split returns two values:  a list of the odd-numbered elements from the argument list and a list of the even-numbered elements. \n\n" "The continuation of a call to values need not be one established by a call to call-with-values, nor must only values be used to return to a continuation established by call-with-values. In particular, (values e) and e are equivalent expressions. For example: \n\n" "" "(+ (values 2) 4) => 6 \n\n(if (values #t) 1 2) => 1 \n\n(call-with-values\n  (lambda () 4)\n  (lambda (x) x)) => 4\n\n" "Similarly, values may be used to pass any number of values to a continuation that ignores the values, as in the following. \n\n" "" "(begin (values 1 2 3) 4) => 4\n\n" "Because a continuation may accept zero or more than one value, continuations obtained via call/cc may accept zero or more than one argument. \n\n" "" "(call-with-values\n   (lambda ()\n    (call/cc (lambda (k) (k 2 3))))\n  (lambda (x y) (list x y))) => (2 3)\n\n" "The behavior is unspecified when a continuation expecting exactly one value receives zero values or more than one value. For example, the behavior of each of the following expressions is unspecified. Some implementations raise an exception, while others silently suppress additional values or supply defaults for missing values. \n\n" "" "(if (values 1 2) 'x 'y) \n\n(+ (values) 5)\n\n" "Programs that wish to force extra values to be ignored in particular contexts can do so easily by calling call-with-values explicitly. A syntactic form, which we might call first, can be defined to abstract the discarding of more than one value when only one is desired. \n\n" "" "(define-syntax first\n  (syntax-rules ()\n    [(_ expr)\n     (call-with-values\n       (lambda () expr)\n       (lambda (x . y) x))])) \n\n(if (first (values #t #f)) 'a 'b) => a\n\n" "Since implementations are required to raise an exception with condition type &assertion if a procedure does not accept the number of arguments passed to it, each of the following raises an exception. \n\n" "" "(call-with-values\n   (lambda () (values 2 3 4))\n  (lambda (x y) x)) \n\n(call-with-values\n  (lambda () (call/cc (lambda (k) (k 0))))\n  (lambda (x y) x))\n\n" "Since producer is most often a lambda expression, it is often convenient to use a syntactic extension that suppresses the lambda expression in the interest of readability. \n\n" "" "(define-syntax with-values\n  (syntax-rules ()\n    [(_ expr consumer)\n     (call-with-values (lambda () expr) consumer)])) \n\n(with-values (values 1 2) list) => (1 2)\n(with-values (split '(1 2 3 4))\n  (lambda (odds evens)\n    evens)) => (2 4)\n\n" "If the consumer is also a lambda expression, the multiple-value variants of let and let* described in Section 4.5 are usually even more convenient.\n\n" "" "(let-values ([(odds evens) (split '(1 2 3 4))])\n  evens) => (2 4) \n\n(let-values ([ls (values 'a 'b 'c)])\n  ls) => (a b c)\n\n" "Many standard syntactic forms and procedures  pass along multiple values. Most of these are \"automatic,\" in the sense that nothing special must be done by the implementation to make this happen. The usual expansion of let into a direct lambda call automatically propagates multiple values produced by the body of the let. Other operators must be coded specially to pass along multiple values. The call-with-port procedure (page 7.6), for example, calls its procedure argument, then closes the port argument before returning the procedure's values, so it must save the values temporarily. This is easily accomplished via let-values, apply, and values:  \n\n" "" "(define call-with-port\n  (lambda (port proc)\n    (let-values ([val* (proc port)])\n      (close-port port)\n      (apply values val*))))\n\n" "If this seems like too much overhead when a single value is returned, the code can use call-with-values and case-lambda to handle the single-value case more efficiently: \n\n" "" "(define call-with-port\n  (lambda (port proc)\n    (call-with-values (lambda () (proc port))\n      (case-lambda\n        [(val) (close-port port) val]\n        [val* (close-port port) (apply values val*)]))))\n\n" "The definitions of values and call-with-values (and concomitant redefinition of call/cc) in the library below demonstrate that the multiple-return-values interface could be implemented in Scheme if it were not already built in. No error checking can be done, however, for the case in which more than one value is returned to a single-value context, such as the test part of an if expression.  \n\n" "" "(library (mrvs)\n  (export call-with-values values call/cc\n    (rename (call/cc call-with-current-continuation)))\n  (import\n    (rename\n      (except (rnrs) values call-with-values)\n      (call/cc rnrs:call/cc))) \n\n  (define magic (cons 'multiple 'values)) \n\n  (define magic?\n    (lambda (x)\n      (and (pair? x) (eq? (car x) magic))))\n\n" "" "  (define call/cc\n    (lambda (p)\n      (rnrs:call/cc\n        (lambda (k)\n          (p (lambda args\n               (k (apply values args)))))))) \n\n  (define values\n    (lambda args\n      (if (and (not (null? args)) (null? (cdr args)))\n          (car args)\n          (cons magic args)))) \n\n  (define call-with-values\n    (lambda (producer consumer)\n      (let ([x (producer)])\n        (if (magic? x)\n            (apply consumer (cdr x))\n            (consumer x))))))\n\n" "Multiple values can be implemented more efficiently [2], but this code serves to illustrate the meanings of the operators and may be used to provide multiple values in older, nonstandard implementations that do not support them. \n\n") ("control:s80" "procedure: (eval obj environment)\nreturns: values of the Scheme expression represented by obj in environment \nlibraries: (rnrs eval)\n\n" "If obj does not represent a syntactically valid expression, eval raises an exception with condition type &syntax. The environments returned by environment, scheme-report-environment, and null-environment are immutable. Thus, eval also raises an exception with condition type &syntax if an assignment to any of the variables in the environment appears within the expression. \n\n" "" "(define cons 'not-cons)\n(eval '(let ([x 3]) (cons x 4)) (environment '(rnrs))) => (3 . 4) \n\n(define lambda 'not-lambda)\n(eval '(lambda (x) x) (environment '(rnrs))) => #<procedure> \n\n(eval '(cons 3 4) (environment)) => exception\n\n") ("control:s81" "procedure: (environment import-spec ...)\nreturns: an environment \nlibraries: (rnrs eval)\n\n" "environment returns an environment formed from the combined bindings of the given import specifiers. Each import-spec must be an s-expression representing a valid import specifier (see Chapter 10). \n\n" "" "(define env (environment '(rnrs) '(prefix (rnrs lists) $)))\n(eval '($cons* 3 4 (* 5 8)) env) => (3 4 . 40)\n\n") ("control:s82" "procedure: (null-environment version)\nprocedure: (scheme-report-environment version)\nreturns: an R5RS compatibility environment \nlibraries: (rnrs r5rs)\n\n" "version must be the exact integer 5.  \n\n" "null-environment returns an environment containing bindings for the keywords whose meanings are defined by the Revised^5 Report on Scheme, along with bindings for the auxiliary keywords else, =>, ..., and _.  \n\n" "scheme-report-environment returns an environment containing the same keyword bindings as the environment returned by null-environment along with bindings for the variables whose meanings are defined by the Revised^5 Report on Scheme, except those not defined by the Revised^6 Report: load, interaction-environment, transcript-on, transcript-off, and char-ready?.  \n\n" "The bindings for each of the identifiers in the environments returned by these procedures are those of the corresponding Revised^6 Report library, so this does not provide full backward compatibility, even if the excepted identifier bindings are not used. \n\n") ("binding:s2" "syntax: variable \nreturns: the value of variable \n\n" "Any identifier appearing as an expression in a program is a variable if a visible variable binding for the identifier exists, e.g., the identifier appears within the scope of a binding created by define, lambda, let, or some other variable-binding construct.  \n\n" "" "list => #<procedure>\n(define x 'a)\n(list x x) => (a a)\n(let ([x 'b])\n  (list x x)) => (b b)\n(let ([let 'let]) let) => let\n\n" "It is a syntax violation for an identifier reference to appear within a library form or top-level program if it is not bound as a variable, keyword, record name, or other entity. Since the scope of the definitions in a library, top-level program, lambda, or other local body is the entire body, it is not necessary for the definition of a variable to appear before its first reference appears, as long as the reference is not actually evaluated until the definition has been completed. So, for example, the reference to g within the definition of f below  \n\n" "" "(define f\n  (lambda (x)\n    (g x)))\n(define g\n  (lambda (x)\n    (+ x x)))\n\n" "is okay, but the reference to g in the definition of q below is not.  \n\n" "" "(define q (g 3))\n(define g\n  (lambda (x)\n    (+ x x)))\n\n") ("binding:s3" "syntax: (lambda formals body1 body2 ...)\nreturns: a procedure \nlibraries: (rnrs base), (rnrs)  \n\n" "The lambda syntactic form is used to create procedures. Any operation that creates a procedure or establishes local variable bindings is ultimately defined in terms of lambda or case-lambda.  \n\n" "The variables in formals are the formal parameters of the procedure, and the sequence of subforms body1 body2 ... is its body. \n\n" "The body may begin with a sequence of definitions, in which case the bindings created by the definitions are local to the body. If definitions are present, the keyword bindings are used and discarded while expanding the body, and the body is expanded into a letrec* expression formed from the variable definitions and the remaining expressions, as described on page 292. The remainder of this description of lambda assumes that this transformation has taken place, if necessary, so that the body is a sequence of expressions without definitions. \n\n" "When the procedure is created, the bindings of all variables occurring free within the body, excluding the formal parameters, are retained with the procedure. Subsequently, whenever the procedure is applied to a sequence of actual parameters, the formal parameters are bound to the actual parameters, the retained bindings are restored, and the body is evaluated. \n\n" "Upon application, the formal parameters defined by formals are bound to the actual parameters as follows. \n\n" "\n* If formals is a proper list of variables, e.g., (x y z), each variable is bound to the corresponding actual parameter. An exception with condition type &assertion is raised if too few or too many actual parameters are supplied. \n* If formals is a single variable (not in a list), e.g., z, it is bound to a list of the actual parameters. \n* If formals is an improper list of variables terminated by a variable, e.g., (x y . z), each variable but the last is bound to the corresponding actual parameter. The last variable is bound to a list of the remaining actual parameters. An exception with condition type &assertion is raised if too few actual parameters are supplied. \n\n" "" "When the body is evaluated, the expressions in the body are evaluated in sequence, and the procedure returns the values of the last expression. \n\n" "Procedures do not have a printed representation in the usual sense. Scheme systems print procedures in different ways; this book uses the notation #<procedure>.  \n\n" "" "(lambda (x) (+ x 3)) => #<procedure>\n((lambda (x) (+ x 3)) 7) => 10\n((lambda (x y) (* x (+ x y))) 7 13) => 140\n((lambda (f x) (f x x)) + 11) => 22\n((lambda () (+ 3 4))) => 7 \n\n((lambda (x . y) (list x y))\n 28 37) => (28 (37))\n((lambda (x . y) (list x y))\n 28 37 47 28) => (28 (37 47 28))\n((lambda (x y . z) (list x y z))\n 1 2 3 4) => (1 2 (3 4))\n((lambda x x) 7 13) => (7 13)\n\n") ("binding:s13" "syntax: (case-lambda clause ...)\nreturns: a procedure \nlibraries: (rnrs control), (rnrs)  \n\n" "A case-lambda expression consists of a set of clauses, each resembling a lambda expression. Each clause has the form below. \n\n" "" "[formals body1 body2 ...]\n\n" "The formal parameters of a clause are defined by formals in the same manner as for a lambda expression. The number of arguments accepted by the procedure value of a case-lambda expression is determined by the numbers of arguments accepted by the individual clauses. \n\n" "When a procedure created with case-lambda is invoked, the clauses are considered in order. The first clause that accepts the given number of actual parameters is selected, the formal parameters defined by its formals are bound to the corresponding actual parameters, and the body is evaluated as described for lambda above. If formals in a clause is a proper list of identifiers, then the clause accepts exactly as many actual parameters as there are formal parameters (identifiers) in formals. As with a lambda formals, a case-lambda clause formals may be a single identifier, in which case the clause accepts any number of arguments, or an improper list of identifiers terminated by an identifier, in which case the clause accepts any number of arguments greater than or equal to the number of formal parameters excluding the terminating identifier. If no clause accepts the number of actual parameters supplied, an exception with condition type &assertion is raised.  \n\n" "The following definition for make-list uses case-lambda to support an optional fill parameter. \n\n" "" "(define make-list\n  (case-lambda\n    [(n) (make-list n #f)]\n    [(n x)\n     (do ([n n (- n 1)] [ls '() (cons x ls)])\n         ((zero? n) ls))]))\n\n" "The substring procedure may be extended with case-lambda to accept either no end index, in which case it defaults to the end of the string, or no start and end indices, in which case substring is equivalent to string-copy:  \n\n" "" "(define substring1\n  (case-lambda\n    [(s) (substring1 s 0 (string-length s))]\n    [(s start) (substring1 s start (string-length s))]\n    [(s start end) (substring s start end)]))\n\n" "It is also possible to default the start index rather than the end index when only one index is supplied: \n\n" "" "(define substring2\n  (case-lambda\n    [(s) (substring2 s 0 (string-length s))]\n    [(s end) (substring2 s 0 end)]\n    [(s start end) (substring s start end)]))\n\n" "It is even possible to require that both or neither of the start and end indices be supplied, simply by leaving out the middle clause: \n\n" "" "(define substring3\n  (case-lambda\n    [(s) (substring3 s 0 (string-length s))]\n    [(s start end) (substring s start end)]))\n\n") ("binding:s16" "syntax: (let ((var expr) ...) body1 body2 ...)\nreturns: the values of the final body expression \nlibraries: (rnrs base), (rnrs)  \n\n" "let establishes local variable bindings. Each variable var is bound to the value of the corresponding expression expr. The body of the let, in which the variables are bound, is the sequence of subforms body1 body2 ... and is processed and evaluated like a lambda body.  \n\n" "The forms let, let*, letrec, and letrec* (the others are described after let) are similar but serve slightly different purposes. With let, in contrast with let*, letrec, and letrec*, the expressions expr ... are all outside the scope of the variables var .... Also, in contrast with let* and letrec*, no ordering is implied for the evaluation of the expressions expr .... They may be evaluated from left to right, from right to left, or in any other order at the discretion of the implementation. Use let whenever the values are independent of the variables and the order of evaluation is unimportant. \n\n" "" "(let ([x (* 3.0 3.0)] [y (* 4.0 4.0)])\n  (sqrt (+ x y))) => 5.0 \n\n(let ([x 'a] [y '(b c)])\n  (cons x y)) => (a b c) \n\n(let ([x 0] [y 1])\n  (let ([x y] [y x])\n    (list x y))) => (1 0)\n\n" "The following definition of let shows the typical derivation of let from lambda.  \n\n" "" "(define-syntax let\n  (syntax-rules ()\n    [(_ ((x e) ...) b1 b2 ...)\n     ((lambda (x ...) b1 b2 ...) e ...)]))\n\n" "Another form of let, named let, is described in Section 5.4, and a definition of the full let can be found on page 312. \n\n") ("binding:s18" "syntax: (let* ((var expr) ...) body1 body2 ...)\nreturns: the values of the final body expression \nlibraries: (rnrs base), (rnrs)  \n\n" "let* is similar to let except that the expressions expr ... are evaluated in sequence from left to right, and each of these expressions is within the scope of the variables to the left. Use let* when there is a linear dependency among the values or when the order of evaluation is important. \n\n" "" "(let* ([x (* 5.0 5.0)]\n       [y (- x (* 4.0 4.0))])\n  (sqrt y)) => 3.0 \n\n(let ([x 0] [y 1])\n  (let* ([x y] [y x])\n    (list x y))) => (1 1)\n\n" "Any let* expression may be converted to a set of nested let expressions. The following definition of let* demonstrates the typical transformation. \n\n" "" "(define-syntax let*\n  (syntax-rules ()\n    [(_ () e1 e2 ...)\n     (let () e1 e2 ...)]\n    [(_ ((x1 v1) (x2 v2) ...) e1 e2 ...)\n     (let ((x1 v1))\n       (let* ((x2 v2) ...) e1 e2 ...))]))\n\n") ("binding:s20" "syntax: (letrec ((var expr) ...) body1 body2 ...)\nreturns: the values of the final body expression \nlibraries: (rnrs base), (rnrs)  \n\n" "letrec is similar to let and let*, except that all of the expressions expr ...are within the scope of all of the variables var .... letrec allows the definition of mutually recursive procedures. \n\n" "" "(letrec ([sum (lambda (x)\n                (if (zero? x)\n                    0\n                    (+ x (sum (- x 1)))))])\n  (sum 5)) => 15\n\n" "The order of evaluation of the expressions expr ... is unspecified, so a program must not evaluate a reference to any of the variables bound by the letrec expression before all of the values have been computed. (Occurrence of a variable within a lambda expression does not count as a reference, unless the resulting procedure is applied before all of the values have been computed.) If this restriction is violated, an exception with condition type &assertion is raised.  \n\n" "An expr should not return more than once. That is, it should not return both normally and via the invocation of a continuation obtained during its evaluation, and it should not return twice via two invocations of such a continuation. Implementations are not required to detect a violation of this restriction, but if they do, an exception with condition type &assertion is raised. \n\n" "Choose letrec over let or let* when there is a circular dependency among the variables and their values and when the order of evaluation is unimportant. Choose letrec* over letrec when there is a circular dependency and the bindings need to be evaluated from left to right. \n\n" "A letrec expression of the form  \n\n" "" "(letrec ((var expr) ...) body1 body2 ...)\n\n" "may be expressed in terms of let and set! as  \n\n" "" "(let ((var #f) ...)\n  (let ((temp expr) ...)\n    (set! var temp) ...\n    (let () body1 body2 ...)))\n\n" "where temp ... are fresh variables, i.e., ones that do not already appear in the letrec expression, one for each (var expr) pair. The outer let expression establishes the variable bindings. The initial value given each variable is unimportant, so any value suffices in place of #f. The bindings are established first so that expr ...may contain occurrences of the variables, i.e., so that the expressions are computed within the scope of the variables. The middle let evaluates the values and binds them to the temporary variables, and the set! expressions assign each variable to the corresponding value. The inner let is present in case the body contains internal definitions. \n\n" "A definition of letrec that uses this transformation is shown on page 310. \n\n" "This transformation does not enforce the restriction that the expr expressions must not evaluate any references of or assignments to the variables. More elaborate transformations that enforce this restriction and actually produce more efficient code are possible [31]. \n\n") ("binding:s22" "syntax: (letrec* ((var expr) ...) body1 body2 ...)\nreturns: the values of the final body expression \nlibraries: (rnrs base), (rnrs)  \n\n" "letrec* is similar to letrec, except that letrec* evaluates expr ... in sequence from left to right. While programs must still not evaluate a reference to any var before the corresponding expr has been evaluated, references to var may be evaluated any time thereafter, including during the evaluation of the expr of any subsequent binding. \n\n" "A letrec* expression of the form  \n\n" "" "(letrec* ((var expr) ...) body1 body2 ...)\n\n" "may be expressed in terms of let and set! as  \n\n" "" "(let ((var #f) ...)\n  (set! var expr) ...\n  (let () body1 body2 ...))\n\n" "The outer let expression creates the bindings, each assignment evaluates an expression and immediately sets the corresponding variable to its value, in sequence, and the inner let evaluates the body. let is used in the latter case rather than begin since the body may include internal definitions as well as expressions. \n\n" "" "(letrec* ([sum (lambda (x)\n                 (if (zero? x)\n                     0\n                     (+ x (sum (- x 1)))))]\n          [f (lambda () (cons n n-sum))]\n          [n 15]\n          [n-sum (sum n)])\n  (f)) => (15 . 120) \n\n(letrec* ([f (lambda () (lambda () g))]\n          [g (f)])\n  (eq? (g) g)) => #t \n\n(letrec* ([g (f)]\n          [f (lambda () (lambda () g))])\n  (eq? (g) g)) => exception: attempt to reference undefined variable f\n\n") ("binding:s23" "syntax: (let-values ((formals expr) ...) body1 body2 ...)\nsyntax: (let*-values ((formals expr) ...) body1 body2 ...)\nreturns: the values of the final body expression \nlibraries: (rnrs base), (rnrs)  \n\n" "let-values is a convenient way to receive multiple values and bind them to variables. It is structured like let but permits an arbitrary formals list (like lambda) on each left-hand side. let*-values is similar but performs the bindings in left-to-right order, as with let*. An exception with condition type &assertion is raised if the number of values returned by an expr is not appropriate for the corresponding formals, as described in the entry for lambda above. A definition of let-values is given on page 310. \n\n" "" "(let-values ([(a b) (values 1 2)] [c (values 1 2 3)])\n  (list a b c)) => (1 2 (1 2 3)) \n\n(let*-values ([(a b) (values 1 2)] [(a b) (values b a)])\n  (list a b)) => (2 1)\n\n") ("binding:s24" "syntax: (define var expr)\nsyntax: (define var)\nsyntax: (define (var0 var1 ...) body1 body2 ...)\nsyntax: (define (var0 . varr) body1 body2 ...)\nsyntax: (define (var0 var1 var2 ... . varr) body1 body2 ...)\nlibraries: (rnrs base), (rnrs)  \n\n" "In the first form, define creates a new binding of var to the value of expr. The expr should not return more than once. That is, it should not return both normally and via the invocation of a continuation obtained during its evaluation, and it should not return twice via two invocations of such a continuation. Implementations are not required to detect a violation of this restriction, but if they do, an exception with condition type &assertion is raised. \n\n" "The second form is equivalent to (define var unspecified), where unspecified is some unspecified value. The remaining are shorthand forms for binding variables to procedures; they are identical to the following definition in terms of lambda.  \n\n" "" "(define var\n  (lambda formals\n    body1 body2 ...))\n\n" "where formals is (var1 ...), varr, or (var1 var2 ... . varr) for the third, fourth, and fifth define formats.  \n\n" "Definitions may appear at the front of a library body, anywhere among the forms of a top-level-program body, and at the front of a lambda or case-lambda body or the body of any form derived from lambda, e.g., let, or letrec*. Any body that begins with a sequence of definitions is transformed during macro expansion into a letrec* expression as described on page 292. \n\n" "Syntax definitions may appear along with variable definitions wherever variable definitions may appear; see Chapter 8. \n\n" "" "(define x 3)\nx => 3 \n\n(define f\n  (lambda (x y)\n    (* (+ x y) 2)))\n(f 5 4) => 18 \n\n(define (sum-of-squares x y)\n  (+ (* x x) (* y y)))\n(sum-of-squares 3 4) => 25 \n\n(define f\n  (lambda (x)\n    (+ x 1)))\n(let ([x 2])\n  (define f\n    (lambda (y)\n      (+ y x)))\n  (f 3)) => 5\n(f 3) => 4\n\n" "A set of definitions may be grouped by enclosing them in a begin form. Definitions grouped in this manner may appear wherever ordinary variable and syntax definitions may appear. They are treated as if written separately, i.e., without the enclosing begin form. This feature allows syntactic extensions to expand into groups of definitions. \n\n" "" "(define-syntax multi-define-syntax\n  (syntax-rules ()\n    [(_ (var expr) ...)\n     (begin\n       (define-syntax var expr)\n       ...)]))\n(let ()\n  (define plus\n    (lambda (x y)\n        (if (zero? x)\n            y\n            (plus (sub1 x) (add1 y)))))\n  (multi-define-syntax\n    (add1 (syntax-rules () [(_ e) (+ e 1)]))\n    (sub1 (syntax-rules () [(_ e) (- e 1)])))\n  (plus 7 8)) => 15\n\n" "Many implementations support an interactive \"top level\" in which variable and other definitions may be entered interactively or loaded from files. The behavior of these top-level definitions is outside the scope of the Revised^6 Report, but as long as top-level variables are defined before any references or assignments to them are evaluated, the behavior is consistent across most implementations. So, for example, the reference to g in the top-level definition of f below is okay if g is not already defined, and g is assumed to name a variable to be defined at some later point. \n\n" "" "(define f\n  (lambda (x)\n    (g x)))\n\n" "If this is then followed by a definition of g before f is evaluated, the assumption that g would be defined as a variable is proven correct, and a call to f works as expected.  \n\n" "" "(define g\n  (lambda (x)\n    (+ x x)))\n(f 3) => 6\n\n" "If g were defined instead as the keyword for a syntactic extension, the assumption that g would be bound as a variable is proven false, and if f is not redefined before it is invoked, the implementation is likely to raise an exception. \n\n") ("binding:s28" "syntax: (set! var expr)\nreturns: unspecified \nlibraries: (rnrs base), (rnrs)  \n\n" "set! does not establish a new binding for var but rather alters the value of an existing binding. It first evaluates expr, then assigns var to the value of expr. Any subsequent reference to var within the scope of the altered binding evaluates to the new value. \n\n" "Assignments are not employed as frequently in Scheme as in most other languages, but they are useful for implementing state changes.\n\n" "" "(define flip-flop\n  (let ([state #f])\n    (lambda ()\n      (set! state (not state))\n      state))) \n\n(flip-flop) => #t\n(flip-flop) => #f\n(flip-flop) => #t\n\n" "Assignments are also useful for caching values. The example below uses a technique called memoization, in which a procedure records the values associated with old input values so it need not recompute them, to implement a fast version of the otherwise exponential doubly recursive definition of the Fibonacci function (see page 69).\n\n" "" "(define memoize\n  (lambda (proc)\n    (let ([cache '()])\n      (lambda (x)\n        (cond\n          [(assq x cache) => cdr]\n          [else\n           (let ([ans (proc x)])\n             (set! cache (cons (cons x ans) cache))\n             ans)]))))) \n\n(define fibonacci\n  (memoize\n    (lambda (n)\n      (if (< n 2)\n          1\n          (+ (fibonacci (- n 1)) (fibonacci (- n 2))))))) \n\n(fibonacci 100) => 573147844013817084101\n\n" "")))))